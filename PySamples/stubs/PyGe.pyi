
class AcGeError:
    def as_integer_ratio (self, /):
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count (self, /):
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length (self, /):
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''the denominator of a rational number in lowest terms'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''the imaginary part of a complex number'''
    ...
    def k0Arg1 (self, *args, **kwargs):
      '''None'''
    ...
    def k0Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def k0This (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1InsideThis (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1OnThis (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1TooBig (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg1Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg1Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg2Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearlyDependentArg1Arg2Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kOk (self, *args, **kwargs):
      '''None'''
    ...
    def kPerpendicularArg1Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''the numerator of a rational number in lowest terms'''
    ...
    def real (self, *args, **kwargs):
      '''the real part of a complex number'''
    ...
    def to_bytes (self, /, length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...

class BoundBlock2d:
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def contains (self, *args, **kwargs):
      '''
contains( (BoundBlock2d)arg1, (Point2d)arg2) -> bool :

    C++ signature :
        bool contains(class PyGeBoundBlock2d {lvalue},class AcGePoint2d)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity2d)arg1) -> Entity2d :

    C++ signature :
        class PyGeEntity2d copy(class PyGeEntity2d {lvalue})'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (BoundBlock2d)arg1, (Point2d)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d {lvalue} extend(class PyGeBoundBlock2d {lvalue},class AcGePoint2d)'''
    ...
    def getBasePoint (self, *args, **kwargs):
      '''
getBasePoint( (BoundBlock2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getBasePoint(class PyGeBoundBlock2d {lvalue})'''
    ...
    def getDirection1 (self, *args, **kwargs):
      '''
getDirection1( (BoundBlock2d)arg1) -> Vector2d :

    C++ signature :
        class AcGeVector2d getDirection1(class PyGeBoundBlock2d {lvalue})'''
    ...
    def getDirection2 (self, *args, **kwargs):
      '''
getDirection2( (BoundBlock2d)arg1) -> Vector2d :

    C++ signature :
        class AcGeVector2d getDirection2(class PyGeBoundBlock2d {lvalue})'''
    ...
    def getMaxPoint (self, *args, **kwargs):
      '''
getMaxPoint( (BoundBlock2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getMaxPoint(class PyGeBoundBlock2d {lvalue})'''
    ...
    def getMinPoint (self, *args, **kwargs):
      '''
getMinPoint( (BoundBlock2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getMinPoint(class PyGeBoundBlock2d {lvalue})'''
    ...
    def isBox (self, *args, **kwargs):
      '''
isBox( (BoundBlock2d)arg1) -> bool :

    C++ signature :
        bool isBox(class PyGeBoundBlock2d {lvalue})'''
    ...
    def isDisjoint (self, *args, **kwargs):
      '''
isDisjoint( (BoundBlock2d)arg1, (BoundBlock2d)arg2) -> bool :

    C++ signature :
        bool isDisjoint(class PyGeBoundBlock2d {lvalue},class PyGeBoundBlock2d)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity2d)arg1, (Entity2d)arg2) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d)

isEqualTo( (Entity2d)arg1, (Entity2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity2d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity2d {lvalue},enum AcGe::EntityId)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity2d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity2d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Entity2d)arg1, (Point2d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeEntity2d {lvalue},class AcGePoint2d)

isOn( (Entity2d)arg1, (Point2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeEntity2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity2d)arg1, (Line2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} mirror(class PyGeEntity2d {lvalue},class PyGeLine2d)'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double)

rotateBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double)

scaleBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def set (self, *args, **kwargs):
      '''
set( (BoundBlock2d)arg1, (Point2d)arg2, (Point2d)arg3) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d {lvalue} set(class PyGeBoundBlock2d {lvalue},class AcGePoint2d,class AcGePoint2d)

set( (BoundBlock2d)arg1, (Point2d)arg2, (Vector2d)arg3, (Vector2d)arg4) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d {lvalue} set(class PyGeBoundBlock2d {lvalue},class AcGePoint2d,class AcGeVector2d,class AcGeVector2d)'''
    ...
    def setToBox (self, *args, **kwargs):
      '''
setToBox( (BoundBlock2d)arg1, (bool)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d {lvalue} setToBox(class PyGeBoundBlock2d {lvalue},bool)'''
    ...
    def swell (self, *args, **kwargs):
      '''
swell( (BoundBlock2d)arg1, (float)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d {lvalue} swell(class PyGeBoundBlock2d {lvalue},double)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity2d)arg1, (Matrix2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} transformBy(class PyGeEntity2d {lvalue},class AcGeMatrix2d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity2d)arg1, (Vector2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} translateBy(class PyGeEntity2d {lvalue},class AcGeVector2d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity2d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity2d {lvalue})'''
    ...

class BoundBlock3d:
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def contains (self, *args, **kwargs):
      '''
contains( (BoundBlock3d)arg1, (Point3d)arg2) -> bool :

    C++ signature :
        bool contains(class PyGeBoundBlock3d {lvalue},class AcGePoint3d)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity3d)arg1) -> Entity3d :

    C++ signature :
        class PyGeEntity3d copy(class PyGeEntity3d {lvalue})'''
    ...
    def extend (self, *args, **kwargs):
      '''
extend( (BoundBlock3d)arg1, (Point3d)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d {lvalue} extend(class PyGeBoundBlock3d {lvalue},class AcGePoint3d)'''
    ...
    def getBasePoint (self, *args, **kwargs):
      '''
getBasePoint( (BoundBlock3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getBasePoint(class PyGeBoundBlock3d {lvalue})'''
    ...
    def getDirection1 (self, *args, **kwargs):
      '''
getDirection1( (BoundBlock3d)arg1) -> Vector3d :

    C++ signature :
        class AcGeVector3d getDirection1(class PyGeBoundBlock3d {lvalue})'''
    ...
    def getDirection3 (self, *args, **kwargs):
      '''
getDirection3( (BoundBlock3d)arg1) -> Vector3d :

    C++ signature :
        class AcGeVector3d getDirection3(class PyGeBoundBlock3d {lvalue})

getDirection3( (BoundBlock3d)arg1) -> Vector3d :

    C++ signature :
        class AcGeVector3d getDirection3(class PyGeBoundBlock3d {lvalue})'''
    ...
    def getMaxPoint (self, *args, **kwargs):
      '''
getMaxPoint( (BoundBlock3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getMaxPoint(class PyGeBoundBlock3d {lvalue})'''
    ...
    def getMinPoint (self, *args, **kwargs):
      '''
getMinPoint( (BoundBlock3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getMinPoint(class PyGeBoundBlock3d {lvalue})'''
    ...
    def isBox (self, *args, **kwargs):
      '''
isBox( (BoundBlock3d)arg1) -> bool :

    C++ signature :
        bool isBox(class PyGeBoundBlock3d {lvalue})'''
    ...
    def isDisjoint (self, *args, **kwargs):
      '''
isDisjoint( (BoundBlock3d)arg1, (BoundBlock3d)arg2) -> bool :

    C++ signature :
        bool isDisjoint(class PyGeBoundBlock3d {lvalue},class PyGeBoundBlock3d)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity3d)arg1, (Entity3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity3d {lvalue},class PyGeEntity3d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity3d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity3d {lvalue},enum AcGe::EntityId)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity3d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity3d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Entity3d)arg1, (Point3d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeEntity3d {lvalue},class AcGePoint3d)

isOn( (Entity3d)arg1, (Point3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeEntity3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} mirror(class PyGeEntity3d {lvalue},class PyGePlane)'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d)

rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3, (Point3d)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d,class AcGePoint3d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity3d)arg1, (float)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double)

scaleBy( (Entity3d)arg1, (float)arg2, (Point3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double,class AcGePoint3d)'''
    ...
    def set (self, *args, **kwargs):
      '''
set( (BoundBlock3d)arg1, (Point3d)arg2, (Point3d)arg3) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d {lvalue} set(class PyGeBoundBlock3d {lvalue},class AcGePoint3d,class AcGePoint3d)

set( (BoundBlock3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Vector3d)arg4, (Vector3d)arg5) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d {lvalue} set(class PyGeBoundBlock3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeVector3d,class AcGeVector3d)'''
    ...
    def setToBox (self, *args, **kwargs):
      '''
setToBox( (BoundBlock3d)arg1, (bool)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d {lvalue} setToBox(class PyGeBoundBlock3d {lvalue},bool)'''
    ...
    def swell (self, *args, **kwargs):
      '''
swell( (BoundBlock3d)arg1, (float)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d {lvalue} swell(class PyGeBoundBlock3d {lvalue},double)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity3d)arg1, (Matrix3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} transformBy(class PyGeEntity3d {lvalue},class AcGeMatrix3d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity3d)arg1, (Vector3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} translateBy(class PyGeEntity3d {lvalue},class AcGeVector3d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity3d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity3d {lvalue})'''
    ...

class CircArc2d:
    def area (self, *args, **kwargs):
      '''
area( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double area(class PyGeCurve2d {lvalue},double,double)

area( (Curve2d)arg1, (float)arg2, (float)arg3, (Tol)arg4) -> float :

    C++ signature :
        double area(class PyGeCurve2d {lvalue},double,double,class AcGeTol)'''
    ...
    def boundBlock (self, *args, **kwargs):
      '''
boundBlock( (Curve2d)arg1) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d boundBlock(class PyGeCurve2d {lvalue})

boundBlock( (Curve2d)arg1, (Interval)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d boundBlock(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def center (self, *args, **kwargs):
      '''
center( (CircArc2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d center(class PyGeCircArc2d {lvalue})'''
    ...
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Curve2d)arg1, (Point2d)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d closestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

closestPointTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> Point2d :

    C++ signature :
        class AcGePoint2d closestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

closestPointTo( (Curve2d)arg1, (Curve2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

closestPointTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity2d)arg1) -> Entity2d :

    C++ signature :
        class PyGeEntity2d copy(class PyGeEntity2d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Curve2d)arg1, (Point2d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

distanceTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

distanceTo( (Curve2d)arg1, (Curve2d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

distanceTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def endAng (self, *args, **kwargs):
      '''
endAng( (CircArc2d)arg1) -> float :

    C++ signature :
        double endAng(class PyGeCircArc2d {lvalue})'''
    ...
    def endPoint (self, *args, **kwargs):
      '''
endPoint( (CircArc2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d endPoint(class PyGeCircArc2d {lvalue})'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Curve2d)arg1, (float)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d evalPoint(class PyGeCurve2d {lvalue},double)

evalPoint( (Curve2d)arg1, (float)arg2, (CmdFlags)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple evalPoint(class PyGeCurve2d {lvalue},double,int)'''
    ...
    def explode (self, *args, **kwargs):
      '''
explode( (Curve2d)arg1) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve2d {lvalue})

explode( (Curve2d)arg1, (Interval)arg2) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def getClosestPointTo (self, *args, **kwargs):
      '''
getClosestPointTo( (Curve2d)arg1, (Point2d)arg2) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getClosestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

getClosestPointTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getClosestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def getClosestPointsTo (self, *args, **kwargs):
      '''
getClosestPointsTo( (Curve2d)arg1, (Curve2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

getClosestPointsTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def getEndPoint (self, *args, **kwargs):
      '''
getEndPoint( (Curve2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getEndPoint(class PyGeCurve2d {lvalue})'''
    ...
    def getInterval (self, *args, **kwargs):
      '''
getInterval( (Curve2d)arg1) -> Interval :

    C++ signature :
        class PyGeInterval getInterval(class PyGeCurve2d {lvalue})'''
    ...
    def getNormalPoint (self, *args, **kwargs):
      '''
getNormalPoint( (Curve2d)arg1, (Point2d)arg2) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getNormalPoint(class PyGeCurve2d {lvalue},class AcGePoint2d)

getNormalPoint( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getNormalPoint(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def getSamplePoints (self, *args, **kwargs):
      '''
getSamplePoints( (Curve2d)arg1, (CmdFlags)arg2) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve2d {lvalue},int)

getSamplePoints( (Curve2d)arg1, (float)arg2, (float)arg3, (float)arg4) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve2d {lvalue},double,double,double)'''
    ...
    def getSplitCurves (self, *args, **kwargs):
      '''
getSplitCurves( (Curve2d)arg1, (float)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getSplitCurves(class PyGeCurve2d {lvalue},double)'''
    ...
    def getStartPoint (self, *args, **kwargs):
      '''
getStartPoint( (Curve2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getStartPoint(class PyGeCurve2d {lvalue})'''
    ...
    def getTrimmedOffset (self, *args, **kwargs):
      '''
getTrimmedOffset( (Curve2d)arg1, (float)arg2, (OffsetCrvExtType)arg3) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve2d {lvalue},double,enum AcGe::OffsetCrvExtType)

getTrimmedOffset( (Curve2d)arg1, (float)arg2, (OffsetCrvExtType)arg3, (Tol)arg4) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve2d {lvalue},double,enum AcGe::OffsetCrvExtType,class AcGeTol)'''
    ...
    def hasEndPoint (self, *args, **kwargs):
      '''
hasEndPoint( (Curve2d)arg1) -> bool :

    C++ signature :
        bool hasEndPoint(class PyGeCurve2d {lvalue})'''
    ...
    def hasStartPoint (self, *args, **kwargs):
      '''
hasStartPoint( (Curve2d)arg1) -> bool :

    C++ signature :
        bool hasStartPoint(class PyGeCurve2d {lvalue})'''
    ...
    def intersectWith (self, *args, **kwargs):
      '''
intersectWith( (CircArc2d)arg1, (LinearEnt2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeCircArc2d {lvalue},class PyGeLinearEnt2d)

intersectWith( (CircArc2d)arg1, (LinearEnt2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeCircArc2d {lvalue},class PyGeLinearEnt2d,class AcGeTol)

intersectWith( (CircArc2d)arg1, (CircArc2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeCircArc2d {lvalue},class PyGeCircArc2d)

intersectWith( (CircArc2d)arg1, (CircArc2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeCircArc2d {lvalue},class PyGeCircArc2d,class AcGeTol)'''
    ...
    def isClockWise (self, *args, **kwargs):
      '''
isClockWise( (CircArc2d)arg1) -> bool :

    C++ signature :
        bool isClockWise(class PyGeCircArc2d {lvalue})'''
    ...
    def isClosed (self, *args, **kwargs):
      '''
isClosed( (Curve2d)arg1) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve2d {lvalue})

isClosed( (Curve2d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isDegenerate (self, *args, **kwargs):
      '''
isDegenerate( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve2d {lvalue})

isDegenerate( (Curve2d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity2d)arg1, (Entity2d)arg2) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d)

isEqualTo( (Entity2d)arg1, (Entity2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d,class AcGeTol)'''
    ...
    def isInside (self, *args, **kwargs):
      '''
isInside( (CircArc2d)arg1, (Point2d)arg2) -> bool :

    C++ signature :
        bool isInside(class PyGeCircArc2d {lvalue},class AcGePoint2d)

isInside( (CircArc2d)arg1, (Point2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isInside(class PyGeCircArc2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity2d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity2d {lvalue},enum AcGe::EntityId)'''
    ...
    def isLinear (self, *args, **kwargs):
      '''
isLinear( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve2d {lvalue})

isLinear( (Curve2d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity2d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity2d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Curve2d)arg1, (Point2d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d)

isOn( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

isOn( (Curve2d)arg1, (Point2d)arg2, (float)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,double {lvalue})

isOn( (Curve2d)arg1, (Point2d)arg2, (float)arg3, (Tol)arg4) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,double {lvalue},class AcGeTol)

isOn( (Curve2d)arg1, (float)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},double)

isOn( (Curve2d)arg1, (float)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},double,class AcGeTol)'''
    ...
    def isPeriodic (self, *args, **kwargs):
      '''
isPeriodic( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPeriodic(class PyGeCurve2d {lvalue})'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double length(class PyGeCurve2d {lvalue},double,double)

length( (Curve2d)arg1, (float)arg2, (float)arg3, (float)arg4) -> float :

    C++ signature :
        double length(class PyGeCurve2d {lvalue},double,double,double)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity2d)arg1, (Line2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} mirror(class PyGeEntity2d {lvalue},class PyGeLine2d)'''
    ...
    def orthoBoundBlock (self, *args, **kwargs):
      '''
orthoBoundBlock( (Curve2d)arg1) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d orthoBoundBlock(class PyGeCurve2d {lvalue})

orthoBoundBlock( (Curve2d)arg1, (Interval)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d orthoBoundBlock(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def paramAtLength (self, *args, **kwargs):
      '''
paramAtLength( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve2d {lvalue},double,double)

paramAtLength( (Curve2d)arg1, (float)arg2, (float)arg3, (bool)arg4, (float)arg5) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve2d {lvalue},double,double,bool,double)'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Curve2d)arg1, (Point2d)arg2) -> float :

    C++ signature :
        double paramOf(class PyGeCurve2d {lvalue},class AcGePoint2d)

paramOf( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double paramOf(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def radius (self, *args, **kwargs):
      '''
radius( (CircArc2d)arg1) -> float :

    C++ signature :
        double radius(class PyGeCircArc2d {lvalue})'''
    ...
    def refVec (self, *args, **kwargs):
      '''
refVec( (CircArc2d)arg1) -> Vector2d :

    C++ signature :
        class AcGeVector2d refVec(class PyGeCircArc2d {lvalue})'''
    ...
    def reverseParam (self, *args, **kwargs):
      '''
reverseParam( (Curve2d)arg1) -> Curve2d :

    C++ signature :
        class PyGeCurve2d {lvalue} reverseParam(class PyGeCurve2d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double)

rotateBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double)

scaleBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def set (self, *args, **kwargs):
      '''
set( (CircArc2d)arg1, (Point2d)arg2, (float)arg3) -> CircArc2d :

    C++ signature :
        class PyGeCircArc2d {lvalue} set(class PyGeCircArc2d {lvalue},class AcGePoint2d,double)

set( (CircArc2d)arg1, (Point2d)arg2, (float)arg3, (float)arg4, (float)arg5, (Vector2d)arg6, (bool)arg7) -> CircArc2d :

    C++ signature :
        class PyGeCircArc2d {lvalue} set(class PyGeCircArc2d {lvalue},class AcGePoint2d,double,double,double,class AcGeVector2d,bool)

set( (CircArc2d)arg1, (Point2d)arg2, (Point2d)arg3, (Point2d)arg4) -> CircArc2d :

    C++ signature :
        class PyGeCircArc2d {lvalue} set(class PyGeCircArc2d {lvalue},class AcGePoint2d,class AcGePoint2d,class AcGePoint2d)

set( (CircArc2d)arg1, (Point2d)arg2, (Point2d)arg3, (float)arg4, (bool)arg5) -> CircArc2d :

    C++ signature :
        class PyGeCircArc2d {lvalue} set(class PyGeCircArc2d {lvalue},class AcGePoint2d,class AcGePoint2d,double,bool)

set( (CircArc2d)arg1, (Curve2d)arg2, (Curve2d)arg3, (float)arg4) -> CircArc2d :

    C++ signature :
        class PyGeCircArc2d {lvalue} set(class PyGeCircArc2d {lvalue},class PyGeCurve2d,class PyGeCurve2d,double)

set( (CircArc2d)arg1, (Curve2d)arg2, (Curve2d)arg3, (Curve2d)arg4) -> CircArc2d :

    C++ signature :
        class PyGeCircArc2d {lvalue} set(class PyGeCircArc2d {lvalue},class PyGeCurve2d,class PyGeCurve2d,class PyGeCurve2d)'''
    ...
    def setAngles (self, *args, **kwargs):
      '''
setAngles( (CircArc2d)arg1, (float)arg2, (float)arg3) -> CircArc2d :

    C++ signature :
        class PyGeCircArc2d {lvalue} setAngles(class PyGeCircArc2d {lvalue},double,double)'''
    ...
    def setCenter (self, *args, **kwargs):
      '''
setCenter( (CircArc2d)arg1, (Point2d)arg2) -> CircArc2d :

    C++ signature :
        class PyGeCircArc2d {lvalue} setCenter(class PyGeCircArc2d {lvalue},class AcGePoint2d)'''
    ...
    def setInterval (self, *args, **kwargs):
      '''
setInterval( (Curve2d)arg1) -> Curve2d :

    C++ signature :
        class PyGeCurve2d {lvalue} setInterval(class PyGeCurve2d {lvalue})

setInterval( (Curve2d)arg1, (Interval)arg2) -> bool :

    C++ signature :
        bool setInterval(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def setRadius (self, *args, **kwargs):
      '''
setRadius( (CircArc2d)arg1, (float)arg2) -> CircArc2d :

    C++ signature :
        class PyGeCircArc2d {lvalue} setRadius(class PyGeCircArc2d {lvalue},double)'''
    ...
    def setRefVec (self, *args, **kwargs):
      '''
setRefVec( (CircArc2d)arg1, (Vector2d)arg2) -> CircArc2d :

    C++ signature :
        class PyGeCircArc2d {lvalue} setRefVec(class PyGeCircArc2d {lvalue},class AcGeVector2d)'''
    ...
    def setToComplement (self, *args, **kwargs):
      '''
setToComplement( (CircArc2d)arg1) -> CircArc2d :

    C++ signature :
        class PyGeCircArc2d {lvalue} setToComplement(class PyGeCircArc2d {lvalue})'''
    ...
    def startAng (self, *args, **kwargs):
      '''
startAng( (CircArc2d)arg1) -> float :

    C++ signature :
        double startAng(class PyGeCircArc2d {lvalue})'''
    ...
    def startPoint (self, *args, **kwargs):
      '''
startPoint( (CircArc2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d startPoint(class PyGeCircArc2d {lvalue})'''
    ...
    def tangent (self, *args, **kwargs):
      '''
tangent( (CircArc2d)arg1, (Point2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple tangent(class PyGeCircArc2d {lvalue},class AcGePoint2d)

tangent( (CircArc2d)arg1, (Point2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple tangent(class PyGeCircArc2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity2d)arg1, (Matrix2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} transformBy(class PyGeEntity2d {lvalue},class AcGeMatrix2d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity2d)arg1, (Vector2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} translateBy(class PyGeEntity2d {lvalue},class AcGeVector2d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity2d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity2d {lvalue})'''
    ...

class CircArc3d:
    def area (self, *args, **kwargs):
      '''
area( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double area(class PyGeCurve3d {lvalue},double,double)

area( (Curve3d)arg1, (float)arg2, (float)arg3, (Tol)arg4) -> float :

    C++ signature :
        double area(class PyGeCurve3d {lvalue},double,double,class AcGeTol)'''
    ...
    def boundBlock (self, *args, **kwargs):
      '''
boundBlock( (Curve3d)arg1) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d boundBlock(class PyGeCurve3d {lvalue})

boundBlock( (Curve3d)arg1, (Interval)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d boundBlock(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def center (self, *args, **kwargs):
      '''
center( (CircArc3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d center(class PyGeCircArc3d {lvalue})'''
    ...
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Curve3d)arg1, (Point3d)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

closestPointTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

closestPointTo( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

closestPointTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def closestPointToPlane (self, *args, **kwargs):
      '''
closestPointToPlane( (CircArc3d)arg1, (PlanarEnt)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointToPlane(class PyGeCircArc3d {lvalue},class PyGePlanarEnt)

closestPointToPlane( (CircArc3d)arg1, (PlanarEnt)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointToPlane(class PyGeCircArc3d {lvalue},class PyGePlanarEnt,class AcGeTol)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity3d)arg1) -> Entity3d :

    C++ signature :
        class PyGeEntity3d copy(class PyGeEntity3d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Curve3d)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

distanceTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

distanceTo( (Curve3d)arg1, (Curve3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

distanceTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def endAng (self, *args, **kwargs):
      '''
endAng( (CircArc3d)arg1) -> float :

    C++ signature :
        double endAng(class PyGeCircArc3d {lvalue})'''
    ...
    def endPoint (self, *args, **kwargs):
      '''
endPoint( (CircArc3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d endPoint(class PyGeCircArc3d {lvalue})'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Curve3d)arg1, (float)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d evalPoint(class PyGeCurve3d {lvalue},double)

evalPoint( (Curve3d)arg1, (float)arg2, (CmdFlags)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple evalPoint(class PyGeCurve3d {lvalue},double,int)'''
    ...
    def explode (self, *args, **kwargs):
      '''
explode( (Curve3d)arg1) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve3d {lvalue})

explode( (Curve3d)arg1, (Interval)arg2) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def getClosestPointTo (self, *args, **kwargs):
      '''
getClosestPointTo( (Curve3d)arg1, (Point3d)arg2) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

getClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def getClosestPointsTo (self, *args, **kwargs):
      '''
getClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

getClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def getEndPoint (self, *args, **kwargs):
      '''
getEndPoint( (Curve3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getEndPoint(class PyGeCurve3d {lvalue})'''
    ...
    def getInterval (self, *args, **kwargs):
      '''
getInterval( (Curve3d)arg1) -> Interval :

    C++ signature :
        class PyGeInterval getInterval(class PyGeCurve3d {lvalue})'''
    ...
    def getNormalPoint (self, *args, **kwargs):
      '''
getNormalPoint( (Curve3d)arg1, (Point3d)arg2) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getNormalPoint(class PyGeCurve3d {lvalue},class AcGePoint3d)

getNormalPoint( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getNormalPoint(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def getPlane (self, *args, **kwargs):
      '''
getPlane( (CircArc3d)arg1) -> Plane :

    C++ signature :
        class PyGePlane getPlane(class PyGeCircArc3d {lvalue})'''
    ...
    def getProjClosestPointTo (self, *args, **kwargs):
      '''
getProjClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getProjClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d)

getProjClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Tol)arg4) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getProjClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def getProjClosestPointsTo (self, *args, **kwargs):
      '''
getProjClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getProjClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d)

getProjClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple getProjClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def getSamplePoints (self, *args, **kwargs):
      '''
getSamplePoints( (Curve3d)arg1, (CmdFlags)arg2) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve3d {lvalue},int)

getSamplePoints( (Curve3d)arg1, (float)arg2, (float)arg3, (float)arg4) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve3d {lvalue},double,double,double)'''
    ...
    def getSplitCurves (self, *args, **kwargs):
      '''
getSplitCurves( (Curve3d)arg1, (float)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getSplitCurves(class PyGeCurve3d {lvalue},double)'''
    ...
    def getStartPoint (self, *args, **kwargs):
      '''
getStartPoint( (Curve3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getStartPoint(class PyGeCurve3d {lvalue})'''
    ...
    def getTrimmedOffset (self, *args, **kwargs):
      '''
getTrimmedOffset( (Curve3d)arg1, (float)arg2, (Vector3d)arg3, (OffsetCrvExtType)arg4) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve3d {lvalue},double,class AcGeVector3d,enum AcGe::OffsetCrvExtType)

getTrimmedOffset( (Curve3d)arg1, (float)arg2, (Vector3d)arg3, (OffsetCrvExtType)arg4, (Tol)arg5) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve3d {lvalue},double,class AcGeVector3d,enum AcGe::OffsetCrvExtType,class AcGeTol)'''
    ...
    def hasEndPoint (self, *args, **kwargs):
      '''
hasEndPoint( (Curve3d)arg1) -> bool :

    C++ signature :
        bool hasEndPoint(class PyGeCurve3d {lvalue})'''
    ...
    def hasStartPoint (self, *args, **kwargs):
      '''
hasStartPoint( (Curve3d)arg1) -> bool :

    C++ signature :
        bool hasStartPoint(class PyGeCurve3d {lvalue})'''
    ...
    def intersectWith (self, *args, **kwargs):
      '''
intersectWith( (CircArc3d)arg1, (LinearEnt3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeCircArc3d {lvalue},class PyGeLinearEnt3d)

intersectWith( (CircArc3d)arg1, (LinearEnt3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeCircArc3d {lvalue},class PyGeLinearEnt3d,class AcGeTol)

intersectWith( (CircArc3d)arg1, (CircArc3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeCircArc3d {lvalue},class PyGeCircArc3d)

intersectWith( (CircArc3d)arg1, (CircArc3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeCircArc3d {lvalue},class PyGeCircArc3d,class AcGeTol)

intersectWith( (CircArc3d)arg1, (PlanarEnt)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeCircArc3d {lvalue},class PyGePlanarEnt)

intersectWith( (CircArc3d)arg1, (PlanarEnt)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeCircArc3d {lvalue},class PyGePlanarEnt,class AcGeTol)'''
    ...
    def isClosed (self, *args, **kwargs):
      '''
isClosed( (Curve3d)arg1) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve3d {lvalue})

isClosed( (Curve3d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isCoplanarWith (self, *args, **kwargs):
      '''
isCoplanarWith( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isCoplanarWith(class PyGeCurve3d {lvalue},class PyGeCurve3d)

isCoplanarWith( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple isCoplanarWith(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def isDegenerate (self, *args, **kwargs):
      '''
isDegenerate( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve3d {lvalue})

isDegenerate( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity3d)arg1, (Entity3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity3d {lvalue},class PyGeEntity3d,class AcGeTol)'''
    ...
    def isInside (self, *args, **kwargs):
      '''
isInside( (CircArc3d)arg1, (Point3d)arg2) -> bool :

    C++ signature :
        bool isInside(class PyGeCircArc3d {lvalue},class AcGePoint3d)

isInside( (CircArc3d)arg1, (Point3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isInside(class PyGeCircArc3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity3d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity3d {lvalue},enum AcGe::EntityId)'''
    ...
    def isLinear (self, *args, **kwargs):
      '''
isLinear( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve3d {lvalue})

isLinear( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity3d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity3d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Curve3d)arg1, (Point3d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d)

isOn( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

isOn( (Curve3d)arg1, (Point3d)arg2, (float)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d,double {lvalue})

isOn( (Curve3d)arg1, (Point3d)arg2, (float)arg3, (Tol)arg4) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d,double {lvalue},class AcGeTol)

isOn( (Curve3d)arg1, (float)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},double)

isOn( (Curve3d)arg1, (float)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},double,class AcGeTol)'''
    ...
    def isPeriodic (self, *args, **kwargs):
      '''
isPeriodic( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPeriodic(class PyGeCurve3d {lvalue})'''
    ...
    def isPlanar (self, *args, **kwargs):
      '''
isPlanar( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPlanar(class PyGeCurve3d {lvalue})

isPlanar( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isPlanar(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double length(class PyGeCurve3d {lvalue},double,double)

length( (Curve3d)arg1, (float)arg2, (float)arg3, (float)arg4) -> float :

    C++ signature :
        double length(class PyGeCurve3d {lvalue},double,double,double)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} mirror(class PyGeEntity3d {lvalue},class PyGePlane)'''
    ...
    def normal (self, *args, **kwargs):
      '''
normal( (CircArc3d)arg1) -> Vector3d :

    C++ signature :
        class AcGeVector3d normal(class PyGeCircArc3d {lvalue})'''
    ...
    def orthoBoundBlock (self, *args, **kwargs):
      '''
orthoBoundBlock( (Curve3d)arg1) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d orthoBoundBlock(class PyGeCurve3d {lvalue})

orthoBoundBlock( (Curve3d)arg1, (Interval)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d orthoBoundBlock(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def orthoProject (self, *args, **kwargs):
      '''
orthoProject( (Curve3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d orthoProject(class PyGeCurve3d {lvalue},class PyGePlane)

orthoProject( (Curve3d)arg1, (Plane)arg2, (Tol)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d orthoProject(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeTol)'''
    ...
    def paramAtLength (self, *args, **kwargs):
      '''
paramAtLength( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve3d {lvalue},double,double)

paramAtLength( (Curve3d)arg1, (float)arg2, (float)arg3, (bool)arg4, (float)arg5) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve3d {lvalue},double,double,bool,double)'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Curve3d)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double paramOf(class PyGeCurve3d {lvalue},class AcGePoint3d)

paramOf( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double paramOf(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def projClosestPointTo (self, *args, **kwargs):
      '''
projClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d projClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d)

projClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Tol)arg4) -> Point3d :

    C++ signature :
        class AcGePoint3d projClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def projClosestPointsTo (self, *args, **kwargs):
      '''
projClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple projClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d)

projClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple projClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def projIntersectWith (self, *args, **kwargs):
      '''
projIntersectWith( (CircArc3d)arg1, (LinearEnt3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple projIntersectWith(class PyGeCircArc3d {lvalue},class PyGeLinearEnt3d,class AcGeVector3d)

projIntersectWith( (CircArc3d)arg1, (LinearEnt3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple projIntersectWith(class PyGeCircArc3d {lvalue},class PyGeLinearEnt3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def project (self, *args, **kwargs):
      '''
project( (Curve3d)arg1, (Plane)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d project(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeVector3d)

project( (Curve3d)arg1, (Plane)arg2, (Vector3d)arg3, (Tol)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d project(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeVector3d,class AcGeTol)'''
    ...
    def radius (self, *args, **kwargs):
      '''
radius( (CircArc3d)arg1) -> float :

    C++ signature :
        double radius(class PyGeCircArc3d {lvalue})'''
    ...
    def refVec (self, *args, **kwargs):
      '''
refVec( (CircArc3d)arg1) -> Vector3d :

    C++ signature :
        class AcGeVector3d refVec(class PyGeCircArc3d {lvalue})'''
    ...
    def reverseParam (self, *args, **kwargs):
      '''
reverseParam( (Curve3d)arg1) -> Curve3d :

    C++ signature :
        class PyGeCurve3d {lvalue} reverseParam(class PyGeCurve3d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d)

rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3, (Point3d)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d,class AcGePoint3d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity3d)arg1, (float)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double)

scaleBy( (Entity3d)arg1, (float)arg2, (Point3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double,class AcGePoint3d)'''
    ...
    def set (self, *args, **kwargs):
      '''
set( (CircArc3d)arg1, (Point3d)arg2, (Vector3d)arg3, (float)arg4) -> CircArc3d :

    C++ signature :
        class PyGeCircArc3d {lvalue} set(class PyGeCircArc3d {lvalue},class AcGePoint3d,class AcGeVector3d,double)

set( (CircArc3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Vector3d)arg4, (float)arg5, (float)arg6, (float)arg7) -> CircArc3d :

    C++ signature :
        class PyGeCircArc3d {lvalue} set(class PyGeCircArc3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeVector3d,double,double,double)

set( (CircArc3d)arg1, (Point3d)arg2, (Point3d)arg3, (Point3d)arg4) -> CircArc3d :

    C++ signature :
        class PyGeCircArc3d {lvalue} set(class PyGeCircArc3d {lvalue},class AcGePoint3d,class AcGePoint3d,class AcGePoint3d)

set( (CircArc3d)arg1, (Curve3d)arg2, (Curve3d)arg3, (float)arg4) -> CircArc3d :

    C++ signature :
        class PyGeCircArc3d {lvalue} set(class PyGeCircArc3d {lvalue},class PyGeCurve3d,class PyGeCurve3d,double)

set( (CircArc3d)arg1, (Curve3d)arg2, (Curve3d)arg3, (Curve3d)arg4) -> CircArc3d :

    C++ signature :
        class PyGeCircArc3d {lvalue} set(class PyGeCircArc3d {lvalue},class PyGeCurve3d,class PyGeCurve3d,class PyGeCurve3d)'''
    ...
    def setAngles (self, *args, **kwargs):
      '''
setAngles( (CircArc3d)arg1, (float)arg2, (float)arg3) -> CircArc3d :

    C++ signature :
        class PyGeCircArc3d {lvalue} setAngles(class PyGeCircArc3d {lvalue},double,double)'''
    ...
    def setAxes (self, *args, **kwargs):
      '''
setAxes( (CircArc3d)arg1, (Vector3d)arg2, (Vector3d)arg3) -> CircArc3d :

    C++ signature :
        class PyGeCircArc3d {lvalue} setAxes(class PyGeCircArc3d {lvalue},class AcGeVector3d,class AcGeVector3d)'''
    ...
    def setCenter (self, *args, **kwargs):
      '''
setCenter( (CircArc3d)arg1, (Point3d)arg2) -> CircArc3d :

    C++ signature :
        class PyGeCircArc3d {lvalue} setCenter(class PyGeCircArc3d {lvalue},class AcGePoint3d)'''
    ...
    def setInterval (self, *args, **kwargs):
      '''
setInterval( (Curve3d)arg1) -> Curve3d :

    C++ signature :
        class PyGeCurve3d {lvalue} setInterval(class PyGeCurve3d {lvalue})

setInterval( (Curve3d)arg1, (Interval)arg2) -> bool :

    C++ signature :
        bool setInterval(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def setRadius (self, *args, **kwargs):
      '''
setRadius( (CircArc3d)arg1, (float)arg2) -> CircArc3d :

    C++ signature :
        class PyGeCircArc3d {lvalue} setRadius(class PyGeCircArc3d {lvalue},double)'''
    ...
    def startAng (self, *args, **kwargs):
      '''
startAng( (CircArc3d)arg1) -> float :

    C++ signature :
        double startAng(class PyGeCircArc3d {lvalue})'''
    ...
    def startPoint (self, *args, **kwargs):
      '''
startPoint( (CircArc3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d startPoint(class PyGeCircArc3d {lvalue})'''
    ...
    def tangent (self, *args, **kwargs):
      '''
tangent( (CircArc3d)arg1, (Point3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple tangent(class PyGeCircArc3d {lvalue},class AcGePoint3d)

tangent( (CircArc3d)arg1, (Point3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple tangent(class PyGeCircArc3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity3d)arg1, (Matrix3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} transformBy(class PyGeEntity3d {lvalue},class AcGeMatrix3d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity3d)arg1, (Vector3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} translateBy(class PyGeEntity3d {lvalue},class AcGeVector3d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity3d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity3d {lvalue})'''
    ...

class ClipBoundary2d:
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity2d)arg1) -> Entity2d :

    C++ signature :
        class PyGeEntity2d copy(class PyGeEntity2d {lvalue})'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity2d)arg1, (Entity2d)arg2) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d)

isEqualTo( (Entity2d)arg1, (Entity2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity2d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity2d {lvalue},enum AcGe::EntityId)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity2d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity2d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Entity2d)arg1, (Point2d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeEntity2d {lvalue},class AcGePoint2d)

isOn( (Entity2d)arg1, (Point2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeEntity2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity2d)arg1, (Line2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} mirror(class PyGeEntity2d {lvalue},class PyGeLine2d)'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double)

rotateBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double)

scaleBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity2d)arg1, (Matrix2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} transformBy(class PyGeEntity2d {lvalue},class AcGeMatrix2d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity2d)arg1, (Vector2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} translateBy(class PyGeEntity2d {lvalue},class AcGeVector2d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity2d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity2d {lvalue})'''
    ...

class CompositeCurve2d:
    def area (self, *args, **kwargs):
      '''
area( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double area(class PyGeCurve2d {lvalue},double,double)

area( (Curve2d)arg1, (float)arg2, (float)arg3, (Tol)arg4) -> float :

    C++ signature :
        double area(class PyGeCurve2d {lvalue},double,double,class AcGeTol)'''
    ...
    def boundBlock (self, *args, **kwargs):
      '''
boundBlock( (Curve2d)arg1) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d boundBlock(class PyGeCurve2d {lvalue})

boundBlock( (Curve2d)arg1, (Interval)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d boundBlock(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Curve2d)arg1, (Point2d)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d closestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

closestPointTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> Point2d :

    C++ signature :
        class AcGePoint2d closestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

closestPointTo( (Curve2d)arg1, (Curve2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

closestPointTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity2d)arg1) -> Entity2d :

    C++ signature :
        class PyGeEntity2d copy(class PyGeEntity2d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Curve2d)arg1, (Point2d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

distanceTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

distanceTo( (Curve2d)arg1, (Curve2d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

distanceTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Curve2d)arg1, (float)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d evalPoint(class PyGeCurve2d {lvalue},double)

evalPoint( (Curve2d)arg1, (float)arg2, (CmdFlags)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple evalPoint(class PyGeCurve2d {lvalue},double,int)'''
    ...
    def explode (self, *args, **kwargs):
      '''
explode( (Curve2d)arg1) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve2d {lvalue})

explode( (Curve2d)arg1, (Interval)arg2) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def getClosestPointTo (self, *args, **kwargs):
      '''
getClosestPointTo( (Curve2d)arg1, (Point2d)arg2) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getClosestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

getClosestPointTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getClosestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def getClosestPointsTo (self, *args, **kwargs):
      '''
getClosestPointsTo( (Curve2d)arg1, (Curve2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

getClosestPointsTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def getEndPoint (self, *args, **kwargs):
      '''
getEndPoint( (Curve2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getEndPoint(class PyGeCurve2d {lvalue})'''
    ...
    def getInterval (self, *args, **kwargs):
      '''
getInterval( (Curve2d)arg1) -> Interval :

    C++ signature :
        class PyGeInterval getInterval(class PyGeCurve2d {lvalue})'''
    ...
    def getNormalPoint (self, *args, **kwargs):
      '''
getNormalPoint( (Curve2d)arg1, (Point2d)arg2) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getNormalPoint(class PyGeCurve2d {lvalue},class AcGePoint2d)

getNormalPoint( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getNormalPoint(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def getSamplePoints (self, *args, **kwargs):
      '''
getSamplePoints( (Curve2d)arg1, (CmdFlags)arg2) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve2d {lvalue},int)

getSamplePoints( (Curve2d)arg1, (float)arg2, (float)arg3, (float)arg4) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve2d {lvalue},double,double,double)'''
    ...
    def getSplitCurves (self, *args, **kwargs):
      '''
getSplitCurves( (Curve2d)arg1, (float)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getSplitCurves(class PyGeCurve2d {lvalue},double)'''
    ...
    def getStartPoint (self, *args, **kwargs):
      '''
getStartPoint( (Curve2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getStartPoint(class PyGeCurve2d {lvalue})'''
    ...
    def getTrimmedOffset (self, *args, **kwargs):
      '''
getTrimmedOffset( (Curve2d)arg1, (float)arg2, (OffsetCrvExtType)arg3) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve2d {lvalue},double,enum AcGe::OffsetCrvExtType)

getTrimmedOffset( (Curve2d)arg1, (float)arg2, (OffsetCrvExtType)arg3, (Tol)arg4) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve2d {lvalue},double,enum AcGe::OffsetCrvExtType,class AcGeTol)'''
    ...
    def hasEndPoint (self, *args, **kwargs):
      '''
hasEndPoint( (Curve2d)arg1) -> bool :

    C++ signature :
        bool hasEndPoint(class PyGeCurve2d {lvalue})'''
    ...
    def hasStartPoint (self, *args, **kwargs):
      '''
hasStartPoint( (Curve2d)arg1) -> bool :

    C++ signature :
        bool hasStartPoint(class PyGeCurve2d {lvalue})'''
    ...
    def isClosed (self, *args, **kwargs):
      '''
isClosed( (Curve2d)arg1) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve2d {lvalue})

isClosed( (Curve2d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isDegenerate (self, *args, **kwargs):
      '''
isDegenerate( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve2d {lvalue})

isDegenerate( (Curve2d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity2d)arg1, (Entity2d)arg2) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d)

isEqualTo( (Entity2d)arg1, (Entity2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity2d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity2d {lvalue},enum AcGe::EntityId)'''
    ...
    def isLinear (self, *args, **kwargs):
      '''
isLinear( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve2d {lvalue})

isLinear( (Curve2d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity2d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity2d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Curve2d)arg1, (Point2d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d)

isOn( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

isOn( (Curve2d)arg1, (Point2d)arg2, (float)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,double {lvalue})

isOn( (Curve2d)arg1, (Point2d)arg2, (float)arg3, (Tol)arg4) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,double {lvalue},class AcGeTol)

isOn( (Curve2d)arg1, (float)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},double)

isOn( (Curve2d)arg1, (float)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},double,class AcGeTol)'''
    ...
    def isPeriodic (self, *args, **kwargs):
      '''
isPeriodic( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPeriodic(class PyGeCurve2d {lvalue})'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double length(class PyGeCurve2d {lvalue},double,double)

length( (Curve2d)arg1, (float)arg2, (float)arg3, (float)arg4) -> float :

    C++ signature :
        double length(class PyGeCurve2d {lvalue},double,double,double)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity2d)arg1, (Line2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} mirror(class PyGeEntity2d {lvalue},class PyGeLine2d)'''
    ...
    def orthoBoundBlock (self, *args, **kwargs):
      '''
orthoBoundBlock( (Curve2d)arg1) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d orthoBoundBlock(class PyGeCurve2d {lvalue})

orthoBoundBlock( (Curve2d)arg1, (Interval)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d orthoBoundBlock(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def paramAtLength (self, *args, **kwargs):
      '''
paramAtLength( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve2d {lvalue},double,double)

paramAtLength( (Curve2d)arg1, (float)arg2, (float)arg3, (bool)arg4, (float)arg5) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve2d {lvalue},double,double,bool,double)'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Curve2d)arg1, (Point2d)arg2) -> float :

    C++ signature :
        double paramOf(class PyGeCurve2d {lvalue},class AcGePoint2d)

paramOf( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double paramOf(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def reverseParam (self, *args, **kwargs):
      '''
reverseParam( (Curve2d)arg1) -> Curve2d :

    C++ signature :
        class PyGeCurve2d {lvalue} reverseParam(class PyGeCurve2d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double)

rotateBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double)

scaleBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def setInterval (self, *args, **kwargs):
      '''
setInterval( (Curve2d)arg1) -> Curve2d :

    C++ signature :
        class PyGeCurve2d {lvalue} setInterval(class PyGeCurve2d {lvalue})

setInterval( (Curve2d)arg1, (Interval)arg2) -> bool :

    C++ signature :
        bool setInterval(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity2d)arg1, (Matrix2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} transformBy(class PyGeEntity2d {lvalue},class AcGeMatrix2d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity2d)arg1, (Vector2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} translateBy(class PyGeEntity2d {lvalue},class AcGeVector2d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity2d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity2d {lvalue})'''
    ...

class CompositeCurve3d:
    def area (self, *args, **kwargs):
      '''
area( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double area(class PyGeCurve3d {lvalue},double,double)

area( (Curve3d)arg1, (float)arg2, (float)arg3, (Tol)arg4) -> float :

    C++ signature :
        double area(class PyGeCurve3d {lvalue},double,double,class AcGeTol)'''
    ...
    def boundBlock (self, *args, **kwargs):
      '''
boundBlock( (Curve3d)arg1) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d boundBlock(class PyGeCurve3d {lvalue})

boundBlock( (Curve3d)arg1, (Interval)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d boundBlock(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Curve3d)arg1, (Point3d)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

closestPointTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

closestPointTo( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

closestPointTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity3d)arg1) -> Entity3d :

    C++ signature :
        class PyGeEntity3d copy(class PyGeEntity3d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Curve3d)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

distanceTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

distanceTo( (Curve3d)arg1, (Curve3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

distanceTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Curve3d)arg1, (float)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d evalPoint(class PyGeCurve3d {lvalue},double)

evalPoint( (Curve3d)arg1, (float)arg2, (CmdFlags)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple evalPoint(class PyGeCurve3d {lvalue},double,int)'''
    ...
    def explode (self, *args, **kwargs):
      '''
explode( (Curve3d)arg1) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve3d {lvalue})

explode( (Curve3d)arg1, (Interval)arg2) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def getClosestPointTo (self, *args, **kwargs):
      '''
getClosestPointTo( (Curve3d)arg1, (Point3d)arg2) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

getClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def getClosestPointsTo (self, *args, **kwargs):
      '''
getClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

getClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def getEndPoint (self, *args, **kwargs):
      '''
getEndPoint( (Curve3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getEndPoint(class PyGeCurve3d {lvalue})'''
    ...
    def getInterval (self, *args, **kwargs):
      '''
getInterval( (Curve3d)arg1) -> Interval :

    C++ signature :
        class PyGeInterval getInterval(class PyGeCurve3d {lvalue})'''
    ...
    def getNormalPoint (self, *args, **kwargs):
      '''
getNormalPoint( (Curve3d)arg1, (Point3d)arg2) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getNormalPoint(class PyGeCurve3d {lvalue},class AcGePoint3d)

getNormalPoint( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getNormalPoint(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def getProjClosestPointTo (self, *args, **kwargs):
      '''
getProjClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getProjClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d)

getProjClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Tol)arg4) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getProjClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def getProjClosestPointsTo (self, *args, **kwargs):
      '''
getProjClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getProjClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d)

getProjClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple getProjClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def getSamplePoints (self, *args, **kwargs):
      '''
getSamplePoints( (Curve3d)arg1, (CmdFlags)arg2) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve3d {lvalue},int)

getSamplePoints( (Curve3d)arg1, (float)arg2, (float)arg3, (float)arg4) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve3d {lvalue},double,double,double)'''
    ...
    def getSplitCurves (self, *args, **kwargs):
      '''
getSplitCurves( (Curve3d)arg1, (float)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getSplitCurves(class PyGeCurve3d {lvalue},double)'''
    ...
    def getStartPoint (self, *args, **kwargs):
      '''
getStartPoint( (Curve3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getStartPoint(class PyGeCurve3d {lvalue})'''
    ...
    def getTrimmedOffset (self, *args, **kwargs):
      '''
getTrimmedOffset( (Curve3d)arg1, (float)arg2, (Vector3d)arg3, (OffsetCrvExtType)arg4) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve3d {lvalue},double,class AcGeVector3d,enum AcGe::OffsetCrvExtType)

getTrimmedOffset( (Curve3d)arg1, (float)arg2, (Vector3d)arg3, (OffsetCrvExtType)arg4, (Tol)arg5) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve3d {lvalue},double,class AcGeVector3d,enum AcGe::OffsetCrvExtType,class AcGeTol)'''
    ...
    def hasEndPoint (self, *args, **kwargs):
      '''
hasEndPoint( (Curve3d)arg1) -> bool :

    C++ signature :
        bool hasEndPoint(class PyGeCurve3d {lvalue})'''
    ...
    def hasStartPoint (self, *args, **kwargs):
      '''
hasStartPoint( (Curve3d)arg1) -> bool :

    C++ signature :
        bool hasStartPoint(class PyGeCurve3d {lvalue})'''
    ...
    def isClosed (self, *args, **kwargs):
      '''
isClosed( (Curve3d)arg1) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve3d {lvalue})

isClosed( (Curve3d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isCoplanarWith (self, *args, **kwargs):
      '''
isCoplanarWith( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isCoplanarWith(class PyGeCurve3d {lvalue},class PyGeCurve3d)

isCoplanarWith( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple isCoplanarWith(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def isDegenerate (self, *args, **kwargs):
      '''
isDegenerate( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve3d {lvalue})

isDegenerate( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity3d)arg1, (Entity3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity3d {lvalue},class PyGeEntity3d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity3d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity3d {lvalue},enum AcGe::EntityId)'''
    ...
    def isLinear (self, *args, **kwargs):
      '''
isLinear( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve3d {lvalue})

isLinear( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity3d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity3d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Curve3d)arg1, (Point3d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d)

isOn( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

isOn( (Curve3d)arg1, (Point3d)arg2, (float)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d,double {lvalue})

isOn( (Curve3d)arg1, (Point3d)arg2, (float)arg3, (Tol)arg4) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d,double {lvalue},class AcGeTol)

isOn( (Curve3d)arg1, (float)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},double)

isOn( (Curve3d)arg1, (float)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},double,class AcGeTol)'''
    ...
    def isPeriodic (self, *args, **kwargs):
      '''
isPeriodic( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPeriodic(class PyGeCurve3d {lvalue})'''
    ...
    def isPlanar (self, *args, **kwargs):
      '''
isPlanar( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPlanar(class PyGeCurve3d {lvalue})

isPlanar( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isPlanar(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double length(class PyGeCurve3d {lvalue},double,double)

length( (Curve3d)arg1, (float)arg2, (float)arg3, (float)arg4) -> float :

    C++ signature :
        double length(class PyGeCurve3d {lvalue},double,double,double)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} mirror(class PyGeEntity3d {lvalue},class PyGePlane)'''
    ...
    def orthoBoundBlock (self, *args, **kwargs):
      '''
orthoBoundBlock( (Curve3d)arg1) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d orthoBoundBlock(class PyGeCurve3d {lvalue})

orthoBoundBlock( (Curve3d)arg1, (Interval)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d orthoBoundBlock(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def orthoProject (self, *args, **kwargs):
      '''
orthoProject( (Curve3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d orthoProject(class PyGeCurve3d {lvalue},class PyGePlane)

orthoProject( (Curve3d)arg1, (Plane)arg2, (Tol)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d orthoProject(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeTol)'''
    ...
    def paramAtLength (self, *args, **kwargs):
      '''
paramAtLength( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve3d {lvalue},double,double)

paramAtLength( (Curve3d)arg1, (float)arg2, (float)arg3, (bool)arg4, (float)arg5) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve3d {lvalue},double,double,bool,double)'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Curve3d)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double paramOf(class PyGeCurve3d {lvalue},class AcGePoint3d)

paramOf( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double paramOf(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def projClosestPointTo (self, *args, **kwargs):
      '''
projClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d projClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d)

projClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Tol)arg4) -> Point3d :

    C++ signature :
        class AcGePoint3d projClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def projClosestPointsTo (self, *args, **kwargs):
      '''
projClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple projClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d)

projClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple projClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def project (self, *args, **kwargs):
      '''
project( (Curve3d)arg1, (Plane)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d project(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeVector3d)

project( (Curve3d)arg1, (Plane)arg2, (Vector3d)arg3, (Tol)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d project(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeVector3d,class AcGeTol)'''
    ...
    def reverseParam (self, *args, **kwargs):
      '''
reverseParam( (Curve3d)arg1) -> Curve3d :

    C++ signature :
        class PyGeCurve3d {lvalue} reverseParam(class PyGeCurve3d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d)

rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3, (Point3d)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d,class AcGePoint3d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity3d)arg1, (float)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double)

scaleBy( (Entity3d)arg1, (float)arg2, (Point3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double,class AcGePoint3d)'''
    ...
    def setInterval (self, *args, **kwargs):
      '''
setInterval( (Curve3d)arg1) -> Curve3d :

    C++ signature :
        class PyGeCurve3d {lvalue} setInterval(class PyGeCurve3d {lvalue})

setInterval( (Curve3d)arg1, (Interval)arg2) -> bool :

    C++ signature :
        bool setInterval(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity3d)arg1, (Matrix3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} transformBy(class PyGeEntity3d {lvalue},class AcGeMatrix3d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity3d)arg1, (Vector3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} translateBy(class PyGeEntity3d {lvalue},class AcGeVector3d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity3d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity3d {lvalue})'''
    ...

class CubicSplineCurve2d:
    def area (self, *args, **kwargs):
      '''
area( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double area(class PyGeCurve2d {lvalue},double,double)

area( (Curve2d)arg1, (float)arg2, (float)arg3, (Tol)arg4) -> float :

    C++ signature :
        double area(class PyGeCurve2d {lvalue},double,double,class AcGeTol)'''
    ...
    def boundBlock (self, *args, **kwargs):
      '''
boundBlock( (Curve2d)arg1) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d boundBlock(class PyGeCurve2d {lvalue})

boundBlock( (Curve2d)arg1, (Interval)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d boundBlock(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Curve2d)arg1, (Point2d)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d closestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

closestPointTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> Point2d :

    C++ signature :
        class AcGePoint2d closestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

closestPointTo( (Curve2d)arg1, (Curve2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

closestPointTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def continuityAtKnot (self, *args, **kwargs):
      '''
continuityAtKnot( (SplineEnt2d)arg1, (CmdFlags)arg2) -> int :

    C++ signature :
        int continuityAtKnot(class PyGeSplineEnt2d {lvalue},int)

continuityAtKnot( (SplineEnt2d)arg1, (CmdFlags)arg2, (Tol)arg3) -> int :

    C++ signature :
        int continuityAtKnot(class PyGeSplineEnt2d {lvalue},int,class AcGeTol)'''
    ...
    def controlPointAt (self, *args, **kwargs):
      '''
controlPointAt( (SplineEnt2d)arg1, (CmdFlags)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d controlPointAt(class PyGeSplineEnt2d {lvalue},int)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity2d)arg1) -> Entity2d :

    C++ signature :
        class PyGeEntity2d copy(class PyGeEntity2d {lvalue})'''
    ...
    def degree (self, *args, **kwargs):
      '''
degree( (SplineEnt2d)arg1) -> int :

    C++ signature :
        int degree(class PyGeSplineEnt2d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Curve2d)arg1, (Point2d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

distanceTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

distanceTo( (Curve2d)arg1, (Curve2d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

distanceTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def endParam (self, *args, **kwargs):
      '''
endParam( (SplineEnt2d)arg1) -> float :

    C++ signature :
        double endParam(class PyGeSplineEnt2d {lvalue})'''
    ...
    def endPoint (self, *args, **kwargs):
      '''
endPoint( (SplineEnt2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d endPoint(class PyGeSplineEnt2d {lvalue})'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Curve2d)arg1, (float)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d evalPoint(class PyGeCurve2d {lvalue},double)

evalPoint( (Curve2d)arg1, (float)arg2, (CmdFlags)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple evalPoint(class PyGeCurve2d {lvalue},double,int)'''
    ...
    def explode (self, *args, **kwargs):
      '''
explode( (Curve2d)arg1) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve2d {lvalue})

explode( (Curve2d)arg1, (Interval)arg2) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def getClosestPointTo (self, *args, **kwargs):
      '''
getClosestPointTo( (Curve2d)arg1, (Point2d)arg2) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getClosestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

getClosestPointTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getClosestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def getClosestPointsTo (self, *args, **kwargs):
      '''
getClosestPointsTo( (Curve2d)arg1, (Curve2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

getClosestPointsTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def getEndPoint (self, *args, **kwargs):
      '''
getEndPoint( (Curve2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getEndPoint(class PyGeCurve2d {lvalue})'''
    ...
    def getInterval (self, *args, **kwargs):
      '''
getInterval( (Curve2d)arg1) -> Interval :

    C++ signature :
        class PyGeInterval getInterval(class PyGeCurve2d {lvalue})'''
    ...
    def getNormalPoint (self, *args, **kwargs):
      '''
getNormalPoint( (Curve2d)arg1, (Point2d)arg2) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getNormalPoint(class PyGeCurve2d {lvalue},class AcGePoint2d)

getNormalPoint( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getNormalPoint(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def getSamplePoints (self, *args, **kwargs):
      '''
getSamplePoints( (Curve2d)arg1, (CmdFlags)arg2) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve2d {lvalue},int)

getSamplePoints( (Curve2d)arg1, (float)arg2, (float)arg3, (float)arg4) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve2d {lvalue},double,double,double)'''
    ...
    def getSplitCurves (self, *args, **kwargs):
      '''
getSplitCurves( (Curve2d)arg1, (float)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getSplitCurves(class PyGeCurve2d {lvalue},double)'''
    ...
    def getStartPoint (self, *args, **kwargs):
      '''
getStartPoint( (Curve2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getStartPoint(class PyGeCurve2d {lvalue})'''
    ...
    def getTrimmedOffset (self, *args, **kwargs):
      '''
getTrimmedOffset( (Curve2d)arg1, (float)arg2, (OffsetCrvExtType)arg3) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve2d {lvalue},double,enum AcGe::OffsetCrvExtType)

getTrimmedOffset( (Curve2d)arg1, (float)arg2, (OffsetCrvExtType)arg3, (Tol)arg4) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve2d {lvalue},double,enum AcGe::OffsetCrvExtType,class AcGeTol)'''
    ...
    def hasEndPoint (self, *args, **kwargs):
      '''
hasEndPoint( (Curve2d)arg1) -> bool :

    C++ signature :
        bool hasEndPoint(class PyGeCurve2d {lvalue})'''
    ...
    def hasFitData (self, *args, **kwargs):
      '''
hasFitData( (SplineEnt2d)arg1) -> bool :

    C++ signature :
        bool hasFitData(class PyGeSplineEnt2d {lvalue})'''
    ...
    def hasStartPoint (self, *args, **kwargs):
      '''
hasStartPoint( (Curve2d)arg1) -> bool :

    C++ signature :
        bool hasStartPoint(class PyGeCurve2d {lvalue})'''
    ...
    def isClosed (self, *args, **kwargs):
      '''
isClosed( (Curve2d)arg1) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve2d {lvalue})

isClosed( (Curve2d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isDegenerate (self, *args, **kwargs):
      '''
isDegenerate( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve2d {lvalue})

isDegenerate( (Curve2d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity2d)arg1, (Entity2d)arg2) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d)

isEqualTo( (Entity2d)arg1, (Entity2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity2d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity2d {lvalue},enum AcGe::EntityId)'''
    ...
    def isLinear (self, *args, **kwargs):
      '''
isLinear( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve2d {lvalue})

isLinear( (Curve2d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity2d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity2d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Curve2d)arg1, (Point2d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d)

isOn( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

isOn( (Curve2d)arg1, (Point2d)arg2, (float)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,double {lvalue})

isOn( (Curve2d)arg1, (Point2d)arg2, (float)arg3, (Tol)arg4) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,double {lvalue},class AcGeTol)

isOn( (Curve2d)arg1, (float)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},double)

isOn( (Curve2d)arg1, (float)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},double,class AcGeTol)'''
    ...
    def isPeriodic (self, *args, **kwargs):
      '''
isPeriodic( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPeriodic(class PyGeCurve2d {lvalue})'''
    ...
    def isRational (self, *args, **kwargs):
      '''
isRational( (SplineEnt2d)arg1) -> bool :

    C++ signature :
        bool isRational(class PyGeSplineEnt2d {lvalue})'''
    ...
    def knotAt (self, *args, **kwargs):
      '''
knotAt( (SplineEnt2d)arg1, (CmdFlags)arg2) -> float :

    C++ signature :
        double knotAt(class PyGeSplineEnt2d {lvalue},int)'''
    ...
    def knots (self, *args, **kwargs):
      '''
knots( (SplineEnt2d)arg1) -> KnotVector :

    C++ signature :
        class PyGeKnotVector knots(class PyGeSplineEnt2d {lvalue})'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double length(class PyGeCurve2d {lvalue},double,double)

length( (Curve2d)arg1, (float)arg2, (float)arg3, (float)arg4) -> float :

    C++ signature :
        double length(class PyGeCurve2d {lvalue},double,double,double)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity2d)arg1, (Line2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} mirror(class PyGeEntity2d {lvalue},class PyGeLine2d)'''
    ...
    def numControlPoints (self, *args, **kwargs):
      '''
numControlPoints( (SplineEnt2d)arg1) -> int :

    C++ signature :
        int numControlPoints(class PyGeSplineEnt2d {lvalue})'''
    ...
    def numKnots (self, *args, **kwargs):
      '''
numKnots( (SplineEnt2d)arg1) -> int :

    C++ signature :
        int numKnots(class PyGeSplineEnt2d {lvalue})'''
    ...
    def order (self, *args, **kwargs):
      '''
order( (SplineEnt2d)arg1) -> int :

    C++ signature :
        int order(class PyGeSplineEnt2d {lvalue})'''
    ...
    def orthoBoundBlock (self, *args, **kwargs):
      '''
orthoBoundBlock( (Curve2d)arg1) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d orthoBoundBlock(class PyGeCurve2d {lvalue})

orthoBoundBlock( (Curve2d)arg1, (Interval)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d orthoBoundBlock(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def paramAtLength (self, *args, **kwargs):
      '''
paramAtLength( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve2d {lvalue},double,double)

paramAtLength( (Curve2d)arg1, (float)arg2, (float)arg3, (bool)arg4, (float)arg5) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve2d {lvalue},double,double,bool,double)'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Curve2d)arg1, (Point2d)arg2) -> float :

    C++ signature :
        double paramOf(class PyGeCurve2d {lvalue},class AcGePoint2d)

paramOf( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double paramOf(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def reverseParam (self, *args, **kwargs):
      '''
reverseParam( (Curve2d)arg1) -> Curve2d :

    C++ signature :
        class PyGeCurve2d {lvalue} reverseParam(class PyGeCurve2d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double)

rotateBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double)

scaleBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def setControlPointAt (self, *args, **kwargs):
      '''
setControlPointAt( (SplineEnt2d)arg1, (CmdFlags)arg2, (Point2d)arg3) -> SplineEnt2d :

    C++ signature :
        class PyGeSplineEnt2d {lvalue} setControlPointAt(class PyGeSplineEnt2d {lvalue},int,class AcGePoint2d)'''
    ...
    def setInterval (self, *args, **kwargs):
      '''
setInterval( (Curve2d)arg1) -> Curve2d :

    C++ signature :
        class PyGeCurve2d {lvalue} setInterval(class PyGeCurve2d {lvalue})

setInterval( (Curve2d)arg1, (Interval)arg2) -> bool :

    C++ signature :
        bool setInterval(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def setKnotAt (self, *args, **kwargs):
      '''
setKnotAt( (SplineEnt2d)arg1, (CmdFlags)arg2, (float)arg3) -> SplineEnt2d :

    C++ signature :
        class PyGeSplineEnt2d {lvalue} setKnotAt(class PyGeSplineEnt2d {lvalue},int,double)'''
    ...
    def startParam (self, *args, **kwargs):
      '''
startParam( (SplineEnt2d)arg1) -> float :

    C++ signature :
        double startParam(class PyGeSplineEnt2d {lvalue})'''
    ...
    def startPoint (self, *args, **kwargs):
      '''
startPoint( (SplineEnt2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d startPoint(class PyGeSplineEnt2d {lvalue})'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity2d)arg1, (Matrix2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} transformBy(class PyGeEntity2d {lvalue},class AcGeMatrix2d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity2d)arg1, (Vector2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} translateBy(class PyGeEntity2d {lvalue},class AcGeVector2d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity2d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity2d {lvalue})'''
    ...

class CubicSplineCurve3d:
    def area (self, *args, **kwargs):
      '''
area( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double area(class PyGeCurve3d {lvalue},double,double)

area( (Curve3d)arg1, (float)arg2, (float)arg3, (Tol)arg4) -> float :

    C++ signature :
        double area(class PyGeCurve3d {lvalue},double,double,class AcGeTol)'''
    ...
    def boundBlock (self, *args, **kwargs):
      '''
boundBlock( (Curve3d)arg1) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d boundBlock(class PyGeCurve3d {lvalue})

boundBlock( (Curve3d)arg1, (Interval)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d boundBlock(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Curve3d)arg1, (Point3d)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

closestPointTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

closestPointTo( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

closestPointTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def continuityAtKnot (self, *args, **kwargs):
      '''
continuityAtKnot( (SplineEnt3d)arg1, (CmdFlags)arg2) -> int :

    C++ signature :
        int continuityAtKnot(class PyGeSplineEnt3d {lvalue},int)

continuityAtKnot( (SplineEnt3d)arg1, (CmdFlags)arg2, (Tol)arg3) -> int :

    C++ signature :
        int continuityAtKnot(class PyGeSplineEnt3d {lvalue},int,class AcGeTol)'''
    ...
    def controlPointAt (self, *args, **kwargs):
      '''
controlPointAt( (SplineEnt3d)arg1, (CmdFlags)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d controlPointAt(class PyGeSplineEnt3d {lvalue},int)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity3d)arg1) -> Entity3d :

    C++ signature :
        class PyGeEntity3d copy(class PyGeEntity3d {lvalue})'''
    ...
    def degree (self, *args, **kwargs):
      '''
degree( (SplineEnt3d)arg1) -> int :

    C++ signature :
        int degree(class PyGeSplineEnt3d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Curve3d)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

distanceTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

distanceTo( (Curve3d)arg1, (Curve3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

distanceTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def endParam (self, *args, **kwargs):
      '''
endParam( (SplineEnt3d)arg1) -> float :

    C++ signature :
        double endParam(class PyGeSplineEnt3d {lvalue})'''
    ...
    def endPoint (self, *args, **kwargs):
      '''
endPoint( (SplineEnt3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d endPoint(class PyGeSplineEnt3d {lvalue})'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Curve3d)arg1, (float)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d evalPoint(class PyGeCurve3d {lvalue},double)

evalPoint( (Curve3d)arg1, (float)arg2, (CmdFlags)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple evalPoint(class PyGeCurve3d {lvalue},double,int)'''
    ...
    def explode (self, *args, **kwargs):
      '''
explode( (Curve3d)arg1) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve3d {lvalue})

explode( (Curve3d)arg1, (Interval)arg2) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def getClosestPointTo (self, *args, **kwargs):
      '''
getClosestPointTo( (Curve3d)arg1, (Point3d)arg2) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

getClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def getClosestPointsTo (self, *args, **kwargs):
      '''
getClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

getClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def getEndPoint (self, *args, **kwargs):
      '''
getEndPoint( (Curve3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getEndPoint(class PyGeCurve3d {lvalue})'''
    ...
    def getInterval (self, *args, **kwargs):
      '''
getInterval( (Curve3d)arg1) -> Interval :

    C++ signature :
        class PyGeInterval getInterval(class PyGeCurve3d {lvalue})'''
    ...
    def getNormalPoint (self, *args, **kwargs):
      '''
getNormalPoint( (Curve3d)arg1, (Point3d)arg2) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getNormalPoint(class PyGeCurve3d {lvalue},class AcGePoint3d)

getNormalPoint( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getNormalPoint(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def getProjClosestPointTo (self, *args, **kwargs):
      '''
getProjClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getProjClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d)

getProjClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Tol)arg4) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getProjClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def getProjClosestPointsTo (self, *args, **kwargs):
      '''
getProjClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getProjClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d)

getProjClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple getProjClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def getSamplePoints (self, *args, **kwargs):
      '''
getSamplePoints( (Curve3d)arg1, (CmdFlags)arg2) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve3d {lvalue},int)

getSamplePoints( (Curve3d)arg1, (float)arg2, (float)arg3, (float)arg4) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve3d {lvalue},double,double,double)'''
    ...
    def getSplitCurves (self, *args, **kwargs):
      '''
getSplitCurves( (Curve3d)arg1, (float)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getSplitCurves(class PyGeCurve3d {lvalue},double)'''
    ...
    def getStartPoint (self, *args, **kwargs):
      '''
getStartPoint( (Curve3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getStartPoint(class PyGeCurve3d {lvalue})'''
    ...
    def getTrimmedOffset (self, *args, **kwargs):
      '''
getTrimmedOffset( (Curve3d)arg1, (float)arg2, (Vector3d)arg3, (OffsetCrvExtType)arg4) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve3d {lvalue},double,class AcGeVector3d,enum AcGe::OffsetCrvExtType)

getTrimmedOffset( (Curve3d)arg1, (float)arg2, (Vector3d)arg3, (OffsetCrvExtType)arg4, (Tol)arg5) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve3d {lvalue},double,class AcGeVector3d,enum AcGe::OffsetCrvExtType,class AcGeTol)'''
    ...
    def hasEndPoint (self, *args, **kwargs):
      '''
hasEndPoint( (Curve3d)arg1) -> bool :

    C++ signature :
        bool hasEndPoint(class PyGeCurve3d {lvalue})'''
    ...
    def hasFitData (self, *args, **kwargs):
      '''
hasFitData( (SplineEnt3d)arg1) -> bool :

    C++ signature :
        bool hasFitData(class PyGeSplineEnt3d {lvalue})'''
    ...
    def hasStartPoint (self, *args, **kwargs):
      '''
hasStartPoint( (Curve3d)arg1) -> bool :

    C++ signature :
        bool hasStartPoint(class PyGeCurve3d {lvalue})'''
    ...
    def isClosed (self, *args, **kwargs):
      '''
isClosed( (Curve3d)arg1) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve3d {lvalue})

isClosed( (Curve3d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isCoplanarWith (self, *args, **kwargs):
      '''
isCoplanarWith( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isCoplanarWith(class PyGeCurve3d {lvalue},class PyGeCurve3d)

isCoplanarWith( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple isCoplanarWith(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def isDegenerate (self, *args, **kwargs):
      '''
isDegenerate( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve3d {lvalue})

isDegenerate( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity3d)arg1, (Entity3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity3d {lvalue},class PyGeEntity3d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity3d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity3d {lvalue},enum AcGe::EntityId)'''
    ...
    def isLinear (self, *args, **kwargs):
      '''
isLinear( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve3d {lvalue})

isLinear( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity3d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity3d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Curve3d)arg1, (Point3d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d)

isOn( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

isOn( (Curve3d)arg1, (Point3d)arg2, (float)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d,double {lvalue})

isOn( (Curve3d)arg1, (Point3d)arg2, (float)arg3, (Tol)arg4) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d,double {lvalue},class AcGeTol)

isOn( (Curve3d)arg1, (float)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},double)

isOn( (Curve3d)arg1, (float)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},double,class AcGeTol)'''
    ...
    def isPeriodic (self, *args, **kwargs):
      '''
isPeriodic( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPeriodic(class PyGeCurve3d {lvalue})'''
    ...
    def isPlanar (self, *args, **kwargs):
      '''
isPlanar( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPlanar(class PyGeCurve3d {lvalue})

isPlanar( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isPlanar(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isRational (self, *args, **kwargs):
      '''
isRational( (SplineEnt3d)arg1) -> bool :

    C++ signature :
        bool isRational(class PyGeSplineEnt3d {lvalue})'''
    ...
    def knotAt (self, *args, **kwargs):
      '''
knotAt( (SplineEnt3d)arg1, (CmdFlags)arg2) -> float :

    C++ signature :
        double knotAt(class PyGeSplineEnt3d {lvalue},int)'''
    ...
    def knots (self, *args, **kwargs):
      '''
knots( (SplineEnt3d)arg1) -> KnotVector :

    C++ signature :
        class PyGeKnotVector knots(class PyGeSplineEnt3d {lvalue})'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double length(class PyGeCurve3d {lvalue},double,double)

length( (Curve3d)arg1, (float)arg2, (float)arg3, (float)arg4) -> float :

    C++ signature :
        double length(class PyGeCurve3d {lvalue},double,double,double)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} mirror(class PyGeEntity3d {lvalue},class PyGePlane)'''
    ...
    def numControlPoints (self, *args, **kwargs):
      '''
numControlPoints( (SplineEnt3d)arg1) -> int :

    C++ signature :
        int numControlPoints(class PyGeSplineEnt3d {lvalue})'''
    ...
    def numKnots (self, *args, **kwargs):
      '''
numKnots( (SplineEnt3d)arg1) -> int :

    C++ signature :
        int numKnots(class PyGeSplineEnt3d {lvalue})'''
    ...
    def order (self, *args, **kwargs):
      '''
order( (SplineEnt3d)arg1) -> int :

    C++ signature :
        int order(class PyGeSplineEnt3d {lvalue})'''
    ...
    def orthoBoundBlock (self, *args, **kwargs):
      '''
orthoBoundBlock( (Curve3d)arg1) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d orthoBoundBlock(class PyGeCurve3d {lvalue})

orthoBoundBlock( (Curve3d)arg1, (Interval)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d orthoBoundBlock(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def orthoProject (self, *args, **kwargs):
      '''
orthoProject( (Curve3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d orthoProject(class PyGeCurve3d {lvalue},class PyGePlane)

orthoProject( (Curve3d)arg1, (Plane)arg2, (Tol)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d orthoProject(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeTol)'''
    ...
    def paramAtLength (self, *args, **kwargs):
      '''
paramAtLength( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve3d {lvalue},double,double)

paramAtLength( (Curve3d)arg1, (float)arg2, (float)arg3, (bool)arg4, (float)arg5) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve3d {lvalue},double,double,bool,double)'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Curve3d)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double paramOf(class PyGeCurve3d {lvalue},class AcGePoint3d)

paramOf( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double paramOf(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def projClosestPointTo (self, *args, **kwargs):
      '''
projClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d projClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d)

projClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Tol)arg4) -> Point3d :

    C++ signature :
        class AcGePoint3d projClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def projClosestPointsTo (self, *args, **kwargs):
      '''
projClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple projClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d)

projClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple projClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def project (self, *args, **kwargs):
      '''
project( (Curve3d)arg1, (Plane)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d project(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeVector3d)

project( (Curve3d)arg1, (Plane)arg2, (Vector3d)arg3, (Tol)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d project(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeVector3d,class AcGeTol)'''
    ...
    def reverseParam (self, *args, **kwargs):
      '''
reverseParam( (Curve3d)arg1) -> Curve3d :

    C++ signature :
        class PyGeCurve3d {lvalue} reverseParam(class PyGeCurve3d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d)

rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3, (Point3d)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d,class AcGePoint3d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity3d)arg1, (float)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double)

scaleBy( (Entity3d)arg1, (float)arg2, (Point3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double,class AcGePoint3d)'''
    ...
    def setControlPointAt (self, *args, **kwargs):
      '''
setControlPointAt( (SplineEnt3d)arg1, (CmdFlags)arg2, (Point3d)arg3) -> SplineEnt3d :

    C++ signature :
        class PyGeSplineEnt3d {lvalue} setControlPointAt(class PyGeSplineEnt3d {lvalue},int,class AcGePoint3d)'''
    ...
    def setInterval (self, *args, **kwargs):
      '''
setInterval( (Curve3d)arg1) -> Curve3d :

    C++ signature :
        class PyGeCurve3d {lvalue} setInterval(class PyGeCurve3d {lvalue})

setInterval( (Curve3d)arg1, (Interval)arg2) -> bool :

    C++ signature :
        bool setInterval(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def setKnotAt (self, *args, **kwargs):
      '''
setKnotAt( (SplineEnt3d)arg1, (CmdFlags)arg2, (float)arg3) -> SplineEnt3d :

    C++ signature :
        class PyGeSplineEnt3d {lvalue} setKnotAt(class PyGeSplineEnt3d {lvalue},int,double)'''
    ...
    def startParam (self, *args, **kwargs):
      '''
startParam( (SplineEnt3d)arg1) -> float :

    C++ signature :
        double startParam(class PyGeSplineEnt3d {lvalue})'''
    ...
    def startPoint (self, *args, **kwargs):
      '''
startPoint( (SplineEnt3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d startPoint(class PyGeSplineEnt3d {lvalue})'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity3d)arg1, (Matrix3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} transformBy(class PyGeEntity3d {lvalue},class AcGeMatrix3d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity3d)arg1, (Vector3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} translateBy(class PyGeEntity3d {lvalue},class AcGeVector3d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity3d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity3d {lvalue})'''
    ...

class Curve2d:
    def area (self, *args, **kwargs):
      '''
area( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double area(class PyGeCurve2d {lvalue},double,double)

area( (Curve2d)arg1, (float)arg2, (float)arg3, (Tol)arg4) -> float :

    C++ signature :
        double area(class PyGeCurve2d {lvalue},double,double,class AcGeTol)'''
    ...
    def boundBlock (self, *args, **kwargs):
      '''
boundBlock( (Curve2d)arg1) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d boundBlock(class PyGeCurve2d {lvalue})

boundBlock( (Curve2d)arg1, (Interval)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d boundBlock(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Curve2d)arg1, (Point2d)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d closestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

closestPointTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> Point2d :

    C++ signature :
        class AcGePoint2d closestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

closestPointTo( (Curve2d)arg1, (Curve2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

closestPointTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity2d)arg1) -> Entity2d :

    C++ signature :
        class PyGeEntity2d copy(class PyGeEntity2d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Curve2d)arg1, (Point2d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

distanceTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

distanceTo( (Curve2d)arg1, (Curve2d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

distanceTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Curve2d)arg1, (float)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d evalPoint(class PyGeCurve2d {lvalue},double)

evalPoint( (Curve2d)arg1, (float)arg2, (CmdFlags)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple evalPoint(class PyGeCurve2d {lvalue},double,int)'''
    ...
    def explode (self, *args, **kwargs):
      '''
explode( (Curve2d)arg1) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve2d {lvalue})

explode( (Curve2d)arg1, (Interval)arg2) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def getClosestPointTo (self, *args, **kwargs):
      '''
getClosestPointTo( (Curve2d)arg1, (Point2d)arg2) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getClosestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

getClosestPointTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getClosestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def getClosestPointsTo (self, *args, **kwargs):
      '''
getClosestPointsTo( (Curve2d)arg1, (Curve2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

getClosestPointsTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def getEndPoint (self, *args, **kwargs):
      '''
getEndPoint( (Curve2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getEndPoint(class PyGeCurve2d {lvalue})'''
    ...
    def getInterval (self, *args, **kwargs):
      '''
getInterval( (Curve2d)arg1) -> Interval :

    C++ signature :
        class PyGeInterval getInterval(class PyGeCurve2d {lvalue})'''
    ...
    def getNormalPoint (self, *args, **kwargs):
      '''
getNormalPoint( (Curve2d)arg1, (Point2d)arg2) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getNormalPoint(class PyGeCurve2d {lvalue},class AcGePoint2d)

getNormalPoint( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getNormalPoint(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def getSamplePoints (self, *args, **kwargs):
      '''
getSamplePoints( (Curve2d)arg1, (CmdFlags)arg2) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve2d {lvalue},int)

getSamplePoints( (Curve2d)arg1, (float)arg2, (float)arg3, (float)arg4) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve2d {lvalue},double,double,double)'''
    ...
    def getSplitCurves (self, *args, **kwargs):
      '''
getSplitCurves( (Curve2d)arg1, (float)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getSplitCurves(class PyGeCurve2d {lvalue},double)'''
    ...
    def getStartPoint (self, *args, **kwargs):
      '''
getStartPoint( (Curve2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getStartPoint(class PyGeCurve2d {lvalue})'''
    ...
    def getTrimmedOffset (self, *args, **kwargs):
      '''
getTrimmedOffset( (Curve2d)arg1, (float)arg2, (OffsetCrvExtType)arg3) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve2d {lvalue},double,enum AcGe::OffsetCrvExtType)

getTrimmedOffset( (Curve2d)arg1, (float)arg2, (OffsetCrvExtType)arg3, (Tol)arg4) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve2d {lvalue},double,enum AcGe::OffsetCrvExtType,class AcGeTol)'''
    ...
    def hasEndPoint (self, *args, **kwargs):
      '''
hasEndPoint( (Curve2d)arg1) -> bool :

    C++ signature :
        bool hasEndPoint(class PyGeCurve2d {lvalue})'''
    ...
    def hasStartPoint (self, *args, **kwargs):
      '''
hasStartPoint( (Curve2d)arg1) -> bool :

    C++ signature :
        bool hasStartPoint(class PyGeCurve2d {lvalue})'''
    ...
    def isClosed (self, *args, **kwargs):
      '''
isClosed( (Curve2d)arg1) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve2d {lvalue})

isClosed( (Curve2d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isDegenerate (self, *args, **kwargs):
      '''
isDegenerate( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve2d {lvalue})

isDegenerate( (Curve2d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity2d)arg1, (Entity2d)arg2) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d)

isEqualTo( (Entity2d)arg1, (Entity2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity2d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity2d {lvalue},enum AcGe::EntityId)'''
    ...
    def isLinear (self, *args, **kwargs):
      '''
isLinear( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve2d {lvalue})

isLinear( (Curve2d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity2d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity2d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Curve2d)arg1, (Point2d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d)

isOn( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

isOn( (Curve2d)arg1, (Point2d)arg2, (float)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,double {lvalue})

isOn( (Curve2d)arg1, (Point2d)arg2, (float)arg3, (Tol)arg4) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,double {lvalue},class AcGeTol)

isOn( (Curve2d)arg1, (float)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},double)

isOn( (Curve2d)arg1, (float)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},double,class AcGeTol)'''
    ...
    def isPeriodic (self, *args, **kwargs):
      '''
isPeriodic( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPeriodic(class PyGeCurve2d {lvalue})'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double length(class PyGeCurve2d {lvalue},double,double)

length( (Curve2d)arg1, (float)arg2, (float)arg3, (float)arg4) -> float :

    C++ signature :
        double length(class PyGeCurve2d {lvalue},double,double,double)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity2d)arg1, (Line2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} mirror(class PyGeEntity2d {lvalue},class PyGeLine2d)'''
    ...
    def orthoBoundBlock (self, *args, **kwargs):
      '''
orthoBoundBlock( (Curve2d)arg1) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d orthoBoundBlock(class PyGeCurve2d {lvalue})

orthoBoundBlock( (Curve2d)arg1, (Interval)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d orthoBoundBlock(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def paramAtLength (self, *args, **kwargs):
      '''
paramAtLength( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve2d {lvalue},double,double)

paramAtLength( (Curve2d)arg1, (float)arg2, (float)arg3, (bool)arg4, (float)arg5) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve2d {lvalue},double,double,bool,double)'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Curve2d)arg1, (Point2d)arg2) -> float :

    C++ signature :
        double paramOf(class PyGeCurve2d {lvalue},class AcGePoint2d)

paramOf( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double paramOf(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def reverseParam (self, *args, **kwargs):
      '''
reverseParam( (Curve2d)arg1) -> Curve2d :

    C++ signature :
        class PyGeCurve2d {lvalue} reverseParam(class PyGeCurve2d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double)

rotateBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double)

scaleBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def setInterval (self, *args, **kwargs):
      '''
setInterval( (Curve2d)arg1) -> Curve2d :

    C++ signature :
        class PyGeCurve2d {lvalue} setInterval(class PyGeCurve2d {lvalue})

setInterval( (Curve2d)arg1, (Interval)arg2) -> bool :

    C++ signature :
        bool setInterval(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity2d)arg1, (Matrix2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} transformBy(class PyGeEntity2d {lvalue},class AcGeMatrix2d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity2d)arg1, (Vector2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} translateBy(class PyGeEntity2d {lvalue},class AcGeVector2d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity2d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity2d {lvalue})'''
    ...

class Curve3d:
    def area (self, *args, **kwargs):
      '''
area( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double area(class PyGeCurve3d {lvalue},double,double)

area( (Curve3d)arg1, (float)arg2, (float)arg3, (Tol)arg4) -> float :

    C++ signature :
        double area(class PyGeCurve3d {lvalue},double,double,class AcGeTol)'''
    ...
    def boundBlock (self, *args, **kwargs):
      '''
boundBlock( (Curve3d)arg1) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d boundBlock(class PyGeCurve3d {lvalue})

boundBlock( (Curve3d)arg1, (Interval)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d boundBlock(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Curve3d)arg1, (Point3d)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

closestPointTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

closestPointTo( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

closestPointTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity3d)arg1) -> Entity3d :

    C++ signature :
        class PyGeEntity3d copy(class PyGeEntity3d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Curve3d)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

distanceTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

distanceTo( (Curve3d)arg1, (Curve3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

distanceTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Curve3d)arg1, (float)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d evalPoint(class PyGeCurve3d {lvalue},double)

evalPoint( (Curve3d)arg1, (float)arg2, (CmdFlags)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple evalPoint(class PyGeCurve3d {lvalue},double,int)'''
    ...
    def explode (self, *args, **kwargs):
      '''
explode( (Curve3d)arg1) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve3d {lvalue})

explode( (Curve3d)arg1, (Interval)arg2) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def getClosestPointTo (self, *args, **kwargs):
      '''
getClosestPointTo( (Curve3d)arg1, (Point3d)arg2) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

getClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def getClosestPointsTo (self, *args, **kwargs):
      '''
getClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

getClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def getEndPoint (self, *args, **kwargs):
      '''
getEndPoint( (Curve3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getEndPoint(class PyGeCurve3d {lvalue})'''
    ...
    def getInterval (self, *args, **kwargs):
      '''
getInterval( (Curve3d)arg1) -> Interval :

    C++ signature :
        class PyGeInterval getInterval(class PyGeCurve3d {lvalue})'''
    ...
    def getNormalPoint (self, *args, **kwargs):
      '''
getNormalPoint( (Curve3d)arg1, (Point3d)arg2) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getNormalPoint(class PyGeCurve3d {lvalue},class AcGePoint3d)

getNormalPoint( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getNormalPoint(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def getProjClosestPointTo (self, *args, **kwargs):
      '''
getProjClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getProjClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d)

getProjClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Tol)arg4) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getProjClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def getProjClosestPointsTo (self, *args, **kwargs):
      '''
getProjClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getProjClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d)

getProjClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple getProjClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def getSamplePoints (self, *args, **kwargs):
      '''
getSamplePoints( (Curve3d)arg1, (CmdFlags)arg2) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve3d {lvalue},int)

getSamplePoints( (Curve3d)arg1, (float)arg2, (float)arg3, (float)arg4) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve3d {lvalue},double,double,double)'''
    ...
    def getSplitCurves (self, *args, **kwargs):
      '''
getSplitCurves( (Curve3d)arg1, (float)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getSplitCurves(class PyGeCurve3d {lvalue},double)'''
    ...
    def getStartPoint (self, *args, **kwargs):
      '''
getStartPoint( (Curve3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getStartPoint(class PyGeCurve3d {lvalue})'''
    ...
    def getTrimmedOffset (self, *args, **kwargs):
      '''
getTrimmedOffset( (Curve3d)arg1, (float)arg2, (Vector3d)arg3, (OffsetCrvExtType)arg4) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve3d {lvalue},double,class AcGeVector3d,enum AcGe::OffsetCrvExtType)

getTrimmedOffset( (Curve3d)arg1, (float)arg2, (Vector3d)arg3, (OffsetCrvExtType)arg4, (Tol)arg5) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve3d {lvalue},double,class AcGeVector3d,enum AcGe::OffsetCrvExtType,class AcGeTol)'''
    ...
    def hasEndPoint (self, *args, **kwargs):
      '''
hasEndPoint( (Curve3d)arg1) -> bool :

    C++ signature :
        bool hasEndPoint(class PyGeCurve3d {lvalue})'''
    ...
    def hasStartPoint (self, *args, **kwargs):
      '''
hasStartPoint( (Curve3d)arg1) -> bool :

    C++ signature :
        bool hasStartPoint(class PyGeCurve3d {lvalue})'''
    ...
    def isClosed (self, *args, **kwargs):
      '''
isClosed( (Curve3d)arg1) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve3d {lvalue})

isClosed( (Curve3d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isCoplanarWith (self, *args, **kwargs):
      '''
isCoplanarWith( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isCoplanarWith(class PyGeCurve3d {lvalue},class PyGeCurve3d)

isCoplanarWith( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple isCoplanarWith(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def isDegenerate (self, *args, **kwargs):
      '''
isDegenerate( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve3d {lvalue})

isDegenerate( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity3d)arg1, (Entity3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity3d {lvalue},class PyGeEntity3d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity3d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity3d {lvalue},enum AcGe::EntityId)'''
    ...
    def isLinear (self, *args, **kwargs):
      '''
isLinear( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve3d {lvalue})

isLinear( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity3d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity3d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Curve3d)arg1, (Point3d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d)

isOn( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

isOn( (Curve3d)arg1, (Point3d)arg2, (float)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d,double {lvalue})

isOn( (Curve3d)arg1, (Point3d)arg2, (float)arg3, (Tol)arg4) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d,double {lvalue},class AcGeTol)

isOn( (Curve3d)arg1, (float)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},double)

isOn( (Curve3d)arg1, (float)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},double,class AcGeTol)'''
    ...
    def isPeriodic (self, *args, **kwargs):
      '''
isPeriodic( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPeriodic(class PyGeCurve3d {lvalue})'''
    ...
    def isPlanar (self, *args, **kwargs):
      '''
isPlanar( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPlanar(class PyGeCurve3d {lvalue})

isPlanar( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isPlanar(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double length(class PyGeCurve3d {lvalue},double,double)

length( (Curve3d)arg1, (float)arg2, (float)arg3, (float)arg4) -> float :

    C++ signature :
        double length(class PyGeCurve3d {lvalue},double,double,double)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} mirror(class PyGeEntity3d {lvalue},class PyGePlane)'''
    ...
    def orthoBoundBlock (self, *args, **kwargs):
      '''
orthoBoundBlock( (Curve3d)arg1) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d orthoBoundBlock(class PyGeCurve3d {lvalue})

orthoBoundBlock( (Curve3d)arg1, (Interval)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d orthoBoundBlock(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def orthoProject (self, *args, **kwargs):
      '''
orthoProject( (Curve3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d orthoProject(class PyGeCurve3d {lvalue},class PyGePlane)

orthoProject( (Curve3d)arg1, (Plane)arg2, (Tol)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d orthoProject(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeTol)'''
    ...
    def paramAtLength (self, *args, **kwargs):
      '''
paramAtLength( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve3d {lvalue},double,double)

paramAtLength( (Curve3d)arg1, (float)arg2, (float)arg3, (bool)arg4, (float)arg5) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve3d {lvalue},double,double,bool,double)'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Curve3d)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double paramOf(class PyGeCurve3d {lvalue},class AcGePoint3d)

paramOf( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double paramOf(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def projClosestPointTo (self, *args, **kwargs):
      '''
projClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d projClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d)

projClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Tol)arg4) -> Point3d :

    C++ signature :
        class AcGePoint3d projClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def projClosestPointsTo (self, *args, **kwargs):
      '''
projClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple projClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d)

projClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple projClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def project (self, *args, **kwargs):
      '''
project( (Curve3d)arg1, (Plane)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d project(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeVector3d)

project( (Curve3d)arg1, (Plane)arg2, (Vector3d)arg3, (Tol)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d project(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeVector3d,class AcGeTol)'''
    ...
    def reverseParam (self, *args, **kwargs):
      '''
reverseParam( (Curve3d)arg1) -> Curve3d :

    C++ signature :
        class PyGeCurve3d {lvalue} reverseParam(class PyGeCurve3d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d)

rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3, (Point3d)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d,class AcGePoint3d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity3d)arg1, (float)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double)

scaleBy( (Entity3d)arg1, (float)arg2, (Point3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double,class AcGePoint3d)'''
    ...
    def setInterval (self, *args, **kwargs):
      '''
setInterval( (Curve3d)arg1) -> Curve3d :

    C++ signature :
        class PyGeCurve3d {lvalue} setInterval(class PyGeCurve3d {lvalue})

setInterval( (Curve3d)arg1, (Interval)arg2) -> bool :

    C++ signature :
        bool setInterval(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity3d)arg1, (Matrix3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} transformBy(class PyGeEntity3d {lvalue},class AcGeMatrix3d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity3d)arg1, (Vector3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} translateBy(class PyGeEntity3d {lvalue},class AcGeVector3d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity3d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity3d {lvalue})'''
    ...

class CurveCurveInt2d:
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity2d)arg1) -> Entity2d :

    C++ signature :
        class PyGeEntity2d copy(class PyGeEntity2d {lvalue})'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity2d)arg1, (Entity2d)arg2) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d)

isEqualTo( (Entity2d)arg1, (Entity2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity2d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity2d {lvalue},enum AcGe::EntityId)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity2d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity2d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Entity2d)arg1, (Point2d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeEntity2d {lvalue},class AcGePoint2d)

isOn( (Entity2d)arg1, (Point2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeEntity2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity2d)arg1, (Line2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} mirror(class PyGeEntity2d {lvalue},class PyGeLine2d)'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double)

rotateBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double)

scaleBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity2d)arg1, (Matrix2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} transformBy(class PyGeEntity2d {lvalue},class AcGeMatrix2d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity2d)arg1, (Vector2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} translateBy(class PyGeEntity2d {lvalue},class AcGeVector2d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity2d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity2d {lvalue})'''
    ...

class CurveCurveInt3d:
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity3d)arg1) -> Entity3d :

    C++ signature :
        class PyGeEntity3d copy(class PyGeEntity3d {lvalue})'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity3d)arg1, (Entity3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity3d {lvalue},class PyGeEntity3d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity3d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity3d {lvalue},enum AcGe::EntityId)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity3d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity3d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Entity3d)arg1, (Point3d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeEntity3d {lvalue},class AcGePoint3d)

isOn( (Entity3d)arg1, (Point3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeEntity3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} mirror(class PyGeEntity3d {lvalue},class PyGePlane)'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d)

rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3, (Point3d)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d,class AcGePoint3d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity3d)arg1, (float)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double)

scaleBy( (Entity3d)arg1, (float)arg2, (Point3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double,class AcGePoint3d)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity3d)arg1, (Matrix3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} transformBy(class PyGeEntity3d {lvalue},class AcGeMatrix3d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity3d)arg1, (Vector3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} translateBy(class PyGeEntity3d {lvalue},class AcGeVector3d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity3d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity3d {lvalue})'''
    ...

class CurveSurfInt:
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity3d)arg1) -> Entity3d :

    C++ signature :
        class PyGeEntity3d copy(class PyGeEntity3d {lvalue})'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity3d)arg1, (Entity3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity3d {lvalue},class PyGeEntity3d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity3d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity3d {lvalue},enum AcGe::EntityId)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity3d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity3d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Entity3d)arg1, (Point3d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeEntity3d {lvalue},class AcGePoint3d)

isOn( (Entity3d)arg1, (Point3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeEntity3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} mirror(class PyGeEntity3d {lvalue},class PyGePlane)'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d)

rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3, (Point3d)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d,class AcGePoint3d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity3d)arg1, (float)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double)

scaleBy( (Entity3d)arg1, (float)arg2, (Point3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double,class AcGePoint3d)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity3d)arg1, (Matrix3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} transformBy(class PyGeEntity3d {lvalue},class AcGeMatrix3d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity3d)arg1, (Vector3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} translateBy(class PyGeEntity3d {lvalue},class AcGeVector3d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity3d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity3d {lvalue})'''
    ...

class EllipArc2d:
    def area (self, *args, **kwargs):
      '''
area( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double area(class PyGeCurve2d {lvalue},double,double)

area( (Curve2d)arg1, (float)arg2, (float)arg3, (Tol)arg4) -> float :

    C++ signature :
        double area(class PyGeCurve2d {lvalue},double,double,class AcGeTol)'''
    ...
    def boundBlock (self, *args, **kwargs):
      '''
boundBlock( (Curve2d)arg1) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d boundBlock(class PyGeCurve2d {lvalue})

boundBlock( (Curve2d)arg1, (Interval)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d boundBlock(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def center (self, *args, **kwargs):
      '''
center( (EllipArc2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d center(class PyGeEllipArc2d {lvalue})'''
    ...
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Curve2d)arg1, (Point2d)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d closestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

closestPointTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> Point2d :

    C++ signature :
        class AcGePoint2d closestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

closestPointTo( (Curve2d)arg1, (Curve2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

closestPointTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity2d)arg1) -> Entity2d :

    C++ signature :
        class PyGeEntity2d copy(class PyGeEntity2d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Curve2d)arg1, (Point2d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

distanceTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

distanceTo( (Curve2d)arg1, (Curve2d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

distanceTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def endAng (self, *args, **kwargs):
      '''
endAng( (EllipArc2d)arg1) -> float :

    C++ signature :
        double endAng(class PyGeEllipArc2d {lvalue})'''
    ...
    def endPoint (self, *args, **kwargs):
      '''
endPoint( (EllipArc2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d endPoint(class PyGeEllipArc2d {lvalue})'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Curve2d)arg1, (float)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d evalPoint(class PyGeCurve2d {lvalue},double)

evalPoint( (Curve2d)arg1, (float)arg2, (CmdFlags)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple evalPoint(class PyGeCurve2d {lvalue},double,int)'''
    ...
    def explode (self, *args, **kwargs):
      '''
explode( (Curve2d)arg1) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve2d {lvalue})

explode( (Curve2d)arg1, (Interval)arg2) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def getClosestPointTo (self, *args, **kwargs):
      '''
getClosestPointTo( (Curve2d)arg1, (Point2d)arg2) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getClosestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

getClosestPointTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getClosestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def getClosestPointsTo (self, *args, **kwargs):
      '''
getClosestPointsTo( (Curve2d)arg1, (Curve2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

getClosestPointsTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def getEndPoint (self, *args, **kwargs):
      '''
getEndPoint( (Curve2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getEndPoint(class PyGeCurve2d {lvalue})'''
    ...
    def getInterval (self, *args, **kwargs):
      '''
getInterval( (Curve2d)arg1) -> Interval :

    C++ signature :
        class PyGeInterval getInterval(class PyGeCurve2d {lvalue})'''
    ...
    def getNormalPoint (self, *args, **kwargs):
      '''
getNormalPoint( (Curve2d)arg1, (Point2d)arg2) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getNormalPoint(class PyGeCurve2d {lvalue},class AcGePoint2d)

getNormalPoint( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getNormalPoint(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def getSamplePoints (self, *args, **kwargs):
      '''
getSamplePoints( (Curve2d)arg1, (CmdFlags)arg2) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve2d {lvalue},int)

getSamplePoints( (Curve2d)arg1, (float)arg2, (float)arg3, (float)arg4) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve2d {lvalue},double,double,double)'''
    ...
    def getSplitCurves (self, *args, **kwargs):
      '''
getSplitCurves( (Curve2d)arg1, (float)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getSplitCurves(class PyGeCurve2d {lvalue},double)'''
    ...
    def getStartPoint (self, *args, **kwargs):
      '''
getStartPoint( (Curve2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getStartPoint(class PyGeCurve2d {lvalue})'''
    ...
    def getTrimmedOffset (self, *args, **kwargs):
      '''
getTrimmedOffset( (Curve2d)arg1, (float)arg2, (OffsetCrvExtType)arg3) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve2d {lvalue},double,enum AcGe::OffsetCrvExtType)

getTrimmedOffset( (Curve2d)arg1, (float)arg2, (OffsetCrvExtType)arg3, (Tol)arg4) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve2d {lvalue},double,enum AcGe::OffsetCrvExtType,class AcGeTol)'''
    ...
    def hasEndPoint (self, *args, **kwargs):
      '''
hasEndPoint( (Curve2d)arg1) -> bool :

    C++ signature :
        bool hasEndPoint(class PyGeCurve2d {lvalue})'''
    ...
    def hasStartPoint (self, *args, **kwargs):
      '''
hasStartPoint( (Curve2d)arg1) -> bool :

    C++ signature :
        bool hasStartPoint(class PyGeCurve2d {lvalue})'''
    ...
    def intersectWith (self, *args, **kwargs):
      '''
intersectWith( (EllipArc2d)arg1, (LinearEnt2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeEllipArc2d {lvalue},class PyGeLinearEnt2d)

intersectWith( (EllipArc2d)arg1, (LinearEnt2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeEllipArc2d {lvalue},class PyGeLinearEnt2d,class AcGeTol)'''
    ...
    def isCircular (self, *args, **kwargs):
      '''
isCircular( (EllipArc2d)arg1) -> bool :

    C++ signature :
        bool isCircular(class PyGeEllipArc2d {lvalue})

isCircular( (EllipArc2d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isCircular(class PyGeEllipArc2d {lvalue},class AcGeTol)'''
    ...
    def isClockWise (self, *args, **kwargs):
      '''
isClockWise( (EllipArc2d)arg1) -> bool :

    C++ signature :
        bool isClockWise(class PyGeEllipArc2d {lvalue})'''
    ...
    def isClosed (self, *args, **kwargs):
      '''
isClosed( (Curve2d)arg1) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve2d {lvalue})

isClosed( (Curve2d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isDegenerate (self, *args, **kwargs):
      '''
isDegenerate( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve2d {lvalue})

isDegenerate( (Curve2d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity2d)arg1, (Entity2d)arg2) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d)

isEqualTo( (Entity2d)arg1, (Entity2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d,class AcGeTol)'''
    ...
    def isInside (self, *args, **kwargs):
      '''
isInside( (EllipArc2d)arg1, (Point2d)arg2) -> bool :

    C++ signature :
        bool isInside(class PyGeEllipArc2d {lvalue},class AcGePoint2d)

isInside( (EllipArc2d)arg1, (Point2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isInside(class PyGeEllipArc2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity2d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity2d {lvalue},enum AcGe::EntityId)'''
    ...
    def isLinear (self, *args, **kwargs):
      '''
isLinear( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve2d {lvalue})

isLinear( (Curve2d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity2d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity2d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Curve2d)arg1, (Point2d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d)

isOn( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

isOn( (Curve2d)arg1, (Point2d)arg2, (float)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,double {lvalue})

isOn( (Curve2d)arg1, (Point2d)arg2, (float)arg3, (Tol)arg4) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,double {lvalue},class AcGeTol)

isOn( (Curve2d)arg1, (float)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},double)

isOn( (Curve2d)arg1, (float)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},double,class AcGeTol)'''
    ...
    def isPeriodic (self, *args, **kwargs):
      '''
isPeriodic( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPeriodic(class PyGeCurve2d {lvalue})'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double length(class PyGeCurve2d {lvalue},double,double)

length( (Curve2d)arg1, (float)arg2, (float)arg3, (float)arg4) -> float :

    C++ signature :
        double length(class PyGeCurve2d {lvalue},double,double,double)'''
    ...
    def majorAxis (self, *args, **kwargs):
      '''
majorAxis( (EllipArc2d)arg1) -> Vector2d :

    C++ signature :
        class AcGeVector2d majorAxis(class PyGeEllipArc2d {lvalue})'''
    ...
    def majorRadius (self, *args, **kwargs):
      '''
majorRadius( (EllipArc2d)arg1) -> float :

    C++ signature :
        double majorRadius(class PyGeEllipArc2d {lvalue})'''
    ...
    def minorAxis (self, *args, **kwargs):
      '''
minorAxis( (EllipArc2d)arg1) -> Vector2d :

    C++ signature :
        class AcGeVector2d minorAxis(class PyGeEllipArc2d {lvalue})'''
    ...
    def minorRadius (self, *args, **kwargs):
      '''
minorRadius( (EllipArc2d)arg1) -> float :

    C++ signature :
        double minorRadius(class PyGeEllipArc2d {lvalue})'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity2d)arg1, (Line2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} mirror(class PyGeEntity2d {lvalue},class PyGeLine2d)'''
    ...
    def orthoBoundBlock (self, *args, **kwargs):
      '''
orthoBoundBlock( (Curve2d)arg1) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d orthoBoundBlock(class PyGeCurve2d {lvalue})

orthoBoundBlock( (Curve2d)arg1, (Interval)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d orthoBoundBlock(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def paramAtLength (self, *args, **kwargs):
      '''
paramAtLength( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve2d {lvalue},double,double)

paramAtLength( (Curve2d)arg1, (float)arg2, (float)arg3, (bool)arg4, (float)arg5) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve2d {lvalue},double,double,bool,double)'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Curve2d)arg1, (Point2d)arg2) -> float :

    C++ signature :
        double paramOf(class PyGeCurve2d {lvalue},class AcGePoint2d)

paramOf( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double paramOf(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def reverseParam (self, *args, **kwargs):
      '''
reverseParam( (Curve2d)arg1) -> Curve2d :

    C++ signature :
        class PyGeCurve2d {lvalue} reverseParam(class PyGeCurve2d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double)

rotateBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double)

scaleBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def set (self, *args, **kwargs):
      '''
set( (EllipArc2d)arg1, (Point2d)arg2, (Vector2d)arg3, (Vector2d)arg4, (float)arg5, (float)arg6) -> EllipArc2d :

    C++ signature :
        class PyGeEllipArc2d {lvalue} set(class PyGeEllipArc2d {lvalue},class AcGePoint2d,class AcGeVector2d,class AcGeVector2d,double,double)

set( (EllipArc2d)arg1, (Point2d)arg2, (Vector2d)arg3, (Vector2d)arg4, (float)arg5, (float)arg6, (float)arg7, (float)arg8) -> EllipArc2d :

    C++ signature :
        class PyGeEllipArc2d {lvalue} set(class PyGeEllipArc2d {lvalue},class AcGePoint2d,class AcGeVector2d,class AcGeVector2d,double,double,double,double)

set( (EllipArc2d)arg1, (CircArc2d)arg2) -> EllipArc2d :

    C++ signature :
        class PyGeEllipArc2d {lvalue} set(class PyGeEllipArc2d {lvalue},class PyGeCircArc2d)'''
    ...
    def setAngles (self, *args, **kwargs):
      '''
setAngles( (EllipArc2d)arg1, (float)arg2, (float)arg3) -> EllipArc2d :

    C++ signature :
        class PyGeEllipArc2d {lvalue} setAngles(class PyGeEllipArc2d {lvalue},double,double)'''
    ...
    def setAxes (self, *args, **kwargs):
      '''
setAxes( (EllipArc2d)arg1, (Vector2d)arg2, (Vector2d)arg3) -> EllipArc2d :

    C++ signature :
        class PyGeEllipArc2d {lvalue} setAxes(class PyGeEllipArc2d {lvalue},class AcGeVector2d,class AcGeVector2d)'''
    ...
    def setCenter (self, *args, **kwargs):
      '''
setCenter( (EllipArc2d)arg1, (Point2d)arg2) -> EllipArc2d :

    C++ signature :
        class PyGeEllipArc2d {lvalue} setCenter(class PyGeEllipArc2d {lvalue},class AcGePoint2d)'''
    ...
    def setInterval (self, *args, **kwargs):
      '''
setInterval( (Curve2d)arg1) -> Curve2d :

    C++ signature :
        class PyGeCurve2d {lvalue} setInterval(class PyGeCurve2d {lvalue})

setInterval( (Curve2d)arg1, (Interval)arg2) -> bool :

    C++ signature :
        bool setInterval(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def setMajorRadius (self, *args, **kwargs):
      '''
setMajorRadius( (EllipArc2d)arg1, (float)arg2) -> EllipArc2d :

    C++ signature :
        class PyGeEllipArc2d {lvalue} setMajorRadius(class PyGeEllipArc2d {lvalue},double)'''
    ...
    def setMinorRadius (self, *args, **kwargs):
      '''
setMinorRadius( (EllipArc2d)arg1, (float)arg2) -> EllipArc2d :

    C++ signature :
        class PyGeEllipArc2d {lvalue} setMinorRadius(class PyGeEllipArc2d {lvalue},double)'''
    ...
    def startAng (self, *args, **kwargs):
      '''
startAng( (EllipArc2d)arg1) -> float :

    C++ signature :
        double startAng(class PyGeEllipArc2d {lvalue})'''
    ...
    def startPoint (self, *args, **kwargs):
      '''
startPoint( (EllipArc2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d startPoint(class PyGeEllipArc2d {lvalue})'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity2d)arg1, (Matrix2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} transformBy(class PyGeEntity2d {lvalue},class AcGeMatrix2d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity2d)arg1, (Vector2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} translateBy(class PyGeEntity2d {lvalue},class AcGeVector2d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity2d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity2d {lvalue})'''
    ...

class EllipArc3d:
    def area (self, *args, **kwargs):
      '''
area( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double area(class PyGeCurve3d {lvalue},double,double)

area( (Curve3d)arg1, (float)arg2, (float)arg3, (Tol)arg4) -> float :

    C++ signature :
        double area(class PyGeCurve3d {lvalue},double,double,class AcGeTol)'''
    ...
    def boundBlock (self, *args, **kwargs):
      '''
boundBlock( (Curve3d)arg1) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d boundBlock(class PyGeCurve3d {lvalue})

boundBlock( (Curve3d)arg1, (Interval)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d boundBlock(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def center (self, *args, **kwargs):
      '''
center( (EllipArc3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d center(class PyGeEllipArc3d {lvalue})'''
    ...
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Curve3d)arg1, (Point3d)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

closestPointTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

closestPointTo( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

closestPointTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def closestPointToPlane (self, *args, **kwargs):
      '''
closestPointToPlane( (EllipArc3d)arg1, (PlanarEnt)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointToPlane(class PyGeEllipArc3d {lvalue},class PyGePlanarEnt)

closestPointToPlane( (EllipArc3d)arg1, (PlanarEnt)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointToPlane(class PyGeEllipArc3d {lvalue},class PyGePlanarEnt,class AcGeTol)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity3d)arg1) -> Entity3d :

    C++ signature :
        class PyGeEntity3d copy(class PyGeEntity3d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Curve3d)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

distanceTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

distanceTo( (Curve3d)arg1, (Curve3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

distanceTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def endAng (self, *args, **kwargs):
      '''
endAng( (EllipArc3d)arg1) -> float :

    C++ signature :
        double endAng(class PyGeEllipArc3d {lvalue})'''
    ...
    def endPoint (self, *args, **kwargs):
      '''
endPoint( (EllipArc3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d endPoint(class PyGeEllipArc3d {lvalue})'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Curve3d)arg1, (float)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d evalPoint(class PyGeCurve3d {lvalue},double)

evalPoint( (Curve3d)arg1, (float)arg2, (CmdFlags)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple evalPoint(class PyGeCurve3d {lvalue},double,int)'''
    ...
    def explode (self, *args, **kwargs):
      '''
explode( (Curve3d)arg1) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve3d {lvalue})

explode( (Curve3d)arg1, (Interval)arg2) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def getClosestPointTo (self, *args, **kwargs):
      '''
getClosestPointTo( (Curve3d)arg1, (Point3d)arg2) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

getClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def getClosestPointsTo (self, *args, **kwargs):
      '''
getClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

getClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def getEndPoint (self, *args, **kwargs):
      '''
getEndPoint( (Curve3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getEndPoint(class PyGeCurve3d {lvalue})'''
    ...
    def getInterval (self, *args, **kwargs):
      '''
getInterval( (Curve3d)arg1) -> Interval :

    C++ signature :
        class PyGeInterval getInterval(class PyGeCurve3d {lvalue})'''
    ...
    def getNormalPoint (self, *args, **kwargs):
      '''
getNormalPoint( (Curve3d)arg1, (Point3d)arg2) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getNormalPoint(class PyGeCurve3d {lvalue},class AcGePoint3d)

getNormalPoint( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getNormalPoint(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def getPlane (self, *args, **kwargs):
      '''
getPlane( (EllipArc3d)arg1) -> Plane :

    C++ signature :
        class PyGePlane getPlane(class PyGeEllipArc3d {lvalue})'''
    ...
    def getProjClosestPointTo (self, *args, **kwargs):
      '''
getProjClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getProjClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d)

getProjClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Tol)arg4) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getProjClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def getProjClosestPointsTo (self, *args, **kwargs):
      '''
getProjClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getProjClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d)

getProjClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple getProjClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def getSamplePoints (self, *args, **kwargs):
      '''
getSamplePoints( (Curve3d)arg1, (CmdFlags)arg2) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve3d {lvalue},int)

getSamplePoints( (Curve3d)arg1, (float)arg2, (float)arg3, (float)arg4) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve3d {lvalue},double,double,double)'''
    ...
    def getSplitCurves (self, *args, **kwargs):
      '''
getSplitCurves( (Curve3d)arg1, (float)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getSplitCurves(class PyGeCurve3d {lvalue},double)'''
    ...
    def getStartPoint (self, *args, **kwargs):
      '''
getStartPoint( (Curve3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getStartPoint(class PyGeCurve3d {lvalue})'''
    ...
    def getTrimmedOffset (self, *args, **kwargs):
      '''
getTrimmedOffset( (Curve3d)arg1, (float)arg2, (Vector3d)arg3, (OffsetCrvExtType)arg4) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve3d {lvalue},double,class AcGeVector3d,enum AcGe::OffsetCrvExtType)

getTrimmedOffset( (Curve3d)arg1, (float)arg2, (Vector3d)arg3, (OffsetCrvExtType)arg4, (Tol)arg5) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve3d {lvalue},double,class AcGeVector3d,enum AcGe::OffsetCrvExtType,class AcGeTol)'''
    ...
    def hasEndPoint (self, *args, **kwargs):
      '''
hasEndPoint( (Curve3d)arg1) -> bool :

    C++ signature :
        bool hasEndPoint(class PyGeCurve3d {lvalue})'''
    ...
    def hasStartPoint (self, *args, **kwargs):
      '''
hasStartPoint( (Curve3d)arg1) -> bool :

    C++ signature :
        bool hasStartPoint(class PyGeCurve3d {lvalue})'''
    ...
    def intersectWith (self, *args, **kwargs):
      '''
intersectWith( (EllipArc3d)arg1, (LinearEnt3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeEllipArc3d {lvalue},class PyGeLinearEnt3d)

intersectWith( (EllipArc3d)arg1, (LinearEnt3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeEllipArc3d {lvalue},class PyGeLinearEnt3d,class AcGeTol)

intersectWith( (EllipArc3d)arg1, (PlanarEnt)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeEllipArc3d {lvalue},class PyGePlanarEnt)

intersectWith( (EllipArc3d)arg1, (PlanarEnt)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeEllipArc3d {lvalue},class PyGePlanarEnt,class AcGeTol)'''
    ...
    def isCircular (self, *args, **kwargs):
      '''
isCircular( (EllipArc3d)arg1) -> bool :

    C++ signature :
        bool isCircular(class PyGeEllipArc3d {lvalue})

isCircular( (EllipArc3d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isCircular(class PyGeEllipArc3d {lvalue},class AcGeTol)'''
    ...
    def isClosed (self, *args, **kwargs):
      '''
isClosed( (Curve3d)arg1) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve3d {lvalue})

isClosed( (Curve3d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isCoplanarWith (self, *args, **kwargs):
      '''
isCoplanarWith( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isCoplanarWith(class PyGeCurve3d {lvalue},class PyGeCurve3d)

isCoplanarWith( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple isCoplanarWith(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def isDegenerate (self, *args, **kwargs):
      '''
isDegenerate( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve3d {lvalue})

isDegenerate( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity3d)arg1, (Entity3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity3d {lvalue},class PyGeEntity3d,class AcGeTol)'''
    ...
    def isInside (self, *args, **kwargs):
      '''
isInside( (EllipArc3d)arg1, (Point3d)arg2) -> bool :

    C++ signature :
        bool isInside(class PyGeEllipArc3d {lvalue},class AcGePoint3d)

isInside( (EllipArc3d)arg1, (Point3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isInside(class PyGeEllipArc3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity3d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity3d {lvalue},enum AcGe::EntityId)'''
    ...
    def isLinear (self, *args, **kwargs):
      '''
isLinear( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve3d {lvalue})

isLinear( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity3d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity3d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Curve3d)arg1, (Point3d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d)

isOn( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

isOn( (Curve3d)arg1, (Point3d)arg2, (float)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d,double {lvalue})

isOn( (Curve3d)arg1, (Point3d)arg2, (float)arg3, (Tol)arg4) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d,double {lvalue},class AcGeTol)

isOn( (Curve3d)arg1, (float)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},double)

isOn( (Curve3d)arg1, (float)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},double,class AcGeTol)'''
    ...
    def isPeriodic (self, *args, **kwargs):
      '''
isPeriodic( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPeriodic(class PyGeCurve3d {lvalue})'''
    ...
    def isPlanar (self, *args, **kwargs):
      '''
isPlanar( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPlanar(class PyGeCurve3d {lvalue})

isPlanar( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isPlanar(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double length(class PyGeCurve3d {lvalue},double,double)

length( (Curve3d)arg1, (float)arg2, (float)arg3, (float)arg4) -> float :

    C++ signature :
        double length(class PyGeCurve3d {lvalue},double,double,double)'''
    ...
    def majorAxis (self, *args, **kwargs):
      '''
majorAxis( (EllipArc3d)arg1) -> Vector3d :

    C++ signature :
        class AcGeVector3d majorAxis(class PyGeEllipArc3d {lvalue})'''
    ...
    def majorRadius (self, *args, **kwargs):
      '''
majorRadius( (EllipArc3d)arg1) -> float :

    C++ signature :
        double majorRadius(class PyGeEllipArc3d {lvalue})'''
    ...
    def minorAxis (self, *args, **kwargs):
      '''
minorAxis( (EllipArc3d)arg1) -> Vector3d :

    C++ signature :
        class AcGeVector3d minorAxis(class PyGeEllipArc3d {lvalue})'''
    ...
    def minorRadius (self, *args, **kwargs):
      '''
minorRadius( (EllipArc3d)arg1) -> float :

    C++ signature :
        double minorRadius(class PyGeEllipArc3d {lvalue})'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} mirror(class PyGeEntity3d {lvalue},class PyGePlane)'''
    ...
    def normal (self, *args, **kwargs):
      '''
normal( (EllipArc3d)arg1) -> Vector3d :

    C++ signature :
        class AcGeVector3d normal(class PyGeEllipArc3d {lvalue})'''
    ...
    def orthoBoundBlock (self, *args, **kwargs):
      '''
orthoBoundBlock( (Curve3d)arg1) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d orthoBoundBlock(class PyGeCurve3d {lvalue})

orthoBoundBlock( (Curve3d)arg1, (Interval)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d orthoBoundBlock(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def orthoProject (self, *args, **kwargs):
      '''
orthoProject( (Curve3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d orthoProject(class PyGeCurve3d {lvalue},class PyGePlane)

orthoProject( (Curve3d)arg1, (Plane)arg2, (Tol)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d orthoProject(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeTol)'''
    ...
    def paramAtLength (self, *args, **kwargs):
      '''
paramAtLength( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve3d {lvalue},double,double)

paramAtLength( (Curve3d)arg1, (float)arg2, (float)arg3, (bool)arg4, (float)arg5) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve3d {lvalue},double,double,bool,double)'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Curve3d)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double paramOf(class PyGeCurve3d {lvalue},class AcGePoint3d)

paramOf( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double paramOf(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def projClosestPointTo (self, *args, **kwargs):
      '''
projClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d projClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d)

projClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Tol)arg4) -> Point3d :

    C++ signature :
        class AcGePoint3d projClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def projClosestPointsTo (self, *args, **kwargs):
      '''
projClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple projClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d)

projClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple projClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def projIntersectWith (self, *args, **kwargs):
      '''
projIntersectWith( (EllipArc3d)arg1, (LinearEnt3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple projIntersectWith(class PyGeEllipArc3d {lvalue},class PyGeLinearEnt3d,class AcGeVector3d)

projIntersectWith( (EllipArc3d)arg1, (LinearEnt3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple projIntersectWith(class PyGeEllipArc3d {lvalue},class PyGeLinearEnt3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def project (self, *args, **kwargs):
      '''
project( (Curve3d)arg1, (Plane)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d project(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeVector3d)

project( (Curve3d)arg1, (Plane)arg2, (Vector3d)arg3, (Tol)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d project(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeVector3d,class AcGeTol)'''
    ...
    def reverseParam (self, *args, **kwargs):
      '''
reverseParam( (Curve3d)arg1) -> Curve3d :

    C++ signature :
        class PyGeCurve3d {lvalue} reverseParam(class PyGeCurve3d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d)

rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3, (Point3d)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d,class AcGePoint3d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity3d)arg1, (float)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double)

scaleBy( (Entity3d)arg1, (float)arg2, (Point3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double,class AcGePoint3d)'''
    ...
    def set (self, *args, **kwargs):
      '''
set( (EllipArc3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Vector3d)arg4, (float)arg5, (float)arg6) -> EllipArc3d :

    C++ signature :
        class PyGeEllipArc3d {lvalue} set(class PyGeEllipArc3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeVector3d,double,double)

set( (EllipArc3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Vector3d)arg4, (float)arg5, (float)arg6, (float)arg7, (float)arg8) -> EllipArc3d :

    C++ signature :
        class PyGeEllipArc3d {lvalue} set(class PyGeEllipArc3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeVector3d,double,double,double,double)

set( (EllipArc3d)arg1, (CircArc3d)arg2) -> EllipArc3d :

    C++ signature :
        class PyGeEllipArc3d {lvalue} set(class PyGeEllipArc3d {lvalue},class PyGeCircArc3d)'''
    ...
    def setAngles (self, *args, **kwargs):
      '''
setAngles( (EllipArc3d)arg1, (float)arg2, (float)arg3) -> EllipArc3d :

    C++ signature :
        class PyGeEllipArc3d {lvalue} setAngles(class PyGeEllipArc3d {lvalue},double,double)'''
    ...
    def setAxes (self, *args, **kwargs):
      '''
setAxes( (EllipArc3d)arg1, (Vector3d)arg2, (Vector3d)arg3) -> EllipArc3d :

    C++ signature :
        class PyGeEllipArc3d {lvalue} setAxes(class PyGeEllipArc3d {lvalue},class AcGeVector3d,class AcGeVector3d)'''
    ...
    def setCenter (self, *args, **kwargs):
      '''
setCenter( (EllipArc3d)arg1, (Point3d)arg2) -> EllipArc3d :

    C++ signature :
        class PyGeEllipArc3d {lvalue} setCenter(class PyGeEllipArc3d {lvalue},class AcGePoint3d)'''
    ...
    def setInterval (self, *args, **kwargs):
      '''
setInterval( (Curve3d)arg1) -> Curve3d :

    C++ signature :
        class PyGeCurve3d {lvalue} setInterval(class PyGeCurve3d {lvalue})

setInterval( (Curve3d)arg1, (Interval)arg2) -> bool :

    C++ signature :
        bool setInterval(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def setMajorRadius (self, *args, **kwargs):
      '''
setMajorRadius( (EllipArc3d)arg1, (float)arg2) -> EllipArc3d :

    C++ signature :
        class PyGeEllipArc3d {lvalue} setMajorRadius(class PyGeEllipArc3d {lvalue},double)'''
    ...
    def setMinorRadius (self, *args, **kwargs):
      '''
setMinorRadius( (EllipArc3d)arg1, (float)arg2) -> EllipArc3d :

    C++ signature :
        class PyGeEllipArc3d {lvalue} setMinorRadius(class PyGeEllipArc3d {lvalue},double)'''
    ...
    def startAng (self, *args, **kwargs):
      '''
startAng( (EllipArc3d)arg1) -> float :

    C++ signature :
        double startAng(class PyGeEllipArc3d {lvalue})'''
    ...
    def startPoint (self, *args, **kwargs):
      '''
startPoint( (EllipArc3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d startPoint(class PyGeEllipArc3d {lvalue})'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity3d)arg1, (Matrix3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} transformBy(class PyGeEntity3d {lvalue},class AcGeMatrix3d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity3d)arg1, (Vector3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} translateBy(class PyGeEntity3d {lvalue},class AcGeVector3d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity3d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity3d {lvalue})'''
    ...

class Entity2d:
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity2d)arg1) -> Entity2d :

    C++ signature :
        class PyGeEntity2d copy(class PyGeEntity2d {lvalue})'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity2d)arg1, (Entity2d)arg2) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d)

isEqualTo( (Entity2d)arg1, (Entity2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity2d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity2d {lvalue},enum AcGe::EntityId)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity2d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity2d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Entity2d)arg1, (Point2d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeEntity2d {lvalue},class AcGePoint2d)

isOn( (Entity2d)arg1, (Point2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeEntity2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity2d)arg1, (Line2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} mirror(class PyGeEntity2d {lvalue},class PyGeLine2d)'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double)

rotateBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double)

scaleBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity2d)arg1, (Matrix2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} transformBy(class PyGeEntity2d {lvalue},class AcGeMatrix2d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity2d)arg1, (Vector2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} translateBy(class PyGeEntity2d {lvalue},class AcGeVector2d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity2d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity2d {lvalue})'''
    ...

class Entity3d:
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity3d)arg1) -> Entity3d :

    C++ signature :
        class PyGeEntity3d copy(class PyGeEntity3d {lvalue})'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity3d)arg1, (Entity3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity3d {lvalue},class PyGeEntity3d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity3d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity3d {lvalue},enum AcGe::EntityId)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity3d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity3d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Entity3d)arg1, (Point3d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeEntity3d {lvalue},class AcGePoint3d)

isOn( (Entity3d)arg1, (Point3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeEntity3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} mirror(class PyGeEntity3d {lvalue},class PyGePlane)'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d)

rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3, (Point3d)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d,class AcGePoint3d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity3d)arg1, (float)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double)

scaleBy( (Entity3d)arg1, (float)arg2, (Point3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double,class AcGePoint3d)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity3d)arg1, (Matrix3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} transformBy(class PyGeEntity3d {lvalue},class AcGeMatrix3d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity3d)arg1, (Vector3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} translateBy(class PyGeEntity3d {lvalue},class AcGeVector3d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity3d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity3d {lvalue})'''
    ...

class EntityId:
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio (self, /):
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count (self, /):
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length (self, /):
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''the denominator of a rational number in lowest terms'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''the imaginary part of a complex number'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''the numerator of a rational number in lowest terms'''
    ...
    def real (self, *args, **kwargs):
      '''the real part of a complex number'''
    ...
    def to_bytes (self, /, length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...

class ExternalCurve2d:
    def area (self, *args, **kwargs):
      '''
area( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double area(class PyGeCurve2d {lvalue},double,double)

area( (Curve2d)arg1, (float)arg2, (float)arg3, (Tol)arg4) -> float :

    C++ signature :
        double area(class PyGeCurve2d {lvalue},double,double,class AcGeTol)'''
    ...
    def boundBlock (self, *args, **kwargs):
      '''
boundBlock( (Curve2d)arg1) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d boundBlock(class PyGeCurve2d {lvalue})

boundBlock( (Curve2d)arg1, (Interval)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d boundBlock(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Curve2d)arg1, (Point2d)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d closestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

closestPointTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> Point2d :

    C++ signature :
        class AcGePoint2d closestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

closestPointTo( (Curve2d)arg1, (Curve2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

closestPointTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity2d)arg1) -> Entity2d :

    C++ signature :
        class PyGeEntity2d copy(class PyGeEntity2d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Curve2d)arg1, (Point2d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

distanceTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

distanceTo( (Curve2d)arg1, (Curve2d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

distanceTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Curve2d)arg1, (float)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d evalPoint(class PyGeCurve2d {lvalue},double)

evalPoint( (Curve2d)arg1, (float)arg2, (CmdFlags)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple evalPoint(class PyGeCurve2d {lvalue},double,int)'''
    ...
    def explode (self, *args, **kwargs):
      '''
explode( (Curve2d)arg1) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve2d {lvalue})

explode( (Curve2d)arg1, (Interval)arg2) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def getClosestPointTo (self, *args, **kwargs):
      '''
getClosestPointTo( (Curve2d)arg1, (Point2d)arg2) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getClosestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

getClosestPointTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getClosestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def getClosestPointsTo (self, *args, **kwargs):
      '''
getClosestPointsTo( (Curve2d)arg1, (Curve2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

getClosestPointsTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def getEndPoint (self, *args, **kwargs):
      '''
getEndPoint( (Curve2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getEndPoint(class PyGeCurve2d {lvalue})'''
    ...
    def getInterval (self, *args, **kwargs):
      '''
getInterval( (Curve2d)arg1) -> Interval :

    C++ signature :
        class PyGeInterval getInterval(class PyGeCurve2d {lvalue})'''
    ...
    def getNormalPoint (self, *args, **kwargs):
      '''
getNormalPoint( (Curve2d)arg1, (Point2d)arg2) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getNormalPoint(class PyGeCurve2d {lvalue},class AcGePoint2d)

getNormalPoint( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getNormalPoint(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def getSamplePoints (self, *args, **kwargs):
      '''
getSamplePoints( (Curve2d)arg1, (CmdFlags)arg2) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve2d {lvalue},int)

getSamplePoints( (Curve2d)arg1, (float)arg2, (float)arg3, (float)arg4) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve2d {lvalue},double,double,double)'''
    ...
    def getSplitCurves (self, *args, **kwargs):
      '''
getSplitCurves( (Curve2d)arg1, (float)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getSplitCurves(class PyGeCurve2d {lvalue},double)'''
    ...
    def getStartPoint (self, *args, **kwargs):
      '''
getStartPoint( (Curve2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getStartPoint(class PyGeCurve2d {lvalue})'''
    ...
    def getTrimmedOffset (self, *args, **kwargs):
      '''
getTrimmedOffset( (Curve2d)arg1, (float)arg2, (OffsetCrvExtType)arg3) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve2d {lvalue},double,enum AcGe::OffsetCrvExtType)

getTrimmedOffset( (Curve2d)arg1, (float)arg2, (OffsetCrvExtType)arg3, (Tol)arg4) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve2d {lvalue},double,enum AcGe::OffsetCrvExtType,class AcGeTol)'''
    ...
    def hasEndPoint (self, *args, **kwargs):
      '''
hasEndPoint( (Curve2d)arg1) -> bool :

    C++ signature :
        bool hasEndPoint(class PyGeCurve2d {lvalue})'''
    ...
    def hasStartPoint (self, *args, **kwargs):
      '''
hasStartPoint( (Curve2d)arg1) -> bool :

    C++ signature :
        bool hasStartPoint(class PyGeCurve2d {lvalue})'''
    ...
    def isClosed (self, *args, **kwargs):
      '''
isClosed( (Curve2d)arg1) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve2d {lvalue})

isClosed( (Curve2d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isDegenerate (self, *args, **kwargs):
      '''
isDegenerate( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve2d {lvalue})

isDegenerate( (Curve2d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity2d)arg1, (Entity2d)arg2) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d)

isEqualTo( (Entity2d)arg1, (Entity2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity2d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity2d {lvalue},enum AcGe::EntityId)'''
    ...
    def isLinear (self, *args, **kwargs):
      '''
isLinear( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve2d {lvalue})

isLinear( (Curve2d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity2d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity2d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Curve2d)arg1, (Point2d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d)

isOn( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

isOn( (Curve2d)arg1, (Point2d)arg2, (float)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,double {lvalue})

isOn( (Curve2d)arg1, (Point2d)arg2, (float)arg3, (Tol)arg4) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,double {lvalue},class AcGeTol)

isOn( (Curve2d)arg1, (float)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},double)

isOn( (Curve2d)arg1, (float)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},double,class AcGeTol)'''
    ...
    def isPeriodic (self, *args, **kwargs):
      '''
isPeriodic( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPeriodic(class PyGeCurve2d {lvalue})'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double length(class PyGeCurve2d {lvalue},double,double)

length( (Curve2d)arg1, (float)arg2, (float)arg3, (float)arg4) -> float :

    C++ signature :
        double length(class PyGeCurve2d {lvalue},double,double,double)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity2d)arg1, (Line2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} mirror(class PyGeEntity2d {lvalue},class PyGeLine2d)'''
    ...
    def orthoBoundBlock (self, *args, **kwargs):
      '''
orthoBoundBlock( (Curve2d)arg1) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d orthoBoundBlock(class PyGeCurve2d {lvalue})

orthoBoundBlock( (Curve2d)arg1, (Interval)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d orthoBoundBlock(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def paramAtLength (self, *args, **kwargs):
      '''
paramAtLength( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve2d {lvalue},double,double)

paramAtLength( (Curve2d)arg1, (float)arg2, (float)arg3, (bool)arg4, (float)arg5) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve2d {lvalue},double,double,bool,double)'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Curve2d)arg1, (Point2d)arg2) -> float :

    C++ signature :
        double paramOf(class PyGeCurve2d {lvalue},class AcGePoint2d)

paramOf( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double paramOf(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def reverseParam (self, *args, **kwargs):
      '''
reverseParam( (Curve2d)arg1) -> Curve2d :

    C++ signature :
        class PyGeCurve2d {lvalue} reverseParam(class PyGeCurve2d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double)

rotateBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double)

scaleBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def setInterval (self, *args, **kwargs):
      '''
setInterval( (Curve2d)arg1) -> Curve2d :

    C++ signature :
        class PyGeCurve2d {lvalue} setInterval(class PyGeCurve2d {lvalue})

setInterval( (Curve2d)arg1, (Interval)arg2) -> bool :

    C++ signature :
        bool setInterval(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity2d)arg1, (Matrix2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} transformBy(class PyGeEntity2d {lvalue},class AcGeMatrix2d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity2d)arg1, (Vector2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} translateBy(class PyGeEntity2d {lvalue},class AcGeVector2d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity2d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity2d {lvalue})'''
    ...

class ExternalCurve3d:
    def area (self, *args, **kwargs):
      '''
area( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double area(class PyGeCurve3d {lvalue},double,double)

area( (Curve3d)arg1, (float)arg2, (float)arg3, (Tol)arg4) -> float :

    C++ signature :
        double area(class PyGeCurve3d {lvalue},double,double,class AcGeTol)'''
    ...
    def boundBlock (self, *args, **kwargs):
      '''
boundBlock( (Curve3d)arg1) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d boundBlock(class PyGeCurve3d {lvalue})

boundBlock( (Curve3d)arg1, (Interval)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d boundBlock(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Curve3d)arg1, (Point3d)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

closestPointTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

closestPointTo( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

closestPointTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity3d)arg1) -> Entity3d :

    C++ signature :
        class PyGeEntity3d copy(class PyGeEntity3d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Curve3d)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

distanceTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

distanceTo( (Curve3d)arg1, (Curve3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

distanceTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Curve3d)arg1, (float)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d evalPoint(class PyGeCurve3d {lvalue},double)

evalPoint( (Curve3d)arg1, (float)arg2, (CmdFlags)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple evalPoint(class PyGeCurve3d {lvalue},double,int)'''
    ...
    def explode (self, *args, **kwargs):
      '''
explode( (Curve3d)arg1) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve3d {lvalue})

explode( (Curve3d)arg1, (Interval)arg2) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def getClosestPointTo (self, *args, **kwargs):
      '''
getClosestPointTo( (Curve3d)arg1, (Point3d)arg2) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

getClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def getClosestPointsTo (self, *args, **kwargs):
      '''
getClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

getClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def getEndPoint (self, *args, **kwargs):
      '''
getEndPoint( (Curve3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getEndPoint(class PyGeCurve3d {lvalue})'''
    ...
    def getInterval (self, *args, **kwargs):
      '''
getInterval( (Curve3d)arg1) -> Interval :

    C++ signature :
        class PyGeInterval getInterval(class PyGeCurve3d {lvalue})'''
    ...
    def getNormalPoint (self, *args, **kwargs):
      '''
getNormalPoint( (Curve3d)arg1, (Point3d)arg2) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getNormalPoint(class PyGeCurve3d {lvalue},class AcGePoint3d)

getNormalPoint( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getNormalPoint(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def getProjClosestPointTo (self, *args, **kwargs):
      '''
getProjClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getProjClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d)

getProjClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Tol)arg4) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getProjClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def getProjClosestPointsTo (self, *args, **kwargs):
      '''
getProjClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getProjClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d)

getProjClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple getProjClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def getSamplePoints (self, *args, **kwargs):
      '''
getSamplePoints( (Curve3d)arg1, (CmdFlags)arg2) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve3d {lvalue},int)

getSamplePoints( (Curve3d)arg1, (float)arg2, (float)arg3, (float)arg4) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve3d {lvalue},double,double,double)'''
    ...
    def getSplitCurves (self, *args, **kwargs):
      '''
getSplitCurves( (Curve3d)arg1, (float)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getSplitCurves(class PyGeCurve3d {lvalue},double)'''
    ...
    def getStartPoint (self, *args, **kwargs):
      '''
getStartPoint( (Curve3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getStartPoint(class PyGeCurve3d {lvalue})'''
    ...
    def getTrimmedOffset (self, *args, **kwargs):
      '''
getTrimmedOffset( (Curve3d)arg1, (float)arg2, (Vector3d)arg3, (OffsetCrvExtType)arg4) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve3d {lvalue},double,class AcGeVector3d,enum AcGe::OffsetCrvExtType)

getTrimmedOffset( (Curve3d)arg1, (float)arg2, (Vector3d)arg3, (OffsetCrvExtType)arg4, (Tol)arg5) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve3d {lvalue},double,class AcGeVector3d,enum AcGe::OffsetCrvExtType,class AcGeTol)'''
    ...
    def hasEndPoint (self, *args, **kwargs):
      '''
hasEndPoint( (Curve3d)arg1) -> bool :

    C++ signature :
        bool hasEndPoint(class PyGeCurve3d {lvalue})'''
    ...
    def hasStartPoint (self, *args, **kwargs):
      '''
hasStartPoint( (Curve3d)arg1) -> bool :

    C++ signature :
        bool hasStartPoint(class PyGeCurve3d {lvalue})'''
    ...
    def isClosed (self, *args, **kwargs):
      '''
isClosed( (Curve3d)arg1) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve3d {lvalue})

isClosed( (Curve3d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isCoplanarWith (self, *args, **kwargs):
      '''
isCoplanarWith( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isCoplanarWith(class PyGeCurve3d {lvalue},class PyGeCurve3d)

isCoplanarWith( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple isCoplanarWith(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def isDegenerate (self, *args, **kwargs):
      '''
isDegenerate( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve3d {lvalue})

isDegenerate( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity3d)arg1, (Entity3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity3d {lvalue},class PyGeEntity3d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity3d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity3d {lvalue},enum AcGe::EntityId)'''
    ...
    def isLinear (self, *args, **kwargs):
      '''
isLinear( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve3d {lvalue})

isLinear( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity3d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity3d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Curve3d)arg1, (Point3d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d)

isOn( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

isOn( (Curve3d)arg1, (Point3d)arg2, (float)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d,double {lvalue})

isOn( (Curve3d)arg1, (Point3d)arg2, (float)arg3, (Tol)arg4) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d,double {lvalue},class AcGeTol)

isOn( (Curve3d)arg1, (float)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},double)

isOn( (Curve3d)arg1, (float)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},double,class AcGeTol)'''
    ...
    def isPeriodic (self, *args, **kwargs):
      '''
isPeriodic( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPeriodic(class PyGeCurve3d {lvalue})'''
    ...
    def isPlanar (self, *args, **kwargs):
      '''
isPlanar( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPlanar(class PyGeCurve3d {lvalue})

isPlanar( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isPlanar(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double length(class PyGeCurve3d {lvalue},double,double)

length( (Curve3d)arg1, (float)arg2, (float)arg3, (float)arg4) -> float :

    C++ signature :
        double length(class PyGeCurve3d {lvalue},double,double,double)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} mirror(class PyGeEntity3d {lvalue},class PyGePlane)'''
    ...
    def orthoBoundBlock (self, *args, **kwargs):
      '''
orthoBoundBlock( (Curve3d)arg1) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d orthoBoundBlock(class PyGeCurve3d {lvalue})

orthoBoundBlock( (Curve3d)arg1, (Interval)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d orthoBoundBlock(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def orthoProject (self, *args, **kwargs):
      '''
orthoProject( (Curve3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d orthoProject(class PyGeCurve3d {lvalue},class PyGePlane)

orthoProject( (Curve3d)arg1, (Plane)arg2, (Tol)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d orthoProject(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeTol)'''
    ...
    def paramAtLength (self, *args, **kwargs):
      '''
paramAtLength( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve3d {lvalue},double,double)

paramAtLength( (Curve3d)arg1, (float)arg2, (float)arg3, (bool)arg4, (float)arg5) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve3d {lvalue},double,double,bool,double)'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Curve3d)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double paramOf(class PyGeCurve3d {lvalue},class AcGePoint3d)

paramOf( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double paramOf(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def projClosestPointTo (self, *args, **kwargs):
      '''
projClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d projClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d)

projClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Tol)arg4) -> Point3d :

    C++ signature :
        class AcGePoint3d projClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def projClosestPointsTo (self, *args, **kwargs):
      '''
projClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple projClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d)

projClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple projClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def project (self, *args, **kwargs):
      '''
project( (Curve3d)arg1, (Plane)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d project(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeVector3d)

project( (Curve3d)arg1, (Plane)arg2, (Vector3d)arg3, (Tol)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d project(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeVector3d,class AcGeTol)'''
    ...
    def reverseParam (self, *args, **kwargs):
      '''
reverseParam( (Curve3d)arg1) -> Curve3d :

    C++ signature :
        class PyGeCurve3d {lvalue} reverseParam(class PyGeCurve3d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d)

rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3, (Point3d)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d,class AcGePoint3d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity3d)arg1, (float)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double)

scaleBy( (Entity3d)arg1, (float)arg2, (Point3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double,class AcGePoint3d)'''
    ...
    def setInterval (self, *args, **kwargs):
      '''
setInterval( (Curve3d)arg1) -> Curve3d :

    C++ signature :
        class PyGeCurve3d {lvalue} setInterval(class PyGeCurve3d {lvalue})

setInterval( (Curve3d)arg1, (Interval)arg2) -> bool :

    C++ signature :
        bool setInterval(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity3d)arg1, (Matrix3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} transformBy(class PyGeEntity3d {lvalue},class AcGeMatrix3d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity3d)arg1, (Vector3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} translateBy(class PyGeEntity3d {lvalue},class AcGeVector3d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity3d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity3d {lvalue})'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...

class Interval:
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...

class KnotVector:
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...

class Line2d:
    def area (self, *args, **kwargs):
      '''
area( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double area(class PyGeCurve2d {lvalue},double,double)

area( (Curve2d)arg1, (float)arg2, (float)arg3, (Tol)arg4) -> float :

    C++ signature :
        double area(class PyGeCurve2d {lvalue},double,double,class AcGeTol)'''
    ...
    def boundBlock (self, *args, **kwargs):
      '''
boundBlock( (Curve2d)arg1) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d boundBlock(class PyGeCurve2d {lvalue})

boundBlock( (Curve2d)arg1, (Interval)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d boundBlock(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Curve2d)arg1, (Point2d)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d closestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

closestPointTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> Point2d :

    C++ signature :
        class AcGePoint2d closestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

closestPointTo( (Curve2d)arg1, (Curve2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

closestPointTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity2d)arg1) -> Entity2d :

    C++ signature :
        class PyGeEntity2d copy(class PyGeEntity2d {lvalue})'''
    ...
    def direction (self, *args, **kwargs):
      '''
direction( (LinearEnt2d)arg1) -> Vector2d :

    C++ signature :
        class AcGeVector2d direction(class PyGeLinearEnt2d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Curve2d)arg1, (Point2d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

distanceTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

distanceTo( (Curve2d)arg1, (Curve2d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

distanceTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Curve2d)arg1, (float)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d evalPoint(class PyGeCurve2d {lvalue},double)

evalPoint( (Curve2d)arg1, (float)arg2, (CmdFlags)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple evalPoint(class PyGeCurve2d {lvalue},double,int)'''
    ...
    def explode (self, *args, **kwargs):
      '''
explode( (Curve2d)arg1) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve2d {lvalue})

explode( (Curve2d)arg1, (Interval)arg2) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def getClosestPointTo (self, *args, **kwargs):
      '''
getClosestPointTo( (Curve2d)arg1, (Point2d)arg2) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getClosestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

getClosestPointTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getClosestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def getClosestPointsTo (self, *args, **kwargs):
      '''
getClosestPointsTo( (Curve2d)arg1, (Curve2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

getClosestPointsTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def getEndPoint (self, *args, **kwargs):
      '''
getEndPoint( (Curve2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getEndPoint(class PyGeCurve2d {lvalue})'''
    ...
    def getInterval (self, *args, **kwargs):
      '''
getInterval( (Curve2d)arg1) -> Interval :

    C++ signature :
        class PyGeInterval getInterval(class PyGeCurve2d {lvalue})'''
    ...
    def getLine (self, *args, **kwargs):
      '''
getLine( (LinearEnt2d)arg1) -> Line2d :

    C++ signature :
        class PyGeLine2d getLine(class PyGeLinearEnt2d {lvalue})'''
    ...
    def getNormalPoint (self, *args, **kwargs):
      '''
getNormalPoint( (Curve2d)arg1, (Point2d)arg2) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getNormalPoint(class PyGeCurve2d {lvalue},class AcGePoint2d)

getNormalPoint( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getNormalPoint(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def getPerpLine (self, *args, **kwargs):
      '''
getPerpLine( (LinearEnt2d)arg1, (Point2d)arg2) -> Line2d :

    C++ signature :
        class PyGeLine2d getPerpLine(class PyGeLinearEnt2d {lvalue},class AcGePoint2d)'''
    ...
    def getSamplePoints (self, *args, **kwargs):
      '''
getSamplePoints( (Curve2d)arg1, (CmdFlags)arg2) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve2d {lvalue},int)

getSamplePoints( (Curve2d)arg1, (float)arg2, (float)arg3, (float)arg4) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve2d {lvalue},double,double,double)'''
    ...
    def getSplitCurves (self, *args, **kwargs):
      '''
getSplitCurves( (Curve2d)arg1, (float)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getSplitCurves(class PyGeCurve2d {lvalue},double)'''
    ...
    def getStartPoint (self, *args, **kwargs):
      '''
getStartPoint( (Curve2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getStartPoint(class PyGeCurve2d {lvalue})'''
    ...
    def getTrimmedOffset (self, *args, **kwargs):
      '''
getTrimmedOffset( (Curve2d)arg1, (float)arg2, (OffsetCrvExtType)arg3) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve2d {lvalue},double,enum AcGe::OffsetCrvExtType)

getTrimmedOffset( (Curve2d)arg1, (float)arg2, (OffsetCrvExtType)arg3, (Tol)arg4) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve2d {lvalue},double,enum AcGe::OffsetCrvExtType,class AcGeTol)'''
    ...
    def hasEndPoint (self, *args, **kwargs):
      '''
hasEndPoint( (Curve2d)arg1) -> bool :

    C++ signature :
        bool hasEndPoint(class PyGeCurve2d {lvalue})'''
    ...
    def hasStartPoint (self, *args, **kwargs):
      '''
hasStartPoint( (Curve2d)arg1) -> bool :

    C++ signature :
        bool hasStartPoint(class PyGeCurve2d {lvalue})'''
    ...
    def intersectWith (self, *args, **kwargs):
      '''
intersectWith( (LinearEnt2d)arg1, (LinearEnt2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d)

intersectWith( (LinearEnt2d)arg1, (LinearEnt2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d,class AcGeTol)'''
    ...
    def isClosed (self, *args, **kwargs):
      '''
isClosed( (Curve2d)arg1) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve2d {lvalue})

isClosed( (Curve2d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isColinearTo (self, *args, **kwargs):
      '''
isColinearTo( (LinearEnt2d)arg1, (LinearEnt2d)arg2) -> bool :

    C++ signature :
        bool isColinearTo(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d)

isColinearTo( (LinearEnt2d)arg1, (LinearEnt2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isColinearTo(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d,class AcGeTol)'''
    ...
    def isDegenerate (self, *args, **kwargs):
      '''
isDegenerate( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve2d {lvalue})

isDegenerate( (Curve2d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity2d)arg1, (Entity2d)arg2) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d)

isEqualTo( (Entity2d)arg1, (Entity2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity2d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity2d {lvalue},enum AcGe::EntityId)'''
    ...
    def isLinear (self, *args, **kwargs):
      '''
isLinear( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve2d {lvalue})

isLinear( (Curve2d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity2d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity2d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Curve2d)arg1, (Point2d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d)

isOn( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

isOn( (Curve2d)arg1, (Point2d)arg2, (float)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,double {lvalue})

isOn( (Curve2d)arg1, (Point2d)arg2, (float)arg3, (Tol)arg4) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,double {lvalue},class AcGeTol)

isOn( (Curve2d)arg1, (float)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},double)

isOn( (Curve2d)arg1, (float)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},double,class AcGeTol)'''
    ...
    def isParallelTo (self, *args, **kwargs):
      '''
isParallelTo( (LinearEnt2d)arg1, (LinearEnt2d)arg2) -> bool :

    C++ signature :
        bool isParallelTo(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d)

isParallelTo( (LinearEnt2d)arg1, (LinearEnt2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isParallelTo(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d,class AcGeTol)'''
    ...
    def isPeriodic (self, *args, **kwargs):
      '''
isPeriodic( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPeriodic(class PyGeCurve2d {lvalue})'''
    ...
    def isPerpendicularTo (self, *args, **kwargs):
      '''
isPerpendicularTo( (LinearEnt2d)arg1, (LinearEnt2d)arg2) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d)

isPerpendicularTo( (LinearEnt2d)arg1, (LinearEnt2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d,class AcGeTol)'''
    ...
    def kXAxis (self, *args, **kwargs):
      '''None'''
    ...
    def kYAxis (self, *args, **kwargs):
      '''None'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double length(class PyGeCurve2d {lvalue},double,double)

length( (Curve2d)arg1, (float)arg2, (float)arg3, (float)arg4) -> float :

    C++ signature :
        double length(class PyGeCurve2d {lvalue},double,double,double)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity2d)arg1, (Line2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} mirror(class PyGeEntity2d {lvalue},class PyGeLine2d)'''
    ...
    def orthoBoundBlock (self, *args, **kwargs):
      '''
orthoBoundBlock( (Curve2d)arg1) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d orthoBoundBlock(class PyGeCurve2d {lvalue})

orthoBoundBlock( (Curve2d)arg1, (Interval)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d orthoBoundBlock(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def overlap (self, *args, **kwargs):
      '''
overlap( (LinearEnt2d)arg1, (LinearEnt2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple overlap(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d)

overlap( (LinearEnt2d)arg1, (LinearEnt2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple overlap(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d,class AcGeTol)'''
    ...
    def paramAtLength (self, *args, **kwargs):
      '''
paramAtLength( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve2d {lvalue},double,double)

paramAtLength( (Curve2d)arg1, (float)arg2, (float)arg3, (bool)arg4, (float)arg5) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve2d {lvalue},double,double,bool,double)'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Curve2d)arg1, (Point2d)arg2) -> float :

    C++ signature :
        double paramOf(class PyGeCurve2d {lvalue},class AcGePoint2d)

paramOf( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double paramOf(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def pointOnLine (self, *args, **kwargs):
      '''
pointOnLine( (LinearEnt2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d pointOnLine(class PyGeLinearEnt2d {lvalue})'''
    ...
    def reverseParam (self, *args, **kwargs):
      '''
reverseParam( (Curve2d)arg1) -> Curve2d :

    C++ signature :
        class PyGeCurve2d {lvalue} reverseParam(class PyGeCurve2d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double)

rotateBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double)

scaleBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def set (self, *args, **kwargs):
      '''
set( (Line2d)arg1, (Point2d)arg2, (Vector2d)arg3) -> Line2d :

    C++ signature :
        class PyGeLine2d {lvalue} set(class PyGeLine2d {lvalue},class AcGePoint2d,class AcGeVector2d)

set( (Line2d)arg1, (Point2d)arg2, (Point2d)arg3) -> Line2d :

    C++ signature :
        class PyGeLine2d {lvalue} set(class PyGeLine2d {lvalue},class AcGePoint2d,class AcGePoint2d)'''
    ...
    def setInterval (self, *args, **kwargs):
      '''
setInterval( (Curve2d)arg1) -> Curve2d :

    C++ signature :
        class PyGeCurve2d {lvalue} setInterval(class PyGeCurve2d {lvalue})

setInterval( (Curve2d)arg1, (Interval)arg2) -> bool :

    C++ signature :
        bool setInterval(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity2d)arg1, (Matrix2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} transformBy(class PyGeEntity2d {lvalue},class AcGeMatrix2d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity2d)arg1, (Vector2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} translateBy(class PyGeEntity2d {lvalue},class AcGeVector2d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity2d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity2d {lvalue})'''
    ...

class Line3d:
    def area (self, *args, **kwargs):
      '''
area( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double area(class PyGeCurve3d {lvalue},double,double)

area( (Curve3d)arg1, (float)arg2, (float)arg3, (Tol)arg4) -> float :

    C++ signature :
        double area(class PyGeCurve3d {lvalue},double,double,class AcGeTol)'''
    ...
    def boundBlock (self, *args, **kwargs):
      '''
boundBlock( (Curve3d)arg1) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d boundBlock(class PyGeCurve3d {lvalue})

boundBlock( (Curve3d)arg1, (Interval)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d boundBlock(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Curve3d)arg1, (Point3d)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

closestPointTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

closestPointTo( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

closestPointTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity3d)arg1) -> Entity3d :

    C++ signature :
        class PyGeEntity3d copy(class PyGeEntity3d {lvalue})'''
    ...
    def direction (self, *args, **kwargs):
      '''
direction( (LinearEnt3d)arg1) -> Vector3d :

    C++ signature :
        class AcGeVector3d direction(class PyGeLinearEnt3d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Curve3d)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

distanceTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

distanceTo( (Curve3d)arg1, (Curve3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

distanceTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Curve3d)arg1, (float)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d evalPoint(class PyGeCurve3d {lvalue},double)

evalPoint( (Curve3d)arg1, (float)arg2, (CmdFlags)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple evalPoint(class PyGeCurve3d {lvalue},double,int)'''
    ...
    def explode (self, *args, **kwargs):
      '''
explode( (Curve3d)arg1) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve3d {lvalue})

explode( (Curve3d)arg1, (Interval)arg2) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def getClosestPointTo (self, *args, **kwargs):
      '''
getClosestPointTo( (Curve3d)arg1, (Point3d)arg2) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

getClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def getClosestPointsTo (self, *args, **kwargs):
      '''
getClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

getClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def getEndPoint (self, *args, **kwargs):
      '''
getEndPoint( (Curve3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getEndPoint(class PyGeCurve3d {lvalue})'''
    ...
    def getInterval (self, *args, **kwargs):
      '''
getInterval( (Curve3d)arg1) -> Interval :

    C++ signature :
        class PyGeInterval getInterval(class PyGeCurve3d {lvalue})'''
    ...
    def getLine (self, *args, **kwargs):
      '''
getLine( (LinearEnt3d)arg1) -> Line3d :

    C++ signature :
        class PyGeLine3d getLine(class PyGeLinearEnt3d {lvalue})'''
    ...
    def getNormalPoint (self, *args, **kwargs):
      '''
getNormalPoint( (Curve3d)arg1, (Point3d)arg2) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getNormalPoint(class PyGeCurve3d {lvalue},class AcGePoint3d)

getNormalPoint( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getNormalPoint(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def getPerpPlane (self, *args, **kwargs):
      '''
getPerpPlane( (LinearEnt3d)arg1, (Point3d)arg2) -> Plane :

    C++ signature :
        class PyGePlane getPerpPlane(class PyGeLinearEnt3d {lvalue},class AcGePoint3d)'''
    ...
    def getProjClosestPointTo (self, *args, **kwargs):
      '''
getProjClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getProjClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d)

getProjClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Tol)arg4) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getProjClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def getProjClosestPointsTo (self, *args, **kwargs):
      '''
getProjClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getProjClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d)

getProjClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple getProjClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def getSamplePoints (self, *args, **kwargs):
      '''
getSamplePoints( (Curve3d)arg1, (CmdFlags)arg2) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve3d {lvalue},int)

getSamplePoints( (Curve3d)arg1, (float)arg2, (float)arg3, (float)arg4) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve3d {lvalue},double,double,double)'''
    ...
    def getSplitCurves (self, *args, **kwargs):
      '''
getSplitCurves( (Curve3d)arg1, (float)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getSplitCurves(class PyGeCurve3d {lvalue},double)'''
    ...
    def getStartPoint (self, *args, **kwargs):
      '''
getStartPoint( (Curve3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getStartPoint(class PyGeCurve3d {lvalue})'''
    ...
    def getTrimmedOffset (self, *args, **kwargs):
      '''
getTrimmedOffset( (Curve3d)arg1, (float)arg2, (Vector3d)arg3, (OffsetCrvExtType)arg4) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve3d {lvalue},double,class AcGeVector3d,enum AcGe::OffsetCrvExtType)

getTrimmedOffset( (Curve3d)arg1, (float)arg2, (Vector3d)arg3, (OffsetCrvExtType)arg4, (Tol)arg5) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve3d {lvalue},double,class AcGeVector3d,enum AcGe::OffsetCrvExtType,class AcGeTol)'''
    ...
    def hasEndPoint (self, *args, **kwargs):
      '''
hasEndPoint( (Curve3d)arg1) -> bool :

    C++ signature :
        bool hasEndPoint(class PyGeCurve3d {lvalue})'''
    ...
    def hasStartPoint (self, *args, **kwargs):
      '''
hasStartPoint( (Curve3d)arg1) -> bool :

    C++ signature :
        bool hasStartPoint(class PyGeCurve3d {lvalue})'''
    ...
    def intersectWith (self, *args, **kwargs):
      '''
intersectWith( (LinearEnt3d)arg1, (LinearEnt3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d)

intersectWith( (LinearEnt3d)arg1, (LinearEnt3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d,class AcGeTol)

intersectWith( (LinearEnt3d)arg1, (PlanarEnt)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeLinearEnt3d {lvalue},class PyGePlanarEnt)

intersectWith( (LinearEnt3d)arg1, (PlanarEnt)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeLinearEnt3d {lvalue},class PyGePlanarEnt,class AcGeTol)'''
    ...
    def isClosed (self, *args, **kwargs):
      '''
isClosed( (Curve3d)arg1) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve3d {lvalue})

isClosed( (Curve3d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isColinearTo (self, *args, **kwargs):
      '''
isColinearTo( (LinearEnt3d)arg1, (LinearEnt3d)arg2) -> bool :

    C++ signature :
        bool isColinearTo(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d)

isColinearTo( (LinearEnt3d)arg1, (LinearEnt3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isColinearTo(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d,class AcGeTol)'''
    ...
    def isCoplanarWith (self, *args, **kwargs):
      '''
isCoplanarWith( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isCoplanarWith(class PyGeCurve3d {lvalue},class PyGeCurve3d)

isCoplanarWith( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple isCoplanarWith(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def isDegenerate (self, *args, **kwargs):
      '''
isDegenerate( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve3d {lvalue})

isDegenerate( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity3d)arg1, (Entity3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity3d {lvalue},class PyGeEntity3d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity3d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity3d {lvalue},enum AcGe::EntityId)'''
    ...
    def isLinear (self, *args, **kwargs):
      '''
isLinear( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve3d {lvalue})

isLinear( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity3d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity3d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (LinearEnt3d)arg1, (Point3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isOn(class PyGeLinearEnt3d {lvalue},class AcGePoint3d)

isOn( (LinearEnt3d)arg1, (Point3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple isOn(class PyGeLinearEnt3d {lvalue},class AcGePoint3d,class AcGeTol)

isOn( (LinearEnt3d)arg1, (float)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeLinearEnt3d {lvalue},double)

isOn( (LinearEnt3d)arg1, (float)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeLinearEnt3d {lvalue},double,class AcGeTol)

isOn( (LinearEnt3d)arg1, (Plane)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeLinearEnt3d {lvalue},class PyGePlane)

isOn( (LinearEnt3d)arg1, (Plane)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeLinearEnt3d {lvalue},class PyGePlane,class AcGeTol)'''
    ...
    def isParallelTo (self, *args, **kwargs):
      '''
isParallelTo( (LinearEnt3d)arg1, (LinearEnt3d)arg2) -> bool :

    C++ signature :
        bool isParallelTo(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d)

isParallelTo( (LinearEnt3d)arg1, (LinearEnt3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isParallelTo(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d,class AcGeTol)

isParallelTo( (LinearEnt3d)arg1, (PlanarEnt)arg2) -> bool :

    C++ signature :
        bool isParallelTo(class PyGeLinearEnt3d {lvalue},class PyGePlanarEnt)

isParallelTo( (LinearEnt3d)arg1, (PlanarEnt)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isParallelTo(class PyGeLinearEnt3d {lvalue},class PyGePlanarEnt,class AcGeTol)'''
    ...
    def isPeriodic (self, *args, **kwargs):
      '''
isPeriodic( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPeriodic(class PyGeCurve3d {lvalue})'''
    ...
    def isPerpendicularTo (self, *args, **kwargs):
      '''
isPerpendicularTo( (LinearEnt3d)arg1, (LinearEnt3d)arg2) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d)

isPerpendicularTo( (LinearEnt3d)arg1, (LinearEnt3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d,class AcGeTol)

isPerpendicularTo( (LinearEnt3d)arg1, (PlanarEnt)arg2) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGeLinearEnt3d {lvalue},class PyGePlanarEnt)

isPerpendicularTo( (LinearEnt3d)arg1, (PlanarEnt)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGeLinearEnt3d {lvalue},class PyGePlanarEnt,class AcGeTol)'''
    ...
    def isPlanar (self, *args, **kwargs):
      '''
isPlanar( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPlanar(class PyGeCurve3d {lvalue})

isPlanar( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isPlanar(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def kXAxis (self, *args, **kwargs):
      '''None'''
    ...
    def kYAxis (self, *args, **kwargs):
      '''None'''
    ...
    def kZAxis (self, *args, **kwargs):
      '''None'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double length(class PyGeCurve3d {lvalue},double,double)

length( (Curve3d)arg1, (float)arg2, (float)arg3, (float)arg4) -> float :

    C++ signature :
        double length(class PyGeCurve3d {lvalue},double,double,double)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} mirror(class PyGeEntity3d {lvalue},class PyGePlane)'''
    ...
    def orthoBoundBlock (self, *args, **kwargs):
      '''
orthoBoundBlock( (Curve3d)arg1) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d orthoBoundBlock(class PyGeCurve3d {lvalue})

orthoBoundBlock( (Curve3d)arg1, (Interval)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d orthoBoundBlock(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def orthoProject (self, *args, **kwargs):
      '''
orthoProject( (Curve3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d orthoProject(class PyGeCurve3d {lvalue},class PyGePlane)

orthoProject( (Curve3d)arg1, (Plane)arg2, (Tol)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d orthoProject(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeTol)'''
    ...
    def overlap (self, *args, **kwargs):
      '''
overlap( (LinearEnt3d)arg1, (LinearEnt3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple overlap(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d)

overlap( (LinearEnt3d)arg1, (LinearEnt3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple overlap(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d,class AcGeTol)'''
    ...
    def paramAtLength (self, *args, **kwargs):
      '''
paramAtLength( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve3d {lvalue},double,double)

paramAtLength( (Curve3d)arg1, (float)arg2, (float)arg3, (bool)arg4, (float)arg5) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve3d {lvalue},double,double,bool,double)'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Curve3d)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double paramOf(class PyGeCurve3d {lvalue},class AcGePoint3d)

paramOf( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double paramOf(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def pointOnLine (self, *args, **kwargs):
      '''
pointOnLine( (LinearEnt3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d pointOnLine(class PyGeLinearEnt3d {lvalue})'''
    ...
    def projClosestPointTo (self, *args, **kwargs):
      '''
projClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d projClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d)

projClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Tol)arg4) -> Point3d :

    C++ signature :
        class AcGePoint3d projClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def projClosestPointsTo (self, *args, **kwargs):
      '''
projClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple projClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d)

projClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple projClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def projIntersectWith (self, *args, **kwargs):
      '''
projIntersectWith( (LinearEnt3d)arg1, (LinearEnt3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple projIntersectWith(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d,class AcGeVector3d)

projIntersectWith( (LinearEnt3d)arg1, (LinearEnt3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple projIntersectWith(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def project (self, *args, **kwargs):
      '''
project( (Curve3d)arg1, (Plane)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d project(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeVector3d)

project( (Curve3d)arg1, (Plane)arg2, (Vector3d)arg3, (Tol)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d project(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeVector3d,class AcGeTol)'''
    ...
    def reverseParam (self, *args, **kwargs):
      '''
reverseParam( (Curve3d)arg1) -> Curve3d :

    C++ signature :
        class PyGeCurve3d {lvalue} reverseParam(class PyGeCurve3d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d)

rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3, (Point3d)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d,class AcGePoint3d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity3d)arg1, (float)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double)

scaleBy( (Entity3d)arg1, (float)arg2, (Point3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double,class AcGePoint3d)'''
    ...
    def set (self, *args, **kwargs):
      '''
set( (Line3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> Line3d :

    C++ signature :
        class PyGeLine3d {lvalue} set(class PyGeLine3d {lvalue},class AcGePoint3d,class AcGeVector3d)

set( (Line3d)arg1, (Point3d)arg2, (Point3d)arg3) -> Line3d :

    C++ signature :
        class PyGeLine3d {lvalue} set(class PyGeLine3d {lvalue},class AcGePoint3d,class AcGePoint3d)'''
    ...
    def setInterval (self, *args, **kwargs):
      '''
setInterval( (Curve3d)arg1) -> Curve3d :

    C++ signature :
        class PyGeCurve3d {lvalue} setInterval(class PyGeCurve3d {lvalue})

setInterval( (Curve3d)arg1, (Interval)arg2) -> bool :

    C++ signature :
        bool setInterval(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity3d)arg1, (Matrix3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} transformBy(class PyGeEntity3d {lvalue},class AcGeMatrix3d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity3d)arg1, (Vector3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} translateBy(class PyGeEntity3d {lvalue},class AcGeVector3d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity3d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity3d {lvalue})'''
    ...

class LineSeg2d:
    def area (self, *args, **kwargs):
      '''
area( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double area(class PyGeCurve2d {lvalue},double,double)

area( (Curve2d)arg1, (float)arg2, (float)arg3, (Tol)arg4) -> float :

    C++ signature :
        double area(class PyGeCurve2d {lvalue},double,double,class AcGeTol)'''
    ...
    def baryComb (self, *args, **kwargs):
      '''
baryComb( (LineSeg2d)arg1, (float)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d baryComb(class PyGeLineSeg2d {lvalue},double)'''
    ...
    def boundBlock (self, *args, **kwargs):
      '''
boundBlock( (Curve2d)arg1) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d boundBlock(class PyGeCurve2d {lvalue})

boundBlock( (Curve2d)arg1, (Interval)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d boundBlock(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Curve2d)arg1, (Point2d)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d closestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

closestPointTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> Point2d :

    C++ signature :
        class AcGePoint2d closestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

closestPointTo( (Curve2d)arg1, (Curve2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

closestPointTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity2d)arg1) -> Entity2d :

    C++ signature :
        class PyGeEntity2d copy(class PyGeEntity2d {lvalue})'''
    ...
    def direction (self, *args, **kwargs):
      '''
direction( (LinearEnt2d)arg1) -> Vector2d :

    C++ signature :
        class AcGeVector2d direction(class PyGeLinearEnt2d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Curve2d)arg1, (Point2d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

distanceTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

distanceTo( (Curve2d)arg1, (Curve2d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

distanceTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def endPoint (self, *args, **kwargs):
      '''
endPoint( (LineSeg2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d endPoint(class PyGeLineSeg2d {lvalue})'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Curve2d)arg1, (float)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d evalPoint(class PyGeCurve2d {lvalue},double)

evalPoint( (Curve2d)arg1, (float)arg2, (CmdFlags)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple evalPoint(class PyGeCurve2d {lvalue},double,int)'''
    ...
    def explode (self, *args, **kwargs):
      '''
explode( (Curve2d)arg1) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve2d {lvalue})

explode( (Curve2d)arg1, (Interval)arg2) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def getBisector (self, *args, **kwargs):
      '''
getBisector( (LineSeg2d)arg1) -> Line2d :

    C++ signature :
        class PyGeLine2d getBisector(class PyGeLineSeg2d {lvalue})'''
    ...
    def getClosestPointTo (self, *args, **kwargs):
      '''
getClosestPointTo( (Curve2d)arg1, (Point2d)arg2) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getClosestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

getClosestPointTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getClosestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def getClosestPointsTo (self, *args, **kwargs):
      '''
getClosestPointsTo( (Curve2d)arg1, (Curve2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

getClosestPointsTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def getEndPoint (self, *args, **kwargs):
      '''
getEndPoint( (Curve2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getEndPoint(class PyGeCurve2d {lvalue})'''
    ...
    def getInterval (self, *args, **kwargs):
      '''
getInterval( (Curve2d)arg1) -> Interval :

    C++ signature :
        class PyGeInterval getInterval(class PyGeCurve2d {lvalue})'''
    ...
    def getLine (self, *args, **kwargs):
      '''
getLine( (LinearEnt2d)arg1) -> Line2d :

    C++ signature :
        class PyGeLine2d getLine(class PyGeLinearEnt2d {lvalue})'''
    ...
    def getNormalPoint (self, *args, **kwargs):
      '''
getNormalPoint( (Curve2d)arg1, (Point2d)arg2) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getNormalPoint(class PyGeCurve2d {lvalue},class AcGePoint2d)

getNormalPoint( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getNormalPoint(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def getPerpLine (self, *args, **kwargs):
      '''
getPerpLine( (LinearEnt2d)arg1, (Point2d)arg2) -> Line2d :

    C++ signature :
        class PyGeLine2d getPerpLine(class PyGeLinearEnt2d {lvalue},class AcGePoint2d)'''
    ...
    def getSamplePoints (self, *args, **kwargs):
      '''
getSamplePoints( (Curve2d)arg1, (CmdFlags)arg2) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve2d {lvalue},int)

getSamplePoints( (Curve2d)arg1, (float)arg2, (float)arg3, (float)arg4) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve2d {lvalue},double,double,double)'''
    ...
    def getSplitCurves (self, *args, **kwargs):
      '''
getSplitCurves( (Curve2d)arg1, (float)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getSplitCurves(class PyGeCurve2d {lvalue},double)'''
    ...
    def getStartPoint (self, *args, **kwargs):
      '''
getStartPoint( (Curve2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getStartPoint(class PyGeCurve2d {lvalue})'''
    ...
    def getTrimmedOffset (self, *args, **kwargs):
      '''
getTrimmedOffset( (Curve2d)arg1, (float)arg2, (OffsetCrvExtType)arg3) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve2d {lvalue},double,enum AcGe::OffsetCrvExtType)

getTrimmedOffset( (Curve2d)arg1, (float)arg2, (OffsetCrvExtType)arg3, (Tol)arg4) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve2d {lvalue},double,enum AcGe::OffsetCrvExtType,class AcGeTol)'''
    ...
    def hasEndPoint (self, *args, **kwargs):
      '''
hasEndPoint( (Curve2d)arg1) -> bool :

    C++ signature :
        bool hasEndPoint(class PyGeCurve2d {lvalue})'''
    ...
    def hasStartPoint (self, *args, **kwargs):
      '''
hasStartPoint( (Curve2d)arg1) -> bool :

    C++ signature :
        bool hasStartPoint(class PyGeCurve2d {lvalue})'''
    ...
    def intersectWith (self, *args, **kwargs):
      '''
intersectWith( (LinearEnt2d)arg1, (LinearEnt2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d)

intersectWith( (LinearEnt2d)arg1, (LinearEnt2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d,class AcGeTol)'''
    ...
    def isClosed (self, *args, **kwargs):
      '''
isClosed( (Curve2d)arg1) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve2d {lvalue})

isClosed( (Curve2d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isColinearTo (self, *args, **kwargs):
      '''
isColinearTo( (LinearEnt2d)arg1, (LinearEnt2d)arg2) -> bool :

    C++ signature :
        bool isColinearTo(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d)

isColinearTo( (LinearEnt2d)arg1, (LinearEnt2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isColinearTo(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d,class AcGeTol)'''
    ...
    def isDegenerate (self, *args, **kwargs):
      '''
isDegenerate( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve2d {lvalue})

isDegenerate( (Curve2d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity2d)arg1, (Entity2d)arg2) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d)

isEqualTo( (Entity2d)arg1, (Entity2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity2d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity2d {lvalue},enum AcGe::EntityId)'''
    ...
    def isLinear (self, *args, **kwargs):
      '''
isLinear( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve2d {lvalue})

isLinear( (Curve2d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity2d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity2d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Curve2d)arg1, (Point2d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d)

isOn( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

isOn( (Curve2d)arg1, (Point2d)arg2, (float)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,double {lvalue})

isOn( (Curve2d)arg1, (Point2d)arg2, (float)arg3, (Tol)arg4) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,double {lvalue},class AcGeTol)

isOn( (Curve2d)arg1, (float)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},double)

isOn( (Curve2d)arg1, (float)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},double,class AcGeTol)'''
    ...
    def isParallelTo (self, *args, **kwargs):
      '''
isParallelTo( (LinearEnt2d)arg1, (LinearEnt2d)arg2) -> bool :

    C++ signature :
        bool isParallelTo(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d)

isParallelTo( (LinearEnt2d)arg1, (LinearEnt2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isParallelTo(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d,class AcGeTol)'''
    ...
    def isPeriodic (self, *args, **kwargs):
      '''
isPeriodic( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPeriodic(class PyGeCurve2d {lvalue})'''
    ...
    def isPerpendicularTo (self, *args, **kwargs):
      '''
isPerpendicularTo( (LinearEnt2d)arg1, (LinearEnt2d)arg2) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d)

isPerpendicularTo( (LinearEnt2d)arg1, (LinearEnt2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d,class AcGeTol)'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (LineSeg2d)arg1) -> float :

    C++ signature :
        double length(class PyGeLineSeg2d {lvalue})

length( (LineSeg2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double length(class PyGeLineSeg2d {lvalue},double,double)

length( (LineSeg2d)arg1, (float)arg2, (float)arg3, (float)arg4) -> float :

    C++ signature :
        double length(class PyGeLineSeg2d {lvalue},double,double,double)'''
    ...
    def midPoint (self, *args, **kwargs):
      '''
midPoint( (LineSeg2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d midPoint(class PyGeLineSeg2d {lvalue})'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity2d)arg1, (Line2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} mirror(class PyGeEntity2d {lvalue},class PyGeLine2d)'''
    ...
    def orthoBoundBlock (self, *args, **kwargs):
      '''
orthoBoundBlock( (Curve2d)arg1) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d orthoBoundBlock(class PyGeCurve2d {lvalue})

orthoBoundBlock( (Curve2d)arg1, (Interval)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d orthoBoundBlock(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def overlap (self, *args, **kwargs):
      '''
overlap( (LinearEnt2d)arg1, (LinearEnt2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple overlap(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d)

overlap( (LinearEnt2d)arg1, (LinearEnt2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple overlap(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d,class AcGeTol)'''
    ...
    def paramAtLength (self, *args, **kwargs):
      '''
paramAtLength( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve2d {lvalue},double,double)

paramAtLength( (Curve2d)arg1, (float)arg2, (float)arg3, (bool)arg4, (float)arg5) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve2d {lvalue},double,double,bool,double)'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Curve2d)arg1, (Point2d)arg2) -> float :

    C++ signature :
        double paramOf(class PyGeCurve2d {lvalue},class AcGePoint2d)

paramOf( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double paramOf(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def pointOnLine (self, *args, **kwargs):
      '''
pointOnLine( (LinearEnt2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d pointOnLine(class PyGeLinearEnt2d {lvalue})'''
    ...
    def reverseParam (self, *args, **kwargs):
      '''
reverseParam( (Curve2d)arg1) -> Curve2d :

    C++ signature :
        class PyGeCurve2d {lvalue} reverseParam(class PyGeCurve2d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double)

rotateBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double)

scaleBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def set (self, *args, **kwargs):
      '''
set( (LineSeg2d)arg1, (Point2d)arg2, (Vector2d)arg3) -> LineSeg2d :

    C++ signature :
        class PyGeLineSeg2d {lvalue} set(class PyGeLineSeg2d {lvalue},class AcGePoint2d,class AcGeVector2d)

set( (LineSeg2d)arg1, (Point2d)arg2, (Point2d)arg3) -> LineSeg2d :

    C++ signature :
        class PyGeLineSeg2d {lvalue} set(class PyGeLineSeg2d {lvalue},class AcGePoint2d,class AcGePoint2d)

set( (LineSeg2d)arg1, (Curve2d)arg2, (Curve2d)arg3) -> LineSeg2d :

    C++ signature :
        class PyGeLineSeg2d {lvalue} set(class PyGeLineSeg2d {lvalue},class PyGeCurve2d,class PyGeCurve2d)

set( (LineSeg2d)arg1, (Curve2d)arg2, (Point2d)arg3) -> LineSeg2d :

    C++ signature :
        class PyGeLineSeg2d {lvalue} set(class PyGeLineSeg2d {lvalue},class PyGeCurve2d,class AcGePoint2d)'''
    ...
    def setInterval (self, *args, **kwargs):
      '''
setInterval( (Curve2d)arg1) -> Curve2d :

    C++ signature :
        class PyGeCurve2d {lvalue} setInterval(class PyGeCurve2d {lvalue})

setInterval( (Curve2d)arg1, (Interval)arg2) -> bool :

    C++ signature :
        bool setInterval(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def startPoint (self, *args, **kwargs):
      '''
startPoint( (LineSeg2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d startPoint(class PyGeLineSeg2d {lvalue})'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity2d)arg1, (Matrix2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} transformBy(class PyGeEntity2d {lvalue},class AcGeMatrix2d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity2d)arg1, (Vector2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} translateBy(class PyGeEntity2d {lvalue},class AcGeVector2d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity2d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity2d {lvalue})'''
    ...

class LineSeg3d:
    def area (self, *args, **kwargs):
      '''
area( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double area(class PyGeCurve3d {lvalue},double,double)

area( (Curve3d)arg1, (float)arg2, (float)arg3, (Tol)arg4) -> float :

    C++ signature :
        double area(class PyGeCurve3d {lvalue},double,double,class AcGeTol)'''
    ...
    def baryComb (self, *args, **kwargs):
      '''
baryComb( (LineSeg3d)arg1, (float)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d baryComb(class PyGeLineSeg3d {lvalue},double)'''
    ...
    def boundBlock (self, *args, **kwargs):
      '''
boundBlock( (Curve3d)arg1) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d boundBlock(class PyGeCurve3d {lvalue})

boundBlock( (Curve3d)arg1, (Interval)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d boundBlock(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Curve3d)arg1, (Point3d)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

closestPointTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

closestPointTo( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

closestPointTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity3d)arg1) -> Entity3d :

    C++ signature :
        class PyGeEntity3d copy(class PyGeEntity3d {lvalue})'''
    ...
    def direction (self, *args, **kwargs):
      '''
direction( (LinearEnt3d)arg1) -> Vector3d :

    C++ signature :
        class AcGeVector3d direction(class PyGeLinearEnt3d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Curve3d)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

distanceTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

distanceTo( (Curve3d)arg1, (Curve3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

distanceTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def endPoint (self, *args, **kwargs):
      '''
endPoint( (LineSeg3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d endPoint(class PyGeLineSeg3d {lvalue})'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Curve3d)arg1, (float)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d evalPoint(class PyGeCurve3d {lvalue},double)

evalPoint( (Curve3d)arg1, (float)arg2, (CmdFlags)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple evalPoint(class PyGeCurve3d {lvalue},double,int)'''
    ...
    def explode (self, *args, **kwargs):
      '''
explode( (Curve3d)arg1) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve3d {lvalue})

explode( (Curve3d)arg1, (Interval)arg2) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def getBisector (self, *args, **kwargs):
      '''
getBisector( (LineSeg3d)arg1) -> Plane :

    C++ signature :
        class PyGePlane getBisector(class PyGeLineSeg3d {lvalue})'''
    ...
    def getClosestPointTo (self, *args, **kwargs):
      '''
getClosestPointTo( (Curve3d)arg1, (Point3d)arg2) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

getClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def getClosestPointsTo (self, *args, **kwargs):
      '''
getClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

getClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def getEndPoint (self, *args, **kwargs):
      '''
getEndPoint( (Curve3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getEndPoint(class PyGeCurve3d {lvalue})'''
    ...
    def getInterval (self, *args, **kwargs):
      '''
getInterval( (Curve3d)arg1) -> Interval :

    C++ signature :
        class PyGeInterval getInterval(class PyGeCurve3d {lvalue})'''
    ...
    def getLine (self, *args, **kwargs):
      '''
getLine( (LinearEnt3d)arg1) -> Line3d :

    C++ signature :
        class PyGeLine3d getLine(class PyGeLinearEnt3d {lvalue})'''
    ...
    def getNormalPoint (self, *args, **kwargs):
      '''
getNormalPoint( (Curve3d)arg1, (Point3d)arg2) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getNormalPoint(class PyGeCurve3d {lvalue},class AcGePoint3d)

getNormalPoint( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getNormalPoint(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def getPerpPlane (self, *args, **kwargs):
      '''
getPerpPlane( (LinearEnt3d)arg1, (Point3d)arg2) -> Plane :

    C++ signature :
        class PyGePlane getPerpPlane(class PyGeLinearEnt3d {lvalue},class AcGePoint3d)'''
    ...
    def getProjClosestPointTo (self, *args, **kwargs):
      '''
getProjClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getProjClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d)

getProjClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Tol)arg4) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getProjClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def getProjClosestPointsTo (self, *args, **kwargs):
      '''
getProjClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getProjClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d)

getProjClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple getProjClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def getSamplePoints (self, *args, **kwargs):
      '''
getSamplePoints( (Curve3d)arg1, (CmdFlags)arg2) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve3d {lvalue},int)

getSamplePoints( (Curve3d)arg1, (float)arg2, (float)arg3, (float)arg4) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve3d {lvalue},double,double,double)'''
    ...
    def getSplitCurves (self, *args, **kwargs):
      '''
getSplitCurves( (Curve3d)arg1, (float)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getSplitCurves(class PyGeCurve3d {lvalue},double)'''
    ...
    def getStartPoint (self, *args, **kwargs):
      '''
getStartPoint( (Curve3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getStartPoint(class PyGeCurve3d {lvalue})'''
    ...
    def getTrimmedOffset (self, *args, **kwargs):
      '''
getTrimmedOffset( (Curve3d)arg1, (float)arg2, (Vector3d)arg3, (OffsetCrvExtType)arg4) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve3d {lvalue},double,class AcGeVector3d,enum AcGe::OffsetCrvExtType)

getTrimmedOffset( (Curve3d)arg1, (float)arg2, (Vector3d)arg3, (OffsetCrvExtType)arg4, (Tol)arg5) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve3d {lvalue},double,class AcGeVector3d,enum AcGe::OffsetCrvExtType,class AcGeTol)'''
    ...
    def hasEndPoint (self, *args, **kwargs):
      '''
hasEndPoint( (Curve3d)arg1) -> bool :

    C++ signature :
        bool hasEndPoint(class PyGeCurve3d {lvalue})'''
    ...
    def hasStartPoint (self, *args, **kwargs):
      '''
hasStartPoint( (Curve3d)arg1) -> bool :

    C++ signature :
        bool hasStartPoint(class PyGeCurve3d {lvalue})'''
    ...
    def intersectWith (self, *args, **kwargs):
      '''
intersectWith( (LinearEnt3d)arg1, (LinearEnt3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d)

intersectWith( (LinearEnt3d)arg1, (LinearEnt3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d,class AcGeTol)

intersectWith( (LinearEnt3d)arg1, (PlanarEnt)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeLinearEnt3d {lvalue},class PyGePlanarEnt)

intersectWith( (LinearEnt3d)arg1, (PlanarEnt)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeLinearEnt3d {lvalue},class PyGePlanarEnt,class AcGeTol)'''
    ...
    def isClosed (self, *args, **kwargs):
      '''
isClosed( (Curve3d)arg1) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve3d {lvalue})

isClosed( (Curve3d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isColinearTo (self, *args, **kwargs):
      '''
isColinearTo( (LinearEnt3d)arg1, (LinearEnt3d)arg2) -> bool :

    C++ signature :
        bool isColinearTo(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d)

isColinearTo( (LinearEnt3d)arg1, (LinearEnt3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isColinearTo(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d,class AcGeTol)'''
    ...
    def isCoplanarWith (self, *args, **kwargs):
      '''
isCoplanarWith( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isCoplanarWith(class PyGeCurve3d {lvalue},class PyGeCurve3d)

isCoplanarWith( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple isCoplanarWith(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def isDegenerate (self, *args, **kwargs):
      '''
isDegenerate( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve3d {lvalue})

isDegenerate( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity3d)arg1, (Entity3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity3d {lvalue},class PyGeEntity3d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity3d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity3d {lvalue},enum AcGe::EntityId)'''
    ...
    def isLinear (self, *args, **kwargs):
      '''
isLinear( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve3d {lvalue})

isLinear( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity3d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity3d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (LinearEnt3d)arg1, (Point3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isOn(class PyGeLinearEnt3d {lvalue},class AcGePoint3d)

isOn( (LinearEnt3d)arg1, (Point3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple isOn(class PyGeLinearEnt3d {lvalue},class AcGePoint3d,class AcGeTol)

isOn( (LinearEnt3d)arg1, (float)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeLinearEnt3d {lvalue},double)

isOn( (LinearEnt3d)arg1, (float)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeLinearEnt3d {lvalue},double,class AcGeTol)

isOn( (LinearEnt3d)arg1, (Plane)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeLinearEnt3d {lvalue},class PyGePlane)

isOn( (LinearEnt3d)arg1, (Plane)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeLinearEnt3d {lvalue},class PyGePlane,class AcGeTol)'''
    ...
    def isParallelTo (self, *args, **kwargs):
      '''
isParallelTo( (LinearEnt3d)arg1, (LinearEnt3d)arg2) -> bool :

    C++ signature :
        bool isParallelTo(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d)

isParallelTo( (LinearEnt3d)arg1, (LinearEnt3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isParallelTo(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d,class AcGeTol)

isParallelTo( (LinearEnt3d)arg1, (PlanarEnt)arg2) -> bool :

    C++ signature :
        bool isParallelTo(class PyGeLinearEnt3d {lvalue},class PyGePlanarEnt)

isParallelTo( (LinearEnt3d)arg1, (PlanarEnt)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isParallelTo(class PyGeLinearEnt3d {lvalue},class PyGePlanarEnt,class AcGeTol)'''
    ...
    def isPeriodic (self, *args, **kwargs):
      '''
isPeriodic( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPeriodic(class PyGeCurve3d {lvalue})'''
    ...
    def isPerpendicularTo (self, *args, **kwargs):
      '''
isPerpendicularTo( (LinearEnt3d)arg1, (LinearEnt3d)arg2) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d)

isPerpendicularTo( (LinearEnt3d)arg1, (LinearEnt3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d,class AcGeTol)

isPerpendicularTo( (LinearEnt3d)arg1, (PlanarEnt)arg2) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGeLinearEnt3d {lvalue},class PyGePlanarEnt)

isPerpendicularTo( (LinearEnt3d)arg1, (PlanarEnt)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGeLinearEnt3d {lvalue},class PyGePlanarEnt,class AcGeTol)'''
    ...
    def isPlanar (self, *args, **kwargs):
      '''
isPlanar( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPlanar(class PyGeCurve3d {lvalue})

isPlanar( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isPlanar(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (LineSeg3d)arg1) -> float :

    C++ signature :
        double length(class PyGeLineSeg3d {lvalue})

length( (LineSeg3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double length(class PyGeLineSeg3d {lvalue},double,double)

length( (LineSeg3d)arg1, (float)arg2, (float)arg3, (float)arg4) -> float :

    C++ signature :
        double length(class PyGeLineSeg3d {lvalue},double,double,double)'''
    ...
    def midPoint (self, *args, **kwargs):
      '''
midPoint( (LineSeg3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d midPoint(class PyGeLineSeg3d {lvalue})'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} mirror(class PyGeEntity3d {lvalue},class PyGePlane)'''
    ...
    def orthoBoundBlock (self, *args, **kwargs):
      '''
orthoBoundBlock( (Curve3d)arg1) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d orthoBoundBlock(class PyGeCurve3d {lvalue})

orthoBoundBlock( (Curve3d)arg1, (Interval)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d orthoBoundBlock(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def orthoProject (self, *args, **kwargs):
      '''
orthoProject( (Curve3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d orthoProject(class PyGeCurve3d {lvalue},class PyGePlane)

orthoProject( (Curve3d)arg1, (Plane)arg2, (Tol)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d orthoProject(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeTol)'''
    ...
    def overlap (self, *args, **kwargs):
      '''
overlap( (LinearEnt3d)arg1, (LinearEnt3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple overlap(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d)

overlap( (LinearEnt3d)arg1, (LinearEnt3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple overlap(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d,class AcGeTol)'''
    ...
    def paramAtLength (self, *args, **kwargs):
      '''
paramAtLength( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve3d {lvalue},double,double)

paramAtLength( (Curve3d)arg1, (float)arg2, (float)arg3, (bool)arg4, (float)arg5) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve3d {lvalue},double,double,bool,double)'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Curve3d)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double paramOf(class PyGeCurve3d {lvalue},class AcGePoint3d)

paramOf( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double paramOf(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def pointOnLine (self, *args, **kwargs):
      '''
pointOnLine( (LinearEnt3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d pointOnLine(class PyGeLinearEnt3d {lvalue})'''
    ...
    def projClosestPointTo (self, *args, **kwargs):
      '''
projClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d projClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d)

projClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Tol)arg4) -> Point3d :

    C++ signature :
        class AcGePoint3d projClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def projClosestPointsTo (self, *args, **kwargs):
      '''
projClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple projClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d)

projClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple projClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def projIntersectWith (self, *args, **kwargs):
      '''
projIntersectWith( (LinearEnt3d)arg1, (LinearEnt3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple projIntersectWith(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d,class AcGeVector3d)

projIntersectWith( (LinearEnt3d)arg1, (LinearEnt3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple projIntersectWith(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def project (self, *args, **kwargs):
      '''
project( (Curve3d)arg1, (Plane)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d project(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeVector3d)

project( (Curve3d)arg1, (Plane)arg2, (Vector3d)arg3, (Tol)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d project(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeVector3d,class AcGeTol)'''
    ...
    def reverseParam (self, *args, **kwargs):
      '''
reverseParam( (Curve3d)arg1) -> Curve3d :

    C++ signature :
        class PyGeCurve3d {lvalue} reverseParam(class PyGeCurve3d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d)

rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3, (Point3d)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d,class AcGePoint3d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity3d)arg1, (float)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double)

scaleBy( (Entity3d)arg1, (float)arg2, (Point3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double,class AcGePoint3d)'''
    ...
    def set (self, *args, **kwargs):
      '''
set( (LineSeg3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> LineSeg3d :

    C++ signature :
        class PyGeLineSeg3d {lvalue} set(class PyGeLineSeg3d {lvalue},class AcGePoint3d,class AcGeVector3d)

set( (LineSeg3d)arg1, (Point3d)arg2, (Point3d)arg3) -> LineSeg3d :

    C++ signature :
        class PyGeLineSeg3d {lvalue} set(class PyGeLineSeg3d {lvalue},class AcGePoint3d,class AcGePoint3d)'''
    ...
    def setInterval (self, *args, **kwargs):
      '''
setInterval( (Curve3d)arg1) -> Curve3d :

    C++ signature :
        class PyGeCurve3d {lvalue} setInterval(class PyGeCurve3d {lvalue})

setInterval( (Curve3d)arg1, (Interval)arg2) -> bool :

    C++ signature :
        bool setInterval(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def startPoint (self, *args, **kwargs):
      '''
startPoint( (LineSeg3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d startPoint(class PyGeLineSeg3d {lvalue})'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity3d)arg1, (Matrix3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} transformBy(class PyGeEntity3d {lvalue},class AcGeMatrix3d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity3d)arg1, (Vector3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} translateBy(class PyGeEntity3d {lvalue},class AcGeVector3d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity3d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity3d {lvalue})'''
    ...

class LinearEnt2d:
    def area (self, *args, **kwargs):
      '''
area( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double area(class PyGeCurve2d {lvalue},double,double)

area( (Curve2d)arg1, (float)arg2, (float)arg3, (Tol)arg4) -> float :

    C++ signature :
        double area(class PyGeCurve2d {lvalue},double,double,class AcGeTol)'''
    ...
    def boundBlock (self, *args, **kwargs):
      '''
boundBlock( (Curve2d)arg1) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d boundBlock(class PyGeCurve2d {lvalue})

boundBlock( (Curve2d)arg1, (Interval)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d boundBlock(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Curve2d)arg1, (Point2d)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d closestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

closestPointTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> Point2d :

    C++ signature :
        class AcGePoint2d closestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

closestPointTo( (Curve2d)arg1, (Curve2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

closestPointTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity2d)arg1) -> Entity2d :

    C++ signature :
        class PyGeEntity2d copy(class PyGeEntity2d {lvalue})'''
    ...
    def direction (self, *args, **kwargs):
      '''
direction( (LinearEnt2d)arg1) -> Vector2d :

    C++ signature :
        class AcGeVector2d direction(class PyGeLinearEnt2d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Curve2d)arg1, (Point2d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

distanceTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

distanceTo( (Curve2d)arg1, (Curve2d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

distanceTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Curve2d)arg1, (float)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d evalPoint(class PyGeCurve2d {lvalue},double)

evalPoint( (Curve2d)arg1, (float)arg2, (CmdFlags)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple evalPoint(class PyGeCurve2d {lvalue},double,int)'''
    ...
    def explode (self, *args, **kwargs):
      '''
explode( (Curve2d)arg1) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve2d {lvalue})

explode( (Curve2d)arg1, (Interval)arg2) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def getClosestPointTo (self, *args, **kwargs):
      '''
getClosestPointTo( (Curve2d)arg1, (Point2d)arg2) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getClosestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

getClosestPointTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getClosestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def getClosestPointsTo (self, *args, **kwargs):
      '''
getClosestPointsTo( (Curve2d)arg1, (Curve2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

getClosestPointsTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def getEndPoint (self, *args, **kwargs):
      '''
getEndPoint( (Curve2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getEndPoint(class PyGeCurve2d {lvalue})'''
    ...
    def getInterval (self, *args, **kwargs):
      '''
getInterval( (Curve2d)arg1) -> Interval :

    C++ signature :
        class PyGeInterval getInterval(class PyGeCurve2d {lvalue})'''
    ...
    def getLine (self, *args, **kwargs):
      '''
getLine( (LinearEnt2d)arg1) -> Line2d :

    C++ signature :
        class PyGeLine2d getLine(class PyGeLinearEnt2d {lvalue})'''
    ...
    def getNormalPoint (self, *args, **kwargs):
      '''
getNormalPoint( (Curve2d)arg1, (Point2d)arg2) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getNormalPoint(class PyGeCurve2d {lvalue},class AcGePoint2d)

getNormalPoint( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getNormalPoint(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def getPerpLine (self, *args, **kwargs):
      '''
getPerpLine( (LinearEnt2d)arg1, (Point2d)arg2) -> Line2d :

    C++ signature :
        class PyGeLine2d getPerpLine(class PyGeLinearEnt2d {lvalue},class AcGePoint2d)'''
    ...
    def getSamplePoints (self, *args, **kwargs):
      '''
getSamplePoints( (Curve2d)arg1, (CmdFlags)arg2) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve2d {lvalue},int)

getSamplePoints( (Curve2d)arg1, (float)arg2, (float)arg3, (float)arg4) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve2d {lvalue},double,double,double)'''
    ...
    def getSplitCurves (self, *args, **kwargs):
      '''
getSplitCurves( (Curve2d)arg1, (float)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getSplitCurves(class PyGeCurve2d {lvalue},double)'''
    ...
    def getStartPoint (self, *args, **kwargs):
      '''
getStartPoint( (Curve2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getStartPoint(class PyGeCurve2d {lvalue})'''
    ...
    def getTrimmedOffset (self, *args, **kwargs):
      '''
getTrimmedOffset( (Curve2d)arg1, (float)arg2, (OffsetCrvExtType)arg3) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve2d {lvalue},double,enum AcGe::OffsetCrvExtType)

getTrimmedOffset( (Curve2d)arg1, (float)arg2, (OffsetCrvExtType)arg3, (Tol)arg4) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve2d {lvalue},double,enum AcGe::OffsetCrvExtType,class AcGeTol)'''
    ...
    def hasEndPoint (self, *args, **kwargs):
      '''
hasEndPoint( (Curve2d)arg1) -> bool :

    C++ signature :
        bool hasEndPoint(class PyGeCurve2d {lvalue})'''
    ...
    def hasStartPoint (self, *args, **kwargs):
      '''
hasStartPoint( (Curve2d)arg1) -> bool :

    C++ signature :
        bool hasStartPoint(class PyGeCurve2d {lvalue})'''
    ...
    def intersectWith (self, *args, **kwargs):
      '''
intersectWith( (LinearEnt2d)arg1, (LinearEnt2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d)

intersectWith( (LinearEnt2d)arg1, (LinearEnt2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d,class AcGeTol)'''
    ...
    def isClosed (self, *args, **kwargs):
      '''
isClosed( (Curve2d)arg1) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve2d {lvalue})

isClosed( (Curve2d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isColinearTo (self, *args, **kwargs):
      '''
isColinearTo( (LinearEnt2d)arg1, (LinearEnt2d)arg2) -> bool :

    C++ signature :
        bool isColinearTo(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d)

isColinearTo( (LinearEnt2d)arg1, (LinearEnt2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isColinearTo(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d,class AcGeTol)'''
    ...
    def isDegenerate (self, *args, **kwargs):
      '''
isDegenerate( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve2d {lvalue})

isDegenerate( (Curve2d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity2d)arg1, (Entity2d)arg2) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d)

isEqualTo( (Entity2d)arg1, (Entity2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity2d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity2d {lvalue},enum AcGe::EntityId)'''
    ...
    def isLinear (self, *args, **kwargs):
      '''
isLinear( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve2d {lvalue})

isLinear( (Curve2d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity2d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity2d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Curve2d)arg1, (Point2d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d)

isOn( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

isOn( (Curve2d)arg1, (Point2d)arg2, (float)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,double {lvalue})

isOn( (Curve2d)arg1, (Point2d)arg2, (float)arg3, (Tol)arg4) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,double {lvalue},class AcGeTol)

isOn( (Curve2d)arg1, (float)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},double)

isOn( (Curve2d)arg1, (float)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},double,class AcGeTol)'''
    ...
    def isParallelTo (self, *args, **kwargs):
      '''
isParallelTo( (LinearEnt2d)arg1, (LinearEnt2d)arg2) -> bool :

    C++ signature :
        bool isParallelTo(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d)

isParallelTo( (LinearEnt2d)arg1, (LinearEnt2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isParallelTo(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d,class AcGeTol)'''
    ...
    def isPeriodic (self, *args, **kwargs):
      '''
isPeriodic( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPeriodic(class PyGeCurve2d {lvalue})'''
    ...
    def isPerpendicularTo (self, *args, **kwargs):
      '''
isPerpendicularTo( (LinearEnt2d)arg1, (LinearEnt2d)arg2) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d)

isPerpendicularTo( (LinearEnt2d)arg1, (LinearEnt2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d,class AcGeTol)'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double length(class PyGeCurve2d {lvalue},double,double)

length( (Curve2d)arg1, (float)arg2, (float)arg3, (float)arg4) -> float :

    C++ signature :
        double length(class PyGeCurve2d {lvalue},double,double,double)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity2d)arg1, (Line2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} mirror(class PyGeEntity2d {lvalue},class PyGeLine2d)'''
    ...
    def orthoBoundBlock (self, *args, **kwargs):
      '''
orthoBoundBlock( (Curve2d)arg1) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d orthoBoundBlock(class PyGeCurve2d {lvalue})

orthoBoundBlock( (Curve2d)arg1, (Interval)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d orthoBoundBlock(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def overlap (self, *args, **kwargs):
      '''
overlap( (LinearEnt2d)arg1, (LinearEnt2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple overlap(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d)

overlap( (LinearEnt2d)arg1, (LinearEnt2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple overlap(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d,class AcGeTol)'''
    ...
    def paramAtLength (self, *args, **kwargs):
      '''
paramAtLength( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve2d {lvalue},double,double)

paramAtLength( (Curve2d)arg1, (float)arg2, (float)arg3, (bool)arg4, (float)arg5) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve2d {lvalue},double,double,bool,double)'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Curve2d)arg1, (Point2d)arg2) -> float :

    C++ signature :
        double paramOf(class PyGeCurve2d {lvalue},class AcGePoint2d)

paramOf( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double paramOf(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def pointOnLine (self, *args, **kwargs):
      '''
pointOnLine( (LinearEnt2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d pointOnLine(class PyGeLinearEnt2d {lvalue})'''
    ...
    def reverseParam (self, *args, **kwargs):
      '''
reverseParam( (Curve2d)arg1) -> Curve2d :

    C++ signature :
        class PyGeCurve2d {lvalue} reverseParam(class PyGeCurve2d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double)

rotateBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double)

scaleBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def setInterval (self, *args, **kwargs):
      '''
setInterval( (Curve2d)arg1) -> Curve2d :

    C++ signature :
        class PyGeCurve2d {lvalue} setInterval(class PyGeCurve2d {lvalue})

setInterval( (Curve2d)arg1, (Interval)arg2) -> bool :

    C++ signature :
        bool setInterval(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity2d)arg1, (Matrix2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} transformBy(class PyGeEntity2d {lvalue},class AcGeMatrix2d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity2d)arg1, (Vector2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} translateBy(class PyGeEntity2d {lvalue},class AcGeVector2d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity2d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity2d {lvalue})'''
    ...

class LinearEnt3d:
    def area (self, *args, **kwargs):
      '''
area( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double area(class PyGeCurve3d {lvalue},double,double)

area( (Curve3d)arg1, (float)arg2, (float)arg3, (Tol)arg4) -> float :

    C++ signature :
        double area(class PyGeCurve3d {lvalue},double,double,class AcGeTol)'''
    ...
    def boundBlock (self, *args, **kwargs):
      '''
boundBlock( (Curve3d)arg1) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d boundBlock(class PyGeCurve3d {lvalue})

boundBlock( (Curve3d)arg1, (Interval)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d boundBlock(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Curve3d)arg1, (Point3d)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

closestPointTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

closestPointTo( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

closestPointTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity3d)arg1) -> Entity3d :

    C++ signature :
        class PyGeEntity3d copy(class PyGeEntity3d {lvalue})'''
    ...
    def direction (self, *args, **kwargs):
      '''
direction( (LinearEnt3d)arg1) -> Vector3d :

    C++ signature :
        class AcGeVector3d direction(class PyGeLinearEnt3d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Curve3d)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

distanceTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

distanceTo( (Curve3d)arg1, (Curve3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

distanceTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Curve3d)arg1, (float)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d evalPoint(class PyGeCurve3d {lvalue},double)

evalPoint( (Curve3d)arg1, (float)arg2, (CmdFlags)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple evalPoint(class PyGeCurve3d {lvalue},double,int)'''
    ...
    def explode (self, *args, **kwargs):
      '''
explode( (Curve3d)arg1) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve3d {lvalue})

explode( (Curve3d)arg1, (Interval)arg2) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def getClosestPointTo (self, *args, **kwargs):
      '''
getClosestPointTo( (Curve3d)arg1, (Point3d)arg2) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

getClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def getClosestPointsTo (self, *args, **kwargs):
      '''
getClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

getClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def getEndPoint (self, *args, **kwargs):
      '''
getEndPoint( (Curve3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getEndPoint(class PyGeCurve3d {lvalue})'''
    ...
    def getInterval (self, *args, **kwargs):
      '''
getInterval( (Curve3d)arg1) -> Interval :

    C++ signature :
        class PyGeInterval getInterval(class PyGeCurve3d {lvalue})'''
    ...
    def getLine (self, *args, **kwargs):
      '''
getLine( (LinearEnt3d)arg1) -> Line3d :

    C++ signature :
        class PyGeLine3d getLine(class PyGeLinearEnt3d {lvalue})'''
    ...
    def getNormalPoint (self, *args, **kwargs):
      '''
getNormalPoint( (Curve3d)arg1, (Point3d)arg2) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getNormalPoint(class PyGeCurve3d {lvalue},class AcGePoint3d)

getNormalPoint( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getNormalPoint(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def getPerpPlane (self, *args, **kwargs):
      '''
getPerpPlane( (LinearEnt3d)arg1, (Point3d)arg2) -> Plane :

    C++ signature :
        class PyGePlane getPerpPlane(class PyGeLinearEnt3d {lvalue},class AcGePoint3d)'''
    ...
    def getProjClosestPointTo (self, *args, **kwargs):
      '''
getProjClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getProjClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d)

getProjClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Tol)arg4) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getProjClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def getProjClosestPointsTo (self, *args, **kwargs):
      '''
getProjClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getProjClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d)

getProjClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple getProjClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def getSamplePoints (self, *args, **kwargs):
      '''
getSamplePoints( (Curve3d)arg1, (CmdFlags)arg2) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve3d {lvalue},int)

getSamplePoints( (Curve3d)arg1, (float)arg2, (float)arg3, (float)arg4) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve3d {lvalue},double,double,double)'''
    ...
    def getSplitCurves (self, *args, **kwargs):
      '''
getSplitCurves( (Curve3d)arg1, (float)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getSplitCurves(class PyGeCurve3d {lvalue},double)'''
    ...
    def getStartPoint (self, *args, **kwargs):
      '''
getStartPoint( (Curve3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getStartPoint(class PyGeCurve3d {lvalue})'''
    ...
    def getTrimmedOffset (self, *args, **kwargs):
      '''
getTrimmedOffset( (Curve3d)arg1, (float)arg2, (Vector3d)arg3, (OffsetCrvExtType)arg4) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve3d {lvalue},double,class AcGeVector3d,enum AcGe::OffsetCrvExtType)

getTrimmedOffset( (Curve3d)arg1, (float)arg2, (Vector3d)arg3, (OffsetCrvExtType)arg4, (Tol)arg5) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve3d {lvalue},double,class AcGeVector3d,enum AcGe::OffsetCrvExtType,class AcGeTol)'''
    ...
    def hasEndPoint (self, *args, **kwargs):
      '''
hasEndPoint( (Curve3d)arg1) -> bool :

    C++ signature :
        bool hasEndPoint(class PyGeCurve3d {lvalue})'''
    ...
    def hasStartPoint (self, *args, **kwargs):
      '''
hasStartPoint( (Curve3d)arg1) -> bool :

    C++ signature :
        bool hasStartPoint(class PyGeCurve3d {lvalue})'''
    ...
    def intersectWith (self, *args, **kwargs):
      '''
intersectWith( (LinearEnt3d)arg1, (LinearEnt3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d)

intersectWith( (LinearEnt3d)arg1, (LinearEnt3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d,class AcGeTol)

intersectWith( (LinearEnt3d)arg1, (PlanarEnt)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeLinearEnt3d {lvalue},class PyGePlanarEnt)

intersectWith( (LinearEnt3d)arg1, (PlanarEnt)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeLinearEnt3d {lvalue},class PyGePlanarEnt,class AcGeTol)'''
    ...
    def isClosed (self, *args, **kwargs):
      '''
isClosed( (Curve3d)arg1) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve3d {lvalue})

isClosed( (Curve3d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isColinearTo (self, *args, **kwargs):
      '''
isColinearTo( (LinearEnt3d)arg1, (LinearEnt3d)arg2) -> bool :

    C++ signature :
        bool isColinearTo(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d)

isColinearTo( (LinearEnt3d)arg1, (LinearEnt3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isColinearTo(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d,class AcGeTol)'''
    ...
    def isCoplanarWith (self, *args, **kwargs):
      '''
isCoplanarWith( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isCoplanarWith(class PyGeCurve3d {lvalue},class PyGeCurve3d)

isCoplanarWith( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple isCoplanarWith(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def isDegenerate (self, *args, **kwargs):
      '''
isDegenerate( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve3d {lvalue})

isDegenerate( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity3d)arg1, (Entity3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity3d {lvalue},class PyGeEntity3d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity3d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity3d {lvalue},enum AcGe::EntityId)'''
    ...
    def isLinear (self, *args, **kwargs):
      '''
isLinear( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve3d {lvalue})

isLinear( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity3d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity3d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (LinearEnt3d)arg1, (Point3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isOn(class PyGeLinearEnt3d {lvalue},class AcGePoint3d)

isOn( (LinearEnt3d)arg1, (Point3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple isOn(class PyGeLinearEnt3d {lvalue},class AcGePoint3d,class AcGeTol)

isOn( (LinearEnt3d)arg1, (float)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeLinearEnt3d {lvalue},double)

isOn( (LinearEnt3d)arg1, (float)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeLinearEnt3d {lvalue},double,class AcGeTol)

isOn( (LinearEnt3d)arg1, (Plane)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeLinearEnt3d {lvalue},class PyGePlane)

isOn( (LinearEnt3d)arg1, (Plane)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeLinearEnt3d {lvalue},class PyGePlane,class AcGeTol)'''
    ...
    def isParallelTo (self, *args, **kwargs):
      '''
isParallelTo( (LinearEnt3d)arg1, (LinearEnt3d)arg2) -> bool :

    C++ signature :
        bool isParallelTo(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d)

isParallelTo( (LinearEnt3d)arg1, (LinearEnt3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isParallelTo(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d,class AcGeTol)

isParallelTo( (LinearEnt3d)arg1, (PlanarEnt)arg2) -> bool :

    C++ signature :
        bool isParallelTo(class PyGeLinearEnt3d {lvalue},class PyGePlanarEnt)

isParallelTo( (LinearEnt3d)arg1, (PlanarEnt)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isParallelTo(class PyGeLinearEnt3d {lvalue},class PyGePlanarEnt,class AcGeTol)'''
    ...
    def isPeriodic (self, *args, **kwargs):
      '''
isPeriodic( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPeriodic(class PyGeCurve3d {lvalue})'''
    ...
    def isPerpendicularTo (self, *args, **kwargs):
      '''
isPerpendicularTo( (LinearEnt3d)arg1, (LinearEnt3d)arg2) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d)

isPerpendicularTo( (LinearEnt3d)arg1, (LinearEnt3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d,class AcGeTol)

isPerpendicularTo( (LinearEnt3d)arg1, (PlanarEnt)arg2) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGeLinearEnt3d {lvalue},class PyGePlanarEnt)

isPerpendicularTo( (LinearEnt3d)arg1, (PlanarEnt)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGeLinearEnt3d {lvalue},class PyGePlanarEnt,class AcGeTol)'''
    ...
    def isPlanar (self, *args, **kwargs):
      '''
isPlanar( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPlanar(class PyGeCurve3d {lvalue})

isPlanar( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isPlanar(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double length(class PyGeCurve3d {lvalue},double,double)

length( (Curve3d)arg1, (float)arg2, (float)arg3, (float)arg4) -> float :

    C++ signature :
        double length(class PyGeCurve3d {lvalue},double,double,double)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} mirror(class PyGeEntity3d {lvalue},class PyGePlane)'''
    ...
    def orthoBoundBlock (self, *args, **kwargs):
      '''
orthoBoundBlock( (Curve3d)arg1) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d orthoBoundBlock(class PyGeCurve3d {lvalue})

orthoBoundBlock( (Curve3d)arg1, (Interval)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d orthoBoundBlock(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def orthoProject (self, *args, **kwargs):
      '''
orthoProject( (Curve3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d orthoProject(class PyGeCurve3d {lvalue},class PyGePlane)

orthoProject( (Curve3d)arg1, (Plane)arg2, (Tol)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d orthoProject(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeTol)'''
    ...
    def overlap (self, *args, **kwargs):
      '''
overlap( (LinearEnt3d)arg1, (LinearEnt3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple overlap(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d)

overlap( (LinearEnt3d)arg1, (LinearEnt3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple overlap(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d,class AcGeTol)'''
    ...
    def paramAtLength (self, *args, **kwargs):
      '''
paramAtLength( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve3d {lvalue},double,double)

paramAtLength( (Curve3d)arg1, (float)arg2, (float)arg3, (bool)arg4, (float)arg5) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve3d {lvalue},double,double,bool,double)'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Curve3d)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double paramOf(class PyGeCurve3d {lvalue},class AcGePoint3d)

paramOf( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double paramOf(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def pointOnLine (self, *args, **kwargs):
      '''
pointOnLine( (LinearEnt3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d pointOnLine(class PyGeLinearEnt3d {lvalue})'''
    ...
    def projClosestPointTo (self, *args, **kwargs):
      '''
projClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d projClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d)

projClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Tol)arg4) -> Point3d :

    C++ signature :
        class AcGePoint3d projClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def projClosestPointsTo (self, *args, **kwargs):
      '''
projClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple projClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d)

projClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple projClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def projIntersectWith (self, *args, **kwargs):
      '''
projIntersectWith( (LinearEnt3d)arg1, (LinearEnt3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple projIntersectWith(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d,class AcGeVector3d)

projIntersectWith( (LinearEnt3d)arg1, (LinearEnt3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple projIntersectWith(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def project (self, *args, **kwargs):
      '''
project( (Curve3d)arg1, (Plane)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d project(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeVector3d)

project( (Curve3d)arg1, (Plane)arg2, (Vector3d)arg3, (Tol)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d project(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeVector3d,class AcGeTol)'''
    ...
    def reverseParam (self, *args, **kwargs):
      '''
reverseParam( (Curve3d)arg1) -> Curve3d :

    C++ signature :
        class PyGeCurve3d {lvalue} reverseParam(class PyGeCurve3d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d)

rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3, (Point3d)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d,class AcGePoint3d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity3d)arg1, (float)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double)

scaleBy( (Entity3d)arg1, (float)arg2, (Point3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double,class AcGePoint3d)'''
    ...
    def setInterval (self, *args, **kwargs):
      '''
setInterval( (Curve3d)arg1) -> Curve3d :

    C++ signature :
        class PyGeCurve3d {lvalue} setInterval(class PyGeCurve3d {lvalue})

setInterval( (Curve3d)arg1, (Interval)arg2) -> bool :

    C++ signature :
        bool setInterval(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity3d)arg1, (Matrix3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} transformBy(class PyGeEntity3d {lvalue},class AcGeMatrix3d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity3d)arg1, (Vector3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} translateBy(class PyGeEntity3d {lvalue},class AcGeVector3d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity3d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity3d {lvalue})'''
    ...

class Matrix2d:
    def alignCoordSys (self, *args, **kwargs):
      '''
alignCoordSys( (Point2d)arg1, (Vector2d)arg2, (Vector2d)arg3, (Point2d)arg4, (Vector2d)arg5, (Vector2d)arg6) -> Matrix2d :

    C++ signature :
        class AcGeMatrix2d alignCoordSys(class AcGePoint2d,class AcGeVector2d,class AcGeVector2d,class AcGePoint2d,class AcGeVector2d,class AcGeVector2d)'''
    ...
    def det (self, *args, **kwargs):
      '''
det( (Matrix2d)arg1) -> float :

    C++ signature :
        double det(class AcGeMatrix2d {lvalue})'''
    ...
    def elementAt (self, *args, **kwargs):
      '''
elementAt( (Matrix2d)arg1, (int)arg2, (int)arg3) -> float :

    C++ signature :
        double elementAt(class AcGeMatrix2d {lvalue},unsigned int,unsigned int)'''
    ...
    def getCoordSystem (self, *args, **kwargs):
      '''
getCoordSystem( (Matrix2d)arg1, (Point2d)arg2, (Vector2d)arg3, (Vector2d)arg4) -> None :

    C++ signature :
        void getCoordSystem(class AcGeMatrix2d {lvalue},class AcGePoint2d {lvalue},class AcGeVector2d {lvalue},class AcGeVector2d {lvalue})'''
    ...
    def inverse (self, *args, **kwargs):
      '''
inverse( (Matrix2d)arg1) -> Matrix2d :

    C++ signature :
        class AcGeMatrix2d inverse(class AcGeMatrix2d {lvalue})'''
    ...
    def invert (self, *args, **kwargs):
      '''
invert( (Matrix2d)arg1) -> Matrix2d :

    C++ signature :
        class AcGeMatrix2d {lvalue} invert(class AcGeMatrix2d {lvalue})'''
    ...
    def isConformal (self, *args, **kwargs):
      '''
isConformal( (Matrix2d)arg1, (float)arg2, (float)arg3, (bool)arg4, (Vector2d)arg5) -> bool :

    C++ signature :
        bool isConformal(class AcGeMatrix2d {lvalue},double {lvalue},double {lvalue},bool {lvalue},class AcGeVector2d {lvalue})'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Matrix2d)arg1, (Matrix2d)arg2 [, (Tol)AcGeTol=<PyGe.Tol object at 0x000001F037793760>]) -> bool :

    C++ signature :
        bool isEqualTo(class AcGeMatrix2d {lvalue},class AcGeMatrix2d [,class AcGeTol=<PyGe.Tol object at 0x000001F037793760>])'''
    ...
    def isScaledOrtho (self, *args, **kwargs):
      '''
isScaledOrtho( (Matrix2d)arg1 [, (Tol)AcGeTol=<PyGe.Tol object at 0x000001F037793880>]) -> bool :

    C++ signature :
        bool isScaledOrtho(class AcGeMatrix2d {lvalue} [,class AcGeTol=<PyGe.Tol object at 0x000001F037793880>])'''
    ...
    def isSingular (self, *args, **kwargs):
      '''
isSingular( (Matrix2d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isSingular(class AcGeMatrix2d {lvalue},class AcGeTol)'''
    ...
    def isUniScaledOrtho (self, *args, **kwargs):
      '''
isUniScaledOrtho( (Matrix2d)arg1 [, (Tol)AcGeTol=<PyGe.Tol object at 0x000001F0377937F0>]) -> bool :

    C++ signature :
        bool isUniScaledOrtho(class AcGeMatrix2d {lvalue} [,class AcGeTol=<PyGe.Tol object at 0x000001F0377937F0>])'''
    ...
    def kIdentity (self, *args, **kwargs):
      '''None'''
    ...
    def mirroring (self, *args, **kwargs):
      '''
mirroring( (Point2d)arg1) -> Matrix2d :

    C++ signature :
        class AcGeMatrix2d mirroring(class AcGePoint2d)

mirroring( (object)arg1) -> Matrix2d :

    C++ signature :
        class AcGeMatrix2d mirroring(class AcGeLine2d)'''
    ...
    def postMultBy (self, *args, **kwargs):
      '''
postMultBy( (Matrix2d)arg1, (Matrix2d)arg2) -> Matrix2d :

    C++ signature :
        class AcGeMatrix2d {lvalue} postMultBy(class AcGeMatrix2d {lvalue},class AcGeMatrix2d)'''
    ...
    def preMultBy (self, *args, **kwargs):
      '''
preMultBy( (Matrix2d)arg1, (Matrix2d)arg2) -> Matrix2d :

    C++ signature :
        class AcGeMatrix2d {lvalue} preMultBy(class AcGeMatrix2d {lvalue},class AcGeMatrix2d)'''
    ...
    def rotation (self, *args, **kwargs):
      '''
rotation( (float)arg1, (Point2d)arg2) -> Matrix2d :

    C++ signature :
        class AcGeMatrix2d rotation(double,class AcGePoint2d)'''
    ...
    def scale (self, *args, **kwargs):
      '''
scale( (Matrix2d)arg1) -> float :

    C++ signature :
        double scale(class AcGeMatrix2d {lvalue})'''
    ...
    def scaling (self, *args, **kwargs):
      '''staticmethod(function) -> method

Convert a function to be a static method.

A static method does not receive an implicit first argument.
To declare a static method, use this idiom:

     class C:
         @staticmethod
         def f(arg1, arg2, ...):
             ...

It can be called either on the class (e.g. C.f()) or on an instance
(e.g. C().f()). Both the class and the instance are ignored, and
neither is passed implicitly as the first argument to the method.

Static methods in Python are similar to those found in Java or C++.
For a more advanced concept, see the classmethod builtin.'''
    ...
    def setCoordSystem (self, *args, **kwargs):
      '''
setCoordSystem( (Matrix2d)arg1, (Point2d)arg2, (Vector2d)arg3, (Vector2d)arg4) -> Matrix2d :

    C++ signature :
        class AcGeMatrix2d {lvalue} setCoordSystem(class AcGeMatrix2d {lvalue},class AcGePoint2d,class AcGeVector2d,class AcGeVector2d)'''
    ...
    def setToAlignCoordSys (self, *args, **kwargs):
      '''
setToAlignCoordSys( (Matrix2d)arg1, (Point2d)arg2, (Vector2d)arg3, (Vector2d)arg4, (Point2d)arg5, (Vector2d)arg6, (Vector2d)arg7) -> Matrix2d :

    C++ signature :
        class AcGeMatrix2d {lvalue} setToAlignCoordSys(class AcGeMatrix2d {lvalue},class AcGePoint2d,class AcGeVector2d,class AcGeVector2d,class AcGePoint2d,class AcGeVector2d,class AcGeVector2d)'''
    ...
    def setToIdentity (self, *args, **kwargs):
      '''
setToIdentity( (Matrix2d)arg1) -> Matrix2d :

    C++ signature :
        class AcGeMatrix2d {lvalue} setToIdentity(class AcGeMatrix2d {lvalue})'''
    ...
    def setToMirroring (self, *args, **kwargs):
      '''
setToMirroring( (Matrix2d)arg1, (Point2d)arg2) -> Matrix2d :

    C++ signature :
        class AcGeMatrix2d {lvalue} setToMirroring(class AcGeMatrix2d {lvalue},class AcGePoint2d)

setToMirroring( (Matrix2d)arg1, (object)arg2) -> Matrix2d :

    C++ signature :
        class AcGeMatrix2d {lvalue} setToMirroring(class AcGeMatrix2d {lvalue},class AcGeLine2d)'''
    ...
    def setToProduct (self, *args, **kwargs):
      '''
setToProduct( (Matrix2d)arg1, (Matrix2d)arg2, (Matrix2d)arg3) -> Matrix2d :

    C++ signature :
        class AcGeMatrix2d {lvalue} setToProduct(class AcGeMatrix2d {lvalue},class AcGeMatrix2d,class AcGeMatrix2d)'''
    ...
    def setToRotation (self, *args, **kwargs):
      '''
setToRotation( (Matrix2d)arg1, (float)arg2 [, (Point2d)AcGePoint2d=<PyGe.Point2d object at 0x000001F0377321F0>]) -> Matrix2d :

    C++ signature :
        class AcGeMatrix2d {lvalue} setToRotation(class AcGeMatrix2d {lvalue},double [,class AcGePoint2d=<PyGe.Point2d object at 0x000001F0377321F0>])'''
    ...
    def setToScaling (self, *args, **kwargs):
      '''
setToScaling( (Matrix2d)arg1, (float)arg2, (Point2d)arg3) -> Matrix2d :

    C++ signature :
        class AcGeMatrix2d {lvalue} setToScaling(class AcGeMatrix2d {lvalue},double,class AcGePoint2d)'''
    ...
    def setToTranslation (self, *args, **kwargs):
      '''
setToTranslation( (Matrix2d)arg1, (Vector2d)arg2) -> Matrix2d :

    C++ signature :
        class AcGeMatrix2d {lvalue} setToTranslation(class AcGeMatrix2d {lvalue},class AcGeVector2d)'''
    ...
    def setTranslation (self, *args, **kwargs):
      '''
setTranslation( (Matrix2d)arg1, (Vector2d)arg2) -> Matrix2d :

    C++ signature :
        class AcGeMatrix2d {lvalue} setTranslation(class AcGeMatrix2d {lvalue},class AcGeVector2d)'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (Matrix2d)arg1) -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > toString(class AcGeMatrix2d)'''
    ...
    def translation (self, *args, **kwargs):
      '''
translation( (Matrix2d)arg1) -> Vector2d :

    C++ signature :
        class AcGeVector2d translation(class AcGeMatrix2d {lvalue})

translation( (Vector2d)arg1) -> Matrix2d :

    C++ signature :
        class AcGeMatrix2d translation(class AcGeVector2d)'''
    ...
    def transpose (self, *args, **kwargs):
      '''
transpose( (Matrix2d)arg1) -> Matrix2d :

    C++ signature :
        class AcGeMatrix2d transpose(class AcGeMatrix2d {lvalue})'''
    ...
    def transposeIt (self, *args, **kwargs):
      '''
transposeIt( (Matrix2d)arg1) -> Matrix2d :

    C++ signature :
        class AcGeMatrix2d {lvalue} transposeIt(class AcGeMatrix2d {lvalue})'''
    ...

class Matrix3d:
    def alignCoordSys (self, *args, **kwargs):
      '''
alignCoordSys( (Point3d)arg1, (Vector3d)arg2, (Vector3d)arg3, (Vector3d)arg4, (Point3d)arg5, (Vector3d)arg6, (Vector3d)arg7, (Vector3d)arg8) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d alignCoordSys(class AcGePoint3d,class AcGeVector3d,class AcGeVector3d,class AcGeVector3d,class AcGePoint3d,class AcGeVector3d,class AcGeVector3d,class AcGeVector3d)'''
    ...
    def convertToLocal (self, *args, **kwargs):
      '''
convertToLocal( (Matrix3d)arg1, (Vector3d)arg2, (float)arg3) -> Matrix2d :

    C++ signature :
        class AcGeMatrix2d convertToLocal(class AcGeMatrix3d {lvalue},class AcGeVector3d {lvalue},double {lvalue})'''
    ...
    def det (self, *args, **kwargs):
      '''
det( (Matrix3d)arg1) -> float :

    C++ signature :
        double det(class AcGeMatrix3d {lvalue})'''
    ...
    def elementAt (self, *args, **kwargs):
      '''
elementAt( (Matrix3d)arg1, (int)arg2, (int)arg3) -> float :

    C++ signature :
        double elementAt(class AcGeMatrix3d {lvalue},unsigned int,unsigned int)'''
    ...
    def getCoordSystem (self, *args, **kwargs):
      '''
getCoordSystem( (Matrix3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Vector3d)arg4, (Vector3d)arg5) -> None :

    C++ signature :
        void getCoordSystem(class AcGeMatrix3d {lvalue},class AcGePoint3d {lvalue},class AcGeVector3d {lvalue},class AcGeVector3d {lvalue},class AcGeVector3d {lvalue})'''
    ...
    def inverse (self, *args, **kwargs):
      '''
inverse( (Matrix3d)arg1) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d inverse(class AcGeMatrix3d {lvalue})

inverse( (Matrix3d)arg1, (Tol)arg2) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d inverse(class AcGeMatrix3d {lvalue},class AcGeTol)

inverse( (Matrix3d)arg1, (Matrix3d)arg2, (float)arg3) -> bool :

    C++ signature :
        bool inverse(class AcGeMatrix3d {lvalue},class AcGeMatrix3d {lvalue},double)'''
    ...
    def invert (self, *args, **kwargs):
      '''
invert( (Matrix3d)arg1) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d {lvalue} invert(class AcGeMatrix3d {lvalue})'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Matrix3d)arg1, (Matrix3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class AcGeMatrix3d {lvalue},class AcGeMatrix3d,class AcGeTol)'''
    ...
    def isScaledOrtho (self, *args, **kwargs):
      '''
isScaledOrtho( (Matrix3d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isScaledOrtho(class AcGeMatrix3d {lvalue},class AcGeTol)'''
    ...
    def isSingular (self, *args, **kwargs):
      '''
isSingular( (Matrix3d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isSingular(class AcGeMatrix3d {lvalue},class AcGeTol)'''
    ...
    def isUniScaledOrtho (self, *args, **kwargs):
      '''
isUniScaledOrtho( (Matrix3d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isUniScaledOrtho(class AcGeMatrix3d {lvalue},class AcGeTol)'''
    ...
    def kIdentity (self, *args, **kwargs):
      '''None'''
    ...
    def mirroring (self, *args, **kwargs):
      '''
mirroring( (object)arg1) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d mirroring(class AcGePlane)

mirroring( (Point3d)arg1) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d mirroring(class AcGePoint3d)

mirroring( (object)arg1) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d mirroring(class AcGeLine3d)'''
    ...
    def norm (self, *args, **kwargs):
      '''
norm( (Matrix3d)arg1) -> float :

    C++ signature :
        double norm(class AcGeMatrix3d {lvalue})'''
    ...
    def planeToWorld (self, *args, **kwargs):
      '''
planeToWorld( (Vector3d)arg1) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d planeToWorld(class AcGeVector3d)

planeToWorld( (object)arg1) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d planeToWorld(class AcGePlane)'''
    ...
    def postMultBy (self, *args, **kwargs):
      '''
postMultBy( (Matrix3d)arg1, (Matrix3d)arg2) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d {lvalue} postMultBy(class AcGeMatrix3d {lvalue},class AcGeMatrix3d)'''
    ...
    def preMultBy (self, *args, **kwargs):
      '''
preMultBy( (Matrix3d)arg1, (Matrix3d)arg2) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d {lvalue} preMultBy(class AcGeMatrix3d {lvalue},class AcGeMatrix3d)'''
    ...
    def projection (self, *args, **kwargs):
      '''
projection( (object)arg1, (Vector3d)arg2) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d projection(class AcGePlane,class AcGeVector3d)'''
    ...
    def rotation (self, *args, **kwargs):
      '''
rotation( (float)arg1, (Vector3d)arg2, (Point3d)arg3) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d rotation(double,class AcGeVector3d,class AcGePoint3d)'''
    ...
    def scale (self, *args, **kwargs):
      '''
scale( (Matrix3d)arg1) -> float :

    C++ signature :
        double scale(class AcGeMatrix3d {lvalue})'''
    ...
    def scaling (self, *args, **kwargs):
      '''
scaling( (float)arg1, (Point3d)arg2) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d scaling(double,class AcGePoint3d)'''
    ...
    def setCoordSystem (self, *args, **kwargs):
      '''
setCoordSystem( (Matrix3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Vector3d)arg4, (Vector3d)arg5) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d {lvalue} setCoordSystem(class AcGeMatrix3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeVector3d,class AcGeVector3d)'''
    ...
    def setToAlignCoordSys (self, *args, **kwargs):
      '''
setToAlignCoordSys( (Matrix3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Vector3d)arg4, (Vector3d)arg5, (Point3d)arg6, (Vector3d)arg7, (Vector3d)arg8, (Vector3d)arg9) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d {lvalue} setToAlignCoordSys(class AcGeMatrix3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeVector3d,class AcGeVector3d,class AcGePoint3d,class AcGeVector3d,class AcGeVector3d,class AcGeVector3d)'''
    ...
    def setToIdentity (self, *args, **kwargs):
      '''
setToIdentity( (Matrix3d)arg1) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d {lvalue} setToIdentity(class AcGeMatrix3d {lvalue})'''
    ...
    def setToMirroring (self, *args, **kwargs):
      '''
setToMirroring( (Matrix3d)arg1, (object)arg2) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d {lvalue} setToMirroring(class AcGeMatrix3d {lvalue},class AcGePlane)

setToMirroring( (Matrix3d)arg1, (object)arg2) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d {lvalue} setToMirroring(class AcGeMatrix3d {lvalue},class AcGeLine3d)

setToMirroring( (Matrix3d)arg1, (Point3d)arg2) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d {lvalue} setToMirroring(class AcGeMatrix3d {lvalue},class AcGePoint3d)'''
    ...
    def setToPlaneToWorld (self, *args, **kwargs):
      '''
setToPlaneToWorld( (Matrix3d)arg1, (object)arg2) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d {lvalue} setToPlaneToWorld(class AcGeMatrix3d {lvalue},class AcGePlane)

setToPlaneToWorld( (Matrix3d)arg1, (Vector3d)arg2) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d {lvalue} setToPlaneToWorld(class AcGeMatrix3d {lvalue},class AcGeVector3d)'''
    ...
    def setToProduct (self, *args, **kwargs):
      '''
setToProduct( (Matrix3d)arg1, (Matrix3d)arg2, (Matrix3d)arg3) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d {lvalue} setToProduct(class AcGeMatrix3d {lvalue},class AcGeMatrix3d,class AcGeMatrix3d)'''
    ...
    def setToProjection (self, *args, **kwargs):
      '''
setToProjection( (Matrix3d)arg1, (object)arg2, (Vector3d)arg3) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d {lvalue} setToProjection(class AcGeMatrix3d {lvalue},class AcGePlane,class AcGeVector3d)'''
    ...
    def setToRotation (self, *args, **kwargs):
      '''
setToRotation( (Matrix3d)arg1, (float)arg2, (Vector3d)arg3, (Point3d)arg4) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d {lvalue} setToRotation(class AcGeMatrix3d {lvalue},double,class AcGeVector3d,class AcGePoint3d)'''
    ...
    def setToScaling (self, *args, **kwargs):
      '''
setToScaling( (Matrix3d)arg1, (float)arg2, (Point3d)arg3) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d {lvalue} setToScaling(class AcGeMatrix3d {lvalue},double,class AcGePoint3d)'''
    ...
    def setToTranslation (self, *args, **kwargs):
      '''
setToTranslation( (Matrix3d)arg1, (Vector3d)arg2) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d {lvalue} setToTranslation(class AcGeMatrix3d {lvalue},class AcGeVector3d)'''
    ...
    def setToWorldToPlane (self, *args, **kwargs):
      '''
setToWorldToPlane( (Matrix3d)arg1, (object)arg2) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d {lvalue} setToWorldToPlane(class AcGeMatrix3d {lvalue},class AcGePlane)

setToWorldToPlane( (Matrix3d)arg1, (Vector3d)arg2) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d {lvalue} setToWorldToPlane(class AcGeMatrix3d {lvalue},class AcGeVector3d)'''
    ...
    def setTranslation (self, *args, **kwargs):
      '''
setTranslation( (Matrix3d)arg1, (Vector3d)arg2) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d {lvalue} setTranslation(class AcGeMatrix3d {lvalue},class AcGeVector3d)'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (Matrix3d)arg1) -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > toString(class AcGeMatrix3d)'''
    ...
    def translation (self, *args, **kwargs):
      '''
translation( (Matrix3d)arg1) -> Vector3d :

    C++ signature :
        class AcGeVector3d translation(class AcGeMatrix3d {lvalue})

translation( (Vector3d)arg1) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d translation(class AcGeVector3d)'''
    ...
    def transpose (self, *args, **kwargs):
      '''
transpose( (Matrix3d)arg1) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d transpose(class AcGeMatrix3d {lvalue})'''
    ...
    def transposeIt (self, *args, **kwargs):
      '''
transposeIt( (Matrix3d)arg1) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d {lvalue} transposeIt(class AcGeMatrix3d {lvalue})'''
    ...
    def worldToPlane (self, *args, **kwargs):
      '''
worldToPlane( (Vector3d)arg1) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d worldToPlane(class AcGeVector3d)

worldToPlane( (object)arg1) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d worldToPlane(class AcGePlane)'''
    ...

class NurbCurve2d:
    def area (self, *args, **kwargs):
      '''
area( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double area(class PyGeCurve2d {lvalue},double,double)

area( (Curve2d)arg1, (float)arg2, (float)arg3, (Tol)arg4) -> float :

    C++ signature :
        double area(class PyGeCurve2d {lvalue},double,double,class AcGeTol)'''
    ...
    def boundBlock (self, *args, **kwargs):
      '''
boundBlock( (Curve2d)arg1) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d boundBlock(class PyGeCurve2d {lvalue})

boundBlock( (Curve2d)arg1, (Interval)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d boundBlock(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Curve2d)arg1, (Point2d)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d closestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

closestPointTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> Point2d :

    C++ signature :
        class AcGePoint2d closestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

closestPointTo( (Curve2d)arg1, (Curve2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

closestPointTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def continuityAtKnot (self, *args, **kwargs):
      '''
continuityAtKnot( (SplineEnt2d)arg1, (CmdFlags)arg2) -> int :

    C++ signature :
        int continuityAtKnot(class PyGeSplineEnt2d {lvalue},int)

continuityAtKnot( (SplineEnt2d)arg1, (CmdFlags)arg2, (Tol)arg3) -> int :

    C++ signature :
        int continuityAtKnot(class PyGeSplineEnt2d {lvalue},int,class AcGeTol)'''
    ...
    def controlPointAt (self, *args, **kwargs):
      '''
controlPointAt( (SplineEnt2d)arg1, (CmdFlags)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d controlPointAt(class PyGeSplineEnt2d {lvalue},int)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity2d)arg1) -> Entity2d :

    C++ signature :
        class PyGeEntity2d copy(class PyGeEntity2d {lvalue})'''
    ...
    def degree (self, *args, **kwargs):
      '''
degree( (SplineEnt2d)arg1) -> int :

    C++ signature :
        int degree(class PyGeSplineEnt2d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Curve2d)arg1, (Point2d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

distanceTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

distanceTo( (Curve2d)arg1, (Curve2d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

distanceTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def endParam (self, *args, **kwargs):
      '''
endParam( (SplineEnt2d)arg1) -> float :

    C++ signature :
        double endParam(class PyGeSplineEnt2d {lvalue})'''
    ...
    def endPoint (self, *args, **kwargs):
      '''
endPoint( (SplineEnt2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d endPoint(class PyGeSplineEnt2d {lvalue})'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Curve2d)arg1, (float)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d evalPoint(class PyGeCurve2d {lvalue},double)

evalPoint( (Curve2d)arg1, (float)arg2, (CmdFlags)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple evalPoint(class PyGeCurve2d {lvalue},double,int)'''
    ...
    def explode (self, *args, **kwargs):
      '''
explode( (Curve2d)arg1) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve2d {lvalue})

explode( (Curve2d)arg1, (Interval)arg2) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def getClosestPointTo (self, *args, **kwargs):
      '''
getClosestPointTo( (Curve2d)arg1, (Point2d)arg2) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getClosestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

getClosestPointTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getClosestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def getClosestPointsTo (self, *args, **kwargs):
      '''
getClosestPointsTo( (Curve2d)arg1, (Curve2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

getClosestPointsTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def getEndPoint (self, *args, **kwargs):
      '''
getEndPoint( (Curve2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getEndPoint(class PyGeCurve2d {lvalue})'''
    ...
    def getInterval (self, *args, **kwargs):
      '''
getInterval( (Curve2d)arg1) -> Interval :

    C++ signature :
        class PyGeInterval getInterval(class PyGeCurve2d {lvalue})'''
    ...
    def getNormalPoint (self, *args, **kwargs):
      '''
getNormalPoint( (Curve2d)arg1, (Point2d)arg2) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getNormalPoint(class PyGeCurve2d {lvalue},class AcGePoint2d)

getNormalPoint( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getNormalPoint(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def getSamplePoints (self, *args, **kwargs):
      '''
getSamplePoints( (Curve2d)arg1, (CmdFlags)arg2) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve2d {lvalue},int)

getSamplePoints( (Curve2d)arg1, (float)arg2, (float)arg3, (float)arg4) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve2d {lvalue},double,double,double)'''
    ...
    def getSplitCurves (self, *args, **kwargs):
      '''
getSplitCurves( (Curve2d)arg1, (float)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getSplitCurves(class PyGeCurve2d {lvalue},double)'''
    ...
    def getStartPoint (self, *args, **kwargs):
      '''
getStartPoint( (Curve2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getStartPoint(class PyGeCurve2d {lvalue})'''
    ...
    def getTrimmedOffset (self, *args, **kwargs):
      '''
getTrimmedOffset( (Curve2d)arg1, (float)arg2, (OffsetCrvExtType)arg3) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve2d {lvalue},double,enum AcGe::OffsetCrvExtType)

getTrimmedOffset( (Curve2d)arg1, (float)arg2, (OffsetCrvExtType)arg3, (Tol)arg4) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve2d {lvalue},double,enum AcGe::OffsetCrvExtType,class AcGeTol)'''
    ...
    def hasEndPoint (self, *args, **kwargs):
      '''
hasEndPoint( (Curve2d)arg1) -> bool :

    C++ signature :
        bool hasEndPoint(class PyGeCurve2d {lvalue})'''
    ...
    def hasFitData (self, *args, **kwargs):
      '''
hasFitData( (SplineEnt2d)arg1) -> bool :

    C++ signature :
        bool hasFitData(class PyGeSplineEnt2d {lvalue})'''
    ...
    def hasStartPoint (self, *args, **kwargs):
      '''
hasStartPoint( (Curve2d)arg1) -> bool :

    C++ signature :
        bool hasStartPoint(class PyGeCurve2d {lvalue})'''
    ...
    def isClosed (self, *args, **kwargs):
      '''
isClosed( (Curve2d)arg1) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve2d {lvalue})

isClosed( (Curve2d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isDegenerate (self, *args, **kwargs):
      '''
isDegenerate( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve2d {lvalue})

isDegenerate( (Curve2d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity2d)arg1, (Entity2d)arg2) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d)

isEqualTo( (Entity2d)arg1, (Entity2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity2d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity2d {lvalue},enum AcGe::EntityId)'''
    ...
    def isLinear (self, *args, **kwargs):
      '''
isLinear( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve2d {lvalue})

isLinear( (Curve2d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity2d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity2d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Curve2d)arg1, (Point2d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d)

isOn( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

isOn( (Curve2d)arg1, (Point2d)arg2, (float)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,double {lvalue})

isOn( (Curve2d)arg1, (Point2d)arg2, (float)arg3, (Tol)arg4) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,double {lvalue},class AcGeTol)

isOn( (Curve2d)arg1, (float)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},double)

isOn( (Curve2d)arg1, (float)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},double,class AcGeTol)'''
    ...
    def isPeriodic (self, *args, **kwargs):
      '''
isPeriodic( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPeriodic(class PyGeCurve2d {lvalue})'''
    ...
    def isRational (self, *args, **kwargs):
      '''
isRational( (SplineEnt2d)arg1) -> bool :

    C++ signature :
        bool isRational(class PyGeSplineEnt2d {lvalue})'''
    ...
    def knotAt (self, *args, **kwargs):
      '''
knotAt( (SplineEnt2d)arg1, (CmdFlags)arg2) -> float :

    C++ signature :
        double knotAt(class PyGeSplineEnt2d {lvalue},int)'''
    ...
    def knots (self, *args, **kwargs):
      '''
knots( (SplineEnt2d)arg1) -> KnotVector :

    C++ signature :
        class PyGeKnotVector knots(class PyGeSplineEnt2d {lvalue})'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double length(class PyGeCurve2d {lvalue},double,double)

length( (Curve2d)arg1, (float)arg2, (float)arg3, (float)arg4) -> float :

    C++ signature :
        double length(class PyGeCurve2d {lvalue},double,double,double)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity2d)arg1, (Line2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} mirror(class PyGeEntity2d {lvalue},class PyGeLine2d)'''
    ...
    def numControlPoints (self, *args, **kwargs):
      '''
numControlPoints( (SplineEnt2d)arg1) -> int :

    C++ signature :
        int numControlPoints(class PyGeSplineEnt2d {lvalue})'''
    ...
    def numKnots (self, *args, **kwargs):
      '''
numKnots( (SplineEnt2d)arg1) -> int :

    C++ signature :
        int numKnots(class PyGeSplineEnt2d {lvalue})'''
    ...
    def order (self, *args, **kwargs):
      '''
order( (SplineEnt2d)arg1) -> int :

    C++ signature :
        int order(class PyGeSplineEnt2d {lvalue})'''
    ...
    def orthoBoundBlock (self, *args, **kwargs):
      '''
orthoBoundBlock( (Curve2d)arg1) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d orthoBoundBlock(class PyGeCurve2d {lvalue})

orthoBoundBlock( (Curve2d)arg1, (Interval)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d orthoBoundBlock(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def paramAtLength (self, *args, **kwargs):
      '''
paramAtLength( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve2d {lvalue},double,double)

paramAtLength( (Curve2d)arg1, (float)arg2, (float)arg3, (bool)arg4, (float)arg5) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve2d {lvalue},double,double,bool,double)'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Curve2d)arg1, (Point2d)arg2) -> float :

    C++ signature :
        double paramOf(class PyGeCurve2d {lvalue},class AcGePoint2d)

paramOf( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double paramOf(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def reverseParam (self, *args, **kwargs):
      '''
reverseParam( (Curve2d)arg1) -> Curve2d :

    C++ signature :
        class PyGeCurve2d {lvalue} reverseParam(class PyGeCurve2d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double)

rotateBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double)

scaleBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def setControlPointAt (self, *args, **kwargs):
      '''
setControlPointAt( (SplineEnt2d)arg1, (CmdFlags)arg2, (Point2d)arg3) -> SplineEnt2d :

    C++ signature :
        class PyGeSplineEnt2d {lvalue} setControlPointAt(class PyGeSplineEnt2d {lvalue},int,class AcGePoint2d)'''
    ...
    def setInterval (self, *args, **kwargs):
      '''
setInterval( (Curve2d)arg1) -> Curve2d :

    C++ signature :
        class PyGeCurve2d {lvalue} setInterval(class PyGeCurve2d {lvalue})

setInterval( (Curve2d)arg1, (Interval)arg2) -> bool :

    C++ signature :
        bool setInterval(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def setKnotAt (self, *args, **kwargs):
      '''
setKnotAt( (SplineEnt2d)arg1, (CmdFlags)arg2, (float)arg3) -> SplineEnt2d :

    C++ signature :
        class PyGeSplineEnt2d {lvalue} setKnotAt(class PyGeSplineEnt2d {lvalue},int,double)'''
    ...
    def startParam (self, *args, **kwargs):
      '''
startParam( (SplineEnt2d)arg1) -> float :

    C++ signature :
        double startParam(class PyGeSplineEnt2d {lvalue})'''
    ...
    def startPoint (self, *args, **kwargs):
      '''
startPoint( (SplineEnt2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d startPoint(class PyGeSplineEnt2d {lvalue})'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity2d)arg1, (Matrix2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} transformBy(class PyGeEntity2d {lvalue},class AcGeMatrix2d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity2d)arg1, (Vector2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} translateBy(class PyGeEntity2d {lvalue},class AcGeVector2d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity2d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity2d {lvalue})'''
    ...

class NurbCurve3d:
    def area (self, *args, **kwargs):
      '''
area( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double area(class PyGeCurve3d {lvalue},double,double)

area( (Curve3d)arg1, (float)arg2, (float)arg3, (Tol)arg4) -> float :

    C++ signature :
        double area(class PyGeCurve3d {lvalue},double,double,class AcGeTol)'''
    ...
    def boundBlock (self, *args, **kwargs):
      '''
boundBlock( (Curve3d)arg1) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d boundBlock(class PyGeCurve3d {lvalue})

boundBlock( (Curve3d)arg1, (Interval)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d boundBlock(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Curve3d)arg1, (Point3d)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

closestPointTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

closestPointTo( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

closestPointTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def continuityAtKnot (self, *args, **kwargs):
      '''
continuityAtKnot( (SplineEnt3d)arg1, (CmdFlags)arg2) -> int :

    C++ signature :
        int continuityAtKnot(class PyGeSplineEnt3d {lvalue},int)

continuityAtKnot( (SplineEnt3d)arg1, (CmdFlags)arg2, (Tol)arg3) -> int :

    C++ signature :
        int continuityAtKnot(class PyGeSplineEnt3d {lvalue},int,class AcGeTol)'''
    ...
    def controlPointAt (self, *args, **kwargs):
      '''
controlPointAt( (SplineEnt3d)arg1, (CmdFlags)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d controlPointAt(class PyGeSplineEnt3d {lvalue},int)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity3d)arg1) -> Entity3d :

    C++ signature :
        class PyGeEntity3d copy(class PyGeEntity3d {lvalue})'''
    ...
    def degree (self, *args, **kwargs):
      '''
degree( (SplineEnt3d)arg1) -> int :

    C++ signature :
        int degree(class PyGeSplineEnt3d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Curve3d)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

distanceTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

distanceTo( (Curve3d)arg1, (Curve3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

distanceTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def endParam (self, *args, **kwargs):
      '''
endParam( (SplineEnt3d)arg1) -> float :

    C++ signature :
        double endParam(class PyGeSplineEnt3d {lvalue})'''
    ...
    def endPoint (self, *args, **kwargs):
      '''
endPoint( (SplineEnt3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d endPoint(class PyGeSplineEnt3d {lvalue})'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Curve3d)arg1, (float)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d evalPoint(class PyGeCurve3d {lvalue},double)

evalPoint( (Curve3d)arg1, (float)arg2, (CmdFlags)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple evalPoint(class PyGeCurve3d {lvalue},double,int)'''
    ...
    def explode (self, *args, **kwargs):
      '''
explode( (Curve3d)arg1) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve3d {lvalue})

explode( (Curve3d)arg1, (Interval)arg2) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def getClosestPointTo (self, *args, **kwargs):
      '''
getClosestPointTo( (Curve3d)arg1, (Point3d)arg2) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

getClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def getClosestPointsTo (self, *args, **kwargs):
      '''
getClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

getClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def getEndPoint (self, *args, **kwargs):
      '''
getEndPoint( (Curve3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getEndPoint(class PyGeCurve3d {lvalue})'''
    ...
    def getInterval (self, *args, **kwargs):
      '''
getInterval( (Curve3d)arg1) -> Interval :

    C++ signature :
        class PyGeInterval getInterval(class PyGeCurve3d {lvalue})'''
    ...
    def getNormalPoint (self, *args, **kwargs):
      '''
getNormalPoint( (Curve3d)arg1, (Point3d)arg2) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getNormalPoint(class PyGeCurve3d {lvalue},class AcGePoint3d)

getNormalPoint( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getNormalPoint(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def getProjClosestPointTo (self, *args, **kwargs):
      '''
getProjClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getProjClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d)

getProjClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Tol)arg4) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getProjClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def getProjClosestPointsTo (self, *args, **kwargs):
      '''
getProjClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getProjClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d)

getProjClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple getProjClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def getSamplePoints (self, *args, **kwargs):
      '''
getSamplePoints( (Curve3d)arg1, (CmdFlags)arg2) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve3d {lvalue},int)

getSamplePoints( (Curve3d)arg1, (float)arg2, (float)arg3, (float)arg4) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve3d {lvalue},double,double,double)'''
    ...
    def getSplitCurves (self, *args, **kwargs):
      '''
getSplitCurves( (Curve3d)arg1, (float)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getSplitCurves(class PyGeCurve3d {lvalue},double)'''
    ...
    def getStartPoint (self, *args, **kwargs):
      '''
getStartPoint( (Curve3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getStartPoint(class PyGeCurve3d {lvalue})'''
    ...
    def getTrimmedOffset (self, *args, **kwargs):
      '''
getTrimmedOffset( (Curve3d)arg1, (float)arg2, (Vector3d)arg3, (OffsetCrvExtType)arg4) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve3d {lvalue},double,class AcGeVector3d,enum AcGe::OffsetCrvExtType)

getTrimmedOffset( (Curve3d)arg1, (float)arg2, (Vector3d)arg3, (OffsetCrvExtType)arg4, (Tol)arg5) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve3d {lvalue},double,class AcGeVector3d,enum AcGe::OffsetCrvExtType,class AcGeTol)'''
    ...
    def hasEndPoint (self, *args, **kwargs):
      '''
hasEndPoint( (Curve3d)arg1) -> bool :

    C++ signature :
        bool hasEndPoint(class PyGeCurve3d {lvalue})'''
    ...
    def hasFitData (self, *args, **kwargs):
      '''
hasFitData( (SplineEnt3d)arg1) -> bool :

    C++ signature :
        bool hasFitData(class PyGeSplineEnt3d {lvalue})'''
    ...
    def hasStartPoint (self, *args, **kwargs):
      '''
hasStartPoint( (Curve3d)arg1) -> bool :

    C++ signature :
        bool hasStartPoint(class PyGeCurve3d {lvalue})'''
    ...
    def isClosed (self, *args, **kwargs):
      '''
isClosed( (Curve3d)arg1) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve3d {lvalue})

isClosed( (Curve3d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isCoplanarWith (self, *args, **kwargs):
      '''
isCoplanarWith( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isCoplanarWith(class PyGeCurve3d {lvalue},class PyGeCurve3d)

isCoplanarWith( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple isCoplanarWith(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def isDegenerate (self, *args, **kwargs):
      '''
isDegenerate( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve3d {lvalue})

isDegenerate( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity3d)arg1, (Entity3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity3d {lvalue},class PyGeEntity3d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity3d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity3d {lvalue},enum AcGe::EntityId)'''
    ...
    def isLinear (self, *args, **kwargs):
      '''
isLinear( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve3d {lvalue})

isLinear( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity3d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity3d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Curve3d)arg1, (Point3d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d)

isOn( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

isOn( (Curve3d)arg1, (Point3d)arg2, (float)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d,double {lvalue})

isOn( (Curve3d)arg1, (Point3d)arg2, (float)arg3, (Tol)arg4) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d,double {lvalue},class AcGeTol)

isOn( (Curve3d)arg1, (float)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},double)

isOn( (Curve3d)arg1, (float)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},double,class AcGeTol)'''
    ...
    def isPeriodic (self, *args, **kwargs):
      '''
isPeriodic( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPeriodic(class PyGeCurve3d {lvalue})'''
    ...
    def isPlanar (self, *args, **kwargs):
      '''
isPlanar( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPlanar(class PyGeCurve3d {lvalue})

isPlanar( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isPlanar(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isRational (self, *args, **kwargs):
      '''
isRational( (SplineEnt3d)arg1) -> bool :

    C++ signature :
        bool isRational(class PyGeSplineEnt3d {lvalue})'''
    ...
    def knotAt (self, *args, **kwargs):
      '''
knotAt( (SplineEnt3d)arg1, (CmdFlags)arg2) -> float :

    C++ signature :
        double knotAt(class PyGeSplineEnt3d {lvalue},int)'''
    ...
    def knots (self, *args, **kwargs):
      '''
knots( (SplineEnt3d)arg1) -> KnotVector :

    C++ signature :
        class PyGeKnotVector knots(class PyGeSplineEnt3d {lvalue})'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double length(class PyGeCurve3d {lvalue},double,double)

length( (Curve3d)arg1, (float)arg2, (float)arg3, (float)arg4) -> float :

    C++ signature :
        double length(class PyGeCurve3d {lvalue},double,double,double)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} mirror(class PyGeEntity3d {lvalue},class PyGePlane)'''
    ...
    def numControlPoints (self, *args, **kwargs):
      '''
numControlPoints( (SplineEnt3d)arg1) -> int :

    C++ signature :
        int numControlPoints(class PyGeSplineEnt3d {lvalue})'''
    ...
    def numKnots (self, *args, **kwargs):
      '''
numKnots( (SplineEnt3d)arg1) -> int :

    C++ signature :
        int numKnots(class PyGeSplineEnt3d {lvalue})'''
    ...
    def order (self, *args, **kwargs):
      '''
order( (SplineEnt3d)arg1) -> int :

    C++ signature :
        int order(class PyGeSplineEnt3d {lvalue})'''
    ...
    def orthoBoundBlock (self, *args, **kwargs):
      '''
orthoBoundBlock( (Curve3d)arg1) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d orthoBoundBlock(class PyGeCurve3d {lvalue})

orthoBoundBlock( (Curve3d)arg1, (Interval)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d orthoBoundBlock(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def orthoProject (self, *args, **kwargs):
      '''
orthoProject( (Curve3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d orthoProject(class PyGeCurve3d {lvalue},class PyGePlane)

orthoProject( (Curve3d)arg1, (Plane)arg2, (Tol)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d orthoProject(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeTol)'''
    ...
    def paramAtLength (self, *args, **kwargs):
      '''
paramAtLength( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve3d {lvalue},double,double)

paramAtLength( (Curve3d)arg1, (float)arg2, (float)arg3, (bool)arg4, (float)arg5) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve3d {lvalue},double,double,bool,double)'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Curve3d)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double paramOf(class PyGeCurve3d {lvalue},class AcGePoint3d)

paramOf( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double paramOf(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def projClosestPointTo (self, *args, **kwargs):
      '''
projClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d projClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d)

projClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Tol)arg4) -> Point3d :

    C++ signature :
        class AcGePoint3d projClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def projClosestPointsTo (self, *args, **kwargs):
      '''
projClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple projClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d)

projClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple projClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def project (self, *args, **kwargs):
      '''
project( (Curve3d)arg1, (Plane)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d project(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeVector3d)

project( (Curve3d)arg1, (Plane)arg2, (Vector3d)arg3, (Tol)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d project(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeVector3d,class AcGeTol)'''
    ...
    def reverseParam (self, *args, **kwargs):
      '''
reverseParam( (Curve3d)arg1) -> Curve3d :

    C++ signature :
        class PyGeCurve3d {lvalue} reverseParam(class PyGeCurve3d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d)

rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3, (Point3d)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d,class AcGePoint3d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity3d)arg1, (float)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double)

scaleBy( (Entity3d)arg1, (float)arg2, (Point3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double,class AcGePoint3d)'''
    ...
    def setControlPointAt (self, *args, **kwargs):
      '''
setControlPointAt( (SplineEnt3d)arg1, (CmdFlags)arg2, (Point3d)arg3) -> SplineEnt3d :

    C++ signature :
        class PyGeSplineEnt3d {lvalue} setControlPointAt(class PyGeSplineEnt3d {lvalue},int,class AcGePoint3d)'''
    ...
    def setInterval (self, *args, **kwargs):
      '''
setInterval( (Curve3d)arg1) -> Curve3d :

    C++ signature :
        class PyGeCurve3d {lvalue} setInterval(class PyGeCurve3d {lvalue})

setInterval( (Curve3d)arg1, (Interval)arg2) -> bool :

    C++ signature :
        bool setInterval(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def setKnotAt (self, *args, **kwargs):
      '''
setKnotAt( (SplineEnt3d)arg1, (CmdFlags)arg2, (float)arg3) -> SplineEnt3d :

    C++ signature :
        class PyGeSplineEnt3d {lvalue} setKnotAt(class PyGeSplineEnt3d {lvalue},int,double)'''
    ...
    def startParam (self, *args, **kwargs):
      '''
startParam( (SplineEnt3d)arg1) -> float :

    C++ signature :
        double startParam(class PyGeSplineEnt3d {lvalue})'''
    ...
    def startPoint (self, *args, **kwargs):
      '''
startPoint( (SplineEnt3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d startPoint(class PyGeSplineEnt3d {lvalue})'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity3d)arg1, (Matrix3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} transformBy(class PyGeEntity3d {lvalue},class AcGeMatrix3d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity3d)arg1, (Vector3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} translateBy(class PyGeEntity3d {lvalue},class AcGeVector3d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity3d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity3d {lvalue})'''
    ...

class OffsetCrvExtType:
    def as_integer_ratio (self, /):
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count (self, /):
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length (self, /):
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''the denominator of a rational number in lowest terms'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''the imaginary part of a complex number'''
    ...
    def kChamfer (self, *args, **kwargs):
      '''None'''
    ...
    def kExtend (self, *args, **kwargs):
      '''None'''
    ...
    def kFillet (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''the numerator of a rational number in lowest terms'''
    ...
    def real (self, *args, **kwargs):
      '''the real part of a complex number'''
    ...
    def to_bytes (self, /, length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...

class OffsetCurve2d:
    def area (self, *args, **kwargs):
      '''
area( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double area(class PyGeCurve2d {lvalue},double,double)

area( (Curve2d)arg1, (float)arg2, (float)arg3, (Tol)arg4) -> float :

    C++ signature :
        double area(class PyGeCurve2d {lvalue},double,double,class AcGeTol)'''
    ...
    def boundBlock (self, *args, **kwargs):
      '''
boundBlock( (Curve2d)arg1) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d boundBlock(class PyGeCurve2d {lvalue})

boundBlock( (Curve2d)arg1, (Interval)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d boundBlock(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Curve2d)arg1, (Point2d)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d closestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

closestPointTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> Point2d :

    C++ signature :
        class AcGePoint2d closestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

closestPointTo( (Curve2d)arg1, (Curve2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

closestPointTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity2d)arg1) -> Entity2d :

    C++ signature :
        class PyGeEntity2d copy(class PyGeEntity2d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Curve2d)arg1, (Point2d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

distanceTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

distanceTo( (Curve2d)arg1, (Curve2d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

distanceTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Curve2d)arg1, (float)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d evalPoint(class PyGeCurve2d {lvalue},double)

evalPoint( (Curve2d)arg1, (float)arg2, (CmdFlags)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple evalPoint(class PyGeCurve2d {lvalue},double,int)'''
    ...
    def explode (self, *args, **kwargs):
      '''
explode( (Curve2d)arg1) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve2d {lvalue})

explode( (Curve2d)arg1, (Interval)arg2) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def getClosestPointTo (self, *args, **kwargs):
      '''
getClosestPointTo( (Curve2d)arg1, (Point2d)arg2) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getClosestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

getClosestPointTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getClosestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def getClosestPointsTo (self, *args, **kwargs):
      '''
getClosestPointsTo( (Curve2d)arg1, (Curve2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

getClosestPointsTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def getEndPoint (self, *args, **kwargs):
      '''
getEndPoint( (Curve2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getEndPoint(class PyGeCurve2d {lvalue})'''
    ...
    def getInterval (self, *args, **kwargs):
      '''
getInterval( (Curve2d)arg1) -> Interval :

    C++ signature :
        class PyGeInterval getInterval(class PyGeCurve2d {lvalue})'''
    ...
    def getNormalPoint (self, *args, **kwargs):
      '''
getNormalPoint( (Curve2d)arg1, (Point2d)arg2) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getNormalPoint(class PyGeCurve2d {lvalue},class AcGePoint2d)

getNormalPoint( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getNormalPoint(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def getSamplePoints (self, *args, **kwargs):
      '''
getSamplePoints( (Curve2d)arg1, (CmdFlags)arg2) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve2d {lvalue},int)

getSamplePoints( (Curve2d)arg1, (float)arg2, (float)arg3, (float)arg4) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve2d {lvalue},double,double,double)'''
    ...
    def getSplitCurves (self, *args, **kwargs):
      '''
getSplitCurves( (Curve2d)arg1, (float)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getSplitCurves(class PyGeCurve2d {lvalue},double)'''
    ...
    def getStartPoint (self, *args, **kwargs):
      '''
getStartPoint( (Curve2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getStartPoint(class PyGeCurve2d {lvalue})'''
    ...
    def getTrimmedOffset (self, *args, **kwargs):
      '''
getTrimmedOffset( (Curve2d)arg1, (float)arg2, (OffsetCrvExtType)arg3) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve2d {lvalue},double,enum AcGe::OffsetCrvExtType)

getTrimmedOffset( (Curve2d)arg1, (float)arg2, (OffsetCrvExtType)arg3, (Tol)arg4) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve2d {lvalue},double,enum AcGe::OffsetCrvExtType,class AcGeTol)'''
    ...
    def hasEndPoint (self, *args, **kwargs):
      '''
hasEndPoint( (Curve2d)arg1) -> bool :

    C++ signature :
        bool hasEndPoint(class PyGeCurve2d {lvalue})'''
    ...
    def hasStartPoint (self, *args, **kwargs):
      '''
hasStartPoint( (Curve2d)arg1) -> bool :

    C++ signature :
        bool hasStartPoint(class PyGeCurve2d {lvalue})'''
    ...
    def isClosed (self, *args, **kwargs):
      '''
isClosed( (Curve2d)arg1) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve2d {lvalue})

isClosed( (Curve2d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isDegenerate (self, *args, **kwargs):
      '''
isDegenerate( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve2d {lvalue})

isDegenerate( (Curve2d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity2d)arg1, (Entity2d)arg2) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d)

isEqualTo( (Entity2d)arg1, (Entity2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity2d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity2d {lvalue},enum AcGe::EntityId)'''
    ...
    def isLinear (self, *args, **kwargs):
      '''
isLinear( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve2d {lvalue})

isLinear( (Curve2d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity2d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity2d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Curve2d)arg1, (Point2d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d)

isOn( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

isOn( (Curve2d)arg1, (Point2d)arg2, (float)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,double {lvalue})

isOn( (Curve2d)arg1, (Point2d)arg2, (float)arg3, (Tol)arg4) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,double {lvalue},class AcGeTol)

isOn( (Curve2d)arg1, (float)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},double)

isOn( (Curve2d)arg1, (float)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},double,class AcGeTol)'''
    ...
    def isPeriodic (self, *args, **kwargs):
      '''
isPeriodic( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPeriodic(class PyGeCurve2d {lvalue})'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double length(class PyGeCurve2d {lvalue},double,double)

length( (Curve2d)arg1, (float)arg2, (float)arg3, (float)arg4) -> float :

    C++ signature :
        double length(class PyGeCurve2d {lvalue},double,double,double)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity2d)arg1, (Line2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} mirror(class PyGeEntity2d {lvalue},class PyGeLine2d)'''
    ...
    def orthoBoundBlock (self, *args, **kwargs):
      '''
orthoBoundBlock( (Curve2d)arg1) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d orthoBoundBlock(class PyGeCurve2d {lvalue})

orthoBoundBlock( (Curve2d)arg1, (Interval)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d orthoBoundBlock(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def paramAtLength (self, *args, **kwargs):
      '''
paramAtLength( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve2d {lvalue},double,double)

paramAtLength( (Curve2d)arg1, (float)arg2, (float)arg3, (bool)arg4, (float)arg5) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve2d {lvalue},double,double,bool,double)'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Curve2d)arg1, (Point2d)arg2) -> float :

    C++ signature :
        double paramOf(class PyGeCurve2d {lvalue},class AcGePoint2d)

paramOf( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double paramOf(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def reverseParam (self, *args, **kwargs):
      '''
reverseParam( (Curve2d)arg1) -> Curve2d :

    C++ signature :
        class PyGeCurve2d {lvalue} reverseParam(class PyGeCurve2d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double)

rotateBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double)

scaleBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def setInterval (self, *args, **kwargs):
      '''
setInterval( (Curve2d)arg1) -> Curve2d :

    C++ signature :
        class PyGeCurve2d {lvalue} setInterval(class PyGeCurve2d {lvalue})

setInterval( (Curve2d)arg1, (Interval)arg2) -> bool :

    C++ signature :
        bool setInterval(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity2d)arg1, (Matrix2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} transformBy(class PyGeEntity2d {lvalue},class AcGeMatrix2d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity2d)arg1, (Vector2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} translateBy(class PyGeEntity2d {lvalue},class AcGeVector2d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity2d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity2d {lvalue})'''
    ...

class OffsetCurve3d:
    def area (self, *args, **kwargs):
      '''
area( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double area(class PyGeCurve3d {lvalue},double,double)

area( (Curve3d)arg1, (float)arg2, (float)arg3, (Tol)arg4) -> float :

    C++ signature :
        double area(class PyGeCurve3d {lvalue},double,double,class AcGeTol)'''
    ...
    def boundBlock (self, *args, **kwargs):
      '''
boundBlock( (Curve3d)arg1) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d boundBlock(class PyGeCurve3d {lvalue})

boundBlock( (Curve3d)arg1, (Interval)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d boundBlock(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Curve3d)arg1, (Point3d)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

closestPointTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

closestPointTo( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

closestPointTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity3d)arg1) -> Entity3d :

    C++ signature :
        class PyGeEntity3d copy(class PyGeEntity3d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Curve3d)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

distanceTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

distanceTo( (Curve3d)arg1, (Curve3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

distanceTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Curve3d)arg1, (float)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d evalPoint(class PyGeCurve3d {lvalue},double)

evalPoint( (Curve3d)arg1, (float)arg2, (CmdFlags)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple evalPoint(class PyGeCurve3d {lvalue},double,int)'''
    ...
    def explode (self, *args, **kwargs):
      '''
explode( (Curve3d)arg1) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve3d {lvalue})

explode( (Curve3d)arg1, (Interval)arg2) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def getClosestPointTo (self, *args, **kwargs):
      '''
getClosestPointTo( (Curve3d)arg1, (Point3d)arg2) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

getClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def getClosestPointsTo (self, *args, **kwargs):
      '''
getClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

getClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def getEndPoint (self, *args, **kwargs):
      '''
getEndPoint( (Curve3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getEndPoint(class PyGeCurve3d {lvalue})'''
    ...
    def getInterval (self, *args, **kwargs):
      '''
getInterval( (Curve3d)arg1) -> Interval :

    C++ signature :
        class PyGeInterval getInterval(class PyGeCurve3d {lvalue})'''
    ...
    def getNormalPoint (self, *args, **kwargs):
      '''
getNormalPoint( (Curve3d)arg1, (Point3d)arg2) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getNormalPoint(class PyGeCurve3d {lvalue},class AcGePoint3d)

getNormalPoint( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getNormalPoint(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def getProjClosestPointTo (self, *args, **kwargs):
      '''
getProjClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getProjClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d)

getProjClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Tol)arg4) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getProjClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def getProjClosestPointsTo (self, *args, **kwargs):
      '''
getProjClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getProjClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d)

getProjClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple getProjClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def getSamplePoints (self, *args, **kwargs):
      '''
getSamplePoints( (Curve3d)arg1, (CmdFlags)arg2) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve3d {lvalue},int)

getSamplePoints( (Curve3d)arg1, (float)arg2, (float)arg3, (float)arg4) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve3d {lvalue},double,double,double)'''
    ...
    def getSplitCurves (self, *args, **kwargs):
      '''
getSplitCurves( (Curve3d)arg1, (float)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getSplitCurves(class PyGeCurve3d {lvalue},double)'''
    ...
    def getStartPoint (self, *args, **kwargs):
      '''
getStartPoint( (Curve3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getStartPoint(class PyGeCurve3d {lvalue})'''
    ...
    def getTrimmedOffset (self, *args, **kwargs):
      '''
getTrimmedOffset( (Curve3d)arg1, (float)arg2, (Vector3d)arg3, (OffsetCrvExtType)arg4) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve3d {lvalue},double,class AcGeVector3d,enum AcGe::OffsetCrvExtType)

getTrimmedOffset( (Curve3d)arg1, (float)arg2, (Vector3d)arg3, (OffsetCrvExtType)arg4, (Tol)arg5) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve3d {lvalue},double,class AcGeVector3d,enum AcGe::OffsetCrvExtType,class AcGeTol)'''
    ...
    def hasEndPoint (self, *args, **kwargs):
      '''
hasEndPoint( (Curve3d)arg1) -> bool :

    C++ signature :
        bool hasEndPoint(class PyGeCurve3d {lvalue})'''
    ...
    def hasStartPoint (self, *args, **kwargs):
      '''
hasStartPoint( (Curve3d)arg1) -> bool :

    C++ signature :
        bool hasStartPoint(class PyGeCurve3d {lvalue})'''
    ...
    def isClosed (self, *args, **kwargs):
      '''
isClosed( (Curve3d)arg1) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve3d {lvalue})

isClosed( (Curve3d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isCoplanarWith (self, *args, **kwargs):
      '''
isCoplanarWith( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isCoplanarWith(class PyGeCurve3d {lvalue},class PyGeCurve3d)

isCoplanarWith( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple isCoplanarWith(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def isDegenerate (self, *args, **kwargs):
      '''
isDegenerate( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve3d {lvalue})

isDegenerate( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity3d)arg1, (Entity3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity3d {lvalue},class PyGeEntity3d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity3d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity3d {lvalue},enum AcGe::EntityId)'''
    ...
    def isLinear (self, *args, **kwargs):
      '''
isLinear( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve3d {lvalue})

isLinear( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity3d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity3d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Curve3d)arg1, (Point3d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d)

isOn( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

isOn( (Curve3d)arg1, (Point3d)arg2, (float)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d,double {lvalue})

isOn( (Curve3d)arg1, (Point3d)arg2, (float)arg3, (Tol)arg4) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d,double {lvalue},class AcGeTol)

isOn( (Curve3d)arg1, (float)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},double)

isOn( (Curve3d)arg1, (float)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},double,class AcGeTol)'''
    ...
    def isPeriodic (self, *args, **kwargs):
      '''
isPeriodic( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPeriodic(class PyGeCurve3d {lvalue})'''
    ...
    def isPlanar (self, *args, **kwargs):
      '''
isPlanar( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPlanar(class PyGeCurve3d {lvalue})

isPlanar( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isPlanar(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double length(class PyGeCurve3d {lvalue},double,double)

length( (Curve3d)arg1, (float)arg2, (float)arg3, (float)arg4) -> float :

    C++ signature :
        double length(class PyGeCurve3d {lvalue},double,double,double)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} mirror(class PyGeEntity3d {lvalue},class PyGePlane)'''
    ...
    def orthoBoundBlock (self, *args, **kwargs):
      '''
orthoBoundBlock( (Curve3d)arg1) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d orthoBoundBlock(class PyGeCurve3d {lvalue})

orthoBoundBlock( (Curve3d)arg1, (Interval)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d orthoBoundBlock(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def orthoProject (self, *args, **kwargs):
      '''
orthoProject( (Curve3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d orthoProject(class PyGeCurve3d {lvalue},class PyGePlane)

orthoProject( (Curve3d)arg1, (Plane)arg2, (Tol)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d orthoProject(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeTol)'''
    ...
    def paramAtLength (self, *args, **kwargs):
      '''
paramAtLength( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve3d {lvalue},double,double)

paramAtLength( (Curve3d)arg1, (float)arg2, (float)arg3, (bool)arg4, (float)arg5) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve3d {lvalue},double,double,bool,double)'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Curve3d)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double paramOf(class PyGeCurve3d {lvalue},class AcGePoint3d)

paramOf( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double paramOf(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def projClosestPointTo (self, *args, **kwargs):
      '''
projClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d projClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d)

projClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Tol)arg4) -> Point3d :

    C++ signature :
        class AcGePoint3d projClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def projClosestPointsTo (self, *args, **kwargs):
      '''
projClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple projClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d)

projClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple projClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def project (self, *args, **kwargs):
      '''
project( (Curve3d)arg1, (Plane)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d project(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeVector3d)

project( (Curve3d)arg1, (Plane)arg2, (Vector3d)arg3, (Tol)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d project(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeVector3d,class AcGeTol)'''
    ...
    def reverseParam (self, *args, **kwargs):
      '''
reverseParam( (Curve3d)arg1) -> Curve3d :

    C++ signature :
        class PyGeCurve3d {lvalue} reverseParam(class PyGeCurve3d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d)

rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3, (Point3d)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d,class AcGePoint3d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity3d)arg1, (float)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double)

scaleBy( (Entity3d)arg1, (float)arg2, (Point3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double,class AcGePoint3d)'''
    ...
    def setInterval (self, *args, **kwargs):
      '''
setInterval( (Curve3d)arg1) -> Curve3d :

    C++ signature :
        class PyGeCurve3d {lvalue} setInterval(class PyGeCurve3d {lvalue})

setInterval( (Curve3d)arg1, (Interval)arg2) -> bool :

    C++ signature :
        bool setInterval(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity3d)arg1, (Matrix3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} transformBy(class PyGeEntity3d {lvalue},class AcGeMatrix3d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity3d)arg1, (Vector3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} translateBy(class PyGeEntity3d {lvalue},class AcGeVector3d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity3d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity3d {lvalue})'''
    ...

class PlanarEnt:
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Surface)arg1, (Point3d)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyAcGeSurface {lvalue},class AcGePoint3d)

closestPointTo( (Surface)arg1, (Point3d)arg2, (Tol)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyAcGeSurface {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def closestPointToLinearEnt (self, *args, **kwargs):
      '''
closestPointToLinearEnt( (PlanarEnt)arg1, (LinearEnt3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointToLinearEnt(class PyGePlanarEnt {lvalue},class PyGeLinearEnt3d)

closestPointToLinearEnt( (PlanarEnt)arg1, (LinearEnt3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointToLinearEnt(class PyGePlanarEnt {lvalue},class PyGeLinearEnt3d,class AcGeTol)'''
    ...
    def closestPointToPlanarEnt (self, *args, **kwargs):
      '''
closestPointToPlanarEnt( (PlanarEnt)arg1, (PlanarEnt)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointToPlanarEnt(class PyGePlanarEnt {lvalue},class PyGePlanarEnt)

closestPointToPlanarEnt( (PlanarEnt)arg1, (PlanarEnt)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointToPlanarEnt(class PyGePlanarEnt {lvalue},class PyGePlanarEnt,class AcGeTol)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity3d)arg1) -> Entity3d :

    C++ signature :
        class PyGeEntity3d copy(class PyGeEntity3d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Surface)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyAcGeSurface {lvalue},class AcGePoint3d)

distanceTo( (Surface)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyAcGeSurface {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Surface)arg1, (Point2d)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d evalPoint(class PyAcGeSurface {lvalue},class AcGePoint2d)

evalPoint( (Surface)arg1, (Point2d)arg2, (CmdFlags)arg3, (list)arg4) -> Point3d :

    C++ signature :
        class AcGePoint3d evalPoint(class PyAcGeSurface {lvalue},class AcGePoint2d,int,class boost::python::list {lvalue})

evalPoint( (Surface)arg1, (Point2d)arg2, (CmdFlags)arg3, (list)arg4, (Vector3d)arg5) -> Point3d :

    C++ signature :
        class AcGePoint3d evalPoint(class PyAcGeSurface {lvalue},class AcGePoint2d,int,class boost::python::list {lvalue},class AcGeVector3d {lvalue})'''
    ...
    def getCoefficients (self, *args, **kwargs):
      '''
getCoefficients( (PlanarEnt)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple getCoefficients(class PyGePlanarEnt {lvalue})'''
    ...
    def getCoordSystem (self, *args, **kwargs):
      '''
getCoordSystem( (PlanarEnt)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple getCoordSystem(class PyGePlanarEnt {lvalue})'''
    ...
    def intersectWith (self, *args, **kwargs):
      '''
intersectWith( (PlanarEnt)arg1, (LinearEnt3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGePlanarEnt {lvalue},class PyGeLinearEnt3d)

intersectWith( (PlanarEnt)arg1, (LinearEnt3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGePlanarEnt {lvalue},class PyGeLinearEnt3d,class AcGeTol)'''
    ...
    def isClosedInU (self, *args, **kwargs):
      '''
isClosedInU( (Surface)arg1) -> bool :

    C++ signature :
        bool isClosedInU(class PyAcGeSurface {lvalue})

isClosedInU( (Surface)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosedInU(class PyAcGeSurface {lvalue},class AcGeTol)'''
    ...
    def isClosedInV (self, *args, **kwargs):
      '''
isClosedInV( (Surface)arg1) -> bool :

    C++ signature :
        bool isClosedInV(class PyAcGeSurface {lvalue})

isClosedInV( (Surface)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosedInV(class PyAcGeSurface {lvalue},class AcGeTol)'''
    ...
    def isCoplanarTo (self, *args, **kwargs):
      '''
isCoplanarTo( (PlanarEnt)arg1, (PlanarEnt)arg2) -> bool :

    C++ signature :
        bool isCoplanarTo(class PyGePlanarEnt {lvalue},class PyGePlanarEnt)

isCoplanarTo( (PlanarEnt)arg1, (PlanarEnt)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isCoplanarTo(class PyGePlanarEnt {lvalue},class PyGePlanarEnt,class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity3d)arg1, (Entity3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity3d {lvalue},class PyGeEntity3d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity3d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity3d {lvalue},enum AcGe::EntityId)'''
    ...
    def isNormalReversed (self, *args, **kwargs):
      '''
isNormalReversed( (Surface)arg1) -> bool :

    C++ signature :
        bool isNormalReversed(class PyAcGeSurface {lvalue})'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity3d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity3d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Surface)arg1, (Point3d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyAcGeSurface {lvalue},class AcGePoint3d)

isOn( (Surface)arg1, (Point3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyAcGeSurface {lvalue},class AcGePoint3d,class AcGeTol)

isOn( (Surface)arg1, (Point3d)arg2, (Point2d)arg3) -> bool :

    C++ signature :
        bool isOn(class PyAcGeSurface {lvalue},class AcGePoint3d,class AcGePoint2d {lvalue})

isOn( (Surface)arg1, (Point3d)arg2, (Point2d)arg3, (Tol)arg4) -> bool :

    C++ signature :
        bool isOn(class PyAcGeSurface {lvalue},class AcGePoint3d,class AcGePoint2d {lvalue},class AcGeTol)'''
    ...
    def isParallelTo (self, *args, **kwargs):
      '''
isParallelTo( (PlanarEnt)arg1, (LinearEnt3d)arg2) -> bool :

    C++ signature :
        bool isParallelTo(class PyGePlanarEnt {lvalue},class PyGeLinearEnt3d)

isParallelTo( (PlanarEnt)arg1, (LinearEnt3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isParallelTo(class PyGePlanarEnt {lvalue},class PyGeLinearEnt3d,class AcGeTol)

isParallelTo( (PlanarEnt)arg1, (PlanarEnt)arg2) -> bool :

    C++ signature :
        bool isParallelTo(class PyGePlanarEnt {lvalue},class PyGePlanarEnt)

isParallelTo( (PlanarEnt)arg1, (PlanarEnt)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isParallelTo(class PyGePlanarEnt {lvalue},class PyGePlanarEnt,class AcGeTol)'''
    ...
    def isPerpendicularTo (self, *args, **kwargs):
      '''
isPerpendicularTo( (PlanarEnt)arg1, (LinearEnt3d)arg2) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGePlanarEnt {lvalue},class PyGeLinearEnt3d)

isPerpendicularTo( (PlanarEnt)arg1, (LinearEnt3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGePlanarEnt {lvalue},class PyGeLinearEnt3d,class AcGeTol)

isPerpendicularTo( (PlanarEnt)arg1, (PlanarEnt)arg2) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGePlanarEnt {lvalue},class PyGePlanarEnt)

isPerpendicularTo( (PlanarEnt)arg1, (PlanarEnt)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGePlanarEnt {lvalue},class PyGePlanarEnt,class AcGeTol)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} mirror(class PyGeEntity3d {lvalue},class PyGePlane)'''
    ...
    def normal (self, *args, **kwargs):
      '''
normal( (PlanarEnt)arg1) -> Vector3d :

    C++ signature :
        class AcGeVector3d normal(class PyGePlanarEnt {lvalue})'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Surface)arg1, (Point3d)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d paramOf(class PyAcGeSurface {lvalue},class AcGePoint3d)

paramOf( (Surface)arg1, (Point3d)arg2, (Tol)arg3) -> Point2d :

    C++ signature :
        class AcGePoint2d paramOf(class PyAcGeSurface {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def pointOnPlane (self, *args, **kwargs):
      '''
pointOnPlane( (PlanarEnt)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d pointOnPlane(class PyGePlanarEnt {lvalue})'''
    ...
    def reverseNormal (self, *args, **kwargs):
      '''
reverseNormal( (Surface)arg1) -> Surface :

    C++ signature :
        class PyAcGeSurface {lvalue} reverseNormal(class PyAcGeSurface {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d)

rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3, (Point3d)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d,class AcGePoint3d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity3d)arg1, (float)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double)

scaleBy( (Entity3d)arg1, (float)arg2, (Point3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double,class AcGePoint3d)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity3d)arg1, (Matrix3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} transformBy(class PyGeEntity3d {lvalue},class AcGeMatrix3d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity3d)arg1, (Vector3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} translateBy(class PyGeEntity3d {lvalue},class AcGeVector3d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity3d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity3d {lvalue})'''
    ...

class Plane:
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Surface)arg1, (Point3d)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyAcGeSurface {lvalue},class AcGePoint3d)

closestPointTo( (Surface)arg1, (Point3d)arg2, (Tol)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyAcGeSurface {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def closestPointToLinearEnt (self, *args, **kwargs):
      '''
closestPointToLinearEnt( (PlanarEnt)arg1, (LinearEnt3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointToLinearEnt(class PyGePlanarEnt {lvalue},class PyGeLinearEnt3d)

closestPointToLinearEnt( (PlanarEnt)arg1, (LinearEnt3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointToLinearEnt(class PyGePlanarEnt {lvalue},class PyGeLinearEnt3d,class AcGeTol)'''
    ...
    def closestPointToPlanarEnt (self, *args, **kwargs):
      '''
closestPointToPlanarEnt( (PlanarEnt)arg1, (PlanarEnt)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointToPlanarEnt(class PyGePlanarEnt {lvalue},class PyGePlanarEnt)

closestPointToPlanarEnt( (PlanarEnt)arg1, (PlanarEnt)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointToPlanarEnt(class PyGePlanarEnt {lvalue},class PyGePlanarEnt,class AcGeTol)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity3d)arg1) -> Entity3d :

    C++ signature :
        class PyGeEntity3d copy(class PyGeEntity3d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Surface)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyAcGeSurface {lvalue},class AcGePoint3d)

distanceTo( (Surface)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyAcGeSurface {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Surface)arg1, (Point2d)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d evalPoint(class PyAcGeSurface {lvalue},class AcGePoint2d)

evalPoint( (Surface)arg1, (Point2d)arg2, (CmdFlags)arg3, (list)arg4) -> Point3d :

    C++ signature :
        class AcGePoint3d evalPoint(class PyAcGeSurface {lvalue},class AcGePoint2d,int,class boost::python::list {lvalue})

evalPoint( (Surface)arg1, (Point2d)arg2, (CmdFlags)arg3, (list)arg4, (Vector3d)arg5) -> Point3d :

    C++ signature :
        class AcGePoint3d evalPoint(class PyAcGeSurface {lvalue},class AcGePoint2d,int,class boost::python::list {lvalue},class AcGeVector3d {lvalue})'''
    ...
    def getCoefficients (self, *args, **kwargs):
      '''
getCoefficients( (PlanarEnt)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple getCoefficients(class PyGePlanarEnt {lvalue})'''
    ...
    def getCoordSystem (self, *args, **kwargs):
      '''
getCoordSystem( (PlanarEnt)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple getCoordSystem(class PyGePlanarEnt {lvalue})'''
    ...
    def intersectWith (self, *args, **kwargs):
      '''
intersectWith( (Plane)arg1, (LinearEnt3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeBoundedPlane {lvalue},class PyGeLinearEnt3d)

intersectWith( (Plane)arg1, (LinearEnt3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeBoundedPlane {lvalue},class PyGeLinearEnt3d,class AcGeTol)

intersectWith( (Plane)arg1, (Plane)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeBoundedPlane {lvalue},class PyGePlane)

intersectWith( (Plane)arg1, (Plane)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeBoundedPlane {lvalue},class PyGePlane,class AcGeTol)

intersectWith( (Plane)arg1, (Plane)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeBoundedPlane {lvalue},class PyGeBoundedPlane)

intersectWith( (Plane)arg1, (Plane)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeBoundedPlane {lvalue},class PyGeBoundedPlane,class AcGeTol)'''
    ...
    def isClosedInU (self, *args, **kwargs):
      '''
isClosedInU( (Surface)arg1) -> bool :

    C++ signature :
        bool isClosedInU(class PyAcGeSurface {lvalue})

isClosedInU( (Surface)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosedInU(class PyAcGeSurface {lvalue},class AcGeTol)'''
    ...
    def isClosedInV (self, *args, **kwargs):
      '''
isClosedInV( (Surface)arg1) -> bool :

    C++ signature :
        bool isClosedInV(class PyAcGeSurface {lvalue})

isClosedInV( (Surface)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosedInV(class PyAcGeSurface {lvalue},class AcGeTol)'''
    ...
    def isCoplanarTo (self, *args, **kwargs):
      '''
isCoplanarTo( (PlanarEnt)arg1, (PlanarEnt)arg2) -> bool :

    C++ signature :
        bool isCoplanarTo(class PyGePlanarEnt {lvalue},class PyGePlanarEnt)

isCoplanarTo( (PlanarEnt)arg1, (PlanarEnt)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isCoplanarTo(class PyGePlanarEnt {lvalue},class PyGePlanarEnt,class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity3d)arg1, (Entity3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity3d {lvalue},class PyGeEntity3d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity3d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity3d {lvalue},enum AcGe::EntityId)'''
    ...
    def isNormalReversed (self, *args, **kwargs):
      '''
isNormalReversed( (Surface)arg1) -> bool :

    C++ signature :
        bool isNormalReversed(class PyAcGeSurface {lvalue})'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity3d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity3d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Surface)arg1, (Point3d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyAcGeSurface {lvalue},class AcGePoint3d)

isOn( (Surface)arg1, (Point3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyAcGeSurface {lvalue},class AcGePoint3d,class AcGeTol)

isOn( (Surface)arg1, (Point3d)arg2, (Point2d)arg3) -> bool :

    C++ signature :
        bool isOn(class PyAcGeSurface {lvalue},class AcGePoint3d,class AcGePoint2d {lvalue})

isOn( (Surface)arg1, (Point3d)arg2, (Point2d)arg3, (Tol)arg4) -> bool :

    C++ signature :
        bool isOn(class PyAcGeSurface {lvalue},class AcGePoint3d,class AcGePoint2d {lvalue},class AcGeTol)'''
    ...
    def isParallelTo (self, *args, **kwargs):
      '''
isParallelTo( (PlanarEnt)arg1, (LinearEnt3d)arg2) -> bool :

    C++ signature :
        bool isParallelTo(class PyGePlanarEnt {lvalue},class PyGeLinearEnt3d)

isParallelTo( (PlanarEnt)arg1, (LinearEnt3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isParallelTo(class PyGePlanarEnt {lvalue},class PyGeLinearEnt3d,class AcGeTol)

isParallelTo( (PlanarEnt)arg1, (PlanarEnt)arg2) -> bool :

    C++ signature :
        bool isParallelTo(class PyGePlanarEnt {lvalue},class PyGePlanarEnt)

isParallelTo( (PlanarEnt)arg1, (PlanarEnt)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isParallelTo(class PyGePlanarEnt {lvalue},class PyGePlanarEnt,class AcGeTol)'''
    ...
    def isPerpendicularTo (self, *args, **kwargs):
      '''
isPerpendicularTo( (PlanarEnt)arg1, (LinearEnt3d)arg2) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGePlanarEnt {lvalue},class PyGeLinearEnt3d)

isPerpendicularTo( (PlanarEnt)arg1, (LinearEnt3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGePlanarEnt {lvalue},class PyGeLinearEnt3d,class AcGeTol)

isPerpendicularTo( (PlanarEnt)arg1, (PlanarEnt)arg2) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGePlanarEnt {lvalue},class PyGePlanarEnt)

isPerpendicularTo( (PlanarEnt)arg1, (PlanarEnt)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGePlanarEnt {lvalue},class PyGePlanarEnt,class AcGeTol)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} mirror(class PyGeEntity3d {lvalue},class PyGePlane)'''
    ...
    def normal (self, *args, **kwargs):
      '''
normal( (PlanarEnt)arg1) -> Vector3d :

    C++ signature :
        class AcGeVector3d normal(class PyGePlanarEnt {lvalue})'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Surface)arg1, (Point3d)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d paramOf(class PyAcGeSurface {lvalue},class AcGePoint3d)

paramOf( (Surface)arg1, (Point3d)arg2, (Tol)arg3) -> Point2d :

    C++ signature :
        class AcGePoint2d paramOf(class PyAcGeSurface {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def pointOnPlane (self, *args, **kwargs):
      '''
pointOnPlane( (PlanarEnt)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d pointOnPlane(class PyGePlanarEnt {lvalue})'''
    ...
    def reverseNormal (self, *args, **kwargs):
      '''
reverseNormal( (Surface)arg1) -> Surface :

    C++ signature :
        class PyAcGeSurface {lvalue} reverseNormal(class PyAcGeSurface {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d)

rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3, (Point3d)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d,class AcGePoint3d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity3d)arg1, (float)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double)

scaleBy( (Entity3d)arg1, (float)arg2, (Point3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double,class AcGePoint3d)'''
    ...
    def set (self, *args, **kwargs):
      '''
set( (Plane)arg1, (Point3d)arg2, (Vector3d)arg3, (Vector3d)arg4) -> Plane :

    C++ signature :
        class PyGeBoundedPlane {lvalue} set(class PyGeBoundedPlane {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeVector3d)

set( (Plane)arg1, (Point3d)arg2, (Point3d)arg3, (Point3d)arg4) -> Plane :

    C++ signature :
        class PyGeBoundedPlane {lvalue} set(class PyGeBoundedPlane {lvalue},class AcGePoint3d,class AcGePoint3d,class AcGePoint3d)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity3d)arg1, (Matrix3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} transformBy(class PyGeEntity3d {lvalue},class AcGeMatrix3d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity3d)arg1, (Vector3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} translateBy(class PyGeEntity3d {lvalue},class AcGeVector3d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity3d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity3d {lvalue})'''
    ...

class Point2d:
    def asVector (self, *args, **kwargs):
      '''
asVector( (Point2d)arg1) -> Vector2d :

    C++ signature :
        class AcGeVector2d asVector(class AcGePoint2d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Point2d)arg1, (Point2d)arg2) -> float :

    C++ signature :
        double distanceTo(class AcGePoint2d {lvalue},class AcGePoint2d)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Point2d)arg1, (Point2d)arg2 [, (Tol)AcGeTol=<PyGe.Tol object at 0x000001F037793250>]) -> bool :

    C++ signature :
        bool isEqualTo(class AcGePoint2d {lvalue},class AcGePoint2d [,class AcGeTol=<PyGe.Tol object at 0x000001F037793250>])'''
    ...
    def kOrigin (self, *args, **kwargs):
      '''None'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Point2d)arg1, (object)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d {lvalue} mirror(class AcGePoint2d {lvalue},class AcGeLine2d)'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Point2d)arg1, (float)arg2 [, (Point2d)AcGePoint2d=<PyGe.Point2d object at 0x000001F037732110>]) -> Point2d :

    C++ signature :
        class AcGePoint2d {lvalue} rotateBy(class AcGePoint2d {lvalue},double [,class AcGePoint2d=<PyGe.Point2d object at 0x000001F037732110>])'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Point2d)arg1, (float)arg2 [, (Point2d)AcGePoint2d=<PyGe.Point2d object at 0x000001F037732180>]) -> Point2d :

    C++ signature :
        class AcGePoint2d {lvalue} scaleBy(class AcGePoint2d {lvalue},double [,class AcGePoint2d=<PyGe.Point2d object at 0x000001F037732180>])'''
    ...
    def set (self, *args, **kwargs):
      '''
set( (Point2d)arg1, (float)arg2, (float)arg3) -> Point2d :

    C++ signature :
        class AcGePoint2d {lvalue} set(class AcGePoint2d {lvalue},double,double)'''
    ...
    def setToProduct (self, *args, **kwargs):
      '''
setToProduct( (Point2d)arg1, (Matrix2d)arg2, (Point2d)arg3) -> Point2d :

    C++ signature :
        class AcGePoint2d {lvalue} setToProduct(class AcGePoint2d {lvalue},class AcGeMatrix2d,class AcGePoint2d)'''
    ...
    def setToSum (self, *args, **kwargs):
      '''
setToSum( (Point2d)arg1, (Point2d)arg2, (Vector2d)arg3) -> Point2d :

    C++ signature :
        class AcGePoint2d {lvalue} setToSum(class AcGePoint2d {lvalue},class AcGePoint2d,class AcGeVector2d)'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (Point2d)arg1) -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > toString(class AcGePoint2d)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Point2d)arg1, (Matrix2d)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d {lvalue} transformBy(class AcGePoint2d {lvalue},class AcGeMatrix2d)'''
    ...
    def x (self, *args, **kwargs):
      '''None'''
    ...
    def y (self, *args, **kwargs):
      '''None'''
    ...

class Point3d:
    def asVector (self, *args, **kwargs):
      '''
asVector( (Point3d)arg1) -> Vector3d :

    C++ signature :
        class AcGeVector3d asVector(class AcGePoint3d {lvalue})'''
    ...
    def convert2d (self, *args, **kwargs):
      '''
convert2d( (Point3d)arg1, (object)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d convert2d(class AcGePoint3d {lvalue},class AcGePlanarEnt)'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Point3d)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double distanceTo(class AcGePoint3d {lvalue},class AcGePoint3d)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Point3d)arg1, (Point3d)arg2 [, (Tol)AcGeTol=<PyGe.Tol object at 0x000001F037793910>]) -> bool :

    C++ signature :
        bool isEqualTo(class AcGePoint3d {lvalue},class AcGePoint3d [,class AcGeTol=<PyGe.Tol object at 0x000001F037793910>])'''
    ...
    def kOrigin (self, *args, **kwargs):
      '''None'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Point3d)arg1, (object)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d {lvalue} mirror(class AcGePoint3d {lvalue},class AcGePlane)'''
    ...
    def orthoProject (self, *args, **kwargs):
      '''
orthoProject( (Point3d)arg1, (object)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d orthoProject(class AcGePoint3d {lvalue},class AcGePlane)'''
    ...
    def project (self, *args, **kwargs):
      '''
project( (Point3d)arg1, (object)arg2, (Vector3d)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d project(class AcGePoint3d {lvalue},class AcGePlane,class AcGeVector3d)'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Point3d)arg1, (float)arg2, (Vector3d)arg3 [, (Point3d)AcGePoint3d=<PyGe.Point3d object at 0x000001F037739E40>]) -> Point3d :

    C++ signature :
        class AcGePoint3d {lvalue} rotateBy(class AcGePoint3d {lvalue},double,class AcGeVector3d [,class AcGePoint3d=<PyGe.Point3d object at 0x000001F037739E40>])'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Point3d)arg1, (float)arg2 [, (Point3d)AcGePoint3d=<PyGe.Point3d object at 0x000001F037739EC0>]) -> Point3d :

    C++ signature :
        class AcGePoint3d {lvalue} scaleBy(class AcGePoint3d {lvalue},double [,class AcGePoint3d=<PyGe.Point3d object at 0x000001F037739EC0>])'''
    ...
    def set (self, *args, **kwargs):
      '''
set( (Point3d)arg1, (float)arg2, (float)arg3, (float)arg4) -> Point3d :

    C++ signature :
        class AcGePoint3d {lvalue} set(class AcGePoint3d {lvalue},double,double,double)

set( (Point3d)arg1, (object)arg2, (Point2d)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d {lvalue} set(class AcGePoint3d {lvalue},class AcGePlanarEnt,class AcGePoint2d)'''
    ...
    def setToProduct (self, *args, **kwargs):
      '''
setToProduct( (Point3d)arg1, (Matrix3d)arg2, (Point3d)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d {lvalue} setToProduct(class AcGePoint3d {lvalue},class AcGeMatrix3d,class AcGePoint3d)'''
    ...
    def setToSum (self, *args, **kwargs):
      '''
setToSum( (Point3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d {lvalue} setToSum(class AcGePoint3d {lvalue},class AcGePoint3d,class AcGeVector3d)'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (Point3d)arg1) -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > toString(class AcGePoint3d)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Point3d)arg1, (Matrix3d)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d {lvalue} transformBy(class AcGePoint3d {lvalue},class AcGeMatrix3d)'''
    ...
    def x (self, *args, **kwargs):
      '''None'''
    ...
    def y (self, *args, **kwargs):
      '''None'''
    ...
    def z (self, *args, **kwargs):
      '''None'''
    ...

class PointEnt2d:
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity2d)arg1) -> Entity2d :

    C++ signature :
        class PyGeEntity2d copy(class PyGeEntity2d {lvalue})'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity2d)arg1, (Entity2d)arg2) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d)

isEqualTo( (Entity2d)arg1, (Entity2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity2d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity2d {lvalue},enum AcGe::EntityId)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity2d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity2d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Entity2d)arg1, (Point2d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeEntity2d {lvalue},class AcGePoint2d)

isOn( (Entity2d)arg1, (Point2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeEntity2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity2d)arg1, (Line2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} mirror(class PyGeEntity2d {lvalue},class PyGeLine2d)'''
    ...
    def point2d (self, *args, **kwargs):
      '''
point2d( (PointEnt2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d point2d(class PyGePointEnt2d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double)

rotateBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double)

scaleBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity2d)arg1, (Matrix2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} transformBy(class PyGeEntity2d {lvalue},class AcGeMatrix2d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity2d)arg1, (Vector2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} translateBy(class PyGeEntity2d {lvalue},class AcGeVector2d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity2d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity2d {lvalue})'''
    ...

class PointEnt3d:
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity3d)arg1) -> Entity3d :

    C++ signature :
        class PyGeEntity3d copy(class PyGeEntity3d {lvalue})'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity3d)arg1, (Entity3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity3d {lvalue},class PyGeEntity3d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity3d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity3d {lvalue},enum AcGe::EntityId)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity3d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity3d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Entity3d)arg1, (Point3d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeEntity3d {lvalue},class AcGePoint3d)

isOn( (Entity3d)arg1, (Point3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeEntity3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} mirror(class PyGeEntity3d {lvalue},class PyGePlane)'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d)

rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3, (Point3d)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d,class AcGePoint3d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity3d)arg1, (float)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double)

scaleBy( (Entity3d)arg1, (float)arg2, (Point3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double,class AcGePoint3d)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity3d)arg1, (Matrix3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} transformBy(class PyGeEntity3d {lvalue},class AcGeMatrix3d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity3d)arg1, (Vector3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} translateBy(class PyGeEntity3d {lvalue},class AcGeVector3d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity3d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity3d {lvalue})'''
    ...

class PointOnCurve2d:
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity2d)arg1) -> Entity2d :

    C++ signature :
        class PyGeEntity2d copy(class PyGeEntity2d {lvalue})'''
    ...
    def curve (self, *args, **kwargs):
      '''
curve( (PointOnCurve2d)arg1) -> Curve2d :

    C++ signature :
        class PyGeCurve2d curve(class PyGePointOnCurve2d {lvalue})'''
    ...
    def deriv (self, *args, **kwargs):
      '''
deriv( (PointOnCurve2d)arg1, (CmdFlags)arg2) -> Vector2d :

    C++ signature :
        class AcGeVector2d deriv(class PyGePointOnCurve2d {lvalue},int)

deriv( (PointOnCurve2d)arg1, (CmdFlags)arg2, (float)arg3) -> Vector2d :

    C++ signature :
        class AcGeVector2d deriv(class PyGePointOnCurve2d {lvalue},int,double)

deriv( (PointOnCurve2d)arg1, (CmdFlags)arg2, (Curve2d)arg3, (float)arg4) -> Vector2d :

    C++ signature :
        class AcGeVector2d deriv(class PyGePointOnCurve2d {lvalue},int,class PyGeCurve2d,double)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity2d)arg1, (Entity2d)arg2) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d)

isEqualTo( (Entity2d)arg1, (Entity2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity2d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity2d {lvalue},enum AcGe::EntityId)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity2d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity2d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Entity2d)arg1, (Point2d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeEntity2d {lvalue},class AcGePoint2d)

isOn( (Entity2d)arg1, (Point2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeEntity2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity2d)arg1, (Line2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} mirror(class PyGeEntity2d {lvalue},class PyGeLine2d)'''
    ...
    def parameter (self, *args, **kwargs):
      '''
parameter( (PointOnCurve2d)arg1) -> float :

    C++ signature :
        double parameter(class PyGePointOnCurve2d {lvalue})'''
    ...
    def point (self, *args, **kwargs):
      '''
point( (PointOnCurve2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d point(class PyGePointOnCurve2d {lvalue})

point( (PointOnCurve2d)arg1, (float)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d point(class PyGePointOnCurve2d {lvalue},double)

point( (PointOnCurve2d)arg1, (Curve2d)arg2, (float)arg3) -> Point2d :

    C++ signature :
        class AcGePoint2d point(class PyGePointOnCurve2d {lvalue},class PyGeCurve2d,double)'''
    ...
    def point2d (self, *args, **kwargs):
      '''
point2d( (PointEnt2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d point2d(class PyGePointEnt2d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double)

rotateBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double)

scaleBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def setCurve (self, *args, **kwargs):
      '''
setCurve( (PointOnCurve2d)arg1, (Curve2d)arg2) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d {lvalue} setCurve(class PyGePointOnCurve2d {lvalue},class PyGeCurve2d)'''
    ...
    def setParameter (self, *args, **kwargs):
      '''
setParameter( (PointOnCurve2d)arg1, (float)arg2) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d {lvalue} setParameter(class PyGePointOnCurve2d {lvalue},double)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity2d)arg1, (Matrix2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} transformBy(class PyGeEntity2d {lvalue},class AcGeMatrix2d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity2d)arg1, (Vector2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} translateBy(class PyGeEntity2d {lvalue},class AcGeVector2d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity2d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity2d {lvalue})'''
    ...

class PointOnCurve3d:
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity3d)arg1) -> Entity3d :

    C++ signature :
        class PyGeEntity3d copy(class PyGeEntity3d {lvalue})'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity3d)arg1, (Entity3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity3d {lvalue},class PyGeEntity3d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity3d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity3d {lvalue},enum AcGe::EntityId)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity3d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity3d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Entity3d)arg1, (Point3d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeEntity3d {lvalue},class AcGePoint3d)

isOn( (Entity3d)arg1, (Point3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeEntity3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} mirror(class PyGeEntity3d {lvalue},class PyGePlane)'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d)

rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3, (Point3d)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d,class AcGePoint3d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity3d)arg1, (float)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double)

scaleBy( (Entity3d)arg1, (float)arg2, (Point3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double,class AcGePoint3d)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity3d)arg1, (Matrix3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} transformBy(class PyGeEntity3d {lvalue},class AcGeMatrix3d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity3d)arg1, (Vector3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} translateBy(class PyGeEntity3d {lvalue},class AcGeVector3d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity3d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity3d {lvalue})'''
    ...

class Polyline2d:
    def area (self, *args, **kwargs):
      '''
area( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double area(class PyGeCurve2d {lvalue},double,double)

area( (Curve2d)arg1, (float)arg2, (float)arg3, (Tol)arg4) -> float :

    C++ signature :
        double area(class PyGeCurve2d {lvalue},double,double,class AcGeTol)'''
    ...
    def boundBlock (self, *args, **kwargs):
      '''
boundBlock( (Curve2d)arg1) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d boundBlock(class PyGeCurve2d {lvalue})

boundBlock( (Curve2d)arg1, (Interval)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d boundBlock(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Curve2d)arg1, (Point2d)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d closestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

closestPointTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> Point2d :

    C++ signature :
        class AcGePoint2d closestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

closestPointTo( (Curve2d)arg1, (Curve2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

closestPointTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def continuityAtKnot (self, *args, **kwargs):
      '''
continuityAtKnot( (SplineEnt2d)arg1, (CmdFlags)arg2) -> int :

    C++ signature :
        int continuityAtKnot(class PyGeSplineEnt2d {lvalue},int)

continuityAtKnot( (SplineEnt2d)arg1, (CmdFlags)arg2, (Tol)arg3) -> int :

    C++ signature :
        int continuityAtKnot(class PyGeSplineEnt2d {lvalue},int,class AcGeTol)'''
    ...
    def controlPointAt (self, *args, **kwargs):
      '''
controlPointAt( (SplineEnt2d)arg1, (CmdFlags)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d controlPointAt(class PyGeSplineEnt2d {lvalue},int)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity2d)arg1) -> Entity2d :

    C++ signature :
        class PyGeEntity2d copy(class PyGeEntity2d {lvalue})'''
    ...
    def degree (self, *args, **kwargs):
      '''
degree( (SplineEnt2d)arg1) -> int :

    C++ signature :
        int degree(class PyGeSplineEnt2d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Curve2d)arg1, (Point2d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

distanceTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

distanceTo( (Curve2d)arg1, (Curve2d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

distanceTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def endParam (self, *args, **kwargs):
      '''
endParam( (SplineEnt2d)arg1) -> float :

    C++ signature :
        double endParam(class PyGeSplineEnt2d {lvalue})'''
    ...
    def endPoint (self, *args, **kwargs):
      '''
endPoint( (SplineEnt2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d endPoint(class PyGeSplineEnt2d {lvalue})'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Curve2d)arg1, (float)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d evalPoint(class PyGeCurve2d {lvalue},double)

evalPoint( (Curve2d)arg1, (float)arg2, (CmdFlags)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple evalPoint(class PyGeCurve2d {lvalue},double,int)'''
    ...
    def explode (self, *args, **kwargs):
      '''
explode( (Curve2d)arg1) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve2d {lvalue})

explode( (Curve2d)arg1, (Interval)arg2) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def fitPointAt (self, *args, **kwargs):
      '''
fitPointAt( (Polyline2d)arg1, (CmdFlags)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d fitPointAt(class PyGePolyline2d {lvalue},int)'''
    ...
    def getClosestPointTo (self, *args, **kwargs):
      '''
getClosestPointTo( (Curve2d)arg1, (Point2d)arg2) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getClosestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

getClosestPointTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getClosestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def getClosestPointsTo (self, *args, **kwargs):
      '''
getClosestPointsTo( (Curve2d)arg1, (Curve2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

getClosestPointsTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def getEndPoint (self, *args, **kwargs):
      '''
getEndPoint( (Curve2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getEndPoint(class PyGeCurve2d {lvalue})'''
    ...
    def getInterval (self, *args, **kwargs):
      '''
getInterval( (Curve2d)arg1) -> Interval :

    C++ signature :
        class PyGeInterval getInterval(class PyGeCurve2d {lvalue})'''
    ...
    def getNormalPoint (self, *args, **kwargs):
      '''
getNormalPoint( (Curve2d)arg1, (Point2d)arg2) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getNormalPoint(class PyGeCurve2d {lvalue},class AcGePoint2d)

getNormalPoint( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getNormalPoint(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def getSamplePoints (self, *args, **kwargs):
      '''
getSamplePoints( (Curve2d)arg1, (CmdFlags)arg2) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve2d {lvalue},int)

getSamplePoints( (Curve2d)arg1, (float)arg2, (float)arg3, (float)arg4) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve2d {lvalue},double,double,double)'''
    ...
    def getSplitCurves (self, *args, **kwargs):
      '''
getSplitCurves( (Curve2d)arg1, (float)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getSplitCurves(class PyGeCurve2d {lvalue},double)'''
    ...
    def getStartPoint (self, *args, **kwargs):
      '''
getStartPoint( (Curve2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getStartPoint(class PyGeCurve2d {lvalue})'''
    ...
    def getTrimmedOffset (self, *args, **kwargs):
      '''
getTrimmedOffset( (Curve2d)arg1, (float)arg2, (OffsetCrvExtType)arg3) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve2d {lvalue},double,enum AcGe::OffsetCrvExtType)

getTrimmedOffset( (Curve2d)arg1, (float)arg2, (OffsetCrvExtType)arg3, (Tol)arg4) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve2d {lvalue},double,enum AcGe::OffsetCrvExtType,class AcGeTol)'''
    ...
    def hasEndPoint (self, *args, **kwargs):
      '''
hasEndPoint( (Curve2d)arg1) -> bool :

    C++ signature :
        bool hasEndPoint(class PyGeCurve2d {lvalue})'''
    ...
    def hasFitData (self, *args, **kwargs):
      '''
hasFitData( (SplineEnt2d)arg1) -> bool :

    C++ signature :
        bool hasFitData(class PyGeSplineEnt2d {lvalue})'''
    ...
    def hasStartPoint (self, *args, **kwargs):
      '''
hasStartPoint( (Curve2d)arg1) -> bool :

    C++ signature :
        bool hasStartPoint(class PyGeCurve2d {lvalue})'''
    ...
    def isClosed (self, *args, **kwargs):
      '''
isClosed( (Curve2d)arg1) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve2d {lvalue})

isClosed( (Curve2d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isDegenerate (self, *args, **kwargs):
      '''
isDegenerate( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve2d {lvalue})

isDegenerate( (Curve2d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity2d)arg1, (Entity2d)arg2) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d)

isEqualTo( (Entity2d)arg1, (Entity2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity2d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity2d {lvalue},enum AcGe::EntityId)'''
    ...
    def isLinear (self, *args, **kwargs):
      '''
isLinear( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve2d {lvalue})

isLinear( (Curve2d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity2d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity2d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Curve2d)arg1, (Point2d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d)

isOn( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

isOn( (Curve2d)arg1, (Point2d)arg2, (float)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,double {lvalue})

isOn( (Curve2d)arg1, (Point2d)arg2, (float)arg3, (Tol)arg4) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,double {lvalue},class AcGeTol)

isOn( (Curve2d)arg1, (float)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},double)

isOn( (Curve2d)arg1, (float)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},double,class AcGeTol)'''
    ...
    def isPeriodic (self, *args, **kwargs):
      '''
isPeriodic( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPeriodic(class PyGeCurve2d {lvalue})'''
    ...
    def isRational (self, *args, **kwargs):
      '''
isRational( (SplineEnt2d)arg1) -> bool :

    C++ signature :
        bool isRational(class PyGeSplineEnt2d {lvalue})'''
    ...
    def knotAt (self, *args, **kwargs):
      '''
knotAt( (SplineEnt2d)arg1, (CmdFlags)arg2) -> float :

    C++ signature :
        double knotAt(class PyGeSplineEnt2d {lvalue},int)'''
    ...
    def knots (self, *args, **kwargs):
      '''
knots( (SplineEnt2d)arg1) -> KnotVector :

    C++ signature :
        class PyGeKnotVector knots(class PyGeSplineEnt2d {lvalue})'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double length(class PyGeCurve2d {lvalue},double,double)

length( (Curve2d)arg1, (float)arg2, (float)arg3, (float)arg4) -> float :

    C++ signature :
        double length(class PyGeCurve2d {lvalue},double,double,double)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity2d)arg1, (Line2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} mirror(class PyGeEntity2d {lvalue},class PyGeLine2d)'''
    ...
    def numControlPoints (self, *args, **kwargs):
      '''
numControlPoints( (SplineEnt2d)arg1) -> int :

    C++ signature :
        int numControlPoints(class PyGeSplineEnt2d {lvalue})'''
    ...
    def numFitPoints (self, *args, **kwargs):
      '''
numFitPoints( (Polyline2d)arg1) -> int :

    C++ signature :
        int numFitPoints(class PyGePolyline2d {lvalue})'''
    ...
    def numKnots (self, *args, **kwargs):
      '''
numKnots( (SplineEnt2d)arg1) -> int :

    C++ signature :
        int numKnots(class PyGeSplineEnt2d {lvalue})'''
    ...
    def order (self, *args, **kwargs):
      '''
order( (SplineEnt2d)arg1) -> int :

    C++ signature :
        int order(class PyGeSplineEnt2d {lvalue})'''
    ...
    def orthoBoundBlock (self, *args, **kwargs):
      '''
orthoBoundBlock( (Curve2d)arg1) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d orthoBoundBlock(class PyGeCurve2d {lvalue})

orthoBoundBlock( (Curve2d)arg1, (Interval)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d orthoBoundBlock(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def paramAtLength (self, *args, **kwargs):
      '''
paramAtLength( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve2d {lvalue},double,double)

paramAtLength( (Curve2d)arg1, (float)arg2, (float)arg3, (bool)arg4, (float)arg5) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve2d {lvalue},double,double,bool,double)'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Curve2d)arg1, (Point2d)arg2) -> float :

    C++ signature :
        double paramOf(class PyGeCurve2d {lvalue},class AcGePoint2d)

paramOf( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double paramOf(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def reverseParam (self, *args, **kwargs):
      '''
reverseParam( (Curve2d)arg1) -> Curve2d :

    C++ signature :
        class PyGeCurve2d {lvalue} reverseParam(class PyGeCurve2d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double)

rotateBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double)

scaleBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def setControlPointAt (self, *args, **kwargs):
      '''
setControlPointAt( (SplineEnt2d)arg1, (CmdFlags)arg2, (Point2d)arg3) -> SplineEnt2d :

    C++ signature :
        class PyGeSplineEnt2d {lvalue} setControlPointAt(class PyGeSplineEnt2d {lvalue},int,class AcGePoint2d)'''
    ...
    def setFitPointAt (self, *args, **kwargs):
      '''
setFitPointAt( (Polyline2d)arg1, (CmdFlags)arg2, (Point2d)arg3) -> Polyline2d :

    C++ signature :
        class PyGePolyline2d {lvalue} setFitPointAt(class PyGePolyline2d {lvalue},int,class AcGePoint2d)'''
    ...
    def setInterval (self, *args, **kwargs):
      '''
setInterval( (Curve2d)arg1) -> Curve2d :

    C++ signature :
        class PyGeCurve2d {lvalue} setInterval(class PyGeCurve2d {lvalue})

setInterval( (Curve2d)arg1, (Interval)arg2) -> bool :

    C++ signature :
        bool setInterval(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def setKnotAt (self, *args, **kwargs):
      '''
setKnotAt( (SplineEnt2d)arg1, (CmdFlags)arg2, (float)arg3) -> SplineEnt2d :

    C++ signature :
        class PyGeSplineEnt2d {lvalue} setKnotAt(class PyGeSplineEnt2d {lvalue},int,double)'''
    ...
    def startParam (self, *args, **kwargs):
      '''
startParam( (SplineEnt2d)arg1) -> float :

    C++ signature :
        double startParam(class PyGeSplineEnt2d {lvalue})'''
    ...
    def startPoint (self, *args, **kwargs):
      '''
startPoint( (SplineEnt2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d startPoint(class PyGeSplineEnt2d {lvalue})'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity2d)arg1, (Matrix2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} transformBy(class PyGeEntity2d {lvalue},class AcGeMatrix2d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity2d)arg1, (Vector2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} translateBy(class PyGeEntity2d {lvalue},class AcGeVector2d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity2d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity2d {lvalue})'''
    ...

class Polyline3d:
    def area (self, *args, **kwargs):
      '''
area( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double area(class PyGeCurve3d {lvalue},double,double)

area( (Curve3d)arg1, (float)arg2, (float)arg3, (Tol)arg4) -> float :

    C++ signature :
        double area(class PyGeCurve3d {lvalue},double,double,class AcGeTol)'''
    ...
    def boundBlock (self, *args, **kwargs):
      '''
boundBlock( (Curve3d)arg1) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d boundBlock(class PyGeCurve3d {lvalue})

boundBlock( (Curve3d)arg1, (Interval)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d boundBlock(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Curve3d)arg1, (Point3d)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

closestPointTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

closestPointTo( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

closestPointTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def continuityAtKnot (self, *args, **kwargs):
      '''
continuityAtKnot( (SplineEnt3d)arg1, (CmdFlags)arg2) -> int :

    C++ signature :
        int continuityAtKnot(class PyGeSplineEnt3d {lvalue},int)

continuityAtKnot( (SplineEnt3d)arg1, (CmdFlags)arg2, (Tol)arg3) -> int :

    C++ signature :
        int continuityAtKnot(class PyGeSplineEnt3d {lvalue},int,class AcGeTol)'''
    ...
    def controlPointAt (self, *args, **kwargs):
      '''
controlPointAt( (SplineEnt3d)arg1, (CmdFlags)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d controlPointAt(class PyGeSplineEnt3d {lvalue},int)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity3d)arg1) -> Entity3d :

    C++ signature :
        class PyGeEntity3d copy(class PyGeEntity3d {lvalue})'''
    ...
    def degree (self, *args, **kwargs):
      '''
degree( (SplineEnt3d)arg1) -> int :

    C++ signature :
        int degree(class PyGeSplineEnt3d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Curve3d)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

distanceTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

distanceTo( (Curve3d)arg1, (Curve3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

distanceTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def endParam (self, *args, **kwargs):
      '''
endParam( (SplineEnt3d)arg1) -> float :

    C++ signature :
        double endParam(class PyGeSplineEnt3d {lvalue})'''
    ...
    def endPoint (self, *args, **kwargs):
      '''
endPoint( (SplineEnt3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d endPoint(class PyGeSplineEnt3d {lvalue})'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Curve3d)arg1, (float)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d evalPoint(class PyGeCurve3d {lvalue},double)

evalPoint( (Curve3d)arg1, (float)arg2, (CmdFlags)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple evalPoint(class PyGeCurve3d {lvalue},double,int)'''
    ...
    def explode (self, *args, **kwargs):
      '''
explode( (Curve3d)arg1) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve3d {lvalue})

explode( (Curve3d)arg1, (Interval)arg2) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def fitPointAt (self, *args, **kwargs):
      '''
fitPointAt( (Polyline3d)arg1, (CmdFlags)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d fitPointAt(class PyGePolyline3d {lvalue},int)'''
    ...
    def getClosestPointTo (self, *args, **kwargs):
      '''
getClosestPointTo( (Curve3d)arg1, (Point3d)arg2) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

getClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def getClosestPointsTo (self, *args, **kwargs):
      '''
getClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

getClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def getEndPoint (self, *args, **kwargs):
      '''
getEndPoint( (Curve3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getEndPoint(class PyGeCurve3d {lvalue})'''
    ...
    def getInterval (self, *args, **kwargs):
      '''
getInterval( (Curve3d)arg1) -> Interval :

    C++ signature :
        class PyGeInterval getInterval(class PyGeCurve3d {lvalue})'''
    ...
    def getNormalPoint (self, *args, **kwargs):
      '''
getNormalPoint( (Curve3d)arg1, (Point3d)arg2) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getNormalPoint(class PyGeCurve3d {lvalue},class AcGePoint3d)

getNormalPoint( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getNormalPoint(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def getProjClosestPointTo (self, *args, **kwargs):
      '''
getProjClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getProjClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d)

getProjClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Tol)arg4) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getProjClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def getProjClosestPointsTo (self, *args, **kwargs):
      '''
getProjClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getProjClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d)

getProjClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple getProjClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def getSamplePoints (self, *args, **kwargs):
      '''
getSamplePoints( (Curve3d)arg1, (CmdFlags)arg2) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve3d {lvalue},int)

getSamplePoints( (Curve3d)arg1, (float)arg2, (float)arg3, (float)arg4) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve3d {lvalue},double,double,double)'''
    ...
    def getSplitCurves (self, *args, **kwargs):
      '''
getSplitCurves( (Curve3d)arg1, (float)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getSplitCurves(class PyGeCurve3d {lvalue},double)'''
    ...
    def getStartPoint (self, *args, **kwargs):
      '''
getStartPoint( (Curve3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getStartPoint(class PyGeCurve3d {lvalue})'''
    ...
    def getTrimmedOffset (self, *args, **kwargs):
      '''
getTrimmedOffset( (Curve3d)arg1, (float)arg2, (Vector3d)arg3, (OffsetCrvExtType)arg4) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve3d {lvalue},double,class AcGeVector3d,enum AcGe::OffsetCrvExtType)

getTrimmedOffset( (Curve3d)arg1, (float)arg2, (Vector3d)arg3, (OffsetCrvExtType)arg4, (Tol)arg5) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve3d {lvalue},double,class AcGeVector3d,enum AcGe::OffsetCrvExtType,class AcGeTol)'''
    ...
    def hasEndPoint (self, *args, **kwargs):
      '''
hasEndPoint( (Curve3d)arg1) -> bool :

    C++ signature :
        bool hasEndPoint(class PyGeCurve3d {lvalue})'''
    ...
    def hasFitData (self, *args, **kwargs):
      '''
hasFitData( (SplineEnt3d)arg1) -> bool :

    C++ signature :
        bool hasFitData(class PyGeSplineEnt3d {lvalue})'''
    ...
    def hasStartPoint (self, *args, **kwargs):
      '''
hasStartPoint( (Curve3d)arg1) -> bool :

    C++ signature :
        bool hasStartPoint(class PyGeCurve3d {lvalue})'''
    ...
    def isClosed (self, *args, **kwargs):
      '''
isClosed( (Curve3d)arg1) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve3d {lvalue})

isClosed( (Curve3d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isCoplanarWith (self, *args, **kwargs):
      '''
isCoplanarWith( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isCoplanarWith(class PyGeCurve3d {lvalue},class PyGeCurve3d)

isCoplanarWith( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple isCoplanarWith(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def isDegenerate (self, *args, **kwargs):
      '''
isDegenerate( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve3d {lvalue})

isDegenerate( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity3d)arg1, (Entity3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity3d {lvalue},class PyGeEntity3d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity3d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity3d {lvalue},enum AcGe::EntityId)'''
    ...
    def isLinear (self, *args, **kwargs):
      '''
isLinear( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve3d {lvalue})

isLinear( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity3d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity3d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Curve3d)arg1, (Point3d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d)

isOn( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

isOn( (Curve3d)arg1, (Point3d)arg2, (float)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d,double {lvalue})

isOn( (Curve3d)arg1, (Point3d)arg2, (float)arg3, (Tol)arg4) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d,double {lvalue},class AcGeTol)

isOn( (Curve3d)arg1, (float)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},double)

isOn( (Curve3d)arg1, (float)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},double,class AcGeTol)'''
    ...
    def isPeriodic (self, *args, **kwargs):
      '''
isPeriodic( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPeriodic(class PyGeCurve3d {lvalue})'''
    ...
    def isPlanar (self, *args, **kwargs):
      '''
isPlanar( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPlanar(class PyGeCurve3d {lvalue})

isPlanar( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isPlanar(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isRational (self, *args, **kwargs):
      '''
isRational( (SplineEnt3d)arg1) -> bool :

    C++ signature :
        bool isRational(class PyGeSplineEnt3d {lvalue})'''
    ...
    def knotAt (self, *args, **kwargs):
      '''
knotAt( (SplineEnt3d)arg1, (CmdFlags)arg2) -> float :

    C++ signature :
        double knotAt(class PyGeSplineEnt3d {lvalue},int)'''
    ...
    def knots (self, *args, **kwargs):
      '''
knots( (SplineEnt3d)arg1) -> KnotVector :

    C++ signature :
        class PyGeKnotVector knots(class PyGeSplineEnt3d {lvalue})'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double length(class PyGeCurve3d {lvalue},double,double)

length( (Curve3d)arg1, (float)arg2, (float)arg3, (float)arg4) -> float :

    C++ signature :
        double length(class PyGeCurve3d {lvalue},double,double,double)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} mirror(class PyGeEntity3d {lvalue},class PyGePlane)'''
    ...
    def numControlPoints (self, *args, **kwargs):
      '''
numControlPoints( (SplineEnt3d)arg1) -> int :

    C++ signature :
        int numControlPoints(class PyGeSplineEnt3d {lvalue})'''
    ...
    def numFitPoints (self, *args, **kwargs):
      '''
numFitPoints( (Polyline3d)arg1) -> int :

    C++ signature :
        int numFitPoints(class PyGePolyline3d {lvalue})'''
    ...
    def numKnots (self, *args, **kwargs):
      '''
numKnots( (SplineEnt3d)arg1) -> int :

    C++ signature :
        int numKnots(class PyGeSplineEnt3d {lvalue})'''
    ...
    def order (self, *args, **kwargs):
      '''
order( (SplineEnt3d)arg1) -> int :

    C++ signature :
        int order(class PyGeSplineEnt3d {lvalue})'''
    ...
    def orthoBoundBlock (self, *args, **kwargs):
      '''
orthoBoundBlock( (Curve3d)arg1) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d orthoBoundBlock(class PyGeCurve3d {lvalue})

orthoBoundBlock( (Curve3d)arg1, (Interval)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d orthoBoundBlock(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def orthoProject (self, *args, **kwargs):
      '''
orthoProject( (Curve3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d orthoProject(class PyGeCurve3d {lvalue},class PyGePlane)

orthoProject( (Curve3d)arg1, (Plane)arg2, (Tol)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d orthoProject(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeTol)'''
    ...
    def paramAtLength (self, *args, **kwargs):
      '''
paramAtLength( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve3d {lvalue},double,double)

paramAtLength( (Curve3d)arg1, (float)arg2, (float)arg3, (bool)arg4, (float)arg5) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve3d {lvalue},double,double,bool,double)'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Curve3d)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double paramOf(class PyGeCurve3d {lvalue},class AcGePoint3d)

paramOf( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double paramOf(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def projClosestPointTo (self, *args, **kwargs):
      '''
projClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d projClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d)

projClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Tol)arg4) -> Point3d :

    C++ signature :
        class AcGePoint3d projClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def projClosestPointsTo (self, *args, **kwargs):
      '''
projClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple projClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d)

projClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple projClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def project (self, *args, **kwargs):
      '''
project( (Curve3d)arg1, (Plane)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d project(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeVector3d)

project( (Curve3d)arg1, (Plane)arg2, (Vector3d)arg3, (Tol)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d project(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeVector3d,class AcGeTol)'''
    ...
    def reverseParam (self, *args, **kwargs):
      '''
reverseParam( (Curve3d)arg1) -> Curve3d :

    C++ signature :
        class PyGeCurve3d {lvalue} reverseParam(class PyGeCurve3d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d)

rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3, (Point3d)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d,class AcGePoint3d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity3d)arg1, (float)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double)

scaleBy( (Entity3d)arg1, (float)arg2, (Point3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double,class AcGePoint3d)'''
    ...
    def setControlPointAt (self, *args, **kwargs):
      '''
setControlPointAt( (SplineEnt3d)arg1, (CmdFlags)arg2, (Point3d)arg3) -> SplineEnt3d :

    C++ signature :
        class PyGeSplineEnt3d {lvalue} setControlPointAt(class PyGeSplineEnt3d {lvalue},int,class AcGePoint3d)'''
    ...
    def setFitPointAt (self, *args, **kwargs):
      '''
setFitPointAt( (Polyline3d)arg1, (CmdFlags)arg2, (Point3d)arg3) -> Polyline3d :

    C++ signature :
        class PyGePolyline3d {lvalue} setFitPointAt(class PyGePolyline3d {lvalue},int,class AcGePoint3d)'''
    ...
    def setInterval (self, *args, **kwargs):
      '''
setInterval( (Curve3d)arg1) -> Curve3d :

    C++ signature :
        class PyGeCurve3d {lvalue} setInterval(class PyGeCurve3d {lvalue})

setInterval( (Curve3d)arg1, (Interval)arg2) -> bool :

    C++ signature :
        bool setInterval(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def setKnotAt (self, *args, **kwargs):
      '''
setKnotAt( (SplineEnt3d)arg1, (CmdFlags)arg2, (float)arg3) -> SplineEnt3d :

    C++ signature :
        class PyGeSplineEnt3d {lvalue} setKnotAt(class PyGeSplineEnt3d {lvalue},int,double)'''
    ...
    def startParam (self, *args, **kwargs):
      '''
startParam( (SplineEnt3d)arg1) -> float :

    C++ signature :
        double startParam(class PyGeSplineEnt3d {lvalue})'''
    ...
    def startPoint (self, *args, **kwargs):
      '''
startPoint( (SplineEnt3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d startPoint(class PyGeSplineEnt3d {lvalue})'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity3d)arg1, (Matrix3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} transformBy(class PyGeEntity3d {lvalue},class AcGeMatrix3d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity3d)arg1, (Vector3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} translateBy(class PyGeEntity3d {lvalue},class AcGeVector3d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity3d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity3d {lvalue})'''
    ...

class Position2d:
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity2d)arg1) -> Entity2d :

    C++ signature :
        class PyGeEntity2d copy(class PyGeEntity2d {lvalue})'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity2d)arg1, (Entity2d)arg2) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d)

isEqualTo( (Entity2d)arg1, (Entity2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity2d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity2d {lvalue},enum AcGe::EntityId)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity2d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity2d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Entity2d)arg1, (Point2d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeEntity2d {lvalue},class AcGePoint2d)

isOn( (Entity2d)arg1, (Point2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeEntity2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity2d)arg1, (Line2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} mirror(class PyGeEntity2d {lvalue},class PyGeLine2d)'''
    ...
    def point2d (self, *args, **kwargs):
      '''
point2d( (PointEnt2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d point2d(class PyGePointEnt2d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double)

rotateBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double)

scaleBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def set (self, *args, **kwargs):
      '''
set( (Position2d)arg1, (Point2d)arg2) -> Position2d :

    C++ signature :
        class PyGePosition2d {lvalue} set(class PyGePosition2d {lvalue},class AcGePoint2d)

set( (Position2d)arg1, (float)arg2, (float)arg3) -> Position2d :

    C++ signature :
        class PyGePosition2d {lvalue} set(class PyGePosition2d {lvalue},double,double)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity2d)arg1, (Matrix2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} transformBy(class PyGeEntity2d {lvalue},class AcGeMatrix2d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity2d)arg1, (Vector2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} translateBy(class PyGeEntity2d {lvalue},class AcGeVector2d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity2d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity2d {lvalue})'''
    ...

class Position3d:
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity3d)arg1) -> Entity3d :

    C++ signature :
        class PyGeEntity3d copy(class PyGeEntity3d {lvalue})'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity3d)arg1, (Entity3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity3d {lvalue},class PyGeEntity3d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity3d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity3d {lvalue},enum AcGe::EntityId)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity3d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity3d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Entity3d)arg1, (Point3d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeEntity3d {lvalue},class AcGePoint3d)

isOn( (Entity3d)arg1, (Point3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeEntity3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} mirror(class PyGeEntity3d {lvalue},class PyGePlane)'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d)

rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3, (Point3d)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d,class AcGePoint3d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity3d)arg1, (float)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double)

scaleBy( (Entity3d)arg1, (float)arg2, (Point3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double,class AcGePoint3d)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity3d)arg1, (Matrix3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} transformBy(class PyGeEntity3d {lvalue},class AcGeMatrix3d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity3d)arg1, (Vector3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} translateBy(class PyGeEntity3d {lvalue},class AcGeVector3d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity3d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity3d {lvalue})'''
    ...

class Ray2d:
    def area (self, *args, **kwargs):
      '''
area( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double area(class PyGeCurve2d {lvalue},double,double)

area( (Curve2d)arg1, (float)arg2, (float)arg3, (Tol)arg4) -> float :

    C++ signature :
        double area(class PyGeCurve2d {lvalue},double,double,class AcGeTol)'''
    ...
    def boundBlock (self, *args, **kwargs):
      '''
boundBlock( (Curve2d)arg1) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d boundBlock(class PyGeCurve2d {lvalue})

boundBlock( (Curve2d)arg1, (Interval)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d boundBlock(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Curve2d)arg1, (Point2d)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d closestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

closestPointTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> Point2d :

    C++ signature :
        class AcGePoint2d closestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

closestPointTo( (Curve2d)arg1, (Curve2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

closestPointTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity2d)arg1) -> Entity2d :

    C++ signature :
        class PyGeEntity2d copy(class PyGeEntity2d {lvalue})'''
    ...
    def direction (self, *args, **kwargs):
      '''
direction( (LinearEnt2d)arg1) -> Vector2d :

    C++ signature :
        class AcGeVector2d direction(class PyGeLinearEnt2d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Curve2d)arg1, (Point2d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

distanceTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

distanceTo( (Curve2d)arg1, (Curve2d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

distanceTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Curve2d)arg1, (float)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d evalPoint(class PyGeCurve2d {lvalue},double)

evalPoint( (Curve2d)arg1, (float)arg2, (CmdFlags)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple evalPoint(class PyGeCurve2d {lvalue},double,int)'''
    ...
    def explode (self, *args, **kwargs):
      '''
explode( (Curve2d)arg1) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve2d {lvalue})

explode( (Curve2d)arg1, (Interval)arg2) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def getClosestPointTo (self, *args, **kwargs):
      '''
getClosestPointTo( (Curve2d)arg1, (Point2d)arg2) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getClosestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

getClosestPointTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getClosestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def getClosestPointsTo (self, *args, **kwargs):
      '''
getClosestPointsTo( (Curve2d)arg1, (Curve2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

getClosestPointsTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def getEndPoint (self, *args, **kwargs):
      '''
getEndPoint( (Curve2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getEndPoint(class PyGeCurve2d {lvalue})'''
    ...
    def getInterval (self, *args, **kwargs):
      '''
getInterval( (Curve2d)arg1) -> Interval :

    C++ signature :
        class PyGeInterval getInterval(class PyGeCurve2d {lvalue})'''
    ...
    def getLine (self, *args, **kwargs):
      '''
getLine( (LinearEnt2d)arg1) -> Line2d :

    C++ signature :
        class PyGeLine2d getLine(class PyGeLinearEnt2d {lvalue})'''
    ...
    def getNormalPoint (self, *args, **kwargs):
      '''
getNormalPoint( (Curve2d)arg1, (Point2d)arg2) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getNormalPoint(class PyGeCurve2d {lvalue},class AcGePoint2d)

getNormalPoint( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getNormalPoint(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def getPerpLine (self, *args, **kwargs):
      '''
getPerpLine( (LinearEnt2d)arg1, (Point2d)arg2) -> Line2d :

    C++ signature :
        class PyGeLine2d getPerpLine(class PyGeLinearEnt2d {lvalue},class AcGePoint2d)'''
    ...
    def getSamplePoints (self, *args, **kwargs):
      '''
getSamplePoints( (Curve2d)arg1, (CmdFlags)arg2) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve2d {lvalue},int)

getSamplePoints( (Curve2d)arg1, (float)arg2, (float)arg3, (float)arg4) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve2d {lvalue},double,double,double)'''
    ...
    def getSplitCurves (self, *args, **kwargs):
      '''
getSplitCurves( (Curve2d)arg1, (float)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getSplitCurves(class PyGeCurve2d {lvalue},double)'''
    ...
    def getStartPoint (self, *args, **kwargs):
      '''
getStartPoint( (Curve2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getStartPoint(class PyGeCurve2d {lvalue})'''
    ...
    def getTrimmedOffset (self, *args, **kwargs):
      '''
getTrimmedOffset( (Curve2d)arg1, (float)arg2, (OffsetCrvExtType)arg3) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve2d {lvalue},double,enum AcGe::OffsetCrvExtType)

getTrimmedOffset( (Curve2d)arg1, (float)arg2, (OffsetCrvExtType)arg3, (Tol)arg4) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve2d {lvalue},double,enum AcGe::OffsetCrvExtType,class AcGeTol)'''
    ...
    def hasEndPoint (self, *args, **kwargs):
      '''
hasEndPoint( (Curve2d)arg1) -> bool :

    C++ signature :
        bool hasEndPoint(class PyGeCurve2d {lvalue})'''
    ...
    def hasStartPoint (self, *args, **kwargs):
      '''
hasStartPoint( (Curve2d)arg1) -> bool :

    C++ signature :
        bool hasStartPoint(class PyGeCurve2d {lvalue})'''
    ...
    def intersectWith (self, *args, **kwargs):
      '''
intersectWith( (LinearEnt2d)arg1, (LinearEnt2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d)

intersectWith( (LinearEnt2d)arg1, (LinearEnt2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d,class AcGeTol)'''
    ...
    def isClosed (self, *args, **kwargs):
      '''
isClosed( (Curve2d)arg1) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve2d {lvalue})

isClosed( (Curve2d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isColinearTo (self, *args, **kwargs):
      '''
isColinearTo( (LinearEnt2d)arg1, (LinearEnt2d)arg2) -> bool :

    C++ signature :
        bool isColinearTo(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d)

isColinearTo( (LinearEnt2d)arg1, (LinearEnt2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isColinearTo(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d,class AcGeTol)'''
    ...
    def isDegenerate (self, *args, **kwargs):
      '''
isDegenerate( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve2d {lvalue})

isDegenerate( (Curve2d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity2d)arg1, (Entity2d)arg2) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d)

isEqualTo( (Entity2d)arg1, (Entity2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity2d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity2d {lvalue},enum AcGe::EntityId)'''
    ...
    def isLinear (self, *args, **kwargs):
      '''
isLinear( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve2d {lvalue})

isLinear( (Curve2d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity2d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity2d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Curve2d)arg1, (Point2d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d)

isOn( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

isOn( (Curve2d)arg1, (Point2d)arg2, (float)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,double {lvalue})

isOn( (Curve2d)arg1, (Point2d)arg2, (float)arg3, (Tol)arg4) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,double {lvalue},class AcGeTol)

isOn( (Curve2d)arg1, (float)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},double)

isOn( (Curve2d)arg1, (float)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},double,class AcGeTol)'''
    ...
    def isParallelTo (self, *args, **kwargs):
      '''
isParallelTo( (LinearEnt2d)arg1, (LinearEnt2d)arg2) -> bool :

    C++ signature :
        bool isParallelTo(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d)

isParallelTo( (LinearEnt2d)arg1, (LinearEnt2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isParallelTo(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d,class AcGeTol)'''
    ...
    def isPeriodic (self, *args, **kwargs):
      '''
isPeriodic( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPeriodic(class PyGeCurve2d {lvalue})'''
    ...
    def isPerpendicularTo (self, *args, **kwargs):
      '''
isPerpendicularTo( (LinearEnt2d)arg1, (LinearEnt2d)arg2) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d)

isPerpendicularTo( (LinearEnt2d)arg1, (LinearEnt2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d,class AcGeTol)'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double length(class PyGeCurve2d {lvalue},double,double)

length( (Curve2d)arg1, (float)arg2, (float)arg3, (float)arg4) -> float :

    C++ signature :
        double length(class PyGeCurve2d {lvalue},double,double,double)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity2d)arg1, (Line2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} mirror(class PyGeEntity2d {lvalue},class PyGeLine2d)'''
    ...
    def orthoBoundBlock (self, *args, **kwargs):
      '''
orthoBoundBlock( (Curve2d)arg1) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d orthoBoundBlock(class PyGeCurve2d {lvalue})

orthoBoundBlock( (Curve2d)arg1, (Interval)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d orthoBoundBlock(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def overlap (self, *args, **kwargs):
      '''
overlap( (LinearEnt2d)arg1, (LinearEnt2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple overlap(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d)

overlap( (LinearEnt2d)arg1, (LinearEnt2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple overlap(class PyGeLinearEnt2d {lvalue},class PyGeLinearEnt2d,class AcGeTol)'''
    ...
    def paramAtLength (self, *args, **kwargs):
      '''
paramAtLength( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve2d {lvalue},double,double)

paramAtLength( (Curve2d)arg1, (float)arg2, (float)arg3, (bool)arg4, (float)arg5) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve2d {lvalue},double,double,bool,double)'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Curve2d)arg1, (Point2d)arg2) -> float :

    C++ signature :
        double paramOf(class PyGeCurve2d {lvalue},class AcGePoint2d)

paramOf( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double paramOf(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def pointOnLine (self, *args, **kwargs):
      '''
pointOnLine( (LinearEnt2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d pointOnLine(class PyGeLinearEnt2d {lvalue})'''
    ...
    def reverseParam (self, *args, **kwargs):
      '''
reverseParam( (Curve2d)arg1) -> Curve2d :

    C++ signature :
        class PyGeCurve2d {lvalue} reverseParam(class PyGeCurve2d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double)

rotateBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double)

scaleBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def set (self, *args, **kwargs):
      '''
set( (Ray2d)arg1, (Point2d)arg2, (Vector2d)arg3) -> Ray2d :

    C++ signature :
        class PyGeRay2d {lvalue} set(class PyGeRay2d {lvalue},class AcGePoint2d,class AcGeVector2d)

set( (Ray2d)arg1, (Point2d)arg2, (Point2d)arg3) -> Ray2d :

    C++ signature :
        class PyGeRay2d {lvalue} set(class PyGeRay2d {lvalue},class AcGePoint2d,class AcGePoint2d)'''
    ...
    def setInterval (self, *args, **kwargs):
      '''
setInterval( (Curve2d)arg1) -> Curve2d :

    C++ signature :
        class PyGeCurve2d {lvalue} setInterval(class PyGeCurve2d {lvalue})

setInterval( (Curve2d)arg1, (Interval)arg2) -> bool :

    C++ signature :
        bool setInterval(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity2d)arg1, (Matrix2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} transformBy(class PyGeEntity2d {lvalue},class AcGeMatrix2d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity2d)arg1, (Vector2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} translateBy(class PyGeEntity2d {lvalue},class AcGeVector2d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity2d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity2d {lvalue})'''
    ...

class Ray3d:
    def area (self, *args, **kwargs):
      '''
area( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double area(class PyGeCurve3d {lvalue},double,double)

area( (Curve3d)arg1, (float)arg2, (float)arg3, (Tol)arg4) -> float :

    C++ signature :
        double area(class PyGeCurve3d {lvalue},double,double,class AcGeTol)'''
    ...
    def boundBlock (self, *args, **kwargs):
      '''
boundBlock( (Curve3d)arg1) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d boundBlock(class PyGeCurve3d {lvalue})

boundBlock( (Curve3d)arg1, (Interval)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d boundBlock(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Curve3d)arg1, (Point3d)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

closestPointTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

closestPointTo( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

closestPointTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity3d)arg1) -> Entity3d :

    C++ signature :
        class PyGeEntity3d copy(class PyGeEntity3d {lvalue})'''
    ...
    def direction (self, *args, **kwargs):
      '''
direction( (LinearEnt3d)arg1) -> Vector3d :

    C++ signature :
        class AcGeVector3d direction(class PyGeLinearEnt3d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Curve3d)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

distanceTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

distanceTo( (Curve3d)arg1, (Curve3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

distanceTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Curve3d)arg1, (float)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d evalPoint(class PyGeCurve3d {lvalue},double)

evalPoint( (Curve3d)arg1, (float)arg2, (CmdFlags)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple evalPoint(class PyGeCurve3d {lvalue},double,int)'''
    ...
    def explode (self, *args, **kwargs):
      '''
explode( (Curve3d)arg1) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve3d {lvalue})

explode( (Curve3d)arg1, (Interval)arg2) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def getClosestPointTo (self, *args, **kwargs):
      '''
getClosestPointTo( (Curve3d)arg1, (Point3d)arg2) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

getClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def getClosestPointsTo (self, *args, **kwargs):
      '''
getClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

getClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def getEndPoint (self, *args, **kwargs):
      '''
getEndPoint( (Curve3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getEndPoint(class PyGeCurve3d {lvalue})'''
    ...
    def getInterval (self, *args, **kwargs):
      '''
getInterval( (Curve3d)arg1) -> Interval :

    C++ signature :
        class PyGeInterval getInterval(class PyGeCurve3d {lvalue})'''
    ...
    def getLine (self, *args, **kwargs):
      '''
getLine( (LinearEnt3d)arg1) -> Line3d :

    C++ signature :
        class PyGeLine3d getLine(class PyGeLinearEnt3d {lvalue})'''
    ...
    def getNormalPoint (self, *args, **kwargs):
      '''
getNormalPoint( (Curve3d)arg1, (Point3d)arg2) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getNormalPoint(class PyGeCurve3d {lvalue},class AcGePoint3d)

getNormalPoint( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getNormalPoint(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def getPerpPlane (self, *args, **kwargs):
      '''
getPerpPlane( (LinearEnt3d)arg1, (Point3d)arg2) -> Plane :

    C++ signature :
        class PyGePlane getPerpPlane(class PyGeLinearEnt3d {lvalue},class AcGePoint3d)'''
    ...
    def getProjClosestPointTo (self, *args, **kwargs):
      '''
getProjClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getProjClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d)

getProjClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Tol)arg4) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getProjClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def getProjClosestPointsTo (self, *args, **kwargs):
      '''
getProjClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getProjClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d)

getProjClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple getProjClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def getSamplePoints (self, *args, **kwargs):
      '''
getSamplePoints( (Curve3d)arg1, (CmdFlags)arg2) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve3d {lvalue},int)

getSamplePoints( (Curve3d)arg1, (float)arg2, (float)arg3, (float)arg4) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve3d {lvalue},double,double,double)'''
    ...
    def getSplitCurves (self, *args, **kwargs):
      '''
getSplitCurves( (Curve3d)arg1, (float)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getSplitCurves(class PyGeCurve3d {lvalue},double)'''
    ...
    def getStartPoint (self, *args, **kwargs):
      '''
getStartPoint( (Curve3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getStartPoint(class PyGeCurve3d {lvalue})'''
    ...
    def getTrimmedOffset (self, *args, **kwargs):
      '''
getTrimmedOffset( (Curve3d)arg1, (float)arg2, (Vector3d)arg3, (OffsetCrvExtType)arg4) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve3d {lvalue},double,class AcGeVector3d,enum AcGe::OffsetCrvExtType)

getTrimmedOffset( (Curve3d)arg1, (float)arg2, (Vector3d)arg3, (OffsetCrvExtType)arg4, (Tol)arg5) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve3d {lvalue},double,class AcGeVector3d,enum AcGe::OffsetCrvExtType,class AcGeTol)'''
    ...
    def hasEndPoint (self, *args, **kwargs):
      '''
hasEndPoint( (Curve3d)arg1) -> bool :

    C++ signature :
        bool hasEndPoint(class PyGeCurve3d {lvalue})'''
    ...
    def hasStartPoint (self, *args, **kwargs):
      '''
hasStartPoint( (Curve3d)arg1) -> bool :

    C++ signature :
        bool hasStartPoint(class PyGeCurve3d {lvalue})'''
    ...
    def intersectWith (self, *args, **kwargs):
      '''
intersectWith( (LinearEnt3d)arg1, (LinearEnt3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d)

intersectWith( (LinearEnt3d)arg1, (LinearEnt3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d,class AcGeTol)

intersectWith( (LinearEnt3d)arg1, (PlanarEnt)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeLinearEnt3d {lvalue},class PyGePlanarEnt)

intersectWith( (LinearEnt3d)arg1, (PlanarEnt)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple intersectWith(class PyGeLinearEnt3d {lvalue},class PyGePlanarEnt,class AcGeTol)'''
    ...
    def isClosed (self, *args, **kwargs):
      '''
isClosed( (Curve3d)arg1) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve3d {lvalue})

isClosed( (Curve3d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isColinearTo (self, *args, **kwargs):
      '''
isColinearTo( (LinearEnt3d)arg1, (LinearEnt3d)arg2) -> bool :

    C++ signature :
        bool isColinearTo(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d)

isColinearTo( (LinearEnt3d)arg1, (LinearEnt3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isColinearTo(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d,class AcGeTol)'''
    ...
    def isCoplanarWith (self, *args, **kwargs):
      '''
isCoplanarWith( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isCoplanarWith(class PyGeCurve3d {lvalue},class PyGeCurve3d)

isCoplanarWith( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple isCoplanarWith(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def isDegenerate (self, *args, **kwargs):
      '''
isDegenerate( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve3d {lvalue})

isDegenerate( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity3d)arg1, (Entity3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity3d {lvalue},class PyGeEntity3d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity3d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity3d {lvalue},enum AcGe::EntityId)'''
    ...
    def isLinear (self, *args, **kwargs):
      '''
isLinear( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve3d {lvalue})

isLinear( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity3d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity3d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (LinearEnt3d)arg1, (Point3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isOn(class PyGeLinearEnt3d {lvalue},class AcGePoint3d)

isOn( (LinearEnt3d)arg1, (Point3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple isOn(class PyGeLinearEnt3d {lvalue},class AcGePoint3d,class AcGeTol)

isOn( (LinearEnt3d)arg1, (float)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeLinearEnt3d {lvalue},double)

isOn( (LinearEnt3d)arg1, (float)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeLinearEnt3d {lvalue},double,class AcGeTol)

isOn( (LinearEnt3d)arg1, (Plane)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeLinearEnt3d {lvalue},class PyGePlane)

isOn( (LinearEnt3d)arg1, (Plane)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeLinearEnt3d {lvalue},class PyGePlane,class AcGeTol)'''
    ...
    def isParallelTo (self, *args, **kwargs):
      '''
isParallelTo( (LinearEnt3d)arg1, (LinearEnt3d)arg2) -> bool :

    C++ signature :
        bool isParallelTo(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d)

isParallelTo( (LinearEnt3d)arg1, (LinearEnt3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isParallelTo(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d,class AcGeTol)

isParallelTo( (LinearEnt3d)arg1, (PlanarEnt)arg2) -> bool :

    C++ signature :
        bool isParallelTo(class PyGeLinearEnt3d {lvalue},class PyGePlanarEnt)

isParallelTo( (LinearEnt3d)arg1, (PlanarEnt)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isParallelTo(class PyGeLinearEnt3d {lvalue},class PyGePlanarEnt,class AcGeTol)'''
    ...
    def isPeriodic (self, *args, **kwargs):
      '''
isPeriodic( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPeriodic(class PyGeCurve3d {lvalue})'''
    ...
    def isPerpendicularTo (self, *args, **kwargs):
      '''
isPerpendicularTo( (LinearEnt3d)arg1, (LinearEnt3d)arg2) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d)

isPerpendicularTo( (LinearEnt3d)arg1, (LinearEnt3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d,class AcGeTol)

isPerpendicularTo( (LinearEnt3d)arg1, (PlanarEnt)arg2) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGeLinearEnt3d {lvalue},class PyGePlanarEnt)

isPerpendicularTo( (LinearEnt3d)arg1, (PlanarEnt)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isPerpendicularTo(class PyGeLinearEnt3d {lvalue},class PyGePlanarEnt,class AcGeTol)'''
    ...
    def isPlanar (self, *args, **kwargs):
      '''
isPlanar( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPlanar(class PyGeCurve3d {lvalue})

isPlanar( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isPlanar(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double length(class PyGeCurve3d {lvalue},double,double)

length( (Curve3d)arg1, (float)arg2, (float)arg3, (float)arg4) -> float :

    C++ signature :
        double length(class PyGeCurve3d {lvalue},double,double,double)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} mirror(class PyGeEntity3d {lvalue},class PyGePlane)'''
    ...
    def orthoBoundBlock (self, *args, **kwargs):
      '''
orthoBoundBlock( (Curve3d)arg1) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d orthoBoundBlock(class PyGeCurve3d {lvalue})

orthoBoundBlock( (Curve3d)arg1, (Interval)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d orthoBoundBlock(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def orthoProject (self, *args, **kwargs):
      '''
orthoProject( (Curve3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d orthoProject(class PyGeCurve3d {lvalue},class PyGePlane)

orthoProject( (Curve3d)arg1, (Plane)arg2, (Tol)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d orthoProject(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeTol)'''
    ...
    def overlap (self, *args, **kwargs):
      '''
overlap( (LinearEnt3d)arg1, (LinearEnt3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple overlap(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d)

overlap( (LinearEnt3d)arg1, (LinearEnt3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple overlap(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d,class AcGeTol)'''
    ...
    def paramAtLength (self, *args, **kwargs):
      '''
paramAtLength( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve3d {lvalue},double,double)

paramAtLength( (Curve3d)arg1, (float)arg2, (float)arg3, (bool)arg4, (float)arg5) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve3d {lvalue},double,double,bool,double)'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Curve3d)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double paramOf(class PyGeCurve3d {lvalue},class AcGePoint3d)

paramOf( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double paramOf(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def pointOnLine (self, *args, **kwargs):
      '''
pointOnLine( (LinearEnt3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d pointOnLine(class PyGeLinearEnt3d {lvalue})'''
    ...
    def projClosestPointTo (self, *args, **kwargs):
      '''
projClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d projClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d)

projClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Tol)arg4) -> Point3d :

    C++ signature :
        class AcGePoint3d projClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def projClosestPointsTo (self, *args, **kwargs):
      '''
projClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple projClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d)

projClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple projClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def projIntersectWith (self, *args, **kwargs):
      '''
projIntersectWith( (LinearEnt3d)arg1, (LinearEnt3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple projIntersectWith(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d,class AcGeVector3d)

projIntersectWith( (LinearEnt3d)arg1, (LinearEnt3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple projIntersectWith(class PyGeLinearEnt3d {lvalue},class PyGeLinearEnt3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def project (self, *args, **kwargs):
      '''
project( (Curve3d)arg1, (Plane)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d project(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeVector3d)

project( (Curve3d)arg1, (Plane)arg2, (Vector3d)arg3, (Tol)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d project(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeVector3d,class AcGeTol)'''
    ...
    def reverseParam (self, *args, **kwargs):
      '''
reverseParam( (Curve3d)arg1) -> Curve3d :

    C++ signature :
        class PyGeCurve3d {lvalue} reverseParam(class PyGeCurve3d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d)

rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3, (Point3d)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d,class AcGePoint3d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity3d)arg1, (float)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double)

scaleBy( (Entity3d)arg1, (float)arg2, (Point3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double,class AcGePoint3d)'''
    ...
    def set (self, *args, **kwargs):
      '''
set( (Ray3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> Ray3d :

    C++ signature :
        class PyGeRay3d {lvalue} set(class PyGeRay3d {lvalue},class AcGePoint3d,class AcGeVector3d)

set( (Ray3d)arg1, (Point3d)arg2, (Point3d)arg3) -> Ray3d :

    C++ signature :
        class PyGeRay3d {lvalue} set(class PyGeRay3d {lvalue},class AcGePoint3d,class AcGePoint3d)'''
    ...
    def setInterval (self, *args, **kwargs):
      '''
setInterval( (Curve3d)arg1) -> Curve3d :

    C++ signature :
        class PyGeCurve3d {lvalue} setInterval(class PyGeCurve3d {lvalue})

setInterval( (Curve3d)arg1, (Interval)arg2) -> bool :

    C++ signature :
        bool setInterval(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity3d)arg1, (Matrix3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} transformBy(class PyGeEntity3d {lvalue},class AcGeMatrix3d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity3d)arg1, (Vector3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} translateBy(class PyGeEntity3d {lvalue},class AcGeVector3d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity3d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity3d {lvalue})'''
    ...

class Scale2d:
    def postMultBy (self, *args, **kwargs):
      '''
postMultBy( (Scale2d)arg1, (Scale2d)arg2) -> Scale2d :

    C++ signature :
        class AcGeScale2d {lvalue} postMultBy(class AcGeScale2d {lvalue},class AcGeScale2d)'''
    ...
    def preMultBy (self, *args, **kwargs):
      '''
preMultBy( (Scale2d)arg1, (Scale2d)arg2) -> Scale2d :

    C++ signature :
        class AcGeScale2d {lvalue} preMultBy(class AcGeScale2d {lvalue},class AcGeScale2d)'''
    ...
    def setToProduct (self, *args, **kwargs):
      '''
setToProduct( (Scale2d)arg1, (Scale2d)arg2, (float)arg3) -> Scale2d :

    C++ signature :
        class AcGeScale2d {lvalue} setToProduct(class AcGeScale2d {lvalue},class AcGeScale2d,double)

setToProduct( (Scale2d)arg1, (Scale2d)arg2, (Scale2d)arg3) -> Scale2d :

    C++ signature :
        class AcGeScale2d {lvalue} setToProduct(class AcGeScale2d {lvalue},class AcGeScale2d,class AcGeScale2d)'''
    ...
    def sx (self, *args, **kwargs):
      '''None'''
    ...
    def sy (self, *args, **kwargs):
      '''None'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (Scale2d)arg1) -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > toString(class AcGeScale2d)'''
    ...

class Scale3d:
    def postMultBy (self, *args, **kwargs):
      '''
postMultBy( (Scale3d)arg1, (Scale3d)arg2) -> Scale3d :

    C++ signature :
        class AcGeScale3d {lvalue} postMultBy(class AcGeScale3d {lvalue},class AcGeScale3d)'''
    ...
    def preMultBy (self, *args, **kwargs):
      '''
preMultBy( (Scale3d)arg1, (Scale3d)arg2) -> Scale3d :

    C++ signature :
        class AcGeScale3d {lvalue} preMultBy(class AcGeScale3d {lvalue},class AcGeScale3d)'''
    ...
    def setToProduct (self, *args, **kwargs):
      '''
setToProduct( (Scale3d)arg1, (Scale3d)arg2, (float)arg3) -> Scale3d :

    C++ signature :
        class AcGeScale3d {lvalue} setToProduct(class AcGeScale3d {lvalue},class AcGeScale3d,double)

setToProduct( (Scale3d)arg1, (Scale3d)arg2, (Scale3d)arg3) -> Scale3d :

    C++ signature :
        class AcGeScale3d {lvalue} setToProduct(class AcGeScale3d {lvalue},class AcGeScale3d,class AcGeScale3d)'''
    ...
    def sx (self, *args, **kwargs):
      '''None'''
    ...
    def sy (self, *args, **kwargs):
      '''None'''
    ...
    def sz (self, *args, **kwargs):
      '''None'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (Scale3d)arg1) -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > toString(class AcGeScale3d)'''
    ...

class SplineEnt2d:
    def area (self, *args, **kwargs):
      '''
area( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double area(class PyGeCurve2d {lvalue},double,double)

area( (Curve2d)arg1, (float)arg2, (float)arg3, (Tol)arg4) -> float :

    C++ signature :
        double area(class PyGeCurve2d {lvalue},double,double,class AcGeTol)'''
    ...
    def boundBlock (self, *args, **kwargs):
      '''
boundBlock( (Curve2d)arg1) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d boundBlock(class PyGeCurve2d {lvalue})

boundBlock( (Curve2d)arg1, (Interval)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d boundBlock(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Curve2d)arg1, (Point2d)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d closestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

closestPointTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> Point2d :

    C++ signature :
        class AcGePoint2d closestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

closestPointTo( (Curve2d)arg1, (Curve2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

closestPointTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def continuityAtKnot (self, *args, **kwargs):
      '''
continuityAtKnot( (SplineEnt2d)arg1, (CmdFlags)arg2) -> int :

    C++ signature :
        int continuityAtKnot(class PyGeSplineEnt2d {lvalue},int)

continuityAtKnot( (SplineEnt2d)arg1, (CmdFlags)arg2, (Tol)arg3) -> int :

    C++ signature :
        int continuityAtKnot(class PyGeSplineEnt2d {lvalue},int,class AcGeTol)'''
    ...
    def controlPointAt (self, *args, **kwargs):
      '''
controlPointAt( (SplineEnt2d)arg1, (CmdFlags)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d controlPointAt(class PyGeSplineEnt2d {lvalue},int)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity2d)arg1) -> Entity2d :

    C++ signature :
        class PyGeEntity2d copy(class PyGeEntity2d {lvalue})'''
    ...
    def degree (self, *args, **kwargs):
      '''
degree( (SplineEnt2d)arg1) -> int :

    C++ signature :
        int degree(class PyGeSplineEnt2d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Curve2d)arg1, (Point2d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

distanceTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

distanceTo( (Curve2d)arg1, (Curve2d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

distanceTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def endParam (self, *args, **kwargs):
      '''
endParam( (SplineEnt2d)arg1) -> float :

    C++ signature :
        double endParam(class PyGeSplineEnt2d {lvalue})'''
    ...
    def endPoint (self, *args, **kwargs):
      '''
endPoint( (SplineEnt2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d endPoint(class PyGeSplineEnt2d {lvalue})'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Curve2d)arg1, (float)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d evalPoint(class PyGeCurve2d {lvalue},double)

evalPoint( (Curve2d)arg1, (float)arg2, (CmdFlags)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple evalPoint(class PyGeCurve2d {lvalue},double,int)'''
    ...
    def explode (self, *args, **kwargs):
      '''
explode( (Curve2d)arg1) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve2d {lvalue})

explode( (Curve2d)arg1, (Interval)arg2) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def getClosestPointTo (self, *args, **kwargs):
      '''
getClosestPointTo( (Curve2d)arg1, (Point2d)arg2) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getClosestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d)

getClosestPointTo( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getClosestPointTo(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def getClosestPointsTo (self, *args, **kwargs):
      '''
getClosestPointsTo( (Curve2d)arg1, (Curve2d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve2d {lvalue},class PyGeCurve2d)

getClosestPointsTo( (Curve2d)arg1, (Curve2d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve2d {lvalue},class PyGeCurve2d,class AcGeTol)'''
    ...
    def getEndPoint (self, *args, **kwargs):
      '''
getEndPoint( (Curve2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getEndPoint(class PyGeCurve2d {lvalue})'''
    ...
    def getInterval (self, *args, **kwargs):
      '''
getInterval( (Curve2d)arg1) -> Interval :

    C++ signature :
        class PyGeInterval getInterval(class PyGeCurve2d {lvalue})'''
    ...
    def getNormalPoint (self, *args, **kwargs):
      '''
getNormalPoint( (Curve2d)arg1, (Point2d)arg2) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getNormalPoint(class PyGeCurve2d {lvalue},class AcGePoint2d)

getNormalPoint( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> PointOnCurve2d :

    C++ signature :
        class PyGePointOnCurve2d getNormalPoint(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def getSamplePoints (self, *args, **kwargs):
      '''
getSamplePoints( (Curve2d)arg1, (CmdFlags)arg2) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve2d {lvalue},int)

getSamplePoints( (Curve2d)arg1, (float)arg2, (float)arg3, (float)arg4) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve2d {lvalue},double,double,double)'''
    ...
    def getSplitCurves (self, *args, **kwargs):
      '''
getSplitCurves( (Curve2d)arg1, (float)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getSplitCurves(class PyGeCurve2d {lvalue},double)'''
    ...
    def getStartPoint (self, *args, **kwargs):
      '''
getStartPoint( (Curve2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d getStartPoint(class PyGeCurve2d {lvalue})'''
    ...
    def getTrimmedOffset (self, *args, **kwargs):
      '''
getTrimmedOffset( (Curve2d)arg1, (float)arg2, (OffsetCrvExtType)arg3) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve2d {lvalue},double,enum AcGe::OffsetCrvExtType)

getTrimmedOffset( (Curve2d)arg1, (float)arg2, (OffsetCrvExtType)arg3, (Tol)arg4) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve2d {lvalue},double,enum AcGe::OffsetCrvExtType,class AcGeTol)'''
    ...
    def hasEndPoint (self, *args, **kwargs):
      '''
hasEndPoint( (Curve2d)arg1) -> bool :

    C++ signature :
        bool hasEndPoint(class PyGeCurve2d {lvalue})'''
    ...
    def hasFitData (self, *args, **kwargs):
      '''
hasFitData( (SplineEnt2d)arg1) -> bool :

    C++ signature :
        bool hasFitData(class PyGeSplineEnt2d {lvalue})'''
    ...
    def hasStartPoint (self, *args, **kwargs):
      '''
hasStartPoint( (Curve2d)arg1) -> bool :

    C++ signature :
        bool hasStartPoint(class PyGeCurve2d {lvalue})'''
    ...
    def isClosed (self, *args, **kwargs):
      '''
isClosed( (Curve2d)arg1) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve2d {lvalue})

isClosed( (Curve2d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isDegenerate (self, *args, **kwargs):
      '''
isDegenerate( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve2d {lvalue})

isDegenerate( (Curve2d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity2d)arg1, (Entity2d)arg2) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d)

isEqualTo( (Entity2d)arg1, (Entity2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity2d {lvalue},class PyGeEntity2d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity2d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity2d {lvalue},enum AcGe::EntityId)'''
    ...
    def isLinear (self, *args, **kwargs):
      '''
isLinear( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve2d {lvalue})

isLinear( (Curve2d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve2d {lvalue},class AcGeTol)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity2d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity2d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Curve2d)arg1, (Point2d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d)

isOn( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)

isOn( (Curve2d)arg1, (Point2d)arg2, (float)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,double {lvalue})

isOn( (Curve2d)arg1, (Point2d)arg2, (float)arg3, (Tol)arg4) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},class AcGePoint2d,double {lvalue},class AcGeTol)

isOn( (Curve2d)arg1, (float)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},double)

isOn( (Curve2d)arg1, (float)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve2d {lvalue},double,class AcGeTol)'''
    ...
    def isPeriodic (self, *args, **kwargs):
      '''
isPeriodic( (Curve2d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPeriodic(class PyGeCurve2d {lvalue})'''
    ...
    def isRational (self, *args, **kwargs):
      '''
isRational( (SplineEnt2d)arg1) -> bool :

    C++ signature :
        bool isRational(class PyGeSplineEnt2d {lvalue})'''
    ...
    def knotAt (self, *args, **kwargs):
      '''
knotAt( (SplineEnt2d)arg1, (CmdFlags)arg2) -> float :

    C++ signature :
        double knotAt(class PyGeSplineEnt2d {lvalue},int)'''
    ...
    def knots (self, *args, **kwargs):
      '''
knots( (SplineEnt2d)arg1) -> KnotVector :

    C++ signature :
        class PyGeKnotVector knots(class PyGeSplineEnt2d {lvalue})'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double length(class PyGeCurve2d {lvalue},double,double)

length( (Curve2d)arg1, (float)arg2, (float)arg3, (float)arg4) -> float :

    C++ signature :
        double length(class PyGeCurve2d {lvalue},double,double,double)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity2d)arg1, (Line2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} mirror(class PyGeEntity2d {lvalue},class PyGeLine2d)'''
    ...
    def numControlPoints (self, *args, **kwargs):
      '''
numControlPoints( (SplineEnt2d)arg1) -> int :

    C++ signature :
        int numControlPoints(class PyGeSplineEnt2d {lvalue})'''
    ...
    def numKnots (self, *args, **kwargs):
      '''
numKnots( (SplineEnt2d)arg1) -> int :

    C++ signature :
        int numKnots(class PyGeSplineEnt2d {lvalue})'''
    ...
    def order (self, *args, **kwargs):
      '''
order( (SplineEnt2d)arg1) -> int :

    C++ signature :
        int order(class PyGeSplineEnt2d {lvalue})'''
    ...
    def orthoBoundBlock (self, *args, **kwargs):
      '''
orthoBoundBlock( (Curve2d)arg1) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d orthoBoundBlock(class PyGeCurve2d {lvalue})

orthoBoundBlock( (Curve2d)arg1, (Interval)arg2) -> BoundBlock2d :

    C++ signature :
        class PyGeBoundBlock2d orthoBoundBlock(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def paramAtLength (self, *args, **kwargs):
      '''
paramAtLength( (Curve2d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve2d {lvalue},double,double)

paramAtLength( (Curve2d)arg1, (float)arg2, (float)arg3, (bool)arg4, (float)arg5) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve2d {lvalue},double,double,bool,double)'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Curve2d)arg1, (Point2d)arg2) -> float :

    C++ signature :
        double paramOf(class PyGeCurve2d {lvalue},class AcGePoint2d)

paramOf( (Curve2d)arg1, (Point2d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double paramOf(class PyGeCurve2d {lvalue},class AcGePoint2d,class AcGeTol)'''
    ...
    def reverseParam (self, *args, **kwargs):
      '''
reverseParam( (Curve2d)arg1) -> Curve2d :

    C++ signature :
        class PyGeCurve2d {lvalue} reverseParam(class PyGeCurve2d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double)

rotateBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} rotateBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity2d)arg1, (float)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double)

scaleBy( (Entity2d)arg1, (float)arg2, (Point2d)arg3) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} scaleBy(class PyGeEntity2d {lvalue},double,class AcGePoint2d)'''
    ...
    def setControlPointAt (self, *args, **kwargs):
      '''
setControlPointAt( (SplineEnt2d)arg1, (CmdFlags)arg2, (Point2d)arg3) -> SplineEnt2d :

    C++ signature :
        class PyGeSplineEnt2d {lvalue} setControlPointAt(class PyGeSplineEnt2d {lvalue},int,class AcGePoint2d)'''
    ...
    def setInterval (self, *args, **kwargs):
      '''
setInterval( (Curve2d)arg1) -> Curve2d :

    C++ signature :
        class PyGeCurve2d {lvalue} setInterval(class PyGeCurve2d {lvalue})

setInterval( (Curve2d)arg1, (Interval)arg2) -> bool :

    C++ signature :
        bool setInterval(class PyGeCurve2d {lvalue},class PyGeInterval)'''
    ...
    def setKnotAt (self, *args, **kwargs):
      '''
setKnotAt( (SplineEnt2d)arg1, (CmdFlags)arg2, (float)arg3) -> SplineEnt2d :

    C++ signature :
        class PyGeSplineEnt2d {lvalue} setKnotAt(class PyGeSplineEnt2d {lvalue},int,double)'''
    ...
    def startParam (self, *args, **kwargs):
      '''
startParam( (SplineEnt2d)arg1) -> float :

    C++ signature :
        double startParam(class PyGeSplineEnt2d {lvalue})'''
    ...
    def startPoint (self, *args, **kwargs):
      '''
startPoint( (SplineEnt2d)arg1) -> Point2d :

    C++ signature :
        class AcGePoint2d startPoint(class PyGeSplineEnt2d {lvalue})'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity2d)arg1, (Matrix2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} transformBy(class PyGeEntity2d {lvalue},class AcGeMatrix2d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity2d)arg1, (Vector2d)arg2) -> Entity2d :

    C++ signature :
        class PyGeEntity2d {lvalue} translateBy(class PyGeEntity2d {lvalue},class AcGeVector2d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity2d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity2d {lvalue})'''
    ...

class SplineEnt3d:
    def area (self, *args, **kwargs):
      '''
area( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double area(class PyGeCurve3d {lvalue},double,double)

area( (Curve3d)arg1, (float)arg2, (float)arg3, (Tol)arg4) -> float :

    C++ signature :
        double area(class PyGeCurve3d {lvalue},double,double,class AcGeTol)'''
    ...
    def boundBlock (self, *args, **kwargs):
      '''
boundBlock( (Curve3d)arg1) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d boundBlock(class PyGeCurve3d {lvalue})

boundBlock( (Curve3d)arg1, (Interval)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d boundBlock(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Curve3d)arg1, (Point3d)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

closestPointTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

closestPointTo( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

closestPointTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple closestPointTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def continuityAtKnot (self, *args, **kwargs):
      '''
continuityAtKnot( (SplineEnt3d)arg1, (CmdFlags)arg2) -> int :

    C++ signature :
        int continuityAtKnot(class PyGeSplineEnt3d {lvalue},int)

continuityAtKnot( (SplineEnt3d)arg1, (CmdFlags)arg2, (Tol)arg3) -> int :

    C++ signature :
        int continuityAtKnot(class PyGeSplineEnt3d {lvalue},int,class AcGeTol)'''
    ...
    def controlPointAt (self, *args, **kwargs):
      '''
controlPointAt( (SplineEnt3d)arg1, (CmdFlags)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d controlPointAt(class PyGeSplineEnt3d {lvalue},int)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity3d)arg1) -> Entity3d :

    C++ signature :
        class PyGeEntity3d copy(class PyGeEntity3d {lvalue})'''
    ...
    def degree (self, *args, **kwargs):
      '''
degree( (SplineEnt3d)arg1) -> int :

    C++ signature :
        int degree(class PyGeSplineEnt3d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Curve3d)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

distanceTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

distanceTo( (Curve3d)arg1, (Curve3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

distanceTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def endParam (self, *args, **kwargs):
      '''
endParam( (SplineEnt3d)arg1) -> float :

    C++ signature :
        double endParam(class PyGeSplineEnt3d {lvalue})'''
    ...
    def endPoint (self, *args, **kwargs):
      '''
endPoint( (SplineEnt3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d endPoint(class PyGeSplineEnt3d {lvalue})'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Curve3d)arg1, (float)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d evalPoint(class PyGeCurve3d {lvalue},double)

evalPoint( (Curve3d)arg1, (float)arg2, (CmdFlags)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple evalPoint(class PyGeCurve3d {lvalue},double,int)'''
    ...
    def explode (self, *args, **kwargs):
      '''
explode( (Curve3d)arg1) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve3d {lvalue})

explode( (Curve3d)arg1, (Interval)arg2) -> list :

    C++ signature :
        class boost::python::list explode(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def getClosestPointTo (self, *args, **kwargs):
      '''
getClosestPointTo( (Curve3d)arg1, (Point3d)arg2) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d)

getClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def getClosestPointsTo (self, *args, **kwargs):
      '''
getClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d)

getClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def getEndPoint (self, *args, **kwargs):
      '''
getEndPoint( (Curve3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getEndPoint(class PyGeCurve3d {lvalue})'''
    ...
    def getInterval (self, *args, **kwargs):
      '''
getInterval( (Curve3d)arg1) -> Interval :

    C++ signature :
        class PyGeInterval getInterval(class PyGeCurve3d {lvalue})'''
    ...
    def getNormalPoint (self, *args, **kwargs):
      '''
getNormalPoint( (Curve3d)arg1, (Point3d)arg2) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getNormalPoint(class PyGeCurve3d {lvalue},class AcGePoint3d)

getNormalPoint( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getNormalPoint(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def getProjClosestPointTo (self, *args, **kwargs):
      '''
getProjClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getProjClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d)

getProjClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Tol)arg4) -> PointOnCurve3d :

    C++ signature :
        class PyGePointOnCurve3d getProjClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def getProjClosestPointsTo (self, *args, **kwargs):
      '''
getProjClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple getProjClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d)

getProjClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple getProjClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def getSamplePoints (self, *args, **kwargs):
      '''
getSamplePoints( (Curve3d)arg1, (CmdFlags)arg2) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve3d {lvalue},int)

getSamplePoints( (Curve3d)arg1, (float)arg2, (float)arg3, (float)arg4) -> list :

    C++ signature :
        class boost::python::list getSamplePoints(class PyGeCurve3d {lvalue},double,double,double)'''
    ...
    def getSplitCurves (self, *args, **kwargs):
      '''
getSplitCurves( (Curve3d)arg1, (float)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getSplitCurves(class PyGeCurve3d {lvalue},double)'''
    ...
    def getStartPoint (self, *args, **kwargs):
      '''
getStartPoint( (Curve3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d getStartPoint(class PyGeCurve3d {lvalue})'''
    ...
    def getTrimmedOffset (self, *args, **kwargs):
      '''
getTrimmedOffset( (Curve3d)arg1, (float)arg2, (Vector3d)arg3, (OffsetCrvExtType)arg4) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve3d {lvalue},double,class AcGeVector3d,enum AcGe::OffsetCrvExtType)

getTrimmedOffset( (Curve3d)arg1, (float)arg2, (Vector3d)arg3, (OffsetCrvExtType)arg4, (Tol)arg5) -> list :

    C++ signature :
        class boost::python::list getTrimmedOffset(class PyGeCurve3d {lvalue},double,class AcGeVector3d,enum AcGe::OffsetCrvExtType,class AcGeTol)'''
    ...
    def hasEndPoint (self, *args, **kwargs):
      '''
hasEndPoint( (Curve3d)arg1) -> bool :

    C++ signature :
        bool hasEndPoint(class PyGeCurve3d {lvalue})'''
    ...
    def hasFitData (self, *args, **kwargs):
      '''
hasFitData( (SplineEnt3d)arg1) -> bool :

    C++ signature :
        bool hasFitData(class PyGeSplineEnt3d {lvalue})'''
    ...
    def hasStartPoint (self, *args, **kwargs):
      '''
hasStartPoint( (Curve3d)arg1) -> bool :

    C++ signature :
        bool hasStartPoint(class PyGeCurve3d {lvalue})'''
    ...
    def isClosed (self, *args, **kwargs):
      '''
isClosed( (Curve3d)arg1) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve3d {lvalue})

isClosed( (Curve3d)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosed(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isCoplanarWith (self, *args, **kwargs):
      '''
isCoplanarWith( (Curve3d)arg1, (Curve3d)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isCoplanarWith(class PyGeCurve3d {lvalue},class PyGeCurve3d)

isCoplanarWith( (Curve3d)arg1, (Curve3d)arg2, (Tol)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple isCoplanarWith(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeTol)'''
    ...
    def isDegenerate (self, *args, **kwargs):
      '''
isDegenerate( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve3d {lvalue})

isDegenerate( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isDegenerate(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity3d)arg1, (Entity3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity3d {lvalue},class PyGeEntity3d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity3d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity3d {lvalue},enum AcGe::EntityId)'''
    ...
    def isLinear (self, *args, **kwargs):
      '''
isLinear( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve3d {lvalue})

isLinear( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isLinear(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity3d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity3d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Curve3d)arg1, (Point3d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d)

isOn( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)

isOn( (Curve3d)arg1, (Point3d)arg2, (float)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d,double {lvalue})

isOn( (Curve3d)arg1, (Point3d)arg2, (float)arg3, (Tol)arg4) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},class AcGePoint3d,double {lvalue},class AcGeTol)

isOn( (Curve3d)arg1, (float)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},double)

isOn( (Curve3d)arg1, (float)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeCurve3d {lvalue},double,class AcGeTol)'''
    ...
    def isPeriodic (self, *args, **kwargs):
      '''
isPeriodic( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPeriodic(class PyGeCurve3d {lvalue})'''
    ...
    def isPlanar (self, *args, **kwargs):
      '''
isPlanar( (Curve3d)arg1) -> tuple :

    C++ signature :
        class boost::python::tuple isPlanar(class PyGeCurve3d {lvalue})

isPlanar( (Curve3d)arg1, (Tol)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple isPlanar(class PyGeCurve3d {lvalue},class AcGeTol)'''
    ...
    def isRational (self, *args, **kwargs):
      '''
isRational( (SplineEnt3d)arg1) -> bool :

    C++ signature :
        bool isRational(class PyGeSplineEnt3d {lvalue})'''
    ...
    def knotAt (self, *args, **kwargs):
      '''
knotAt( (SplineEnt3d)arg1, (CmdFlags)arg2) -> float :

    C++ signature :
        double knotAt(class PyGeSplineEnt3d {lvalue},int)'''
    ...
    def knots (self, *args, **kwargs):
      '''
knots( (SplineEnt3d)arg1) -> KnotVector :

    C++ signature :
        class PyGeKnotVector knots(class PyGeSplineEnt3d {lvalue})'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double length(class PyGeCurve3d {lvalue},double,double)

length( (Curve3d)arg1, (float)arg2, (float)arg3, (float)arg4) -> float :

    C++ signature :
        double length(class PyGeCurve3d {lvalue},double,double,double)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} mirror(class PyGeEntity3d {lvalue},class PyGePlane)'''
    ...
    def numControlPoints (self, *args, **kwargs):
      '''
numControlPoints( (SplineEnt3d)arg1) -> int :

    C++ signature :
        int numControlPoints(class PyGeSplineEnt3d {lvalue})'''
    ...
    def numKnots (self, *args, **kwargs):
      '''
numKnots( (SplineEnt3d)arg1) -> int :

    C++ signature :
        int numKnots(class PyGeSplineEnt3d {lvalue})'''
    ...
    def order (self, *args, **kwargs):
      '''
order( (SplineEnt3d)arg1) -> int :

    C++ signature :
        int order(class PyGeSplineEnt3d {lvalue})'''
    ...
    def orthoBoundBlock (self, *args, **kwargs):
      '''
orthoBoundBlock( (Curve3d)arg1) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d orthoBoundBlock(class PyGeCurve3d {lvalue})

orthoBoundBlock( (Curve3d)arg1, (Interval)arg2) -> BoundBlock3d :

    C++ signature :
        class PyGeBoundBlock3d orthoBoundBlock(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def orthoProject (self, *args, **kwargs):
      '''
orthoProject( (Curve3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d orthoProject(class PyGeCurve3d {lvalue},class PyGePlane)

orthoProject( (Curve3d)arg1, (Plane)arg2, (Tol)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d orthoProject(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeTol)'''
    ...
    def paramAtLength (self, *args, **kwargs):
      '''
paramAtLength( (Curve3d)arg1, (float)arg2, (float)arg3) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve3d {lvalue},double,double)

paramAtLength( (Curve3d)arg1, (float)arg2, (float)arg3, (bool)arg4, (float)arg5) -> float :

    C++ signature :
        double paramAtLength(class PyGeCurve3d {lvalue},double,double,bool,double)'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Curve3d)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double paramOf(class PyGeCurve3d {lvalue},class AcGePoint3d)

paramOf( (Curve3d)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double paramOf(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def projClosestPointTo (self, *args, **kwargs):
      '''
projClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d projClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d)

projClosestPointTo( (Curve3d)arg1, (Point3d)arg2, (Vector3d)arg3, (Tol)arg4) -> Point3d :

    C++ signature :
        class AcGePoint3d projClosestPointTo(class PyGeCurve3d {lvalue},class AcGePoint3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def projClosestPointsTo (self, *args, **kwargs):
      '''
projClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3) -> tuple :

    C++ signature :
        class boost::python::tuple projClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d)

projClosestPointsTo( (Curve3d)arg1, (Curve3d)arg2, (Vector3d)arg3, (Tol)arg4) -> tuple :

    C++ signature :
        class boost::python::tuple projClosestPointsTo(class PyGeCurve3d {lvalue},class PyGeCurve3d,class AcGeVector3d,class AcGeTol)'''
    ...
    def project (self, *args, **kwargs):
      '''
project( (Curve3d)arg1, (Plane)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d project(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeVector3d)

project( (Curve3d)arg1, (Plane)arg2, (Vector3d)arg3, (Tol)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d project(class PyGeCurve3d {lvalue},class PyGePlane,class AcGeVector3d,class AcGeTol)'''
    ...
    def reverseParam (self, *args, **kwargs):
      '''
reverseParam( (Curve3d)arg1) -> Curve3d :

    C++ signature :
        class PyGeCurve3d {lvalue} reverseParam(class PyGeCurve3d {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d)

rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3, (Point3d)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d,class AcGePoint3d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity3d)arg1, (float)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double)

scaleBy( (Entity3d)arg1, (float)arg2, (Point3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double,class AcGePoint3d)'''
    ...
    def setControlPointAt (self, *args, **kwargs):
      '''
setControlPointAt( (SplineEnt3d)arg1, (CmdFlags)arg2, (Point3d)arg3) -> SplineEnt3d :

    C++ signature :
        class PyGeSplineEnt3d {lvalue} setControlPointAt(class PyGeSplineEnt3d {lvalue},int,class AcGePoint3d)'''
    ...
    def setInterval (self, *args, **kwargs):
      '''
setInterval( (Curve3d)arg1) -> Curve3d :

    C++ signature :
        class PyGeCurve3d {lvalue} setInterval(class PyGeCurve3d {lvalue})

setInterval( (Curve3d)arg1, (Interval)arg2) -> bool :

    C++ signature :
        bool setInterval(class PyGeCurve3d {lvalue},class PyGeInterval)'''
    ...
    def setKnotAt (self, *args, **kwargs):
      '''
setKnotAt( (SplineEnt3d)arg1, (CmdFlags)arg2, (float)arg3) -> SplineEnt3d :

    C++ signature :
        class PyGeSplineEnt3d {lvalue} setKnotAt(class PyGeSplineEnt3d {lvalue},int,double)'''
    ...
    def startParam (self, *args, **kwargs):
      '''
startParam( (SplineEnt3d)arg1) -> float :

    C++ signature :
        double startParam(class PyGeSplineEnt3d {lvalue})'''
    ...
    def startPoint (self, *args, **kwargs):
      '''
startPoint( (SplineEnt3d)arg1) -> Point3d :

    C++ signature :
        class AcGePoint3d startPoint(class PyGeSplineEnt3d {lvalue})'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity3d)arg1, (Matrix3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} transformBy(class PyGeEntity3d {lvalue},class AcGeMatrix3d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity3d)arg1, (Vector3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} translateBy(class PyGeEntity3d {lvalue},class AcGeVector3d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity3d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity3d {lvalue})'''
    ...

class SurfSurfInt:
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity3d)arg1) -> Entity3d :

    C++ signature :
        class PyGeEntity3d copy(class PyGeEntity3d {lvalue})'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity3d)arg1, (Entity3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity3d {lvalue},class PyGeEntity3d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity3d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity3d {lvalue},enum AcGe::EntityId)'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity3d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity3d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Entity3d)arg1, (Point3d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyGeEntity3d {lvalue},class AcGePoint3d)

isOn( (Entity3d)arg1, (Point3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyGeEntity3d {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} mirror(class PyGeEntity3d {lvalue},class PyGePlane)'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d)

rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3, (Point3d)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d,class AcGePoint3d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity3d)arg1, (float)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double)

scaleBy( (Entity3d)arg1, (float)arg2, (Point3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double,class AcGePoint3d)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity3d)arg1, (Matrix3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} transformBy(class PyGeEntity3d {lvalue},class AcGeMatrix3d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity3d)arg1, (Vector3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} translateBy(class PyGeEntity3d {lvalue},class AcGeVector3d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity3d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity3d {lvalue})'''
    ...

class Surface:
    def className (self, *args, **kwargs):
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closestPointTo (self, *args, **kwargs):
      '''
closestPointTo( (Surface)arg1, (Point3d)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyAcGeSurface {lvalue},class AcGePoint3d)

closestPointTo( (Surface)arg1, (Point3d)arg2, (Tol)arg3) -> Point3d :

    C++ signature :
        class AcGePoint3d closestPointTo(class PyAcGeSurface {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def copy (self, *args, **kwargs):
      '''
copy( (Entity3d)arg1) -> Entity3d :

    C++ signature :
        class PyGeEntity3d copy(class PyGeEntity3d {lvalue})'''
    ...
    def distanceTo (self, *args, **kwargs):
      '''
distanceTo( (Surface)arg1, (Point3d)arg2) -> float :

    C++ signature :
        double distanceTo(class PyAcGeSurface {lvalue},class AcGePoint3d)

distanceTo( (Surface)arg1, (Point3d)arg2, (Tol)arg3) -> float :

    C++ signature :
        double distanceTo(class PyAcGeSurface {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def evalPoint (self, *args, **kwargs):
      '''
evalPoint( (Surface)arg1, (Point2d)arg2) -> Point3d :

    C++ signature :
        class AcGePoint3d evalPoint(class PyAcGeSurface {lvalue},class AcGePoint2d)

evalPoint( (Surface)arg1, (Point2d)arg2, (CmdFlags)arg3, (list)arg4) -> Point3d :

    C++ signature :
        class AcGePoint3d evalPoint(class PyAcGeSurface {lvalue},class AcGePoint2d,int,class boost::python::list {lvalue})

evalPoint( (Surface)arg1, (Point2d)arg2, (CmdFlags)arg3, (list)arg4, (Vector3d)arg5) -> Point3d :

    C++ signature :
        class AcGePoint3d evalPoint(class PyAcGeSurface {lvalue},class AcGePoint2d,int,class boost::python::list {lvalue},class AcGeVector3d {lvalue})'''
    ...
    def isClosedInU (self, *args, **kwargs):
      '''
isClosedInU( (Surface)arg1) -> bool :

    C++ signature :
        bool isClosedInU(class PyAcGeSurface {lvalue})

isClosedInU( (Surface)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosedInU(class PyAcGeSurface {lvalue},class AcGeTol)'''
    ...
    def isClosedInV (self, *args, **kwargs):
      '''
isClosedInV( (Surface)arg1) -> bool :

    C++ signature :
        bool isClosedInV(class PyAcGeSurface {lvalue})

isClosedInV( (Surface)arg1, (Tol)arg2) -> bool :

    C++ signature :
        bool isClosedInV(class PyAcGeSurface {lvalue},class AcGeTol)'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Entity3d)arg1, (Entity3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isEqualTo(class PyGeEntity3d {lvalue},class PyGeEntity3d,class AcGeTol)'''
    ...
    def isKindOf (self, *args, **kwargs):
      '''
isKindOf( (Entity3d)arg1, (EntityId)arg2) -> bool :

    C++ signature :
        bool isKindOf(class PyGeEntity3d {lvalue},enum AcGe::EntityId)'''
    ...
    def isNormalReversed (self, *args, **kwargs):
      '''
isNormalReversed( (Surface)arg1) -> bool :

    C++ signature :
        bool isNormalReversed(class PyAcGeSurface {lvalue})'''
    ...
    def isNull (self, *args, **kwargs):
      '''
isNull( (Entity3d)arg1) -> bool :

    C++ signature :
        bool isNull(class PyGeEntity3d {lvalue})'''
    ...
    def isOn (self, *args, **kwargs):
      '''
isOn( (Surface)arg1, (Point3d)arg2) -> bool :

    C++ signature :
        bool isOn(class PyAcGeSurface {lvalue},class AcGePoint3d)

isOn( (Surface)arg1, (Point3d)arg2, (Tol)arg3) -> bool :

    C++ signature :
        bool isOn(class PyAcGeSurface {lvalue},class AcGePoint3d,class AcGeTol)

isOn( (Surface)arg1, (Point3d)arg2, (Point2d)arg3) -> bool :

    C++ signature :
        bool isOn(class PyAcGeSurface {lvalue},class AcGePoint3d,class AcGePoint2d {lvalue})

isOn( (Surface)arg1, (Point3d)arg2, (Point2d)arg3, (Tol)arg4) -> bool :

    C++ signature :
        bool isOn(class PyAcGeSurface {lvalue},class AcGePoint3d,class AcGePoint2d {lvalue},class AcGeTol)'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Entity3d)arg1, (Plane)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} mirror(class PyGeEntity3d {lvalue},class PyGePlane)'''
    ...
    def paramOf (self, *args, **kwargs):
      '''
paramOf( (Surface)arg1, (Point3d)arg2) -> Point2d :

    C++ signature :
        class AcGePoint2d paramOf(class PyAcGeSurface {lvalue},class AcGePoint3d)

paramOf( (Surface)arg1, (Point3d)arg2, (Tol)arg3) -> Point2d :

    C++ signature :
        class AcGePoint2d paramOf(class PyAcGeSurface {lvalue},class AcGePoint3d,class AcGeTol)'''
    ...
    def reverseNormal (self, *args, **kwargs):
      '''
reverseNormal( (Surface)arg1) -> Surface :

    C++ signature :
        class PyAcGeSurface {lvalue} reverseNormal(class PyAcGeSurface {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d)

rotateBy( (Entity3d)arg1, (float)arg2, (Vector3d)arg3, (Point3d)arg4) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} rotateBy(class PyGeEntity3d {lvalue},double,class AcGeVector3d,class AcGePoint3d)'''
    ...
    def scaleBy (self, *args, **kwargs):
      '''
scaleBy( (Entity3d)arg1, (float)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double)

scaleBy( (Entity3d)arg1, (float)arg2, (Point3d)arg3) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} scaleBy(class PyGeEntity3d {lvalue},double,class AcGePoint3d)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Entity3d)arg1, (Matrix3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} transformBy(class PyGeEntity3d {lvalue},class AcGeMatrix3d)'''
    ...
    def translateBy (self, *args, **kwargs):
      '''
translateBy( (Entity3d)arg1, (Vector3d)arg2) -> Entity3d :

    C++ signature :
        class PyGeEntity3d {lvalue} translateBy(class PyGeEntity3d {lvalue},class AcGeVector3d)'''
    ...
    def type (self, *args, **kwargs):
      '''
type( (Entity3d)arg1) -> EntityId :

    C++ signature :
        enum AcGe::EntityId type(class PyGeEntity3d {lvalue})'''
    ...

class Tol:
    def current (self, *args, **kwargs):
      '''None'''
    ...
    def equalPoint (self, *args, **kwargs):
      '''
equalPoint( (Tol)arg1) -> float :

    C++ signature :
        double equalPoint(class AcGeTol {lvalue})'''
    ...
    def equalVector (self, *args, **kwargs):
      '''
equalVector( (Tol)arg1) -> float :

    C++ signature :
        double equalVector(class AcGeTol {lvalue})'''
    ...
    def setEqualPoint (self, *args, **kwargs):
      '''
setEqualPoint( (Tol)arg1, (float)arg2) -> None :

    C++ signature :
        void setEqualPoint(class AcGeTol {lvalue},double)'''
    ...
    def setEqualVector (self, *args, **kwargs):
      '''
setEqualVector( (Tol)arg1, (float)arg2) -> None :

    C++ signature :
        void setEqualVector(class AcGeTol {lvalue},double)'''
    ...

class Vector2d:
    def angle (self, *args, **kwargs):
      '''
angle( (Vector2d)arg1) -> float :

    C++ signature :
        double angle(class AcGeVector2d {lvalue})'''
    ...
    def angleTo (self, *args, **kwargs):
      '''
angleTo( (Vector2d)arg1, (Vector2d)arg2) -> float :

    C++ signature :
        double angleTo(class AcGeVector2d {lvalue},class AcGeVector2d)'''
    ...
    def dotProduct (self, *args, **kwargs):
      '''
dotProduct( (Vector2d)arg1, (Vector2d)arg2) -> float :

    C++ signature :
        double dotProduct(class AcGeVector2d {lvalue},class AcGeVector2d)'''
    ...
    def isCodirectionalTo (self, *args, **kwargs):
      '''
isCodirectionalTo( (Vector2d)arg1, (Vector2d)arg2 [, (Tol)AcGeTol=<PyGe.Tol object at 0x000001F0377935B0>]) -> bool :

    C++ signature :
        bool isCodirectionalTo(class AcGeVector2d {lvalue},class AcGeVector2d [,class AcGeTol=<PyGe.Tol object at 0x000001F0377935B0>])'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Vector2d)arg1, (Vector2d)arg2 [, (Tol)AcGeTol=<PyGe.Tol object at 0x000001F0377936D0>]) -> bool :

    C++ signature :
        bool isEqualTo(class AcGeVector2d {lvalue},class AcGeVector2d [,class AcGeTol=<PyGe.Tol object at 0x000001F0377936D0>])'''
    ...
    def isParallelTo (self, *args, **kwargs):
      '''
isParallelTo( (Vector2d)arg1, (Vector2d)arg2 [, (Tol)AcGeTol=<PyGe.Tol object at 0x000001F037793520>]) -> bool :

    C++ signature :
        bool isParallelTo(class AcGeVector2d {lvalue},class AcGeVector2d [,class AcGeTol=<PyGe.Tol object at 0x000001F037793520>])'''
    ...
    def isPerpendicularTo (self, *args, **kwargs):
      '''
isPerpendicularTo( (Vector2d)arg1, (Vector2d)arg2 [, (Tol)AcGeTol=<PyGe.Tol object at 0x000001F037793640>]) -> bool :

    C++ signature :
        bool isPerpendicularTo(class AcGeVector2d {lvalue},class AcGeVector2d [,class AcGeTol=<PyGe.Tol object at 0x000001F037793640>])'''
    ...
    def isUnitLength (self, *args, **kwargs):
      '''
isUnitLength( (Vector2d)arg1 [, (Tol)AcGeTol=<PyGe.Tol object at 0x000001F037793400>]) -> bool :

    C++ signature :
        bool isUnitLength(class AcGeVector2d {lvalue} [,class AcGeTol=<PyGe.Tol object at 0x000001F037793400>])'''
    ...
    def isZeroLength (self, *args, **kwargs):
      '''
isZeroLength( (Vector2d)arg1 [, (Tol)AcGeTol=<PyGe.Tol object at 0x000001F037793490>]) -> bool :

    C++ signature :
        bool isZeroLength(class AcGeVector2d {lvalue} [,class AcGeTol=<PyGe.Tol object at 0x000001F037793490>])'''
    ...
    def kIdentity (self, *args, **kwargs):
      '''None'''
    ...
    def kXAxis (self, *args, **kwargs):
      '''None'''
    ...
    def kYAxis (self, *args, **kwargs):
      '''None'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (Vector2d)arg1) -> float :

    C++ signature :
        double length(class AcGeVector2d {lvalue})'''
    ...
    def lengthSqrd (self, *args, **kwargs):
      '''
lengthSqrd( (Vector2d)arg1) -> float :

    C++ signature :
        double lengthSqrd(class AcGeVector2d {lvalue})'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Vector2d)arg1, (Vector2d)arg2) -> Vector2d :

    C++ signature :
        class AcGeVector2d {lvalue} mirror(class AcGeVector2d {lvalue},class AcGeVector2d)'''
    ...
    def negate (self, *args, **kwargs):
      '''
negate( (Vector2d)arg1) -> Vector2d :

    C++ signature :
        class AcGeVector2d {lvalue} negate(class AcGeVector2d {lvalue})'''
    ...
    def normal (self, *args, **kwargs):
      '''
normal( (Vector2d)arg1 [, (Tol)AcGeTol=<PyGe.Tol object at 0x000001F0377932E0>]) -> Vector2d :

    C++ signature :
        class AcGeVector2d normal(class AcGeVector2d {lvalue} [,class AcGeTol=<PyGe.Tol object at 0x000001F0377932E0>])'''
    ...
    def normalize (self, *args, **kwargs):
      '''
normalize( (Vector2d)arg1 [, (Tol)AcGeTol=<PyGe.Tol object at 0x000001F037793370>]) -> Vector2d :

    C++ signature :
        class AcGeVector2d {lvalue} normalize(class AcGeVector2d {lvalue} [,class AcGeTol=<PyGe.Tol object at 0x000001F037793370>])'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Vector2d)arg1, (float)arg2) -> Vector2d :

    C++ signature :
        class AcGeVector2d {lvalue} rotateBy(class AcGeVector2d {lvalue},double)'''
    ...
    def set (self, *args, **kwargs):
      '''
set( (Vector2d)arg1, (float)arg2, (float)arg3) -> Vector2d :

    C++ signature :
        class AcGeVector2d {lvalue} set(class AcGeVector2d {lvalue},double,double)'''
    ...
    def setToProduct (self, *args, **kwargs):
      '''
setToProduct( (Vector2d)arg1, (Vector2d)arg2, (float)arg3) -> Vector2d :

    C++ signature :
        class AcGeVector2d {lvalue} setToProduct(class AcGeVector2d {lvalue},class AcGeVector2d,double)

setToProduct( (Vector2d)arg1, (Matrix2d)arg2, (Vector2d)arg3) -> Vector2d :

    C++ signature :
        class AcGeVector2d {lvalue} setToProduct(class AcGeVector2d {lvalue},class AcGeMatrix2d,class AcGeVector2d)'''
    ...
    def setToSum (self, *args, **kwargs):
      '''
setToSum( (Vector2d)arg1, (Vector2d)arg2, (Vector2d)arg3) -> Vector2d :

    C++ signature :
        class AcGeVector2d {lvalue} setToSum(class AcGeVector2d {lvalue},class AcGeVector2d,class AcGeVector2d)'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (Vector2d)arg1) -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > toString(class AcGeVector2d)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Vector2d)arg1, (Matrix2d)arg2) -> Vector2d :

    C++ signature :
        class AcGeVector2d {lvalue} transformBy(class AcGeVector2d {lvalue},class AcGeMatrix2d)'''
    ...
    def x (self, *args, **kwargs):
      '''None'''
    ...
    def y (self, *args, **kwargs):
      '''None'''
    ...

class Vector3d:
    def angleOnPlane (self, *args, **kwargs):
      '''
angleOnPlane( (Vector3d)arg1, (object)arg2) -> float :

    C++ signature :
        double angleOnPlane(class AcGeVector3d {lvalue},class AcGePlanarEnt)'''
    ...
    def angleTo (self, *args, **kwargs):
      '''
angleTo( (Vector3d)arg1, (Vector3d)arg2) -> float :

    C++ signature :
        double angleTo(class AcGeVector3d {lvalue},class AcGeVector3d)

angleTo( (Vector3d)arg1, (Vector3d)arg2, (Vector3d)arg3) -> float :

    C++ signature :
        double angleTo(class AcGeVector3d {lvalue},class AcGeVector3d,class AcGeVector3d)'''
    ...
    def convert2d (self, *args, **kwargs):
      '''
convert2d( (Vector3d)arg1, (object)arg2) -> Vector2d :

    C++ signature :
        class AcGeVector2d convert2d(class AcGeVector3d {lvalue},class AcGePlanarEnt)'''
    ...
    def crossProduct (self, *args, **kwargs):
      '''
crossProduct( (Vector3d)arg1, (Vector3d)arg2) -> Vector3d :

    C++ signature :
        class AcGeVector3d crossProduct(class AcGeVector3d {lvalue},class AcGeVector3d)'''
    ...
    def dotProduct (self, *args, **kwargs):
      '''
dotProduct( (Vector3d)arg1, (Vector3d)arg2) -> float :

    C++ signature :
        double dotProduct(class AcGeVector3d {lvalue},class AcGeVector3d)'''
    ...
    def isCodirectionalTo (self, *args, **kwargs):
      '''
isCodirectionalTo( (Vector3d)arg1, (Vector3d)arg2 [, (Tol)AcGeTol=<PyGe.Tol object at 0x000001F037793BE0>]) -> bool :

    C++ signature :
        bool isCodirectionalTo(class AcGeVector3d {lvalue},class AcGeVector3d [,class AcGeTol=<PyGe.Tol object at 0x000001F037793BE0>])'''
    ...
    def isEqualTo (self, *args, **kwargs):
      '''
isEqualTo( (Vector3d)arg1, (Vector3d)arg2 [, (Tol)AcGeTol=<PyGe.Tol object at 0x000001F037793D00>]) -> bool :

    C++ signature :
        bool isEqualTo(class AcGeVector3d {lvalue},class AcGeVector3d [,class AcGeTol=<PyGe.Tol object at 0x000001F037793D00>])'''
    ...
    def isParallelTo (self, *args, **kwargs):
      '''
isParallelTo( (Vector3d)arg1, (Vector3d)arg2 [, (Tol)AcGeTol=<PyGe.Tol object at 0x000001F037793B50>]) -> bool :

    C++ signature :
        bool isParallelTo(class AcGeVector3d {lvalue},class AcGeVector3d [,class AcGeTol=<PyGe.Tol object at 0x000001F037793B50>])'''
    ...
    def isPerpendicularTo (self, *args, **kwargs):
      '''
isPerpendicularTo( (Vector3d)arg1, (Vector3d)arg2 [, (Tol)AcGeTol=<PyGe.Tol object at 0x000001F037793C70>]) -> bool :

    C++ signature :
        bool isPerpendicularTo(class AcGeVector3d {lvalue},class AcGeVector3d [,class AcGeTol=<PyGe.Tol object at 0x000001F037793C70>])'''
    ...
    def isUnitLength (self, *args, **kwargs):
      '''
isUnitLength( (Vector3d)arg1 [, (Tol)AcGeTol=<PyGe.Tol object at 0x000001F037793A30>]) -> bool :

    C++ signature :
        bool isUnitLength(class AcGeVector3d {lvalue} [,class AcGeTol=<PyGe.Tol object at 0x000001F037793A30>])'''
    ...
    def isZeroLength (self, *args, **kwargs):
      '''
isZeroLength( (Vector3d)arg1 [, (Tol)AcGeTol=<PyGe.Tol object at 0x000001F037793AC0>]) -> bool :

    C++ signature :
        bool isZeroLength(class AcGeVector3d {lvalue} [,class AcGeTol=<PyGe.Tol object at 0x000001F037793AC0>])'''
    ...
    def kIdentity (self, *args, **kwargs):
      '''None'''
    ...
    def kXAxis (self, *args, **kwargs):
      '''None'''
    ...
    def kYAxis (self, *args, **kwargs):
      '''None'''
    ...
    def kZAxis (self, *args, **kwargs):
      '''None'''
    ...
    def largestElement (self, *args, **kwargs):
      '''
largestElement( (Vector3d)arg1) -> int :

    C++ signature :
        unsigned int largestElement(class AcGeVector3d {lvalue})'''
    ...
    def length (self, *args, **kwargs):
      '''
length( (Vector3d)arg1) -> float :

    C++ signature :
        double length(class AcGeVector3d {lvalue})'''
    ...
    def lengthSqrd (self, *args, **kwargs):
      '''
lengthSqrd( (Vector3d)arg1) -> float :

    C++ signature :
        double lengthSqrd(class AcGeVector3d {lvalue})'''
    ...
    def mirror (self, *args, **kwargs):
      '''
mirror( (Vector3d)arg1, (Vector3d)arg2) -> Vector3d :

    C++ signature :
        class AcGeVector3d {lvalue} mirror(class AcGeVector3d {lvalue},class AcGeVector3d)'''
    ...
    def negate (self, *args, **kwargs):
      '''
negate( (Vector3d)arg1) -> Vector3d :

    C++ signature :
        class AcGeVector3d {lvalue} negate(class AcGeVector3d {lvalue})'''
    ...
    def normal (self, *args, **kwargs):
      '''
normal( (Vector3d)arg1 [, (Tol)AcGeTol=<PyGe.Tol object at 0x000001F0377939A0>]) -> Vector3d :

    C++ signature :
        class AcGeVector3d normal(class AcGeVector3d {lvalue} [,class AcGeTol=<PyGe.Tol object at 0x000001F0377939A0>])'''
    ...
    def normalize (self, *args, **kwargs):
      '''
normalize( (Vector3d)arg1, (Tol)arg2) -> Vector3d :

    C++ signature :
        class AcGeVector3d {lvalue} normalize(class AcGeVector3d {lvalue},class AcGeTol)

normalize( (Vector3d)arg1, (Tol)arg2, (AcGeError)arg3) -> Vector3d :

    C++ signature :
        class AcGeVector3d {lvalue} normalize(class AcGeVector3d {lvalue},class AcGeTol,enum AcGe::ErrorCondition {lvalue})'''
    ...
    def orthoProject (self, *args, **kwargs):
      '''
orthoProject( (Vector3d)arg1, (Vector3d)arg2) -> Vector3d :

    C++ signature :
        class AcGeVector3d orthoProject(class AcGeVector3d {lvalue},class AcGeVector3d)

orthoProject( (Vector3d)arg1, (Vector3d)arg2, (Tol)arg3, (AcGeError)arg4) -> Vector3d :

    C++ signature :
        class AcGeVector3d orthoProject(class AcGeVector3d {lvalue},class AcGeVector3d,class AcGeTol,enum AcGe::ErrorCondition {lvalue})'''
    ...
    def perpVector (self, *args, **kwargs):
      '''
perpVector( (Vector3d)arg1) -> Vector3d :

    C++ signature :
        class AcGeVector3d perpVector(class AcGeVector3d {lvalue})'''
    ...
    def project (self, *args, **kwargs):
      '''
project( (Vector3d)arg1, (Vector3d)arg2, (Vector3d)arg3) -> Vector3d :

    C++ signature :
        class AcGeVector3d project(class AcGeVector3d {lvalue},class AcGeVector3d,class AcGeVector3d)

project( (Vector3d)arg1, (Vector3d)arg2, (Vector3d)arg3, (Tol)arg4, (AcGeError)arg5) -> Vector3d :

    C++ signature :
        class AcGeVector3d project(class AcGeVector3d {lvalue},class AcGeVector3d,class AcGeVector3d,class AcGeTol,enum AcGe::ErrorCondition {lvalue})'''
    ...
    def rotateBy (self, *args, **kwargs):
      '''
rotateBy( (Vector3d)arg1, (float)arg2, (Vector3d)arg3) -> Vector3d :

    C++ signature :
        class AcGeVector3d {lvalue} rotateBy(class AcGeVector3d {lvalue},double,class AcGeVector3d)'''
    ...
    def rotateTo (self, *args, **kwargs):
      '''
rotateTo( (Vector3d)arg1, (Vector3d)arg2, (Vector3d)arg3) -> Matrix3d :

    C++ signature :
        class AcGeMatrix3d rotateTo(class AcGeVector3d {lvalue},class AcGeVector3d,class AcGeVector3d)'''
    ...
    def set (self, *args, **kwargs):
      '''
set( (Vector3d)arg1, (float)arg2, (float)arg3, (float)arg4) -> Vector3d :

    C++ signature :
        class AcGeVector3d {lvalue} set(class AcGeVector3d {lvalue},double,double,double)

set( (Vector3d)arg1, (object)arg2, (Vector2d)arg3) -> Vector3d :

    C++ signature :
        class AcGeVector3d {lvalue} set(class AcGeVector3d {lvalue},class AcGePlanarEnt,class AcGeVector2d)'''
    ...
    def setToProduct (self, *args, **kwargs):
      '''
setToProduct( (Vector3d)arg1, (Vector3d)arg2, (float)arg3) -> Vector3d :

    C++ signature :
        class AcGeVector3d {lvalue} setToProduct(class AcGeVector3d {lvalue},class AcGeVector3d,double)

setToProduct( (Vector3d)arg1, (Matrix3d)arg2, (Vector3d)arg3) -> Vector3d :

    C++ signature :
        class AcGeVector3d {lvalue} setToProduct(class AcGeVector3d {lvalue},class AcGeMatrix3d,class AcGeVector3d)'''
    ...
    def setToSum (self, *args, **kwargs):
      '''
setToSum( (Vector3d)arg1, (Vector3d)arg2, (Vector3d)arg3) -> Vector3d :

    C++ signature :
        class AcGeVector3d {lvalue} setToSum(class AcGeVector3d {lvalue},class AcGeVector3d,class AcGeVector3d)'''
    ...
    def toString (self, *args, **kwargs):
      '''
toString( (Vector3d)arg1) -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > toString(class AcGeVector3d)'''
    ...
    def transformBy (self, *args, **kwargs):
      '''
transformBy( (Vector3d)arg1, (Matrix3d)arg2) -> Vector3d :

    C++ signature :
        class AcGeVector3d {lvalue} transformBy(class AcGeVector3d {lvalue},class AcGeMatrix3d)'''
    ...
    def x (self, *args, **kwargs):
      '''None'''
    ...
    def y (self, *args, **kwargs):
      '''None'''
    ...
    def z (self, *args, **kwargs):
      '''None'''
    ...

class __loader__:
    def _ORIGIN (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def create_module (spec):
      '''Create a built-in module'''
    ...
    def exec_module (module):
      '''Exec a built-in module'''
    ...
    def find_module (fullname, path=None):
      '''Find the built-in module.

        If 'path' is ever specified then the search is considered a failure.

        This method is deprecated.  Use find_spec() instead.

        '''
    ...
    def find_spec (fullname, path=None, target=None):
      '''None'''
    ...
    def get_code (fullname):
      '''Return None as built-in modules do not have code objects.'''
    ...
    def get_source (fullname):
      '''Return None as built-in modules do not have source code.'''
    ...
    def is_package (fullname):
      '''Return False as built-in modules are never packages.'''
    ...
    def load_module (fullname):
      '''Load the specified module into sys.modules and return it.

    This method is deprecated.  Use loader.exec_module() instead.

    '''
    ...
    def module_repr (module):
      '''Return repr for the module.

        The method is deprecated.  The import machinery does the job itself.

        '''
    ...
    def capitalize ():
      '''Return a capitalized version of the string.

More specifically, make the first character have upper case and the rest lower
case.'''
    ...
    def casefold ():
      '''Return a version of the string suitable for caseless comparisons.'''
    ...
    def center (width, fillchar=' ', /):
      '''Return a centered string of length width.

Padding is done using the specified fill character (default is a space).'''
    ...
    def count (self, *args, **kwargs):
      '''S.count(sub[, start[, end]]) -> int

Return the number of non-overlapping occurrences of substring sub in
string S[start:end].  Optional arguments start and end are
interpreted as in slice notation.'''
    ...
    def encode (encoding='utf-8', errors='strict'):
      '''Encode the string using the codec registered for encoding.

  encoding
    The encoding in which to encode the string.
  errors
    The error handling scheme to use for encoding errors.
    The default is 'strict' meaning that encoding errors raise a
    UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and
    'xmlcharrefreplace' as well as any other name registered with
    codecs.register_error that can handle UnicodeEncodeErrors.'''
    ...
    def endswith (self, *args, **kwargs):
      '''S.endswith(suffix[, start[, end]]) -> bool

Return True if S ends with the specified suffix, False otherwise.
With optional start, test S beginning at that position.
With optional end, stop comparing S at that position.
suffix can also be a tuple of strings to try.'''
    ...
    def expandtabs (tabsize=8):
      '''Return a copy where all tab characters are expanded using spaces.

If tabsize is not given, a tab size of 8 characters is assumed.'''
    ...
    def find (self, *args, **kwargs):
      '''S.find(sub[, start[, end]]) -> int

Return the lowest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.

Return -1 on failure.'''
    ...
    def format (self, *args, **kwargs):
      '''S.format(*args, **kwargs) -> str

Return a formatted version of S, using substitutions from args and kwargs.
The substitutions are identified by braces ('{' and '}').'''
    ...
    def format_map (self, *args, **kwargs):
      '''S.format_map(mapping) -> str

Return a formatted version of S, using substitutions from mapping.
The substitutions are identified by braces ('{' and '}').'''
    ...
    def index (self, *args, **kwargs):
      '''S.index(sub[, start[, end]]) -> int

Return the lowest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.

Raises ValueError when the substring is not found.'''
    ...
    def isalnum ():
      '''Return True if the string is an alpha-numeric string, False otherwise.

A string is alpha-numeric if all characters in the string are alpha-numeric and
there is at least one character in the string.'''
    ...
    def isalpha ():
      '''Return True if the string is an alphabetic string, False otherwise.

A string is alphabetic if all characters in the string are alphabetic and there
is at least one character in the string.'''
    ...
    def isascii ():
      '''Return True if all characters in the string are ASCII, False otherwise.

ASCII characters have code points in the range U+0000-U+007F.
Empty string is ASCII too.'''
    ...
    def isdecimal ():
      '''Return True if the string is a decimal string, False otherwise.

A string is a decimal string if all characters in the string are decimal and
there is at least one character in the string.'''
    ...
    def isdigit ():
      '''Return True if the string is a digit string, False otherwise.

A string is a digit string if all characters in the string are digits and there
is at least one character in the string.'''
    ...
    def isidentifier ():
      '''Return True if the string is a valid Python identifier, False otherwise.

Call keyword.iskeyword(s) to test whether string s is a reserved identifier,
such as "def" or "class".'''
    ...
    def islower ():
      '''Return True if the string is a lowercase string, False otherwise.

A string is lowercase if all cased characters in the string are lowercase and
there is at least one cased character in the string.'''
    ...
    def isnumeric ():
      '''Return True if the string is a numeric string, False otherwise.

A string is numeric if all characters in the string are numeric and there is at
least one character in the string.'''
    ...
    def isprintable ():
      '''Return True if the string is printable, False otherwise.

A string is printable if all of its characters are considered printable in
repr() or if it is empty.'''
    ...
    def isspace ():
      '''Return True if the string is a whitespace string, False otherwise.

A string is whitespace if all characters in the string are whitespace and there
is at least one character in the string.'''
    ...
    def istitle ():
      '''Return True if the string is a title-cased string, False otherwise.

In a title-cased string, upper- and title-case characters may only
follow uncased characters and lowercase characters only cased ones.'''
    ...
    def isupper ():
      '''Return True if the string is an uppercase string, False otherwise.

A string is uppercase if all cased characters in the string are uppercase and
there is at least one cased character in the string.'''
    ...
    def join (iterable, /):
      '''Concatenate any number of strings.

The string whose method is called is inserted in between each given string.
The result is returned as a new string.

Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs''''
    ...
    def ljust (width, fillchar=' ', /):
      '''Return a left-justified string of length width.

Padding is done using the specified fill character (default is a space).'''
    ...
    def lower ():
      '''Return a copy of the string converted to lowercase.'''
    ...
    def lstrip (chars=None, /):
      '''Return a copy of the string with leading whitespace removed.

If chars is given and not None, remove characters in chars instead.'''
    ...
    def maketrans (self, *args, **kwargs):
      '''Return a translation table usable for str.translate().

If there is only one argument, it must be a dictionary mapping Unicode
ordinals (integers) or characters to Unicode ordinals, strings or None.
Character keys will be then converted to ordinals.
If there are two arguments, they must be strings of equal length, and
in the resulting dictionary, each character in x will be mapped to the
character at the same position in y. If there is a third argument, it
must be a string, whose characters will be mapped to None in the result.'''
    ...
    def partition (sep, /):
      '''Partition the string into three parts using the given separator.

This will search for the separator in the string.  If the separator is found,
returns a 3-tuple containing the part before the separator, the separator
itself, and the part after it.

If the separator is not found, returns a 3-tuple containing the original string
and two empty strings.'''
    ...
    def removeprefix (prefix, /):
      '''Return a str with the given prefix string removed if present.

If the string starts with the prefix string, return string[len(prefix):].
Otherwise, return a copy of the original string.'''
    ...
    def removesuffix (suffix, /):
      '''Return a str with the given suffix string removed if present.

If the string ends with the suffix string and that suffix is not empty,
return string[:-len(suffix)]. Otherwise, return a copy of the original
string.'''
    ...
    def replace (old, new, count=-1, /):
      '''Return a copy with all occurrences of substring old replaced by new.

  count
    Maximum number of occurrences to replace.
    -1 (the default value) means replace all occurrences.

If the optional argument count is given, only the first count occurrences are
replaced.'''
    ...
    def rfind (self, *args, **kwargs):
      '''S.rfind(sub[, start[, end]]) -> int

Return the highest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.

Return -1 on failure.'''
    ...
    def rindex (self, *args, **kwargs):
      '''S.rindex(sub[, start[, end]]) -> int

Return the highest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.

Raises ValueError when the substring is not found.'''
    ...
    def rjust (width, fillchar=' ', /):
      '''Return a right-justified string of length width.

Padding is done using the specified fill character (default is a space).'''
    ...
    def rpartition (sep, /):
      '''Partition the string into three parts using the given separator.

This will search for the separator in the string, starting at the end. If
the separator is found, returns a 3-tuple containing the part before the
separator, the separator itself, and the part after it.

If the separator is not found, returns a 3-tuple containing two empty strings
and the original string.'''
    ...
    def rsplit (sep=None, maxsplit=-1):
      '''Return a list of the substrings in the string, using sep as the separator string.

  sep
    The separator used to split the string.

    When set to None (the default value), will split on any whitespace
    character (including \\n \\r \\t \\f and spaces) and will discard
    empty strings from the result.
  maxsplit
    Maximum number of splits (starting from the left).
    -1 (the default value) means no limit.

Splitting starts at the end of the string and works to the front.'''
    ...
    def rstrip (chars=None, /):
      '''Return a copy of the string with trailing whitespace removed.

If chars is given and not None, remove characters in chars instead.'''
    ...
    def split (sep=None, maxsplit=-1):
      '''Return a list of the substrings in the string, using sep as the separator string.

  sep
    The separator used to split the string.

    When set to None (the default value), will split on any whitespace
    character (including \\n \\r \\t \\f and spaces) and will discard
    empty strings from the result.
  maxsplit
    Maximum number of splits (starting from the left).
    -1 (the default value) means no limit.

Note, str.split() is mainly useful for data that has been intentionally
delimited.  With natural text that includes punctuation, consider using
the regular expression module.'''
    ...
    def splitlines (keepends=False):
      '''Return a list of the lines in the string, breaking at line boundaries.

Line breaks are not included in the resulting list unless keepends is given and
true.'''
    ...
    def startswith (self, *args, **kwargs):
      '''S.startswith(prefix[, start[, end]]) -> bool

Return True if S starts with the specified prefix, False otherwise.
With optional start, test S beginning at that position.
With optional end, stop comparing S at that position.
prefix can also be a tuple of strings to try.'''
    ...
    def strip (chars=None, /):
      '''Return a copy of the string with leading and trailing whitespace removed.

If chars is given and not None, remove characters in chars instead.'''
    ...
    def swapcase ():
      '''Convert uppercase characters to lowercase and lowercase characters to uppercase.'''
    ...
    def title ():
      '''Return a version of the string where each word is titlecased.

More specifically, words start with uppercased characters and all remaining
cased characters have lower case.'''
    ...
    def translate (table, /):
      '''Replace each character in the string using the given translation table.

  table
    Translation table, which must be a mapping of Unicode ordinals to
    Unicode ordinals, strings, or None.

The table must implement lookup/indexing via __getitem__, for instance a
dictionary or list.  If this operation raises LookupError, the character is
left untouched.  Characters mapped to None are deleted.'''
    ...
    def upper ():
      '''Return a copy of the string converted to uppercase.'''
    ...
    def zfill (width, /):
      '''Pad a numeric string with zeros on the left, to fill a field of the given width.

The string is never truncated.'''
    ...
    def capitalize ():
      '''Return a capitalized version of the string.

More specifically, make the first character have upper case and the rest lower
case.'''
    ...
    def casefold ():
      '''Return a version of the string suitable for caseless comparisons.'''
    ...
    def center (width, fillchar=' ', /):
      '''Return a centered string of length width.

Padding is done using the specified fill character (default is a space).'''
    ...
    def count (self, *args, **kwargs):
      '''S.count(sub[, start[, end]]) -> int

Return the number of non-overlapping occurrences of substring sub in
string S[start:end].  Optional arguments start and end are
interpreted as in slice notation.'''
    ...
    def encode (encoding='utf-8', errors='strict'):
      '''Encode the string using the codec registered for encoding.

  encoding
    The encoding in which to encode the string.
  errors
    The error handling scheme to use for encoding errors.
    The default is 'strict' meaning that encoding errors raise a
    UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and
    'xmlcharrefreplace' as well as any other name registered with
    codecs.register_error that can handle UnicodeEncodeErrors.'''
    ...
    def endswith (self, *args, **kwargs):
      '''S.endswith(suffix[, start[, end]]) -> bool

Return True if S ends with the specified suffix, False otherwise.
With optional start, test S beginning at that position.
With optional end, stop comparing S at that position.
suffix can also be a tuple of strings to try.'''
    ...
    def expandtabs (tabsize=8):
      '''Return a copy where all tab characters are expanded using spaces.

If tabsize is not given, a tab size of 8 characters is assumed.'''
    ...
    def find (self, *args, **kwargs):
      '''S.find(sub[, start[, end]]) -> int

Return the lowest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.

Return -1 on failure.'''
    ...
    def format (self, *args, **kwargs):
      '''S.format(*args, **kwargs) -> str

Return a formatted version of S, using substitutions from args and kwargs.
The substitutions are identified by braces ('{' and '}').'''
    ...
    def format_map (self, *args, **kwargs):
      '''S.format_map(mapping) -> str

Return a formatted version of S, using substitutions from mapping.
The substitutions are identified by braces ('{' and '}').'''
    ...
    def index (self, *args, **kwargs):
      '''S.index(sub[, start[, end]]) -> int

Return the lowest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.

Raises ValueError when the substring is not found.'''
    ...
    def isalnum ():
      '''Return True if the string is an alpha-numeric string, False otherwise.

A string is alpha-numeric if all characters in the string are alpha-numeric and
there is at least one character in the string.'''
    ...
    def isalpha ():
      '''Return True if the string is an alphabetic string, False otherwise.

A string is alphabetic if all characters in the string are alphabetic and there
is at least one character in the string.'''
    ...
    def isascii ():
      '''Return True if all characters in the string are ASCII, False otherwise.

ASCII characters have code points in the range U+0000-U+007F.
Empty string is ASCII too.'''
    ...
    def isdecimal ():
      '''Return True if the string is a decimal string, False otherwise.

A string is a decimal string if all characters in the string are decimal and
there is at least one character in the string.'''
    ...
    def isdigit ():
      '''Return True if the string is a digit string, False otherwise.

A string is a digit string if all characters in the string are digits and there
is at least one character in the string.'''
    ...
    def isidentifier ():
      '''Return True if the string is a valid Python identifier, False otherwise.

Call keyword.iskeyword(s) to test whether string s is a reserved identifier,
such as "def" or "class".'''
    ...
    def islower ():
      '''Return True if the string is a lowercase string, False otherwise.

A string is lowercase if all cased characters in the string are lowercase and
there is at least one cased character in the string.'''
    ...
    def isnumeric ():
      '''Return True if the string is a numeric string, False otherwise.

A string is numeric if all characters in the string are numeric and there is at
least one character in the string.'''
    ...
    def isprintable ():
      '''Return True if the string is printable, False otherwise.

A string is printable if all of its characters are considered printable in
repr() or if it is empty.'''
    ...
    def isspace ():
      '''Return True if the string is a whitespace string, False otherwise.

A string is whitespace if all characters in the string are whitespace and there
is at least one character in the string.'''
    ...
    def istitle ():
      '''Return True if the string is a title-cased string, False otherwise.

In a title-cased string, upper- and title-case characters may only
follow uncased characters and lowercase characters only cased ones.'''
    ...
    def isupper ():
      '''Return True if the string is an uppercase string, False otherwise.

A string is uppercase if all cased characters in the string are uppercase and
there is at least one cased character in the string.'''
    ...
    def join (iterable, /):
      '''Concatenate any number of strings.

The string whose method is called is inserted in between each given string.
The result is returned as a new string.

Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs''''
    ...
    def ljust (width, fillchar=' ', /):
      '''Return a left-justified string of length width.

Padding is done using the specified fill character (default is a space).'''
    ...
    def lower ():
      '''Return a copy of the string converted to lowercase.'''
    ...
    def lstrip (chars=None, /):
      '''Return a copy of the string with leading whitespace removed.

If chars is given and not None, remove characters in chars instead.'''
    ...
    def maketrans (self, *args, **kwargs):
      '''Return a translation table usable for str.translate().

If there is only one argument, it must be a dictionary mapping Unicode
ordinals (integers) or characters to Unicode ordinals, strings or None.
Character keys will be then converted to ordinals.
If there are two arguments, they must be strings of equal length, and
in the resulting dictionary, each character in x will be mapped to the
character at the same position in y. If there is a third argument, it
must be a string, whose characters will be mapped to None in the result.'''
    ...
    def partition (sep, /):
      '''Partition the string into three parts using the given separator.

This will search for the separator in the string.  If the separator is found,
returns a 3-tuple containing the part before the separator, the separator
itself, and the part after it.

If the separator is not found, returns a 3-tuple containing the original string
and two empty strings.'''
    ...
    def removeprefix (prefix, /):
      '''Return a str with the given prefix string removed if present.

If the string starts with the prefix string, return string[len(prefix):].
Otherwise, return a copy of the original string.'''
    ...
    def removesuffix (suffix, /):
      '''Return a str with the given suffix string removed if present.

If the string ends with the suffix string and that suffix is not empty,
return string[:-len(suffix)]. Otherwise, return a copy of the original
string.'''
    ...
    def replace (old, new, count=-1, /):
      '''Return a copy with all occurrences of substring old replaced by new.

  count
    Maximum number of occurrences to replace.
    -1 (the default value) means replace all occurrences.

If the optional argument count is given, only the first count occurrences are
replaced.'''
    ...
    def rfind (self, *args, **kwargs):
      '''S.rfind(sub[, start[, end]]) -> int

Return the highest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.

Return -1 on failure.'''
    ...
    def rindex (self, *args, **kwargs):
      '''S.rindex(sub[, start[, end]]) -> int

Return the highest index in S where substring sub is found,
such that sub is contained within S[start:end].  Optional
arguments start and end are interpreted as in slice notation.

Raises ValueError when the substring is not found.'''
    ...
    def rjust (width, fillchar=' ', /):
      '''Return a right-justified string of length width.

Padding is done using the specified fill character (default is a space).'''
    ...
    def rpartition (sep, /):
      '''Partition the string into three parts using the given separator.

This will search for the separator in the string, starting at the end. If
the separator is found, returns a 3-tuple containing the part before the
separator, the separator itself, and the part after it.

If the separator is not found, returns a 3-tuple containing two empty strings
and the original string.'''
    ...
    def rsplit (sep=None, maxsplit=-1):
      '''Return a list of the substrings in the string, using sep as the separator string.

  sep
    The separator used to split the string.

    When set to None (the default value), will split on any whitespace
    character (including \\n \\r \\t \\f and spaces) and will discard
    empty strings from the result.
  maxsplit
    Maximum number of splits (starting from the left).
    -1 (the default value) means no limit.

Splitting starts at the end of the string and works to the front.'''
    ...
    def rstrip (chars=None, /):
      '''Return a copy of the string with trailing whitespace removed.

If chars is given and not None, remove characters in chars instead.'''
    ...
    def split (sep=None, maxsplit=-1):
      '''Return a list of the substrings in the string, using sep as the separator string.

  sep
    The separator used to split the string.

    When set to None (the default value), will split on any whitespace
    character (including \\n \\r \\t \\f and spaces) and will discard
    empty strings from the result.
  maxsplit
    Maximum number of splits (starting from the left).
    -1 (the default value) means no limit.

Note, str.split() is mainly useful for data that has been intentionally
delimited.  With natural text that includes punctuation, consider using
the regular expression module.'''
    ...
    def splitlines (keepends=False):
      '''Return a list of the lines in the string, breaking at line boundaries.

Line breaks are not included in the resulting list unless keepends is given and
true.'''
    ...
    def startswith (self, *args, **kwargs):
      '''S.startswith(prefix[, start[, end]]) -> bool

Return True if S starts with the specified prefix, False otherwise.
With optional start, test S beginning at that position.
With optional end, stop comparing S at that position.
prefix can also be a tuple of strings to try.'''
    ...
    def strip (chars=None, /):
      '''Return a copy of the string with leading and trailing whitespace removed.

If chars is given and not None, remove characters in chars instead.'''
    ...
    def swapcase ():
      '''Convert uppercase characters to lowercase and lowercase characters to uppercase.'''
    ...
    def title ():
      '''Return a version of the string where each word is titlecased.

More specifically, words start with uppercased characters and all remaining
cased characters have lower case.'''
    ...
    def translate (table, /):
      '''Replace each character in the string using the given translation table.

  table
    Translation table, which must be a mapping of Unicode ordinals to
    Unicode ordinals, strings, or None.

The table must implement lookup/indexing via __getitem__, for instance a
dictionary or list.  If this operation raises LookupError, the character is
left untouched.  Characters mapped to None are deleted.'''
    ...
    def upper ():
      '''Return a copy of the string converted to uppercase.'''
    ...
    def zfill (width, /):
      '''Pad a numeric string with zeros on the left, to fill a field of the given width.

The string is never truncated.'''
    ...
    def _cached (self, *args, **kwargs):
      '''None'''
    ...
    def _initializing (self, *args, **kwargs):
      '''bool(x) -> bool

Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.'''
    ...
    def _set_fileattr (self, *args, **kwargs):
      '''bool(x) -> bool

Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.'''
    ...
    def cached (self, *args, **kwargs):
      '''None'''
    ...
    def has_location (self, *args, **kwargs):
      '''bool(x) -> bool

Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.'''
    ...
    def loader ():
      '''Meta path import for built-in modules.

    All methods are either class or static methods to avoid the need to
    instantiate the class.

    '''
    ...
    def loader_state (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def origin (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def parent (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def submodule_search_locations (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def k0Arg1 (self, *args, **kwargs):
      '''None'''
    ...
    def k0Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def k0This (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1InsideThis (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1OnThis (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1TooBig (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg1Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg1Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg2Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearlyDependentArg1Arg2Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kOk (self, *args, **kwargs):
      '''None'''
    ...
    def kPerpendicularArg1Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def k0Arg1 (self, *args, **kwargs):
      '''None'''
    ...
    def k0Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def k0This (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1InsideThis (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1OnThis (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1TooBig (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg1Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg1Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg2Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearlyDependentArg1Arg2Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kOk (self, *args, **kwargs):
      '''None'''
    ...
    def kPerpendicularArg1Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def k0Arg1 (self, *args, **kwargs):
      '''None'''
    ...
    def k0Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def k0This (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1InsideThis (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1OnThis (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1TooBig (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg1Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg1Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg2Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearlyDependentArg1Arg2Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kOk (self, *args, **kwargs):
      '''None'''
    ...
    def kPerpendicularArg1Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def k0Arg1 (self, *args, **kwargs):
      '''None'''
    ...
    def k0Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def k0This (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1InsideThis (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1OnThis (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1TooBig (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg1Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg1Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg2Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearlyDependentArg1Arg2Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kOk (self, *args, **kwargs):
      '''None'''
    ...
    def kPerpendicularArg1Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def k0Arg1 (self, *args, **kwargs):
      '''None'''
    ...
    def k0Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def k0This (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1InsideThis (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1OnThis (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1TooBig (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg1Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg1Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg2Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearlyDependentArg1Arg2Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kOk (self, *args, **kwargs):
      '''None'''
    ...
    def kPerpendicularArg1Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def k0Arg1 (self, *args, **kwargs):
      '''None'''
    ...
    def k0Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def k0This (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1InsideThis (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1OnThis (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1TooBig (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg1Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg1Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg2Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearlyDependentArg1Arg2Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kOk (self, *args, **kwargs):
      '''None'''
    ...
    def kPerpendicularArg1Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kChamfer (self, *args, **kwargs):
      '''None'''
    ...
    def kExtend (self, *args, **kwargs):
      '''None'''
    ...
    def kFillet (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def k0Arg1 (self, *args, **kwargs):
      '''None'''
    ...
    def k0Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def k0This (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1InsideThis (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1OnThis (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1TooBig (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg1Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg1Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg2Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearlyDependentArg1Arg2Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kOk (self, *args, **kwargs):
      '''None'''
    ...
    def kPerpendicularArg1Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def k0Arg1 (self, *args, **kwargs):
      '''None'''
    ...
    def k0Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def k0This (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1InsideThis (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1OnThis (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1TooBig (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg1Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg1Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg2Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearlyDependentArg1Arg2Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kOk (self, *args, **kwargs):
      '''None'''
    ...
    def kPerpendicularArg1Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def k0Arg1 (self, *args, **kwargs):
      '''None'''
    ...
    def k0Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def k0This (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1InsideThis (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1OnThis (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1TooBig (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg1Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg1Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg2Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearlyDependentArg1Arg2Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kOk (self, *args, **kwargs):
      '''None'''
    ...
    def kPerpendicularArg1Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kChamfer (self, *args, **kwargs):
      '''None'''
    ...
    def kExtend (self, *args, **kwargs):
      '''None'''
    ...
    def kFillet (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kChamfer (self, *args, **kwargs):
      '''None'''
    ...
    def kExtend (self, *args, **kwargs):
      '''None'''
    ...
    def kFillet (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def k0Arg1 (self, *args, **kwargs):
      '''None'''
    ...
    def k0Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def k0This (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1InsideThis (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1OnThis (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1TooBig (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg1Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg1Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg2Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearlyDependentArg1Arg2Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kOk (self, *args, **kwargs):
      '''None'''
    ...
    def kPerpendicularArg1Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def k0Arg1 (self, *args, **kwargs):
      '''None'''
    ...
    def k0Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def k0This (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1InsideThis (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1OnThis (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1TooBig (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg1Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg1Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg2Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearlyDependentArg1Arg2Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kOk (self, *args, **kwargs):
      '''None'''
    ...
    def kPerpendicularArg1Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def k0Arg1 (self, *args, **kwargs):
      '''None'''
    ...
    def k0Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def k0This (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1InsideThis (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1OnThis (self, *args, **kwargs):
      '''None'''
    ...
    def kArg1TooBig (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg1Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg1Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kEqualArg2Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearlyDependentArg1Arg2Arg3 (self, *args, **kwargs):
      '''None'''
    ...
    def kOk (self, *args, **kwargs):
      '''None'''
    ...
    def kPerpendicularArg1Arg2 (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def Helix (self, *args, **kwargs):
      '''None'''
    ...
    def as_integer_ratio ():
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count ():
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length ():
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def kAugPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kAugPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBezierCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock2d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundBlock3d (self, *args, **kwargs):
      '''None'''
    ...
    def kBoundedPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCircArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kClipBoundary2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCompositeCrv3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCone (self, *args, **kwargs):
      '''None'''
    ...
    def kConic2d (self, *args, **kwargs):
      '''None'''
    ...
    def kConic3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCubicSplineCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveCurveInt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSampleData (self, *args, **kwargs):
      '''None'''
    ...
    def kCurveSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kDSpline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipArc3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCone (self, *args, **kwargs):
      '''None'''
    ...
    def kEllipCylinder (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity2d (self, *args, **kwargs):
      '''None'''
    ...
    def kEntity3d (self, *args, **kwargs):
      '''None'''
    ...
    def kEnvelope2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalBoundedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalObject (self, *args, **kwargs):
      '''None'''
    ...
    def kExternalSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kFitData3d (self, *args, **kwargs):
      '''None'''
    ...
    def kHatch (self, *args, **kwargs):
      '''None'''
    ...
    def kIntervalBoundBlock (self, *args, **kwargs):
      '''None'''
    ...
    def kLine2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLine3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLineSeg3d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kLinearEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kNurbSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kObject (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kOffsetSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPlanarEnt (self, *args, **kwargs):
      '''None'''
    ...
    def kPlane (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPointOnSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolyline3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPolynomCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition2d (self, *args, **kwargs):
      '''None'''
    ...
    def kPosition3d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay2d (self, *args, **kwargs):
      '''None'''
    ...
    def kRay3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSphere (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSplineEnt3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurface (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve2dTo3d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceCurve3dTo2d (self, *args, **kwargs):
      '''None'''
    ...
    def kSurfaceSurfaceInt (self, *args, **kwargs):
      '''None'''
    ...
    def kTorus (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCrv2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve2d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedCurve3d (self, *args, **kwargs):
      '''None'''
    ...
    def kTrimmedSurface (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def names (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def real (self, *args, **kwargs):
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def to_bytes (length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs):
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
