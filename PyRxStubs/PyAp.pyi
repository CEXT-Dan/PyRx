
class Application:
    def applyHostIcon (self, *args, **kwargs)-> None :
      '''
applyHostIcon( (int)arg1) -> None :

    C++ signature :
        void applyHostIcon(unsigned __int64)'''
    ...
    def className (self, *args, **kwargs)-> str :
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def docManager (self, *args, **kwargs)-> DocManager :
      '''
docManager( (Application)arg1) -> DocManager :

    C++ signature :
        class PyApDocManager docManager(class PyApApplication {lvalue})'''
    ...
    def mainWnd (self, *args, **kwargs)-> int :
      '''
mainWnd() -> int :

    C++ signature :
        __int64 mainWnd()'''
    ...
    def setTitleThemeDark (self, *args, **kwargs)-> None :
      '''
setTitleThemeDark( (int)arg1) -> None :

    C++ signature :
        void setTitleThemeDark(unsigned __int64)'''
    ...

class CmdFlags:
    def DEFUN (self, *args, **kwargs)-> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
:
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def DOCEXCLUSIVELOCK (self, *args, **kwargs)-> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
:
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def DOCREADLOCK (self, *args, **kwargs)-> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
:
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def INPROGRESS (self, *args, **kwargs)-> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
:
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def INTERRUPTIBLE (self, *args, **kwargs)-> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
:
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def MODAL (self, *args, **kwargs)-> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
:
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def NOBEDIT (self, *args, **kwargs)-> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
:
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def NOHISTORY (self, *args, **kwargs)-> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
:
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def NOINTERNALLOCK (self, *args, **kwargs)-> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
:
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def NOMULTIPLE (self, *args, **kwargs)-> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
:
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def NOOEM (self, *args, **kwargs)-> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
:
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def NOPAPERSPACE (self, *args, **kwargs)-> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
:
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def NOPERSPECTIVE (self, *args, **kwargs)-> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
:
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def NOTILEMODE (self, *args, **kwargs)-> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
:
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def NO_UNDO_MARKER (self, *args, **kwargs)-> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
:
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def REDRAW (self, *args, **kwargs)-> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
:
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def SESSION (self, *args, **kwargs)-> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
:
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def TRANSPARENT (self, *args, **kwargs)-> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
:
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def UNDEFINED (self, *args, **kwargs)-> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
:
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...
    def USEPICKSET (self, *args, **kwargs)-> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
:
      '''int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4'''
    ...

class DocLockMode:
    def as_integer_ratio (self, /):
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count (self, /):
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length (self, /):
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''the denominator of a rational number in lowest terms'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''the imaginary part of a complex number'''
    ...
    def kAutoWrite (self, *args, **kwargs):
      '''None'''
    ...
    def kNone (self, *args, **kwargs):
      '''None'''
    ...
    def kNotLocked (self, *args, **kwargs):
      '''None'''
    ...
    def kProtectedAutoWrite (self, *args, **kwargs):
      '''None'''
    ...
    def kRead (self, *args, **kwargs):
      '''None'''
    ...
    def kWrite (self, *args, **kwargs):
      '''None'''
    ...
    def kXWrite (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def names (self, *args, **kwargs)-> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''the numerator of a rational number in lowest terms'''
    ...
    def real (self, *args, **kwargs):
      '''the real part of a complex number'''
    ...
    def to_bytes (self, /, length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs)-> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...

class DocManager:
    def activateDocument (self, *args, **kwargs)-> ErrorStatus :
      '''
activateDocument( (DocManager)arg1, (Document)arg2) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus activateDocument(class PyApDocManager {lvalue},class PyApDocument {lvalue})

activateDocument( (DocManager)arg1, (Document)arg2, (bool)arg3) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus activateDocument(class PyApDocManager {lvalue},class PyApDocument {lvalue},bool)'''
    ...
    def appContextCloseDocument (self, *args, **kwargs)-> ErrorStatus :
      '''
appContextCloseDocument( (DocManager)arg1, (Document)arg2) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus appContextCloseDocument(class PyApDocManager {lvalue},class PyApDocument {lvalue})'''
    ...
    def appContextNewDocument (self, *args, **kwargs)-> ErrorStatus :
      '''
appContextNewDocument( (DocManager)arg1, (str)arg2) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus appContextNewDocument(class PyApDocManager {lvalue},class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >)'''
    ...
    def appContextOpenDocument (self, *args, **kwargs)-> ErrorStatus :
      '''
appContextOpenDocument( (DocManager)arg1, (str)arg2) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus appContextOpenDocument(class PyApDocManager {lvalue},class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >)'''
    ...
    def appContextPromptOpenDocument (self, *args, **kwargs)-> ErrorStatus :
      '''
appContextPromptOpenDocument( (DocManager)arg1) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus appContextPromptOpenDocument(class PyApDocManager {lvalue})'''
    ...
    def appContextRecoverDocument (self, *args, **kwargs)-> ErrorStatus :
      '''
appContextRecoverDocument( (DocManager)arg1, (str)arg2) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus appContextRecoverDocument(class PyApDocManager {lvalue},class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >)'''
    ...
    def className (self, *args, **kwargs)-> str :
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def closeDocument (self, *args, **kwargs)-> ErrorStatus :
      '''
closeDocument( (DocManager)arg1, (Document)arg2) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus closeDocument(class PyApDocManager {lvalue},class PyApDocument {lvalue})'''
    ...
    def curDocument (self, *args, **kwargs)-> Document :
      '''
curDocument( (DocManager)arg1) -> Document :

    C++ signature :
        class PyApDocument curDocument(class PyApDocManager {lvalue})'''
    ...
    def defaultFormatForSave (self, *args, **kwargs)-> SaveFormat :
      '''
defaultFormatForSave( (DocManager)arg1) -> SaveFormat :

    C++ signature :
        enum AcApDocument::SaveFormat defaultFormatForSave(class PyApDocManager {lvalue})'''
    ...
    def disableDocumentActivation (self, *args, **kwargs)-> ErrorStatus :
      '''
disableDocumentActivation( (DocManager)arg1) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus disableDocumentActivation(class PyApDocManager {lvalue})'''
    ...
    def document (self, *args, **kwargs)-> Document :
      '''
document( (DocManager)arg1, (Database)arg2) -> Document :

    C++ signature :
        class PyApDocument document(class PyApDocManager {lvalue},class PyDbDatabase)'''
    ...
    def documentCount (self, *args, **kwargs)-> int :
      '''
documentCount( (DocManager)arg1) -> int :

    C++ signature :
        int documentCount(class PyApDocManager {lvalue})'''
    ...
    def enableDocumentActivation (self, *args, **kwargs)-> ErrorStatus :
      '''
enableDocumentActivation( (DocManager)arg1) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus enableDocumentActivation(class PyApDocManager {lvalue})'''
    ...
    def inputPending (self, *args, **kwargs)-> int :
      '''
inputPending( (DocManager)arg1, (Document)arg2) -> int :

    C++ signature :
        int inputPending(class PyApDocManager {lvalue},class PyApDocument {lvalue})'''
    ...
    def isA (self, *args, **kwargs)-> RxClass :
      '''
isA( (RxObject)arg1) -> RxClass :

    C++ signature :
        class PyRxClass isA(class PyRxObject {lvalue})'''
    ...
    def isApplicationContext (self, *args, **kwargs)-> bool :
      '''
isApplicationContext( (DocManager)arg1) -> bool :

    C++ signature :
        bool isApplicationContext(class PyApDocManager {lvalue})'''
    ...
    def isDocumentActivationEnabled (self, *args, **kwargs)-> bool :
      '''
isDocumentActivationEnabled( (DocManager)arg1) -> bool :

    C++ signature :
        bool isDocumentActivationEnabled(class PyApDocManager {lvalue})'''
    ...
    def isNull (self, *args, **kwargs)-> bool :
      '''
isNull( (RxObject)arg1) -> bool :

    C++ signature :
        bool isNull(class PyRxObject {lvalue})'''
    ...
    def lockDocument (self, *args, **kwargs)-> ErrorStatus :
      '''
lockDocument( (DocManager)arg1, (Document)arg2) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus lockDocument(class PyApDocManager {lvalue},class PyApDocument {lvalue})

lockDocument( (DocManager)arg1, (Document)arg2, (DocLockMode)arg3) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus lockDocument(class PyApDocManager {lvalue},class PyApDocument {lvalue},enum AcAp::DocLockMode)

lockDocument( (DocManager)arg1, (Document)arg2, (DocLockMode)arg3, (str)arg4, (str)arg5, (bool)arg6) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus lockDocument(class PyApDocManager {lvalue},class PyApDocument {lvalue},enum AcAp::DocLockMode,class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >,class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >,bool)'''
    ...
    def mdiActiveDocument (self, *args, **kwargs)-> Document :
      '''
mdiActiveDocument( (DocManager)arg1) -> Document :

    C++ signature :
        class PyApDocument mdiActiveDocument(class PyApDocManager {lvalue})'''
    ...
    def newAcApDocumentIterator (self, *args, **kwargs)-> list :
      '''
newAcApDocumentIterator( (DocManager)arg1) -> list :

    C++ signature :
        class boost::python::list newAcApDocumentIterator(class PyApDocManager {lvalue})'''
    ...
    def newDocument (self, *args, **kwargs)-> ErrorStatus :
      '''
newDocument( (DocManager)arg1) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus newDocument(class PyApDocManager {lvalue})'''
    ...
    def openDocument (self, *args, **kwargs)-> ErrorStatus :
      '''
openDocument( (DocManager)arg1) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus openDocument(class PyApDocManager {lvalue})'''
    ...
    def popResourceHandle (self, *args, **kwargs)-> None :
      '''
popResourceHandle( (DocManager)arg1) -> None :

    C++ signature :
        void popResourceHandle(class PyApDocManager {lvalue})'''
    ...
    def pushAcadResourceHandle (self, *args, **kwargs)-> None :
      '''
pushAcadResourceHandle( (DocManager)arg1) -> None :

    C++ signature :
        void pushAcadResourceHandle(class PyApDocManager {lvalue})'''
    ...
    def refCount (self, *args, **kwargs)-> int :
      '''
refCount( (RxObject)arg1) -> int :

    C++ signature :
        int refCount(class PyRxObject {lvalue})'''
    ...
    def sendModelessInterrupt (self, *args, **kwargs)-> ErrorStatus :
      '''
sendModelessInterrupt( (DocManager)arg1, (Document)arg2) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus sendModelessInterrupt(class PyApDocManager {lvalue},class PyApDocument {lvalue})'''
    ...
    def sendStringToExecute (self, *args, **kwargs)-> ErrorStatus :
      '''
sendStringToExecute( (DocManager)arg1, (Document)arg2, (str)arg3) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus sendStringToExecute(class PyApDocManager {lvalue},class PyApDocument {lvalue},class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >)

sendStringToExecute( (DocManager)arg1, (Document)arg2, (str)arg3, (bool)arg4, (bool)arg5, (bool)arg6) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus sendStringToExecute(class PyApDocManager {lvalue},class PyApDocument {lvalue},class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >,bool,bool,bool)'''
    ...
    def setCurDocument (self, *args, **kwargs)-> ErrorStatus :
      '''
setCurDocument( (DocManager)arg1, (Document)arg2) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus setCurDocument(class PyApDocManager {lvalue},class PyApDocument {lvalue})

setCurDocument( (DocManager)arg1, (Document)arg2, (DocLockMode)arg3, (bool)arg4) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus setCurDocument(class PyApDocManager {lvalue},class PyApDocument {lvalue},enum AcAp::DocLockMode,bool)'''
    ...
    def setDefaultFormatForSave (self, *args, **kwargs)-> ErrorStatus :
      '''
setDefaultFormatForSave( (DocManager)arg1, (SaveFormat)arg2) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus setDefaultFormatForSave(class PyApDocManager {lvalue},enum AcApDocument::SaveFormat)'''
    ...
    def unlockDocument (self, *args, **kwargs)-> ErrorStatus :
      '''
unlockDocument( (DocManager)arg1, (Document)arg2) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus unlockDocument(class PyApDocManager {lvalue},class PyApDocument {lvalue})'''
    ...

class DocManagerReactor:
    def addReactor (self, *args, **kwargs)-> None :
      '''
addReactor( (DocManagerReactor)arg1) -> None :

    C++ signature :
        void addReactor(class PyApDocManagerReactor {lvalue})'''
    ...
    def documentActivated (self, *args, **kwargs)-> None :
      '''
documentActivated( (DocManagerReactor)arg1, (Document)arg2) -> None :

    C++ signature :
        void documentActivated(class PyApDocManagerReactor {lvalue},class PyApDocument {lvalue})'''
    ...
    def documentActivationModified (self, *args, **kwargs)-> None :
      '''
documentActivationModified( (DocManagerReactor)arg1, (bool)arg2) -> None :

    C++ signature :
        void documentActivationModified(class PyApDocManagerReactor {lvalue},bool)'''
    ...
    def documentBecameCurrent (self, *args, **kwargs)-> None :
      '''
documentBecameCurrent( (DocManagerReactor)arg1, (Document)arg2) -> None :

    C++ signature :
        void documentBecameCurrent(class PyApDocManagerReactor {lvalue},class PyApDocument {lvalue})'''
    ...
    def documentCreateCanceled (self, *args, **kwargs)-> None :
      '''
documentCreateCanceled( (DocManagerReactor)arg1, (Document)arg2) -> None :

    C++ signature :
        void documentCreateCanceled(class PyApDocManagerReactor {lvalue},class PyApDocument {lvalue})'''
    ...
    def documentCreateStarted (self, *args, **kwargs)-> None :
      '''
documentCreateStarted( (DocManagerReactor)arg1, (Document)arg2) -> None :

    C++ signature :
        void documentCreateStarted(class PyApDocManagerReactor {lvalue},class PyApDocument {lvalue})'''
    ...
    def documentCreated (self, *args, **kwargs)-> None :
      '''
documentCreated( (DocManagerReactor)arg1, (Document)arg2) -> None :

    C++ signature :
        void documentCreated(class PyApDocManagerReactor {lvalue},class PyApDocument {lvalue})'''
    ...
    def documentDestroyed (self, *args, **kwargs)-> None :
      '''
documentDestroyed( (DocManagerReactor)arg1, (str)arg2) -> None :

    C++ signature :
        void documentDestroyed(class PyApDocManagerReactor {lvalue},class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >)'''
    ...
    def documentLockModeChangeVetoed (self, *args, **kwargs)-> None :
      '''
documentLockModeChangeVetoed( (DocManagerReactor)arg1, (Document)arg2, (str)arg3) -> None :

    C++ signature :
        void documentLockModeChangeVetoed(class PyApDocManagerReactor {lvalue},class PyApDocument {lvalue},class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >)'''
    ...
    def documentLockModeChanged (self, *args, **kwargs)-> None :
      '''
documentLockModeChanged( (DocManagerReactor)arg1, (Document)arg2, (DocLockMode)arg3, (DocLockMode)arg4, (DocLockMode)arg5, (str)arg6) -> None :

    C++ signature :
        void documentLockModeChanged(class PyApDocManagerReactor {lvalue},class PyApDocument {lvalue},enum AcAp::DocLockMode,enum AcAp::DocLockMode,enum AcAp::DocLockMode,class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >)'''
    ...
    def documentLockModeWillChange (self, *args, **kwargs)-> None :
      '''
documentLockModeWillChange( (DocManagerReactor)arg1, (Document)arg2, (DocLockMode)arg3, (DocLockMode)arg4, (DocLockMode)arg5, (str)arg6) -> None :

    C++ signature :
        void documentLockModeWillChange(class PyApDocManagerReactor {lvalue},class PyApDocument {lvalue},enum AcAp::DocLockMode,enum AcAp::DocLockMode,enum AcAp::DocLockMode,class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >)'''
    ...
    def documentToBeActivated (self, *args, **kwargs)-> None :
      '''
documentToBeActivated( (DocManagerReactor)arg1, (Document)arg2) -> None :

    C++ signature :
        void documentToBeActivated(class PyApDocManagerReactor {lvalue},class PyApDocument {lvalue})'''
    ...
    def documentToBeDeactivated (self, *args, **kwargs)-> None :
      '''
documentToBeDeactivated( (DocManagerReactor)arg1, (Document)arg2) -> None :

    C++ signature :
        void documentToBeDeactivated(class PyApDocManagerReactor {lvalue},class PyApDocument {lvalue})'''
    ...
    def documentToBeDestroyed (self, *args, **kwargs)-> None :
      '''
documentToBeDestroyed( (DocManagerReactor)arg1, (Document)arg2) -> None :

    C++ signature :
        void documentToBeDestroyed(class PyApDocManagerReactor {lvalue},class PyApDocument {lvalue})'''
    ...
    def removeReactor (self, *args, **kwargs)-> None :
      '''
removeReactor( (DocManagerReactor)arg1) -> None :

    C++ signature :
        void removeReactor(class PyApDocManagerReactor {lvalue})'''
    ...

class Document:
    def className (self, *args, **kwargs)-> str :
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def database (self, *args, **kwargs)-> Database :
      '''
database( (Document)arg1) -> Database :

    C++ signature :
        class PyDbDatabase database(class PyApDocument {lvalue})'''
    ...
    def docTitle (self, *args, **kwargs)-> str :
      '''
docTitle( (Document)arg1) -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > docTitle(class PyApDocument {lvalue})'''
    ...
    def docWnd (self, *args, **kwargs)-> int :
      '''
docWnd() -> int :

    C++ signature :
        __int64 docWnd()'''
    ...
    def downgradeDocOpen (self, *args, **kwargs)-> ErrorStatus :
      '''
downgradeDocOpen( (Document)arg1, (bool)arg2) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus downgradeDocOpen(class PyApDocument {lvalue},bool)'''
    ...
    def editor (self, *args, **kwargs)-> Editor :
      '''
editor( (Document)arg1) -> Editor :

    C++ signature :
        class PyAcEditor editor(class PyApDocument {lvalue})'''
    ...
    def fileName (self, *args, **kwargs)-> str :
      '''
fileName( (Document)arg1) -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > fileName(class PyApDocument {lvalue})'''
    ...
    def formatForSave (self, *args, **kwargs)-> SaveFormat :
      '''
formatForSave( (Document)arg1) -> SaveFormat :

    C++ signature :
        enum AcApDocument::SaveFormat formatForSave(class PyApDocument {lvalue})'''
    ...
    def getCountOfLispList (self, *args, **kwargs)-> int :
      '''
getCountOfLispList( (Document)arg1) -> int :

    C++ signature :
        int getCountOfLispList(class PyApDocument {lvalue})'''
    ...
    def getItemOfLispList (self, *args, **kwargs)-> tuple :
      '''
getItemOfLispList( (Document)arg1, (int)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple getItemOfLispList(class PyApDocument {lvalue},int)'''
    ...
    def isA (self, *args, **kwargs)-> RxClass :
      '''
isA( (RxObject)arg1) -> RxClass :

    C++ signature :
        class PyRxClass isA(class PyRxObject {lvalue})'''
    ...
    def isCommandInputInactive (self, *args, **kwargs)-> bool :
      '''
isCommandInputInactive( (Document)arg1) -> bool :

    C++ signature :
        bool isCommandInputInactive(class PyApDocument {lvalue})'''
    ...
    def isNull (self, *args, **kwargs)-> bool :
      '''
isNull( (RxObject)arg1) -> bool :

    C++ signature :
        bool isNull(class PyRxObject {lvalue})'''
    ...
    def isQuiescent (self, *args, **kwargs)-> bool :
      '''
isQuiescent( (Document)arg1) -> bool :

    C++ signature :
        bool isQuiescent(class PyApDocument {lvalue})'''
    ...
    def lockMode (self, *args, **kwargs)-> DocLockMode :
      '''
lockMode( (Document)arg1) -> DocLockMode :

    C++ signature :
        enum AcAp::DocLockMode lockMode(class PyApDocument {lvalue})

lockMode( (Document)arg1, (bool)arg2) -> DocLockMode :

    C++ signature :
        enum AcAp::DocLockMode lockMode(class PyApDocument {lvalue},bool)'''
    ...
    def myLockMode (self, *args, **kwargs)-> DocLockMode :
      '''
myLockMode( (Document)arg1) -> DocLockMode :

    C++ signature :
        enum AcAp::DocLockMode myLockMode(class PyApDocument {lvalue})'''
    ...
    def popDbmod (self, *args, **kwargs)-> ErrorStatus :
      '''
popDbmod( (Document)arg1) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus popDbmod(class PyApDocument {lvalue})'''
    ...
    def pushDbmod (self, *args, **kwargs)-> None :
      '''
pushDbmod( (Document)arg1) -> None :

    C++ signature :
        void pushDbmod(class PyApDocument {lvalue})'''
    ...
    def refCount (self, *args, **kwargs)-> int :
      '''
refCount( (RxObject)arg1) -> int :

    C++ signature :
        int refCount(class PyRxObject {lvalue})'''
    ...
    def setDocTitle (self, *args, **kwargs)-> None :
      '''
setDocTitle( (Document)arg1, (str)arg2) -> None :

    C++ signature :
        void setDocTitle(class PyApDocument {lvalue},class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >)'''
    ...
    def transactionManager (self, *args, **kwargs)-> TransactionManager :
      '''
transactionManager( (Document)arg1) -> TransactionManager :

    C++ signature :
        class PyTransactionManager transactionManager(class PyApDocument {lvalue})'''
    ...
    def upgradeDocOpen (self, *args, **kwargs)-> ErrorStatus :
      '''
upgradeDocOpen( (Document)arg1) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus upgradeDocOpen(class PyApDocument {lvalue})'''
    ...

class ResourceOverride:
    def className (self, *args, **kwargs)-> str :
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...

class SaveFormat:
    def as_integer_ratio (self, /):
      '''Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)'''
    ...
    def bit_count (self, /):
      '''Number of ones in the binary representation of the absolute value of self.

Also known as the population count.

>>> bin(13)
'0b1101'
>>> (13).bit_count()
3'''
    ...
    def bit_length (self, /):
      '''Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6'''
    ...
    def conjugate (self, *args, **kwargs):
      '''Returns self, the complex conjugate of any int.'''
    ...
    def denominator (self, *args, **kwargs):
      '''the denominator of a rational number in lowest terms'''
    ...
    def from_bytes (bytes, byteorder, *, signed=False):
      '''Return the integer represented by the given array of bytes.

  bytes
    Holds the array of bytes to convert.  The argument must either
    support the buffer protocol or be an iterable object producing bytes.
    Bytes and bytearray are examples of built-in objects that support the
    buffer protocol.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Indicates whether two's complement is used to represent the integer.'''
    ...
    def imag (self, *args, **kwargs):
      '''the imaginary part of a complex number'''
    ...
    def k2000_Standard (self, *args, **kwargs):
      '''None'''
    ...
    def k2000_Template (self, *args, **kwargs):
      '''None'''
    ...
    def k2000_dwg (self, *args, **kwargs):
      '''None'''
    ...
    def k2000_dxf (self, *args, **kwargs):
      '''None'''
    ...
    def k2000_xml (self, *args, **kwargs):
      '''None'''
    ...
    def k2004_Standard (self, *args, **kwargs):
      '''None'''
    ...
    def k2004_Template (self, *args, **kwargs):
      '''None'''
    ...
    def k2004_dwg (self, *args, **kwargs):
      '''None'''
    ...
    def k2004_dxf (self, *args, **kwargs):
      '''None'''
    ...
    def k2007_Standard (self, *args, **kwargs):
      '''None'''
    ...
    def k2007_Template (self, *args, **kwargs):
      '''None'''
    ...
    def k2007_dwg (self, *args, **kwargs):
      '''None'''
    ...
    def k2007_dxf (self, *args, **kwargs):
      '''None'''
    ...
    def k2010_Standard (self, *args, **kwargs):
      '''None'''
    ...
    def k2010_Template (self, *args, **kwargs):
      '''None'''
    ...
    def k2010_dwg (self, *args, **kwargs):
      '''None'''
    ...
    def k2010_dxf (self, *args, **kwargs):
      '''None'''
    ...
    def k2013_Standard (self, *args, **kwargs):
      '''None'''
    ...
    def k2013_Template (self, *args, **kwargs):
      '''None'''
    ...
    def k2013_dwg (self, *args, **kwargs):
      '''None'''
    ...
    def k2013_dxf (self, *args, **kwargs):
      '''None'''
    ...
    def k2018_Standard (self, *args, **kwargs):
      '''None'''
    ...
    def k2018_Template (self, *args, **kwargs):
      '''None'''
    ...
    def k2018_dwg (self, *args, **kwargs):
      '''None'''
    ...
    def k2018_dxf (self, *args, **kwargs):
      '''None'''
    ...
    def kNative (self, *args, **kwargs):
      '''None'''
    ...
    def kNative_Template (self, *args, **kwargs):
      '''None'''
    ...
    def kR12_dxf (self, *args, **kwargs):
      '''None'''
    ...
    def kR13_dwg (self, *args, **kwargs):
      '''None'''
    ...
    def kR13_dxf (self, *args, **kwargs):
      '''None'''
    ...
    def kR14_dwg (self, *args, **kwargs):
      '''None'''
    ...
    def kR14_dxf (self, *args, **kwargs):
      '''None'''
    ...
    def kUnknown (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def names (self, *args, **kwargs)-> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...
    def numerator (self, *args, **kwargs):
      '''the numerator of a rational number in lowest terms'''
    ...
    def real (self, *args, **kwargs):
      '''the real part of a complex number'''
    ...
    def to_bytes (self, /, length, byteorder, *, signed=False):
      '''Return an array of bytes representing an integer.

  length
    Length of bytes object to use.  An OverflowError is raised if the
    integer is not representable with the given number of bytes.
  byteorder
    The byte order used to represent the integer.  If byteorder is 'big',
    the most significant byte is at the beginning of the byte array.  If
    byteorder is 'little', the most significant byte is at the end of the
    byte array.  To request the native byte order of the host system, use
    `sys.byteorder' as the byte order value.
  signed
    Determines whether two's complement is used to represent the integer.
    If signed is False and a negative integer is given, an OverflowError
    is raised.'''
    ...
    def values (self, *args, **kwargs)-> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
      '''dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)'''
    ...

class TransactionManager:
    def abortTransaction (self, *args, **kwargs)-> ErrorStatus :
      '''
abortTransaction( (TransactionManager)arg1) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus abortTransaction(class PyDbTransactionManager {lvalue})'''
    ...
    def addNewlyCreatedDBRObject (self, *args, **kwargs)-> ErrorStatus :
      '''
addNewlyCreatedDBRObject( (TransactionManager)arg1, (DbObject)arg2) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus addNewlyCreatedDBRObject(class PyDbTransactionManager {lvalue},class PyDbObject {lvalue})

addNewlyCreatedDBRObject( (TransactionManager)arg1, (DbObject)arg2, (bool)arg3) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus addNewlyCreatedDBRObject(class PyDbTransactionManager {lvalue},class PyDbObject {lvalue},bool)'''
    ...
    def className (self, *args, **kwargs)-> str :
      '''
className() -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > className()'''
    ...
    def desc (self, *args, **kwargs)-> RxClass :
      '''
desc() -> RxClass :

    C++ signature :
        class PyRxClass desc()'''
    ...
    def enableGraphicsFlush (self, *args, **kwargs)-> ErrorStatus :
      '''
enableGraphicsFlush( (TransactionManager)arg1, (bool)arg2) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus enableGraphicsFlush(class PyTransactionManager {lvalue},bool)'''
    ...
    def endTransaction (self, *args, **kwargs)-> ErrorStatus :
      '''
endTransaction( (TransactionManager)arg1) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus endTransaction(class PyDbTransactionManager {lvalue})'''
    ...
    def flushGraphics (self, *args, **kwargs)-> None :
      '''
flushGraphics( (TransactionManager)arg1) -> None :

    C++ signature :
        void flushGraphics(class PyTransactionManager {lvalue})'''
    ...
    def getAllObjects (self, *args, **kwargs)-> list :
      '''
getAllObjects( (TransactionManager)arg1) -> list :

    C++ signature :
        class boost::python::list getAllObjects(class PyDbTransactionManager {lvalue})'''
    ...
    def getObject (self, *args, **kwargs)-> DbObject :
      '''
getObject( (TransactionManager)arg1, (ObjectId)arg2) -> DbObject :

    C++ signature :
        class PyDbObject getObject(class PyDbTransactionManager {lvalue},class PyDbObjectId)

getObject( (TransactionManager)arg1, (ObjectId)arg2, (OpenMode)arg3) -> DbObject :

    C++ signature :
        class PyDbObject getObject(class PyDbTransactionManager {lvalue},class PyDbObjectId,enum AcDb::OpenMode)

getObject( (TransactionManager)arg1, (ObjectId)arg2, (OpenMode)arg3, (bool)arg4) -> DbObject :

    C++ signature :
        class PyDbObject getObject(class PyDbTransactionManager {lvalue},class PyDbObjectId,enum AcDb::OpenMode,bool)'''
    ...
    def isA (self, *args, **kwargs)-> RxClass :
      '''
isA( (RxObject)arg1) -> RxClass :

    C++ signature :
        class PyRxClass isA(class PyRxObject {lvalue})'''
    ...
    def isNull (self, *args, **kwargs)-> bool :
      '''
isNull( (RxObject)arg1) -> bool :

    C++ signature :
        bool isNull(class PyRxObject {lvalue})'''
    ...
    def numActiveTransactions (self, *args, **kwargs)-> int :
      '''
numActiveTransactions( (TransactionManager)arg1) -> int :

    C++ signature :
        int numActiveTransactions(class PyDbTransactionManager {lvalue})'''
    ...
    def numOpenedObjects (self, *args, **kwargs)-> int :
      '''
numOpenedObjects( (TransactionManager)arg1) -> int :

    C++ signature :
        int numOpenedObjects(class PyDbTransactionManager {lvalue})'''
    ...
    def queueForGraphicsFlush (self, *args, **kwargs)-> ErrorStatus :
      '''
queueForGraphicsFlush( (TransactionManager)arg1) -> ErrorStatus :

    C++ signature :
        enum Acad::ErrorStatus queueForGraphicsFlush(class PyDbTransactionManager {lvalue})'''
    ...
    def refCount (self, *args, **kwargs)-> int :
      '''
refCount( (RxObject)arg1) -> int :

    C++ signature :
        int refCount(class PyRxObject {lvalue})'''
    ...
    def startTransaction (self, *args, **kwargs)-> Transaction :
      '''
startTransaction( (TransactionManager)arg1) -> Transaction :

    C++ signature :
        class PyTransaction startTransaction(class PyDbTransactionManager {lvalue})'''
    ...
    def topTransaction (self, *args, **kwargs)-> Transaction :
      '''
topTransaction( (TransactionManager)arg1) -> Transaction :

    C++ signature :
        class PyTransaction topTransaction(class PyDbTransactionManager {lvalue})'''
    ...

class __loader__:
    def _ORIGIN (self, *args, **kwargs)-> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict':
      '''str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.'''
    ...
    def create_module (spec):
      '''Create a built-in module'''
    ...
    def exec_module (module):
      '''Exec a built-in module'''
    ...
    def find_module (fullname, path=None):
      '''Find the built-in module.

        If 'path' is ever specified then the search is considered a failure.

        This method is deprecated.  Use find_spec() instead.

        '''
    ...
    def find_spec (fullname, path=None, target=None):
      '''None'''
    ...
    def get_code (fullname):
      '''Return None as built-in modules do not have code objects.'''
    ...
    def get_source (fullname):
      '''Return None as built-in modules do not have source code.'''
    ...
    def is_package (fullname):
      '''Return False as built-in modules are never packages.'''
    ...
    def load_module (fullname):
      '''Load the specified module into sys.modules and return it.

    This method is deprecated.  Use loader.exec_module() instead.

    '''
    ...
    def module_repr (module):
      '''Return repr for the module.

        The method is deprecated.  The import machinery does the job itself.

        '''
    ...

function curDoc:
    def curDoc (self, *args, **kwargs):
      '''
curDoc() -> Document :

    C++ signature :
        class PyApDocument curDoc()'''
    ...
