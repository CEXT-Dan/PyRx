import PyRx
import PyGe
import PyGi
import PyGs
import PyDb
import PyAp
import PyEd
import PyPl
import PyBrxCv
from typing import overload
from typing import Any

class ArcParameterType(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eChordLength (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eCurveAngle (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eCurveLength (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eCurveThroughPoint (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eDegreeOfCurve (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eExternalDist (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eMiddleOrdinate (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eRadius (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eTangentLength (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class ArcType(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eCompound (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eReverse (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class BreaklineIntersectionElevation(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eTinElevationMax (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eTinElevationMid (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eTinElevationMin (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eTinNotAllowed (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class Civil3dAlignmentType(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eCenterline (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eCurbReturn (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eMiscellaneous (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eNotAlignment (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eOffset (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eRail (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class Civil3dEntityType(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eAlignment (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eNoEntity (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eProfile (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eProfileView (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eTinSurface (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class Civil3dLabels(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eAlignmentsLabels (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eAllLabels (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eDefaultLabels (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eNoLabels (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSurfaceLabels (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eUnattachedLabels (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class Civil3dProfileType(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eDynamicSurface (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eLayout (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eNotProfile (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eQuick (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eStaticSurface (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class CvCivil3dConverter(object):

    @overload
    def __init__ (self, /)-> None : ...
    @overload
    def __init__ (self, sourceDb: PyDb.Database, targetDb: PyDb.Database, doLabels: PyBrxCv.Civil3dLabels)-> None : ...
    def __init__ (self, *args, **kwargs)-> None :
      '''Overloads:
    - None: Any
    - sourceDb: PyDb.Database, targetDb: PyDb.Database, doLabels: PyBrxCv.Civil3dLabels
    '''
    ...
    def attachedLabels (self, civilEntity: PyBrxCv.CvCivil3dEntityInfo)-> list :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def convert (self, entitiesToConvert : list)-> list :
      '''                             '''
    ...
    def getCivilEntities (self)-> list :
      '''                             '''
    ...
    def getInsertedEntities (self)-> list :
      '''                             '''
    ...
    def unattachedLabels (self)-> list :
      '''                             '''
    ...

class CvCivil3dEntityInfo(object):
    def __init__ (self)-> None :
      '''                             '''
    ...
    def alignmentType (self)-> PyBrxCv.Civil3dAlignmentType :
      '''                             '''
    ...
    def baseAlignment (self)-> PyBrxCv.CvCivil3dEntityInfo :
      '''                             '''
    ...
    def baseSurface (self)-> PyBrxCv.CvCivil3dEntityInfo :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def isNull (self)-> bool :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def objectId (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def profileType (self)-> PyBrxCv.Civil3dProfileType :
      '''                             '''
    ...
    def profiles (self)-> list :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.Civil3dEntityType :
      '''                             '''
    ...

class CvDb3dAlignment(CvDbCurve):
    def __init__ (self, id: ObjectId, mode: PyDb.OpenMode=PyDb.OpenMode.kForRead, erased: bool=False)-> None :
      '''                             '''
    ...
    def addContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def addPersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Adds the database-resident object specified by objId to the reactor list of the AcDbObject object.'''
    ...
    def addReactor (self, reactor: PyDb.EntityReactor)-> None :
      '''                             '''
    ...
    def addSubentPaths (self, paths: list[PyDb.FullSubentPath])-> None :
      '''Adds one or more subentities to an entity.The prototype of this method is provided for completeness of the subentity manipulation APIs. AutoCAD will never call this method on a custom object.Returns Acad::eOk if successful. The default implementation returns Acad::eNotAvailable.'''
    ...
    def assertNotifyEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should be used inside of member functions that are only called when the object is open kForNotify. When used, it should be the first function called inside the member function.'''
    ...
    def assertReadEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that access the object's data in a read-only fashion (for example, dxfOutFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is open AcDb::kForRead.If this function is called while the object is not open, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def assertWriteEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that modify the object's data (for example, dxfInFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is indeed open for write (if it is not, then AutoCAD terminates); to trigger an immediate sending of "openedForModify" notification; to set up the notification mechanism so that "modified" and "modifiedGraphics" (if the object is derived from AcDbEntity) are sent at the appropriate times; and to ensure that graphics get updated if the object is derived from AcDbEntity.If this function is called on a database resident object, "openedForModify" will be sent if the object is not newly created, and "modified", and "modifiedGraphics" (if appropriate) notifications will be sent when the object is next closed.If recordModified is false, then the autoUndo argument is ignored, and the undo filer is not initialized, no undo recording will take place, but notifications will be sent.If autoUndo and recordModified are both true, then automatic undo recording will be performed and notifications will be sent.If autoUndo is false and recordModified is true, then there will not be any automatic undo recording, but the undo filer is initialized and the object must manually write out partial Undo records and must implement its applyPartialUndo() method. Notifications will be sent.If this function is called while the object is not open AcDb::kForWrite, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def baseHAlignment (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def blockId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the entity's owner, which must be an AcDbBlockTableRecord.If the entity does not have an owner yet, then AcDbObjectId::kNull will be returned.'''
    ...
    def bounds (self, ext: PyDb.Extents)-> bool :
      '''                             '''
    ...
    def cancel (self)-> None :
      '''Terminates the current open operation. All changes made to the object since it was opened are undone, the object is marked as closed, and "cancel" notification is sent.Returns Acad::eOk if successful.'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDb3dAlignment :
      '''                             '''
    ...
    def castShadows (self)-> bool :
      '''Returns a boolean value that indicates whether the entity can cast shadows. '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...

    @staticmethod
    def cloneFrom (otherObject: PyRx.RxObject)-> PyBrxCv.CvDb3dAlignment :
      '''                             '''
    ...
    def close (self)-> None :
      '''Closes the object. All changes made to the object since it was opened are committed to the database, the object is marked as pageable, and a "closed" notification (as well as any other appropriate notification such as "modified", "erased", and so on) is sent.Returns Acad::eOk if successful.If the object is not in an AcDbDatabase yet, then Acad::eNoDatabase is returned.If the object is sending notification, then Acad::eCloseWasNotifying is returned.If the subClose() call made within the close() method returns anything other than Acad::eOk, then that ErrorStatus is returned.'''
    ...
    def collisionType (self)-> PyDb.CollisionType :
      '''This function returns the collision detection treatment for this entity. Subclasses may override this method to customize how the class interacts in collision-aware features.'''
    ...
    def color (self)-> PyDb.Color :
      '''This function returns the full true color information for the entity within an instance of AcCmColor.The index value will be in the range 0 to 256. 0 and 256 are special values.0 indicates the entity uses the color of the BlockReference that's displaying it. If the entity is not displayed through a BlockReference (for example, it's directly owned by the model space BlockTableRecord) and its color is 0, then it will display as though its color were 7.256 indicates the entity uses the color specified in the LayerTableRecord it references.'''
    ...
    def colorIndex (self)-> int :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...
    def createExtensionDictionary (self)-> None :
      '''Creates an AcDbDictionary object and sets it up as the extension dictionary for the AcDbObject.Returns Acad::eOk if successful. If an extension dictionary already exists, Acad::eAlreadyInDb is returned.'''
    ...

    @staticmethod
    def createFromAcGeCurve (curve: PyGe.Curve3d,normal: PyGe.Vector3d = PyGe.Vector3d.kZAxis,tol: PyGe.Tol = 'default')-> PyDb.Curve :
      '''This is createFromAcGeCurve, a member of class AcDbCurve.'''
    ...
    def database (self)-> PyDb.Database :
      '''Returns a pointer to the AcDbDatabase object that contains the AcDbObject.'''
    ...
    def deepClone (self, owner: PyDb.DbObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function gives control of deep clone operations to the object. In the default implementation, the object is cloned and appended to the owner object (pOwnerObject). The cloning is performed by an AcDbDeepCloneFiler. A record is also added to the idMap. Then, using the filer, any owned objects are deep cloned, with isPrimary set to Adesk::kFalse.'''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def disableUndoRecording (self, disable: bool)-> None :
      '''Turns off or on the Undo recording for the object. If disable == Adesk::kTrue, then Undo recording is turned off until this function is called with disable == Adesk::kFalse, at which time Undo recording is turned back on.'''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def downgradeOpen (self)-> None :
      '''Downgrades the object from being open AcDb::kForWrite, to being AcDb::kForRead. In the process, all changes made to the object while it was open for write are committed to the database and appropriate notification is sent.'''
    ...
    def downgradeToNotify (self, wasWritable: bool)-> None :
      '''Restores an object from being open both AcDb::kForNotify and AcDb::kForWrite, to being open just AcDb::kForNotify. The wasWritable value that was returned from the matching AcDbObject::upgradeFromNotify() call should be passed into this function to restore the proper open status.This function must have been preceded by a call to upgradeFromNotify().Returns Acad::eOk if successful.'''
    ...
    def draw (self)-> None :
      '''This function queues up the entity's graphics and flushes the graphics queue, forcing the entity and anything else in the queue to be drawn or re-drawn on-screen.Returns Acad::eOk if successful.If the entity is not in a database, then Acad::eNotInDatabase will be returned.If the entity is in a database other than the one currently loaded into the AutoCAD editor, then Acad::eNotCurrentDatabase will be returned.'''
    ...
    def drawableType (self)-> PyGi.GiDrawableType :
      '''                             '''
    ...
    def entityColor (self)-> PyDb.EntityColor :
      '''This function returns the color settings of the entity in an AcCmEntityColor form. Most clients should use the color() function, which returns the heavyweight AcCmColor object. However, if color name information is not required, this function provides faster access to the lightweight AcCmEntityColor data.'''
    ...
    def erase (self, erasing : bool=True)-> None :
      '''Sets the erase bit of the object. If erasing == Adesk::kTrue, then the erase bit is set on. If erasing == Adesk::kFalse, then the erase bit is set off.'''
    ...
    def explode (self)-> list :
      '''Function UsageThis function is primarily intended for AutoCAD to call as part of an explode operation that includes this entity. However, this function can be used by ObjectARX applications to obtain an array of pointers to non-database-resident entity objects that are what the entity considers to be its exploded parts.When calling this function, the entitySet array does not need to be empty. This function will append to it, and pointers to entities that it creates to be used in its place as the "exploded" result.If this function is successful, it will return Acad::eOk. Other return values may vary depending on how it has been implemented.Function Implementation in Derived ClassesThis function should dynamically create (using the new operator) whatever entity objects are appropriate to be used to replace the entity after an explode operation has taken place. Pointers to these entities are then appended to the entitySet array. Once the pointers have been appended, the function should return with a status of Acad::eOk.'''
    ...

    @overload
    def extend (self, newParam: float)-> None : ...
    @overload
    def extend (self, extendStart: bool, toPoint: PyGe.Point3d)-> None : ...
    def extend (self, *args, **kwargs)-> None :
      '''Overloads:
    - newParam: float
    - extendStart: bool, toPoint: PyGe.Point3d
    
	-This function extends the beginning or end of the curve to the new point determined by the newParam value.If newParam is less than the curve's start parameter, then the curve is reset to start at newParam. If newParam is greater than the curve's end parameter, then the curve is reset to end at newParam.Returns Acad::eOk if successful. If newParam's first period value is between the curve's start and end, then Acad::eInvalidInput will be returned.The function implementation in derived classes must be able to interpret the newParam value, decide if it is beyond the existing curve end or before the curve beginning, and then extend the curve in the appropriate direction to the newParam value.Return ErrorStatus values are up to the implementer, but to be consistent with built-in classes, the following return values are recommended:Acad::eOkFunction completed successfully.Acad::eInvalidInputThe parameter was not acceptable for some reason (for example, if its first period lies within the existing curve so that it would be a trim rather than an extension).The default implementation returns Acad::eNotImplemented.-'''
    ...
    def extensionDictionary (self)-> PyDb.ObjectId :
      '''Returns the objectId of the extension dictionary owned by the object. If the object does not own an extension dictionary, then the returned objectId is set to AcDbObjectId::kNull.'''
    ...
    def getAcGeCurve (self, tol: PyGe.Tol = 'default')-> PyGe.Curve3d :
      '''This is getAcGeCurve, a member of class AcDbCurve.'''
    ...
    def getArea (self)-> float :
      '''This function returns with area set to the area inside the curve. For the AutoCAD built-in classes, the curve must lie on a plane. If the curve is not closed, its start and end points are considered as connected by a line segment that closes it.Returns Acad::eOk if successful. For the AutoCAD built-in classes, Acad::eInvalidInput is returned if the curve is not planar. Other return values are possible for custom entity classes depending on how they were implemented.This function must be able to calculate a bounded area value for the curve.While the AutoCAD built-in classes require the curve to be planar, no such restriction need be made for custom entity classes unless desired by the implementer.ErrorStatus return values are up to the implementer, but the following are recommended to be consistent with existing classes:Acad::eOkFunction completed successfully.Acad::eInvalidInputThe area was not calculable (for example, the curve was not planar).The default implementation's return value is Acad::eNotImplemented.'''
    ...
    def getClosestPointTo (self, point3d: PyGe.Point3d, direction: PyGe.Vector3d=None, extend: bool=False)-> PyGe.Point3d :
      '''This function projects the curve onto the plane defined by givenPnt and normal, finds the point on the projected curve that is nearest to givenPnt, then projects this nearest point back onto the original curve and sets pointOnCurve to the result.If extend == Adesk::kTrue, then the curve is extended along its path to find the closest point.Returns Acad::eOk if successful. Return values for errors are dependent on the implementation.In derived classes; this function needs to be able to project the curve onto a plane determined by a point (givenPnt) and a normal vector (normal), extend the curve's projection if necessary (if extend==Adesk::kTrue), find the point on the projected curve that is nearest to givenPnt, then project the point found back onto the original curve (or its path if it was extended) and set pointOnCurve to the end result.Use of AcGe classes may be helpful in doing some of the projection and nearest point calculation work.If the operation is successful, this function returns Acad::eOk. Return values for errors are dependent upon the error and the implementer. See header file acdh.h for a list of possible ErrorStatus values.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getCompoundObjectTransform (self)-> PyGe.Matrix3d :
      '''This function is intended to be overridden by derived classes that are compound objects (in other words, objects that behave like blocks in the display list).A compound object has little or no geometry of its own; instead it relies on nested entities, perhaps the contents of a BlockTableRecord, to represent itself. A compound object must use the same transformation matrix for all of its contained entities. Otherwise selection and osnap will not function correctly. This is the method that the system uses to obtain that matrix from the compound object.This method should only be overridden if you return the kDrawableIsCompoundObject flag from setAttributes. The matrix you should return here is the one that you pass to pushModelTransform before you render your nested objects. You must override this method if you return the compound object flag in setAttributes, even if you don't push a transform for your nested objects. In that case you would return Acad::eOk and the identity transform in xMat.Default implementation: Returns Acad::eNotApplicable and the identity matrix in xMat.'''
    ...
    def getDistAtParam (self, param: float)-> float :
      '''Calculates the length of the curve's segment from the curve's start point to the point specified by param.Returns Acad::eOk if successful, or Acad::eInvalidInput if param is out of range. For other errors, the implementer must decide what return value to use. See the acdb.h header file for possible ErrorStatus values.In the default implementation, the function returns Acad::eNotImplemented.'''
    ...
    def getDistAtPoint (self, point3d: PyGe.Point3d)-> float :
      '''Calculates the length of the curve's segment between the curve's start point and point and returns the length in distance.Returns Acad::eOk if successful, or Acad::eInvalidInput if the point is not on the curve. For other errors, the implementer must decide what return value to use. See the acdb.h header file for possible ErrorStatus values.Returns Acad::eNotImplemented in the default implementation.'''
    ...
    def getEcs (self)-> PyGe.Matrix3d :
      '''This function is intended to be overridden by derived classes that need to be able to provide access to an object coordinate system for objects of the class. The intent is that this function provide a transformation matrix that can be used to transform vectors or points from the object's object coordinate system (OCS) to the World Coordinate System (WCS).Default implementation: Return the identity matrix (ones along the diagonal, zeros elsewhere) in retVal.We recommend that all data stored in custom classes be stored in WCS coordinates. If this is done, then the object's OCS will be the WCS and the transformation matrix will be the identity matrix. Then this function will not need to be overridden since the identity matrix is this function's default return.'''
    ...
    def getEndParam (self)-> float :
      '''The implementation of this function in derived classes should return with endParam set to the parameter of the endpoint of the curve.Returns Acad::eOk if successful.By default, the function returns Acad::eNotImplemented.'''
    ...
    def getEndPoint (self)-> PyGe.Point3d :
      '''In this class and in derived classes, this function returns with endPoint set to the end point (in WCS coordinates) of the curve.Returns Acad::eOk if successful.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getField (self, prop: str='TEXT')-> PyDb.ObjectId :
      '''Gets the field ID. A field can be stored in an object using the property name as the key.Returns Acad::eOk if the object has a field for the specified property. Otherwise, returns an AutoCAD error status.'''
    ...
    def getFieldDictionary (self)-> PyDb.ObjectId :
      '''Returns the field dictionary ID. The field dictionary stores all the fields set in the object as property name-field object pairs. The ID will be null if there is no field in the object.'''
    ...
    def getFirstDeriv (self, param: float|PyGe.Point3d)-> PyGe.Vector3d :
      '''Here and in derived classes, this function is implemented to evaluate the first derivative at the location on the curve specified by param, and sets firstDeriv to the result (in WCS coordinates).Returns Acad::eOk if successful. If param is not valid for the curve, then Acad::eInvalidInput is returned. Other ErrorStatus return values are up to the implementer.For implementation, the AcGe classes may provide some of the necessary functionality to make the job easier.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getGeomExtents (self)-> PyDb.Extents :
      '''Unimplemented at the AcDbEntity level, this method is intended to be overridden in derived classes.Derived classes should calculate and return the corner points (in WCS coordinates) of a box (with edges parallel to the WCS X, Y, and Z axes) that encloses the 3D extents of the entity, and return those points as an instance of class AcDbExtents in the "extents" parameter.Default implementation: Immediately returns Acad::eInvalidExtents.'''
    ...
    def getGeomExtents2d (self)-> PyDb.Extents2d :
      '''                             '''
    ...

    @overload
    def getGripPoints (self, /)-> tuple[Any,...] : ...
    @overload
    def getGripPoints (self, curViewUnitSize: float, gripSize: int, curViewDir: PyGe.Vector3d, bitflags: int)-> tuple[Any,...] : ...
    def getGripPoints (self, *args, **kwargs)-> tuple[Any,...] :
      '''Overloads:
    - None: Any
    - curViewUnitSize: float, gripSize: int, curViewDir: PyGe.Vector3d, bitflags: int
    
	-Function usageThis function supports "old style" grips, in applications that existed before the enhancement of grip functionality by the addition of the AcDbGripData class.This function is not intended to be called by ObjectARX applications. However, it is possible to do so (for example, as a pass-through from the getStretchPoints() method).Function implementation in derived classesThis function should append to the gripPoints array any points that are to treated as grip points for the entity.The gripPoints array is passed to all entities involved in the grip operation, so the array may already contain grip points for other entities. Therefore, it is very important to append the new points rather than assigning them to any existing elements in the array.When finished appending all desired grip points, return Acad::eOk. If anything other than Acad::eOk is returned, then grips are not activated for this entity.The osnapModes and geomIds arguments are not currently used.Default implementationImmediately returns Adesk::eNotImplemented.-'''
    ...
    def getHandle (self)-> PyDb.Handle :
      '''Fills in handle with the handle value for the object. If the object is not yet database-resident, then it will not have a handle. Use AcDbHandle::isNull to test for this condition.'''
    ...
    def getOffsetCurves (self, dist: float)-> list :
      '''This function creates one or more entities that together make up the result of offsetting the curve by the distance offsetDist. For many curves, the result is a single new curve. (This single new curve may not be of the same class as the original curve. For example, offsetting an AcDbEllipse results in an AcDbSpline, since the result of offsetting an ellipse does NOT fit the equation of an ellipse.)In some cases, it might be necessary for the offset result to be several curves. (The result may even be several curves that would form a single curve if they were joined end-to-end.) To allow for this possibility, a dynamic array of void pointers is used to hold pointers to the resulting entity or entities.To use this array of pointers, the calling application needs to cast the pointer(s) to the appropriate object type(s). If only a specific entity type or set of types are to be handled, then use the cast method of the class(es) desired to see if each pointer can be safely cast to that object type. If the actual object type (class name) is desired, then each object's isA() method may be used to get a pointer to the object's AcRxClass object, which has a name() method.If the offsetDist value is negative, it is usually interpreted as being an offset to make a smaller curve (that is, for an arc it would offset to a radius that is offsetDist less than the starting curve's radius). If the negative value has no meaning in terms of making the curve smaller, a negative offsetDist may be interpreted as an offset in the direction of smaller X,Y,Z WCS coordinates. This is not enforced, so custom entities can interpret the sign of the offsetDist value however they want.The entities returned in the offsetCurves array are dynamically allocated, but have not been added to an AcDbDatabase yet. So, the application that calls this function is responsible for their memory. If they are subsequently appended to a database, then the database takes over responsibility for their memory. Otherwise, the application is responsible for deleting them when they are no longer needed.Returns Acad::eOk if offsetting is successfully completed. If the offset distance is invalid (for example, if you are offsetting an arc such that the offset result would be a negative radius), then Acad::eInvalidInput is returned. For the AutoCAD built-in classes that use ShapeManager (AcDbBody, AcDbRegion, and AcDb3dSolid), Acad::eGeneralModelingFailure will be returned if an error occurs in the ShapeManager modeler. Other ErrorStatus return values are implementation-dependent.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getOffsetCurvesGivenPlaneNormal (self, normal: PyGe.Vector3d, dist: float)-> list :
      '''This function creates one or more entities that, together, make up the result of offsetting the curve by the distance offsetDist in the plane with normal vector normal. For many curves, the result will be a single new curve, which may not be of the same class as the original curve. For example, offsetting an AcDbEllipse results in an AcDbSpline, since the result of offsetting an ellipse does not fit the equation of an ellipse. However, in some cases it might be necessary for the offset result to be several curves. To allow for this possibility, a dynamic array of void pointers is used to hold pointers to the resulting entity or entities.To use this array of pointers, the calling application must cast the pointer(s) to the appropriate object type(s). If only a specific entity type or set of types are to be handled, then using the cast method of the class(es) desired to see if each pointer can be safely cast to that object type will work. If the actual object type is desired, then each object's isA() method may be used to get a pointer to the object's AcRxClass object, which has a name() method to get the classname of the object.If the offsetDist value is negative this is usually interpreted as being an offset to make a smaller curve (that is, for an arc it would offset to a radius that is offsetDist less than the starting curve's radius). Or, if smaller has no meaning, then a negative offsetDist may be interpreted as an offset in the direction of smaller X,Y,Z WCS coordinates. However, this is not enforced, so custom entities can interpret the sign of the offsetDist value however they wish.The entities returned in the offsetCurves arrays are dynamically allocated, but have not been added to an AcDbDatabase yet. So, the application that calls this function is responsible for their memory. If they are subsequently appended to a database, then the database takes over responsibility for their memory. Otherwise, the application is responsible for deleting them when they are no longer needed.Returns Acad::eOk if offsetting is successfully completed. If the offset distance is invalid, or if normal is a zero length vector or the entity is linear and normal is not perpendicular with the entity, then Acad::eInvalidInput is returned. Other ErrorStatus return values are implementation dependent.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getOrthoProjectedCurve (self, plane: PyGe.Plane)-> PyDb.Curve :
      '''This function creates a new curve entity that is the result of projecting the curve along the projPlane's normal onto the projPlane and sets projCurve to point to the newly created curve. projCurve is declared as type AcDbCurve to allow the returned curve to be any class derived from AcDbCurve (for example, when an AcDbArc is projected onto a plane, the result is an AcDbEllipse).The returned curve is dynamically allocated, but has not been added to an AcDbDatabase yet. So, the application that calls this function is responsible for its memory. If the curve is subsequently appended to a database, then the database takes over responsibility for its memory. Otherwise, the application is responsible for deleting it when it is no longer needed.Returns Acad::eOk if successful. Other ErrorStatus values are implementation-dependent.Returns Acad::eNotImplemented in the default implementation.'''
    ...
    def getParamAtDist (self, dist: float)-> float :
      '''This function determines the parameter of the curve at the location that is a distance of dist along the curve from the curve start, and returns the parameter in param.Returns Acad::eOk if successful. If dist is not valid for the curve, then Acad::eInvalidInput is returned. Other ErrorStatus return values are implementation-dependent.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getParamAtPoint (self, point3d: PyGe.Point3d)-> float :
      '''This function determines the parameter of the curve at point and returns the parameter in param.Returns Acad::eOk if successful. If point is not on the curve, then Acad::eInvalidInput is returned. Other ErrorStatus return values are implementation-dependent.Acad::eNotImplemented is returned by the default implementation.'''
    ...
    def getPlane (self)-> PyGe.Plane :
      '''If the entity is planar, then the plane containing the entity is returned in plane and flag is set to AcDb::kPlanar.If the entity is nonplanar, but is linear, then plane is set to an arbitrary plane that contains the entity and flag is set to AcDb::kLinear.If the entity is nonplanar and nonlinear, then plane is left unset and flag is set to AcDb::kNonPlanar.Returns Acad::eOk if successful. Other ErrorStatus return values are implementation-dependent.The default implementation is to return Acad::eNotApplicable.'''
    ...
    def getPlotStyleNameId (self)-> PyDb.ObjectId :
      '''Returns with id set to the object ID of the AcDbPlaceHolder object referenced by the entity. The AcDbPlaceHolder object resides in the plot style name dictionary, and its key in the dictionary is the plot style name.Use the AcDbDictionary::nameAt() function on the plot style name dictionary to get the plot style name string that corresponds to the ID obtained by this function.'''
    ...
    def getPointAtDist (self, dist: float)-> PyGe.Point3d :
      '''This function determines the point on the curve that is a distance of dist along the curve from the curve start, and returns the point in point. point is in WCS coordinates.Returns Acad::eOk if successful. If dist is not valid for the curve, then Acad::eInvalidInput is returned. Other ErrorStatus return values are implementation-dependent.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getPointAtParam (self, param: float)-> PyGe.Point3d :
      '''This function determines the point on the curve that corresponds to the param parameter, and returns the point in point. point is in WCS coordinates.Returns Acad::eOk if successful. If the parameter is not within the curve's range, then Acad::eInvalidInput is returned. Other ErrorStatus return values are implementation-dependent.Returns Acad::eNotImplemented in the default implementation.'''
    ...
    def getPointsArray (self)-> list :
      '''                             '''
    ...
    def getProjectedCurve (self, plane: PyGe.Plane, projDir: PyGe.Vector3d)-> PyDb.Curve :
      '''This function creates a new curve entity that is the result of projecting the curve parallel to projDir onto the projPlane and sets projCurve to point to the newly created curve. projCurve is declared as type AcDbCurve in order to allow the returned curve to be any class derived from AcDbCurve. For example, when an AcDbArc is projected onto a plane, the result is an AcDbEllipse.The returned curve is dynamically allocated, but has not been added to an AcDbDatabase yet. The application that calls this function is therefore responsible for its memory. If the curve is subsequently appended to a database, then the database takes over responsibility for its memory. Otherwise, the application is responsible for deleting it when it is no longer needed.Returns Acad::eOk if successful. If projDir is perpendicular to the projPlane's normal then Acad::eInvalidInput is returned. For the AutoCAD built-in classes that use ShapeManager (AcDbEllipse, AcDbSpline, AcDbBody, AcDbRegion, and AcDb3dSolid), Acad::eGeneralModelingFailure is returned if an error occurs in the ShapeManager modeler. Other ErrorStatus values are implementation-dependent.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getSecondDeriv (self, param: float|PyGe.Point3d)-> PyGe.Vector3d :
      '''Evaluates the second derivative at the location on the curve specified by param and sets secDeriv to the result (in WCS coordinates).Returns Acad::eOk if successful. If param is not valid for the curve, then Acad::eInvalidInput is returned. Other ErrorStatus return values are up to the implementer.For implementation, the AcGe classes provide some of the necessary functionality to make the job easier.Returns Acad::eNotImplemented in the default implementation.'''
    ...
    def getSpline (self)-> PyDb.Spline :
      '''This function creates a new AcDbSpline entity, sets it to be as close an approximation as possible to the curve, and then returns with spline pointing to the newly created spline entity.The returned spline is dynamically allocated, but has not been added to an AcDbDatabase yet. So, the application that calls this function is responsible for its memory. If the spline is subsequently appended to a database, then the database takes over responsibility for its memory. Otherwise, the application is responsible for deleting it when it is no longer needed.Returns Acad::eOk if successful. If there is an error in the ShapeManager modeler (which AcDbSpline uses), then Acad::eGeneralModelingFailure will be returned. Other ErrorStatus values are implementation-dependent.Returns Acad::eNotImplemented in the default implementation.'''
    ...
    def getSplitCurves (self, paramsOrPoints: list)-> list :
      '''This function creates one or more entities that are all subcurves of the original. The points array must contain the points on the curve that are used as the start or end points of the newly created subcurves. The first subcurve starts at the original curve's start point and ends at the first point in the points array. The second subcurve starts at the first point in the points array and ends at the second point in the points array. The third subcurve starts at the second point and ends at the third, and so on. The last subcurve starts at the last point in the points array and ends at the original curve's endpoint.If successive points are coincident (including the original curve's start to the first array point and the last array point to the original curve's end), then no subcurve is created for that pair.Pointers to all new curves are appended to the curveSegments array.The entities that are returned in the curveSegments array are dynamically allocated, but are not yet added to an AcDbDatabase. So, the application that calls this function is responsible for their memory. If they are subsequently appended to a database, then the database takes over responsibility for their memory. Otherwise, the application is responsible for deleting them when they are no longer needed.Depending on how this function is implemented, it is possible that the function might return an ErrorStatus other than Acad::eOk and still have appended some pointers to subcurves to the curveSegments array (AcDbArc does this). Typically, this would be the result of an invalid point somewhere in the middle of the points array. So, it is very important to check the size of the curveSegments array upon return to be sure that any subcurves that are created are properly dealt with.To use the pointer(s) in the curveSegments array, the calling application will need to cast the pointer(s) to the appropriate object type(s). For this function, the objects pointed to by the pointers in the curveSegments array are usually going to be of the same class as the original curve. However, this is not a requirement. To be safe, the pointers should be cast using the appropriate class's cast method.Returns Acad::eOk if successful.If points is empty or any of the points in points are not on the curve, then Acad::eInvalidInput is returned. As mentioned above, it is possible for this ErrorStatus to be returned and still have some subcurve pointers appended to the curveSegments array.For the AutoCAD built-in classes that use ShapeManager (AcDbEllipse, AcDbSpline, AcDbBody, AcDbRegion, and AcDb3dSolid), Acad::eGeneralModelingFailure is returned if an error occurs in the ShapeManager modeler.Other ErrorStatus return values are implementation-dependent.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getSplitCurvesAtParam (self, param: float)-> list :
      '''                             '''
    ...
    def getSplitCurvesAtParams (self, params: list)-> list :
      '''                             '''
    ...
    def getSplitCurvesAtPoint (self, point: PyGe.Point3d)-> list :
      '''                             '''
    ...
    def getSplitCurvesAtPoints (self, points: list)-> list :
      '''                             '''
    ...
    def getStartParam (self)-> float :
      '''This function returns with startParam set to the start parameter on the curve.Returns Acad::eOk if successful.Returns Acad::eNotImplemented in the default implementation.'''
    ...
    def getStartPoint (self)-> PyGe.Point3d :
      '''This function returns with startPoint set to the start point (in WCS coordinates) of the curve.Returns Acad::eOk if successful, and Acad::eNotImplemented in the default implementation.'''
    ...
    def getStretchPoints (self)-> list :
      '''Function usageThis function is not intended to be called by ObjectARX applications. However, it is possible to do so (for example, as a pass-through from the getGripPoints() method).Function implementation in derived classesThis function should append to the stretchPoints array any points that are to treated as stretch points for the entity.Stretch points are used by the stretch command within AutoCAD. Any stretch points that are within the crossing selection window during the stretch command, will be moved by whatever amount the user decides to "stretch" the selected entities. Any stretch points not in the crossing selection window will be left alone. This combination of some stretch points moving while others do not is what "stretches" the entity. If all stretch points are in the crossing window, then the entity is moved instead of stretched.The stretchPoints array is passed to all entities involved in the stretch operation, so the array may already contain stretch points for other entities. Therefore it is very important to append the new points rather than assigning them to any existing elements in the array.When finished appending all desired stretch points, return Acad::eOk. If anything other than Acad::eOk is returned, then this entity's stretch points will be ignored by the stretch operation.Default implementationCalls the AcDbEntity::getGripPoints() method. So, unless the entity needs to have stretch points that are different from the grip points, there is no need to override this method.'''
    ...
    def getSubentPathsAtGsMarker (self, type: PyDb.SubentType, gsMark: int, pickPoint: PyGe.Point3d, viewXform: PyGe.Matrix3d)-> list[PyDb.FullSubentPath] :
      '''Entities use various graphic primitives defined in AcGi to draw themselves. Part of this mechanism is the ability to associate an integer identifier called a graphics system marker (or, GS marker) with each primitive or with groups of primitives. Through the use of certain selection mechanisms, the GS marker for the actual subentity selected on screen can be obtained and, along with some other information passed into this function, can be used to create one or more AcDbFullSubentPath objects, each one representing a subentity and providing a more complete description of the subentity and its environment. These AcDbFullSubentPath objects can be used by several other functions for various purposes such as highlighting or unhighlighting the subentities on screen.Function usageIf the entity (of which the subentity is a part) is directly owned by the model or paper space BlockTableRecords, then leave out numInserts and entAndInsertStack so that their default value will be used.Typically the GS marker is obtained via the use of ads_ssget() followed by ads_ssnamex() (see the ObjectARX Developer's Guide for more information on this).The pickPoint can be obtained from ads_ssnamex() as well (it's the first group 5009 in the returned list).The viewXform can be calculated using the ads_trans() function on the vectors (1,0,0), (0,1,0), and (0,0,1) to translate them from DCS to WCS. The translations of these three vectors (with an extra 0 appended on to the end of each) would be used as the first three rows of the matrix. The last row is not used so it can be left as is. This argument is not used by any of the AutoCAD built-in entities.If the entity is nested inside one or more block definitions, then the numInserts and entAndInsertStack arguments must also be filled in with non-zero or non-null values. If they are not filled in, then this function will fail and return an error status. One way to get the necessary object IDs is to use ads_nentselp() to obtain the list of ads_names of the container objects. This list must then be converted to object IDs and reversed.Upon return, the subentPaths argument will point to a dynamically allocated array of one or more AcDbFullSubentPath objects. The numPaths argument will contain the number of AcDbFullSubentPath objects being returned.The calling application is responsible for deallocating the memory used by the subentPaths array. The C++ delete [ ] should be used.Return values for this function may vary depending on how the function has been implemented (see below).Function implementation in derived classesEntity classes which do not set GS markers probably should not implement this function since the GS marker is the primary (and often the only) means of subentity distinction.When implemented, this function must use the material provided in type, gsMark, pickPoint, viewXform, numInserts, and entAndInsertStack to determine which subentity or subentities meet the criteria in these arguments. Next it must create a dynamically allocated array of AcDbFullSubentPaths (using the C++ new operator) with one element for each subentity determined in the first step. Finally it must fill in each AcDbFullSubentPath object in the array with the information appropriate to the subentity it will represent.If numInserts == 0 and entAndInsertStack == NULL, it's important to check to be sure that the entity's owner is indeed the model or paper space BlockTableRecord. This can be done by using the entity's ownerId() method to obtain the objectId of its owner, and then opening up that object and using its name() method to obtain its name string. If the owner is not the model or paper space BlockTableRecord, and numInserts == 0 or entAndInsertStack == NULL, or both, then the input data is invalid and this function should set numPaths to 0, set subentPaths to NULL and then return the error status Acad::eInvalidInput.Each AcDbFullSubentPath object has two parts, an array of objectIds containing all the container objects, and an embedded AcDbSubentId object which in turn has two elements: an index value and a SubentityType.If the "main" entity (the entity on which this function is being called) is not nested within BlockReferences (that is, numInserts == 0 and entAndInsertStack == NULL), then the objectId array should contain only the objectId of the "main" entity. If the "main" entity is nested in one or more BlockReferences, then the AcDbObjectIdArray is the same as entAndInsertStack, so copying the entAndInsertStack elements into the AcDbObjectIdArray is all that's required.The SubentType data item within the embedded AcDbSubentId should be set the same as type.The index data item within the embedded AcDbSubentId can be any value you wish (it is often simply the GS marker), but if implemented, the following functions must be able to interpret them to determine the corresponding GS marker(s) or subentity (or subentities):getGsMarkersAtSubentPath()subentPtr()The pickPoint and viewXform arguments are provided as extra aids (if necessary) in determining which subentity is involved. For example, some entity types might display differently depending on the display viewpoint. The viewXform transformation matrix can be used in such cases.The viewXform argument provides a transformation matrix to transform from WCS (World Coordinate System) to DCS (display coordinate system).The display coordinate system is oriented such that the positive Z axis is coming out of the display screen towards the user, the positive X axis is horizontally from left to right on screen, and the positive Y axis is vertically upwards on screen.So, if the current viewpoint is at (1,0,0) (the viewer is always looking towards (0,0,0)) then the viewXform matrix would be:0 1 0 00 0 1 01 0 0 00 0 0 1In this matrix the last row and the last column are not used. Notice also that the third row is the DCS Z axis in WCS coordinates (which is the WCS version of the AutoCAD VIEWPOINT system variable).When this function returns, the return code to use is completely up to the implementer, but to be consistent with other existing entity class implementations of this function the following should be used:If the function succeeds, it should return Acad::eOk.If an invalid or unsupported SubentType is passed in, then numPaths should be set to 0, subentPaths should be set to NULL, and Acad::eWrongSubentityType should be returned.If an invalid GS marker (or any other data item that turns out to be needed) is passed in, then numPaths should be set to 0, subentPaths should be set to NULL, and Acad::eInvalidInput should be returned.Default implementationImmediately returns Adesk::eNotApplicable.'''
    ...
    def getTransformedCopy (self, matrix3d: PyGe.Matrix3d)-> PyDb.Entity :
      '''Function usageThis function creates a clone of the entity, applies the xform transformation matrix to the clone, and then returns with pEnt pointing to the transformed clone.Returns Acad::eOk if successful.If xform is a non-uniform scaling matrix or non-orthogonal then Acad::eCannotScaleNonUniformly or Acad::eNotImplemented is returned.WarningFor AutoCAD built-in complex entities such as polylines, this function produces a shallow clone of the header entity only, which also owns the original set of "owned" entities (such as vertices for a polyline) which are then transformed by the xform matrix. This results in a corrupt drawing (two header entities owning the same set of "owned" entities) as well as transforming the original set of "owned" entities instead of a copied set.Function implementation in derived classesThe default AcDbEntity implementation of this function should be adequate for most derived entity types. However, derived entity classes that wish to support non-uniform scaling or non-orthogonal transformations will need to override this method with their own implementation.This function must create a copy of the entity (using memory that has been dynamically allocated via the C++ new operator), apply the transformation matrix xform to the copy and then return with pEnt pointing to the transformed copy.Determining what constitutes a valid transformation matrix and whether to do a shallow clone (that is, the entity's clone() method), a deepclone (if the entity owns other objects), or no clone at all (that is, make this function a no-op), is up to the implementer.Return values for this function are also up to the implementer, but to be consistent with other existing classes the following is recommended:If the function succeeds, it should return Acad::eOk.If the function is to be a no-op, it should return Acad::eNotImplementedIf non-uniform scaling is not to be supported and a non-uniform scaling matrix is passed in, then either Acad::eCannotScaleNonUniformly or Acad::eNotImplemented should be returned.Default implementationIf the entity is uniformly scaled and orthogonal, AcDbEntity::getTransformedCopy will call the entity's clone() method to create a clone of the entity, then call AcDbEntity::transformBy() on the clone, and then return with pEnt set to point to the transformed clone. If xform is a non-uniformly scaled or a non-orthogonal matrix, then this function will return Acad::eNotImplemented.'''
    ...
    def handOverTo (self, newObject: PyDb.DbObject, keepXData: bool, keepExtDict: bool)-> None :
      '''This function provides the ability to exchange a non-database-resident object (NDBRO) in place of an existing database-resident object (DBRO) while retaining the objectId, handle, and reactor list of the DBRO. An example of this situation is when the BREAK command is used to break a circle into one or two arc segments. AcDbArc is a completely different class from AcDbCircle, so a new AcDbArc object must be substituted in place of the AcDbCircle object that is there now, yet the arc must get the handle and objectId that the circle has.To use the handOverTo() function, the object to be replaced (the AcDbCircle in the example) must be open AcDb::kForWrite. The object's handOverTo() function is called with newObject pointing to a non-database-resident object that replaces it (the AcDbArc in the example).keepXData is set to Adesk::kTrue if the xdata is to be retained or Adesk::kFalse if the xdata is to be thrown out.keepExtDict is set to Adesk::kTrue if the extension dictionary and its contents are to be retained, or set to Adesk::kFalse if the extension dictionary and its contents are to be thrown out.Once returned from this function, the replacement object (the AcDbArc in the example) is open for AcDb::kForWrite and must have its close() member called to commit the change and close out Undo recording. Then it's up to the ObjectARX application to delete the old object (the AcDbCircle in the example) from memory since it's no longer database-resident.Returns Acad::eObjectToBeDeleted if the operation is successful. If newObject is pointing to an object that is already in the database, or the object invoking handOverTo() is not database-resident, then Acad::eIllegalReplacement is returned.'''
    ...
    def hasFields (self)-> bool :
      '''Returns true if the object has one or more PyDb.Field Objects. Otherwise returns false.'''
    ...
    def hasPersistentReactor (self, id: PyDb.ObjectId)-> bool :
      '''This method returns true if objId is the object ID of a reactor attached to this object. Otherwise, it returns false.'''
    ...
    def hasXData (self, appname: str)-> bool :
      '''                             '''
    ...
    def highlight (self, path: PyDb.FullSubentPath = None, highlightAll : bool = False)-> None :
      '''Function usageThis function uses the AcDbFullSubentPathid to determine which subentity in the entity is desired. It then highlights that subentity on screen. If no AcDbFullSubentPath argument is provided, then the entire entity will be highlighted.Typically, the AcDbFullSubentPath object passed in via subId is obtained from the entity's AcDbEntity::getSubentPathsAtGsMarker() method. This guarantees that it is fully and properly filled in.This function uses the entity's getGsMarkersAtSubentPath() method to get the GS markers associated with subId. If that function does not return Acad::eOk, then this function will fail and return whatever ErrorStatus was returned by getGsMarkersAtSubentPath().If this function succeeds, then it returns Acad::eOk.It is not necessary to balance each highlight() function call with a corresponding call to unhighlight(). Calling the unhighlight() function will unhighlight the entity designated by subId regardless of how many times the highlight function has been called on it.WarningIf the entity on which this method is called has its graphics queued for regeneration (that is, changes have been made to the entity but have not yet been reflected on screen), then this method will not cause a highlight to occur. Also, calling this method on an entity that's open for write and whose graphics are queued for regeneration may terminate AutoCAD.To avoid this limitation, before calling highlight(), you should flush the entity's graphics by either calling the entity's draw() method, or calling the AcTransactionManager::flushGraphics() function.Function implementation in derived classesThe AcDbEntity::highlight() implementation does all the work necessary to highlight any subentities that correspond to the subIdFullSubentPath. So, there is no need to override this method unless you wish to do some pre-or post-processing, or you wish to disable the ability to highlight subentities.If this method is overridden and it is supposed to highlight subentities, then the AcDbEntity::highlight() method will need to be invoked at some point within this function in order to do the actual highlighting.Within the AcDbEntity::highlight() method, the getGsMarkersAtSubentPath() method of this entity is called to translate the FullSubentPath into the corresponding GS markers. So, if this function is to succeed, the getGsMarkersAtSubentPath() method needs to be implemented as well.For more information on the subIdAcDbFullSubentPath argument, see the documentation on the getGsMarkersAtSubentPath() or getSubentPathsAtGsMarker() methods.'''
    ...
    def id (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...

    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, thisGsMarker : int, otherGsMarker : int)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane, thisGsMarker : int, otherGsMarker : int)-> list : ...
    def intersectWith (self, *args, **kwargs)-> list :
      '''Overloads:
    - entity: PyDb.Entity, intType : PyDb.Intersect
    - entity: PyDb.Entity, intType : PyDb.Intersect, thisGsMarker : int, otherGsMarker : int
    - entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane
    - entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane, thisGsMarker : int, otherGsMarker : int
    
	-Function usageIt finds the intersections of the entity pointed to by pEnt and all the edges of the bounding box of this entity.The intType is used to determine how to deal with extending the two entities in order to calculate intersections. The possible AcDb::Intersect values are:AcDb::kOnBothOperandsDo not extend either entity. This results in only calculating intersections where the two entitys' geometry actually intersectAcDb::kExtendThisExtend this entity (if necessary) when calculating intersections, but do not extend the pEnt entity.AcDb::kExtendArgExtend the pEnt entity (if necessary) when calculating intersections, but do not extend this entity.AcDb::kExtendBothExtend both the pEnt entity and this entity (if necessary) when calculating intersectionsAny intersection points found are appended to the points array. All points are in WCS coordinates.The thisGsMarker and otherGsMarker arguments are intended to provide this function with information to allow it to localize the search for intersections to be between specific subentities. However, this function is not required to make use of either of these arguments (most, if not all, of the AutoCAD built-in entity classes do not). When calling this function, either or both of these arguments may be 0 in order to indicate that they should be ignored.If this function is successful it returns Acad::eOk. Return values for error conditions are dependent on the implementation of this function in the classes involved.Function implementation in derived classesThis function should do all it can to find all intersection points between the entity it's being called on and the entity pointed to by pEnt. All intersection points found should be appended to the points array. All such points must be in WCS coordinates.When implementing the intersection calculation portion of this function you should take a good look at the AcGe classes to see if they can provide any useful functionality to help in finding intersections with the geometric primitives that make up the entity this function is being called on and the pEnt entity. For example, the AcGeCurve3d class has an isOn() method that will indicate if a supplied point is on the curve and the AcGeCircArc3d class has several intersectWith() methods to find intersections with other AcGe types.If the pEnt entity is a type not recognized by this function, it is quite reasonable to call the pEnt entity's intersectWith() method passing in a pointer to this entity as the "pEnt", and all the other arguments passed into this function (remembering to convert the intType argument If necessary) to see if that entity can determine any intersection points. This is what the AutoCAD built-in classes do.Also, don't forget to take into account the intType value. The intType tells you which, if any, of the two entities should be extended to find "apparent" intersections. It is not required that apparent intersection be supported, but if it is not, then an appropriate ErrorStatus value should be returned to indicate that the call failed.The thisGsMarker and otherGsMarker arguments are provided to allow this function to determine exactly which subentities are involved in the intersection operation (for example, if this function is being called by AutoCAD as part of an intersection Osnap operation these arguments would indicate which subentities are within the osnap pickbox). For these arguments, a value less than or equal to zero indicates that that argument should not be used.If this function completes successfully (even if no intersection points are found), it should return Acad::eOk. Determining what is considered an error and what ErrorStatus return code to use for any such errors are up to the implementer -- there are no conventions in this regard.Default implementationImmediately returns Acad::eNotImplemented.-'''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isAProxy (self)-> int :
      '''Returns Adesk::kTrue if the object is a proxy object or entity. Otherwise returns Adesk::kFalse.'''
    ...
    def isAcDbObjectIdsInFlux (self)-> int :
      '''This function refers to a condition that occurs during deep clone operations. It returns Adesk::kTrue when the cloned objects' IDs have not yet been translated and thus cannot be used in any operations on the objects. This condition normally occurs only during AcEditorReactor::beginDeepCloneXlation, AcDbObject::deepClone, or AcDbObject::wblockClone. Any operations that involve AcDbObjectId references, such as symbol table records, should be postponed until after endDeepClone. AcDbObject::subClose is never called on any objects whose IDs are in flux.'''
    ...
    def isAnnotative (self)-> PyDb.AnnotativeStates :
      '''                             '''
    ...
    def isCancelling (self)-> int :
      '''Returns Adesk::kTrue if the object is currently in the middle of a cancel() call (that is, an open is being canceled and all changes made are being rolled back). Otherwise returns Adesk::kFalse.'''
    ...
    def isClosed (self)-> int :
      '''This function returns Adesk::kTrue if, and only if, the curve is closed; that is, its start point is identical to its end point. Otherwise, it returns Adesk::kFalse.Returns Acad::kFalse in the default implementation.'''
    ...
    def isEraseStatusToggled (self)-> int :
      '''Returns Adesk::kTrue if the object's erase bit has been toggled since it was opened. Otherwise returns Adesk::kFalse.'''
    ...
    def isErased (self)-> int :
      '''Returns Adesk::kTrue if the object is currently erased. Otherwise returns Adesk::kFalse.'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isModified (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called). Otherwise returns Adesk::kFalse.'''
    ...
    def isModifiedGraphics (self)-> int :
      '''Returns Adesk::kTrue if the object is derived from AcDbEntity and has had either an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called), or its recordGraphicsModified() function called with an Adesk::kTrue argument value.Otherwise it returns Adesk::kFalse.'''
    ...
    def isModifiedXData (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called) and has then had its setXData() method called. Otherwise it returns Adesk::kFalse.'''
    ...
    def isNewObject (self)-> int :
      '''Returns Adesk::kTrue if the object has not yet been closed since it was first created. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifyEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForNotify. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifying (self)-> int :
      '''Returns Adesk::kTrue if the object is in the process of sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isPeriodic (self)-> int :
      '''This function returns Adesk::kTrue if, and only if, the curve has an infinite range in both directions and there is a period value T such that there is a point on curve at (u + T) = point on curve (u), for any parameter u. If the curve is not periodic, then Adesk::kFalse is returned.The default implementation returns Adesk::kFalse.'''
    ...
    def isPersistent (self)-> int :
      '''                             '''
    ...
    def isPlanar (self)-> int :
      '''This function returns Adesk::kTrue if and only if there is a plane that contains the entity. Otherwise Adesk::kFalse is returned.'''
    ...
    def isReadEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForRead. Otherwise returns Adesk::kFalse.'''
    ...
    def isReallyClosing (self)-> int :
      '''Returns true if calling close() at this time would really close the object completely. For example, if the object is not in a transaction, and is open for read with only one reader, then Adesk::kTrue would be returned. If, on the other hand, the object is in a transaction, then Adesk::kFalse would be returned.'''
    ...
    def isTransactionResident (self)-> int :
      '''Returns Adesk::kTrue if the object is currently part of a transaction. Otherwise returns Adesk::kFalse.'''
    ...
    def isUndoRecordingDisabled (self)-> bool :
      '''Returns true if undo recording is disabled.'''
    ...
    def isUndoing (self)-> int :
      '''Returns Adesk::kTrue if the object is involved in an Undo operation at this time. Otherwise returns Adesk::kFalse.'''
    ...
    def isWriteEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForWrite and is not currently sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def layer (self)-> str :
      '''This function returns a copy of the name string in the AcDbLayerTableRecord object referenced by the entity.The calling application is responsible for deallocating the memory used by the returned string. The acutDelString() function is recommended.WarningCalling this function before the entity has had its referenced layer object ID set (that is, it's still set to AcDbObjectId::kNull) will terminate AutoCAD. If the referenced layer objectId is AcDbObjectId::kNull when the entity is added to a database, it will be set to the object ID of the database's current default layer.'''
    ...
    def layerId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the AcDbLayerTableRecord referenced by the entity. If the layerId has not been set yet, then AcDbObjectId::kNull is returned.'''
    ...
    def length (self)-> float :
      '''                             '''
    ...
    def lineWeight (self)-> PyDb.LineWeight :
      '''This function returns the AcDb::LineWeight of the entity.'''
    ...
    def linetype (self)-> str :
      '''This function returns a copy of the name string in the AcDbLinetypeTableRecord object referenced by the entity.The calling application is responsible for deallocating the memory used by the returned string. Either the C++ delete [ ] or the C free() function may be used.Warning Calling this function before the entity has had its referenced linetype object ID set (that is, it's still set to AcDbObjectId::kNull) will terminate AutoCAD. If the referenced linetype objectId is AcDbObjectId::kNull when the entity is added to a database it will be set to the object ID of the database's current default linetype.'''
    ...
    def linetypeId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the AcDbLinetypeTableRecord referenced by the entity. If the linetypeId has not been set yet, then AcDbObjectId::kNull will be returned.'''
    ...
    def linetypeScale (self)-> float :
      '''This function returns the linetype scale factor for the entity.'''
    ...
    def list (self)-> None :
      '''Function usageThis function is intended to be called from AutoCAD whenever the entity is selected during the LIST command. However, it can be called from ObjectARX applications if desired.This function will print entity specific information to the AutoCAD command line.Function implementation in derived classesWhen implementing this function in a derived class, the first thing that should be done in the function is to make a call to assertReadEnabled(). The next thing to do is to call the parent class's list() method to allow the parent class to list it's information (the parent class should in turn call its parent class first and so on up the inheritance chain until AcDbObject is reached. This way all the entity's information will be properly printed out in order). Once the parent class's list function has been called then a series of ads_printf() calls can be used to list whatever information is desired.Default implementationLists out the entity's DXF name, the layer, the space the entity resides in (model or paper), and the entity's handle.'''
    ...
    def material (self)-> str :
      '''Returns the material name.'''
    ...
    def materialId (self)-> PyDb.ObjectId :
      '''Returns the ID of the associated AcDbMaterial object.'''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def objectId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the object. If the object is not yet database-resident, then the returned objectId will be set to AcDbObjectId::kNull.'''
    ...
    def ownerId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the owner of the object. If the object does not yet have an owner, or the ownerId data member has not yet been set using AcDbObject::setOwnerId, then the returned objectId will be set to AcDbObjectId::kNull.Appending the object to a BlockTable record, a symbol table, or a dictionary automatically calls AcDbObject::setOwnerId.'''
    ...
    def plotStyleName (self)-> str :
      '''This function returns a copy of the plotStyleName string of the entity. The caller is responsible for deallocating the returned string.The plotStyleName value is used for DXF group code 390.'''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def receiveShadows (self)-> bool :
      '''Returns a boolean value indicating whether this entity can receive shadows.'''
    ...
    def recordGraphicsModified (self)-> None :
      '''This method sets the entity's state to indicate whether or not the entity should be updated on screen when it is closed. If the entity is set not to update, then any changes made will appear the next time the entity is regenerated.If setModified is false and the entity is currently set to update its graphics on close (which is its default state), then this function sets the entity so that it will not update on screen when it is closed and objectModified notification is sent to all entity type reactors attached to the entity. If setModified is false and the entity is already set not to update its graphics on close, then this function simply returns.If setModified is true, then the entity is set to update on screen when it is closed.'''
    ...
    def releaseExtensionDictionary (self)-> None :
      '''Removes the object's extension dictionary (that is, removes the object as the owner of the dictionary object) if it exists and is empty. Once removed, this function calls the dictionary's erase() method. Any reactors attached to the extension dictionary receive normal notification appropriate to an open for write, erase, close sequence.Returns Acad::eOk if successful.If the dictionary is not empty, then this function fails and returns Acad::eContainerNotEmpty.'''
    ...
    def removeContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def removeField (self, id: str|PyDb.ObjectId)-> None :
      '''Removes the specified field.Returns Acad::eOk if successful. Otherwise, returns an AutoCAD error status.'''
    ...
    def removePersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Removes the persistent reactor specified by objId from the reactor list of the object. The object must be open AcDb::kForWrite to be able to execute this function.Returns Acad::eOk if successful. If the object is currently sending notification and is not open AcDb::kForWrite, then Acad::eWasNotifying is returned.'''
    ...
    def removeReactor (self, reactor: PyDb.EntityReactor)-> None :
      '''                             '''
    ...
    def reverseCurve (self)-> None :
      '''Reverses the parameterization of the curve. The start becomes the end and visa versa.'''
    ...
    def rolloverHit (self, nSubentId: int, nMouseFlags: int, bReset: bool)-> int :
      '''                             '''
    ...
    def setAcDbObjectIdsInFlux (self)-> None :
      '''This function must be called on any newly created objects in AcDbObject::deepClone or AcDbObject::wblockClone. It indicates that reference object IDs are not yet pointing to the correct objects. The references can be translated only when the entire deep clone operation is complete. The flag is cleared at that time.'''
    ...
    def setAnnotative (self, state : PyDb.AnnotativeStates)-> None :
      '''                             '''
    ...
    def setAttributes (self, traits: PyGi.DrawableTraits)-> int :
      '''                             '''
    ...
    def setBaseHAlignment (self, id : PyDb.ObjectId)-> bool :
      '''                             '''
    ...
    def setCastShadows (self, val: bool)-> None :
      '''Sets the property to indicate whether the entity can cast shadows.'''
    ...
    def setColor (self, clr: PyDb.AcCmColor, dosubents : bool=True, db : PyDb.Database='current')-> None :
      '''Function usageThis method sets the entity's color to the color specified by color. If the entity owns subentities and doSubents == Adesk::kTrue, the color change is applied to the subentities as well. Custom classes may override this method.'''
    ...
    def setColorIndex (self, clr: int, dosubents : bool=True)-> None :
      '''Function usageThis method sets the entity's color to the AutoCAD color index color. If the entity owns subentities and doSubents == Adesk::kTrue, then the color index change will be applied to the subentities as well.'''
    ...
    def setDatabaseDefaults (self, db: PyDb.Database = 'current')-> None :
      '''This function sets the entity's:ColorLayerLinetypeLinetype scaleVisibilityPlot style nameLine weightto the default values of the database indicated by pDb: If pDb == NULL, then the current database in the AutoCAD editor is used.'''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...

    @overload
    def setField (self, field: PyDb.Field)-> PyDb.ObjectId : ...
    @overload
    def setField (self, propName: str, field: PyDb.Field)-> PyDb.ObjectId : ...
    def setField (self, *args, **kwargs)-> PyDb.ObjectId :
      '''Overloads:
    - field: PyDb.Field
    - propName: str, field: PyDb.Field
    '''
    ...
    def setFromAcGeCurve (self, curve: PyGe.Curve3d, normal: PyGe.Vector3d = PyGe.Vector3d.kZAxis, tol: PyGe.Tol = 'default')-> None :
      '''This is setFromAcGeCurve, a member of class AcDbCurve.'''
    ...
    def setLayer (self, val: str|PyDb.ObjectId, dosubents : bool=True, allowHiddenLayer : bool=False)-> None :
      '''This method sets entity to reference the AcDbLayerTableRecord identified by the name specified in newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the layer change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.'''
    ...
    def setLineWeight (self, val: PyDb.LineWeight, dosubents : bool=True)-> None :
      '''This method sets the entity to use lineweight. If the entity owns subentities and doSubents == Adesk::kTrue, then the line weight change will be applied to the subentities as well.Returns Acad::eOk if successful.Function implementation in derived classesIf this function is overridden and wishes to set the line weight of the entity, then it must call AcDbEntity::setLineWeight() passing on the lineweight and doSubents arguments.It is also possible for this function's implementation to deal directly with any subentities and pass a doSubents value of Adesk::kFalse to AcDbEntity:: setLineWeight().If the line weight setting operation is successful, then this function should return Acad::eOk. If lineweight is not an acceptable value, then this function should return Acad::eInvalidInput. Any other error return values are up to the implementer.'''
    ...
    def setLinetype (self, val: str|PyDb.ObjectId, dosubents : bool=True)-> None :
      '''Function usageThis method sets the entity to reference the AcDbLinetypeTableRecord with the name specified in newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the linetype change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.'''
    ...
    def setLinetypeScale (self, val: float, dosubents : bool=True)-> None :
      '''This method sets the entity to use newval as its linetype scale factor. newVal must be nonnegative. If the entity owns subentities and doSubents == Adesk::kTrue, then the linetype scale change will be applied to the subentities as well.'''
    ...
    def setMaterial (self, val: str|PyDb.ObjectId, dosubents : bool=True)-> None :
      '''This method sets the material reference to the specified material. The specified name must correspond to an existing AcDbMaterial object.Returns Acad::eOk when successful'''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setOwnerId (self, owner: PyDb.ObjectId)-> None :
      '''Sets the ownerId data member of the object to be objId, thus establishing a "backpointer." This backpointer is used by WBLOCK to be sure all necessary objects are written out.Returns Acad::eOk if successful.'''
    ...

    @overload
    def setPlotStyleName (self, /)-> None : ...
    @overload
    def setPlotStyleName (self, nameType: PyDb.PlotStyleNameType, doSubents: bool)-> None : ...
    @overload
    def setPlotStyleName (self, nameType: PyDb.PlotStyleNameType, newId: PyDb.ObjectId, doSubents: bool)-> None : ...
    def setPlotStyleName (self, *args, **kwargs)-> None :
      '''Overloads:
    - None: Any
    - nameType: PyDb.PlotStyleNameType, doSubents: bool
    - nameType: PyDb.PlotStyleNameType, newId: PyDb.ObjectId, doSubents: bool
    
	-This function searches the PlotStyleName dictionary for an entry with the name that matches newName and if found, sets the entity to use that plotStyleName entry. Because a lookup in the PlotStyleName dictionary is required, the entity must be database-resident for this method to succeed. The names ByLayer and ByBlock are allowed as well as user-defined names.If the entity owns subentities and doSubents == Adesk::kTrue, then the change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.Returns Acad::eOk if successful. If the entity is not database-resident, then Acad::eNoDatabase will be returned. If there is no entry in the PlotStyleName dictionary for newName, then Acad::eKeyNotFound will be returned.The plotStyleName value is used for DXF group code 390.-'''
    ...
    def setPropertiesFrom (self, entity: PyDb.Entity, dosubents : bool=True)-> None :
      '''This method copies theColorLayerLinetypeLinetype scaleVisibilityvalues from the entity pointed to by pEntity into this entity. If the entity owns subentities and doSubents == Adesk::kTrue, then the property changes will be applied to the subentities as well.Returns Acad::eOk if successful.'''
    ...
    def setReceiveShadows (self, val: bool)-> None :
      '''Sets the property indicating whether this entity can receive shadows.'''
    ...
    def setVAlignment (self, id : PyDb.ObjectId)-> bool :
      '''                             '''
    ...
    def setVisibility (self, val: PyDb.Visibility, dosubents : bool=True)-> None :
      '''This method sets the visibility of an entity to the value specified by newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the visibility change will be applied to the subentities as well.'''
    ...
    def setXData (self, xdata: list)-> None :
      '''Each regapp sublist (delimited by a resbuf with restype == 1001 and resval.rstring == a valid regappName string) within the resbuf chain pointed to by xdata, is placed in the xdata area of the object. If any of the regappNames in xdata are already present in the xdata area of the object, then that regappName's existing data on the object is overwritten by that regappName's new data in xdata.All resbufs with restype == 1001 must have valid regappNames for the database the object resides in (that is, the regappNames must be in the APPID table of the database).Only valid xdata group codes (1000--1071) are accepted in the restype fields of the resbufs in xdata.No "-3" group code is necessary, and in fact, is not accepted. So, the first element in the resbuf chain must be a 1001 group code with a resval.rstring set to a regappName that's already registered in the regapp table. To register a regappName, use the acdbRegApp() function.To remove an appName (and its xdata) from an object, just use a resbuf with restype == 1001, resval == and no data resbufs following it (that is, either its rbnext == NULL or the next resbuf is another 1001)This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If this function is overridden, then it should supermessage its parent in order to invoke the built-in mechanism to add the xdata to the object.Returns Acad::eOk if the xdata is successfully added to the object. If there is insufficient space in the xdata area of the object, then Acad::eXdataSizeExceeded is returned. If any of the regappNames in xdata are not in the APPID table, then Acad::eRegappIdNotFound is returned.'''
    ...
    def snoop (self,  filer : PyDb.SnoopDwgFiler)-> None :
      '''                             '''
    ...
    def swapIdWith (self, otherId: PyDb.DbObject, swapXdata: bool, swapExtDict: bool)-> None :
      '''This function swaps objectIds and handles between the object specified by otherId and the object invoking this function. Both objects must currently be database-resident and must reside in the same database. If swapXdata == Adesk::kTrue, then the objects swap extended entity data as well. If swapExtDict == Adesk::kTrue, then the objects swap extension dictionaries also.If the object specified by otherId or the object invoking this function are not database-resident, then Acad::eNoDatabase is returned. If both objects involved are not in the same database, then Acad::eWrongDatabase is returned.'''
    ...
    def transformBy (self, matrix3d: PyGe.Matrix3d)-> None :
      '''Function usageThis function provides a means by which AutoCAD and ObjectARX applications can ask the entity to apply a transformation matrix (xform) to itself.Each entity class must implement this function, so restrictions on what types of transformations are supported are up to the implementer of the entity class. The AutoCAD built-in entity classes for entity types that existed before R13 (that is, all the classes listed in the header file dbents.h such as AcDbCircle, AcDbLine, AcDbArc, AcDb2dPolyline, etc.) require that the transformation matrix represent a uniformly scaling orthogonal transformation (if it is not, then Acad::eCannotScaleNonUniformly will be returned). Other AutoCAD built-in classes have no restrictions.Returns Acad::eOk if successful. Return values for errors are implementation-dependent.Function implementation in derived classesThis function must apply the transformation matrix xform to the entity and change the entity's state to reflect the transformation. It is completely up to the implementer as to how to apply the transformation. It is also up to the implementer to decide what, if any, restrictions will be placed on the type of transformations supported. If any restrictions are desired, then it's up to the implementation of this function to enforce them.If your derived class implements transformBy() without calling the base class, you must call AcDbObject:: xDataTransformBy() or your Xdata will not be transformed.If this function successfully transforms the entity, then it should return Acad::eOk.Return values for error conditions are completely up to the implementer of this function. However, if the error is caused by a non-uniformly scaling or non-orthogonal matrix, then to be consistent with other entities that have this restriction, it is recommended that Acad::eCannotScaleNonUniformly be returned.'''
    ...
    def upgradeFromNotify (self, wasWritable: bool)-> None :
      '''Upgrades the object from being at least open AcDb::kForNotify to being open both AcDb::kForNotify and AcDb::kForWrite. The wasWritable argument is set to Adesk::kTrue if the object was already open for write, otherwise it's set to Adesk::kFalse. The wasWritable value should be saved to be passed into the downgradeToNotify() call later.This function must be followed at some point by a call to downgradeToNotify() with no open() (in any of its forms) or close() calls in between.This method should only be called from within other methods of the same object it is being called from. In other words, this method is intended to be used by an object to change it's own open status so that it can safely modify itself.upgradeFromNotify() and downgradeToNotify() call pairs are not nestable.Returns Acad::eOk if successful. If the object is not currently open AcDb::kForNotify, then Acad::eNotApplicable is returned. If the object is currently in the process of actually sending notification (that is, isNotifying() returns Adesk::kTrue), then Acad::eWasNotifying is returned.'''
    ...
    def upgradeOpen (self)-> None :
      '''If the object is currently open AcDb::kForRead with only one reader, then this function upgrades the object to open AcDb::kForWrite. In the process of changing to open for write, the object is closed, thus triggering any pertinent notification.Returns Acad::eOk if successful. If the object has more than one reader, then the open status is not changed and Adesk::eHadMultipleReaders is returned. If the object is already open AcDb::kForWrite, then Acad::eWasOpenForWrite is returned. If the object is currently sending notification, then the open status is not changed and Acad::eWasNotifying is returned.'''
    ...
    def vAlignment (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def viewportDraw (self, vpdraw: PyGi.ViewportDraw)-> None :
      '''                             '''
    ...
    def viewportDrawLogicalFlags (self, vpdraw: PyGi.ViewportDraw)-> int :
      '''                             '''
    ...
    def visibility (self)-> PyDb.Visibility :
      '''This method returns the entity's current visibility state, either AcDb::kVisible or AcDb::kInvisible.'''
    ...
    def wblockClone (self, owner: PyRx.RxObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function is almost identical to AcDbObject::deepClone, except that an AcDbWblockCloneFiler is used and ownership is not carried across database boundaries. Subcloning is based on hard owner and hard pointer connections.'''
    ...
    def worldDraw (self, wdraw: PyGi.WorldDraw)-> int :
      '''                             '''
    ...
    def xData (self, appname: str = None)-> list :
      '''Returns a linked list of resbuf structures containing a copy of the xdata for the object. If regappName == NULL is passed in, all xdata is returned, otherwise only the xdata for the specified name is returned. If not all xdata is required, but the xdata for more than one regappName is desired, then multiple calls to this member function must be made--one for each regappName.The caller of this function is responsible for releasing the memory used by the resbuf list that is returned. The most commonly used way to deallocate such a list is via the acutRelRb() function.This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If a failure accessing the xdata occurs, NULL is returned.'''
    ...
    def xDataTransformBy (self, xform: PyGe.Matrix3d)-> None :
      '''This method applies the xform transformation matrix to any XData data types 1011, 1021, 1031, 1012, 1022, 1032, 1013, 1023, 1033, 1041, and 1042 in the object's XData. See the documentation on XData for more information on the way the transformation matrix is applied to the different data types.This method should be called from within the transformBy() method on custom entities so that such entities will transform XData in the same way that the built-in AcDb entities do.Returns Acad::eOk if successful.'''
    ...
    def xmitPropagateModify (self)-> None :
      '''Within an object's close() method is a call to the object's xmitPropagateModify().The AcDbObject::xmitPropagateModify() default implementation is to inform the containing database that the object has been modified, appended to the database, or erased. The database then sends out the appropriate notification to any AcDbDatabaseReactors attached to it.Within AutoCAD, this function is used by complex entities such as polylines to allow the subentities to notify the header that they have been changed. The header can then "propagate" the notification by sending its own notification that the "complex entity" has been modified.The way this works is:The subobject class has it's xmitPropagateModify() class overridden such that it calls it's parent class's xmitPropagateModify() and also calls the owning object's recvPropagateModify().The "root" or "header" class has it's recvPropagateModify() overridden to provide an implementation that triggers "modified" notification to be sent for the "root" or "header" (which effectively represents the whole complex object).The subobject's close() triggers "modified" notification for the subobject and calls the subobject's xmitPropagateModify() function. So, when the subobject's close() is called, its xmitPropagateModify() is called. This then calls the owning object's recvPropagateModify(), which then triggers the owner to send "modified" notification.So, the result is a "modified" notification from both the subentity and the "root" or "header" entity.When overridden, this function should:Call its parent class's xmitPropagateModify() (which ultimately results in the execution of AcDbObject::xmitPropagateModify() to trigger database notification).Call its owner's recvPropagateModify() (passing in its "this" pointer) to "propagate" the notification information to the "root" owner to be sent out.'''
    ...

class CvDbCurve(PyDb.Curve):
    def __init__ (self, id: ObjectId, mode: PyDb.OpenMode=PyDb.OpenMode.kForRead, erased: bool=False)-> None :
      '''                             '''
    ...
    def addContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def addPersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Adds the database-resident object specified by objId to the reactor list of the AcDbObject object.'''
    ...
    def addReactor (self, reactor: PyDb.EntityReactor)-> None :
      '''                             '''
    ...
    def addSubentPaths (self, paths: list[PyDb.FullSubentPath])-> None :
      '''Adds one or more subentities to an entity.The prototype of this method is provided for completeness of the subentity manipulation APIs. AutoCAD will never call this method on a custom object.Returns Acad::eOk if successful. The default implementation returns Acad::eNotAvailable.'''
    ...
    def assertNotifyEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should be used inside of member functions that are only called when the object is open kForNotify. When used, it should be the first function called inside the member function.'''
    ...
    def assertReadEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that access the object's data in a read-only fashion (for example, dxfOutFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is open AcDb::kForRead.If this function is called while the object is not open, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def assertWriteEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that modify the object's data (for example, dxfInFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is indeed open for write (if it is not, then AutoCAD terminates); to trigger an immediate sending of "openedForModify" notification; to set up the notification mechanism so that "modified" and "modifiedGraphics" (if the object is derived from AcDbEntity) are sent at the appropriate times; and to ensure that graphics get updated if the object is derived from AcDbEntity.If this function is called on a database resident object, "openedForModify" will be sent if the object is not newly created, and "modified", and "modifiedGraphics" (if appropriate) notifications will be sent when the object is next closed.If recordModified is false, then the autoUndo argument is ignored, and the undo filer is not initialized, no undo recording will take place, but notifications will be sent.If autoUndo and recordModified are both true, then automatic undo recording will be performed and notifications will be sent.If autoUndo is false and recordModified is true, then there will not be any automatic undo recording, but the undo filer is initialized and the object must manually write out partial Undo records and must implement its applyPartialUndo() method. Notifications will be sent.If this function is called while the object is not open AcDb::kForWrite, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def blockId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the entity's owner, which must be an AcDbBlockTableRecord.If the entity does not have an owner yet, then AcDbObjectId::kNull will be returned.'''
    ...
    def bounds (self, ext: PyDb.Extents)-> bool :
      '''                             '''
    ...
    def cancel (self)-> None :
      '''Terminates the current open operation. All changes made to the object since it was opened are undone, the object is marked as closed, and "cancel" notification is sent.Returns Acad::eOk if successful.'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbCurve :
      '''                             '''
    ...
    def castShadows (self)-> bool :
      '''Returns a boolean value that indicates whether the entity can cast shadows. '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...

    @staticmethod
    def cloneFrom (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbCurve :
      '''                             '''
    ...
    def close (self)-> None :
      '''Closes the object. All changes made to the object since it was opened are committed to the database, the object is marked as pageable, and a "closed" notification (as well as any other appropriate notification such as "modified", "erased", and so on) is sent.Returns Acad::eOk if successful.If the object is not in an AcDbDatabase yet, then Acad::eNoDatabase is returned.If the object is sending notification, then Acad::eCloseWasNotifying is returned.If the subClose() call made within the close() method returns anything other than Acad::eOk, then that ErrorStatus is returned.'''
    ...
    def collisionType (self)-> PyDb.CollisionType :
      '''This function returns the collision detection treatment for this entity. Subclasses may override this method to customize how the class interacts in collision-aware features.'''
    ...
    def color (self)-> PyDb.Color :
      '''This function returns the full true color information for the entity within an instance of AcCmColor.The index value will be in the range 0 to 256. 0 and 256 are special values.0 indicates the entity uses the color of the BlockReference that's displaying it. If the entity is not displayed through a BlockReference (for example, it's directly owned by the model space BlockTableRecord) and its color is 0, then it will display as though its color were 7.256 indicates the entity uses the color specified in the LayerTableRecord it references.'''
    ...
    def colorIndex (self)-> int :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...
    def createExtensionDictionary (self)-> None :
      '''Creates an AcDbDictionary object and sets it up as the extension dictionary for the AcDbObject.Returns Acad::eOk if successful. If an extension dictionary already exists, Acad::eAlreadyInDb is returned.'''
    ...

    @staticmethod
    def createFromAcGeCurve (curve: PyGe.Curve3d,normal: PyGe.Vector3d = PyGe.Vector3d.kZAxis,tol: PyGe.Tol = 'default')-> PyDb.Curve :
      '''This is createFromAcGeCurve, a member of class AcDbCurve.'''
    ...
    def database (self)-> PyDb.Database :
      '''Returns a pointer to the AcDbDatabase object that contains the AcDbObject.'''
    ...
    def deepClone (self, owner: PyDb.DbObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function gives control of deep clone operations to the object. In the default implementation, the object is cloned and appended to the owner object (pOwnerObject). The cloning is performed by an AcDbDeepCloneFiler. A record is also added to the idMap. Then, using the filer, any owned objects are deep cloned, with isPrimary set to Adesk::kFalse.'''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def disableUndoRecording (self, disable: bool)-> None :
      '''Turns off or on the Undo recording for the object. If disable == Adesk::kTrue, then Undo recording is turned off until this function is called with disable == Adesk::kFalse, at which time Undo recording is turned back on.'''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def downgradeOpen (self)-> None :
      '''Downgrades the object from being open AcDb::kForWrite, to being AcDb::kForRead. In the process, all changes made to the object while it was open for write are committed to the database and appropriate notification is sent.'''
    ...
    def downgradeToNotify (self, wasWritable: bool)-> None :
      '''Restores an object from being open both AcDb::kForNotify and AcDb::kForWrite, to being open just AcDb::kForNotify. The wasWritable value that was returned from the matching AcDbObject::upgradeFromNotify() call should be passed into this function to restore the proper open status.This function must have been preceded by a call to upgradeFromNotify().Returns Acad::eOk if successful.'''
    ...
    def draw (self)-> None :
      '''This function queues up the entity's graphics and flushes the graphics queue, forcing the entity and anything else in the queue to be drawn or re-drawn on-screen.Returns Acad::eOk if successful.If the entity is not in a database, then Acad::eNotInDatabase will be returned.If the entity is in a database other than the one currently loaded into the AutoCAD editor, then Acad::eNotCurrentDatabase will be returned.'''
    ...
    def drawableType (self)-> PyGi.GiDrawableType :
      '''                             '''
    ...
    def entityColor (self)-> PyDb.EntityColor :
      '''This function returns the color settings of the entity in an AcCmEntityColor form. Most clients should use the color() function, which returns the heavyweight AcCmColor object. However, if color name information is not required, this function provides faster access to the lightweight AcCmEntityColor data.'''
    ...
    def erase (self, erasing : bool=True)-> None :
      '''Sets the erase bit of the object. If erasing == Adesk::kTrue, then the erase bit is set on. If erasing == Adesk::kFalse, then the erase bit is set off.'''
    ...
    def explode (self)-> list :
      '''Function UsageThis function is primarily intended for AutoCAD to call as part of an explode operation that includes this entity. However, this function can be used by ObjectARX applications to obtain an array of pointers to non-database-resident entity objects that are what the entity considers to be its exploded parts.When calling this function, the entitySet array does not need to be empty. This function will append to it, and pointers to entities that it creates to be used in its place as the "exploded" result.If this function is successful, it will return Acad::eOk. Other return values may vary depending on how it has been implemented.Function Implementation in Derived ClassesThis function should dynamically create (using the new operator) whatever entity objects are appropriate to be used to replace the entity after an explode operation has taken place. Pointers to these entities are then appended to the entitySet array. Once the pointers have been appended, the function should return with a status of Acad::eOk.'''
    ...

    @overload
    def extend (self, newParam: float)-> None : ...
    @overload
    def extend (self, extendStart: bool, toPoint: PyGe.Point3d)-> None : ...
    def extend (self, *args, **kwargs)-> None :
      '''Overloads:
    - newParam: float
    - extendStart: bool, toPoint: PyGe.Point3d
    
	-This function extends the beginning or end of the curve to the new point determined by the newParam value.If newParam is less than the curve's start parameter, then the curve is reset to start at newParam. If newParam is greater than the curve's end parameter, then the curve is reset to end at newParam.Returns Acad::eOk if successful. If newParam's first period value is between the curve's start and end, then Acad::eInvalidInput will be returned.The function implementation in derived classes must be able to interpret the newParam value, decide if it is beyond the existing curve end or before the curve beginning, and then extend the curve in the appropriate direction to the newParam value.Return ErrorStatus values are up to the implementer, but to be consistent with built-in classes, the following return values are recommended:Acad::eOkFunction completed successfully.Acad::eInvalidInputThe parameter was not acceptable for some reason (for example, if its first period lies within the existing curve so that it would be a trim rather than an extension).The default implementation returns Acad::eNotImplemented.-'''
    ...
    def extensionDictionary (self)-> PyDb.ObjectId :
      '''Returns the objectId of the extension dictionary owned by the object. If the object does not own an extension dictionary, then the returned objectId is set to AcDbObjectId::kNull.'''
    ...
    def getAcGeCurve (self, tol: PyGe.Tol = 'default')-> PyGe.Curve3d :
      '''This is getAcGeCurve, a member of class AcDbCurve.'''
    ...
    def getArea (self)-> float :
      '''This function returns with area set to the area inside the curve. For the AutoCAD built-in classes, the curve must lie on a plane. If the curve is not closed, its start and end points are considered as connected by a line segment that closes it.Returns Acad::eOk if successful. For the AutoCAD built-in classes, Acad::eInvalidInput is returned if the curve is not planar. Other return values are possible for custom entity classes depending on how they were implemented.This function must be able to calculate a bounded area value for the curve.While the AutoCAD built-in classes require the curve to be planar, no such restriction need be made for custom entity classes unless desired by the implementer.ErrorStatus return values are up to the implementer, but the following are recommended to be consistent with existing classes:Acad::eOkFunction completed successfully.Acad::eInvalidInputThe area was not calculable (for example, the curve was not planar).The default implementation's return value is Acad::eNotImplemented.'''
    ...
    def getClosestPointTo (self, point3d: PyGe.Point3d, direction: PyGe.Vector3d=None, extend: bool=False)-> PyGe.Point3d :
      '''This function projects the curve onto the plane defined by givenPnt and normal, finds the point on the projected curve that is nearest to givenPnt, then projects this nearest point back onto the original curve and sets pointOnCurve to the result.If extend == Adesk::kTrue, then the curve is extended along its path to find the closest point.Returns Acad::eOk if successful. Return values for errors are dependent on the implementation.In derived classes; this function needs to be able to project the curve onto a plane determined by a point (givenPnt) and a normal vector (normal), extend the curve's projection if necessary (if extend==Adesk::kTrue), find the point on the projected curve that is nearest to givenPnt, then project the point found back onto the original curve (or its path if it was extended) and set pointOnCurve to the end result.Use of AcGe classes may be helpful in doing some of the projection and nearest point calculation work.If the operation is successful, this function returns Acad::eOk. Return values for errors are dependent upon the error and the implementer. See header file acdh.h for a list of possible ErrorStatus values.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getCompoundObjectTransform (self)-> PyGe.Matrix3d :
      '''This function is intended to be overridden by derived classes that are compound objects (in other words, objects that behave like blocks in the display list).A compound object has little or no geometry of its own; instead it relies on nested entities, perhaps the contents of a BlockTableRecord, to represent itself. A compound object must use the same transformation matrix for all of its contained entities. Otherwise selection and osnap will not function correctly. This is the method that the system uses to obtain that matrix from the compound object.This method should only be overridden if you return the kDrawableIsCompoundObject flag from setAttributes. The matrix you should return here is the one that you pass to pushModelTransform before you render your nested objects. You must override this method if you return the compound object flag in setAttributes, even if you don't push a transform for your nested objects. In that case you would return Acad::eOk and the identity transform in xMat.Default implementation: Returns Acad::eNotApplicable and the identity matrix in xMat.'''
    ...
    def getDistAtParam (self, param: float)-> float :
      '''Calculates the length of the curve's segment from the curve's start point to the point specified by param.Returns Acad::eOk if successful, or Acad::eInvalidInput if param is out of range. For other errors, the implementer must decide what return value to use. See the acdb.h header file for possible ErrorStatus values.In the default implementation, the function returns Acad::eNotImplemented.'''
    ...
    def getDistAtPoint (self, point3d: PyGe.Point3d)-> float :
      '''Calculates the length of the curve's segment between the curve's start point and point and returns the length in distance.Returns Acad::eOk if successful, or Acad::eInvalidInput if the point is not on the curve. For other errors, the implementer must decide what return value to use. See the acdb.h header file for possible ErrorStatus values.Returns Acad::eNotImplemented in the default implementation.'''
    ...
    def getEcs (self)-> PyGe.Matrix3d :
      '''This function is intended to be overridden by derived classes that need to be able to provide access to an object coordinate system for objects of the class. The intent is that this function provide a transformation matrix that can be used to transform vectors or points from the object's object coordinate system (OCS) to the World Coordinate System (WCS).Default implementation: Return the identity matrix (ones along the diagonal, zeros elsewhere) in retVal.We recommend that all data stored in custom classes be stored in WCS coordinates. If this is done, then the object's OCS will be the WCS and the transformation matrix will be the identity matrix. Then this function will not need to be overridden since the identity matrix is this function's default return.'''
    ...
    def getEndParam (self)-> float :
      '''The implementation of this function in derived classes should return with endParam set to the parameter of the endpoint of the curve.Returns Acad::eOk if successful.By default, the function returns Acad::eNotImplemented.'''
    ...
    def getEndPoint (self)-> PyGe.Point3d :
      '''In this class and in derived classes, this function returns with endPoint set to the end point (in WCS coordinates) of the curve.Returns Acad::eOk if successful.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getField (self, prop: str='TEXT')-> PyDb.ObjectId :
      '''Gets the field ID. A field can be stored in an object using the property name as the key.Returns Acad::eOk if the object has a field for the specified property. Otherwise, returns an AutoCAD error status.'''
    ...
    def getFieldDictionary (self)-> PyDb.ObjectId :
      '''Returns the field dictionary ID. The field dictionary stores all the fields set in the object as property name-field object pairs. The ID will be null if there is no field in the object.'''
    ...
    def getFirstDeriv (self, param: float|PyGe.Point3d)-> PyGe.Vector3d :
      '''Here and in derived classes, this function is implemented to evaluate the first derivative at the location on the curve specified by param, and sets firstDeriv to the result (in WCS coordinates).Returns Acad::eOk if successful. If param is not valid for the curve, then Acad::eInvalidInput is returned. Other ErrorStatus return values are up to the implementer.For implementation, the AcGe classes may provide some of the necessary functionality to make the job easier.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getGeomExtents (self)-> PyDb.Extents :
      '''Unimplemented at the AcDbEntity level, this method is intended to be overridden in derived classes.Derived classes should calculate and return the corner points (in WCS coordinates) of a box (with edges parallel to the WCS X, Y, and Z axes) that encloses the 3D extents of the entity, and return those points as an instance of class AcDbExtents in the "extents" parameter.Default implementation: Immediately returns Acad::eInvalidExtents.'''
    ...
    def getGeomExtents2d (self)-> PyDb.Extents2d :
      '''                             '''
    ...

    @overload
    def getGripPoints (self, /)-> tuple[Any,...] : ...
    @overload
    def getGripPoints (self, curViewUnitSize: float, gripSize: int, curViewDir: PyGe.Vector3d, bitflags: int)-> tuple[Any,...] : ...
    def getGripPoints (self, *args, **kwargs)-> tuple[Any,...] :
      '''Overloads:
    - None: Any
    - curViewUnitSize: float, gripSize: int, curViewDir: PyGe.Vector3d, bitflags: int
    
	-Function usageThis function supports "old style" grips, in applications that existed before the enhancement of grip functionality by the addition of the AcDbGripData class.This function is not intended to be called by ObjectARX applications. However, it is possible to do so (for example, as a pass-through from the getStretchPoints() method).Function implementation in derived classesThis function should append to the gripPoints array any points that are to treated as grip points for the entity.The gripPoints array is passed to all entities involved in the grip operation, so the array may already contain grip points for other entities. Therefore, it is very important to append the new points rather than assigning them to any existing elements in the array.When finished appending all desired grip points, return Acad::eOk. If anything other than Acad::eOk is returned, then grips are not activated for this entity.The osnapModes and geomIds arguments are not currently used.Default implementationImmediately returns Adesk::eNotImplemented.-'''
    ...
    def getHandle (self)-> PyDb.Handle :
      '''Fills in handle with the handle value for the object. If the object is not yet database-resident, then it will not have a handle. Use AcDbHandle::isNull to test for this condition.'''
    ...
    def getOffsetCurves (self, dist: float)-> list :
      '''This function creates one or more entities that together make up the result of offsetting the curve by the distance offsetDist. For many curves, the result is a single new curve. (This single new curve may not be of the same class as the original curve. For example, offsetting an AcDbEllipse results in an AcDbSpline, since the result of offsetting an ellipse does NOT fit the equation of an ellipse.)In some cases, it might be necessary for the offset result to be several curves. (The result may even be several curves that would form a single curve if they were joined end-to-end.) To allow for this possibility, a dynamic array of void pointers is used to hold pointers to the resulting entity or entities.To use this array of pointers, the calling application needs to cast the pointer(s) to the appropriate object type(s). If only a specific entity type or set of types are to be handled, then use the cast method of the class(es) desired to see if each pointer can be safely cast to that object type. If the actual object type (class name) is desired, then each object's isA() method may be used to get a pointer to the object's AcRxClass object, which has a name() method.If the offsetDist value is negative, it is usually interpreted as being an offset to make a smaller curve (that is, for an arc it would offset to a radius that is offsetDist less than the starting curve's radius). If the negative value has no meaning in terms of making the curve smaller, a negative offsetDist may be interpreted as an offset in the direction of smaller X,Y,Z WCS coordinates. This is not enforced, so custom entities can interpret the sign of the offsetDist value however they want.The entities returned in the offsetCurves array are dynamically allocated, but have not been added to an AcDbDatabase yet. So, the application that calls this function is responsible for their memory. If they are subsequently appended to a database, then the database takes over responsibility for their memory. Otherwise, the application is responsible for deleting them when they are no longer needed.Returns Acad::eOk if offsetting is successfully completed. If the offset distance is invalid (for example, if you are offsetting an arc such that the offset result would be a negative radius), then Acad::eInvalidInput is returned. For the AutoCAD built-in classes that use ShapeManager (AcDbBody, AcDbRegion, and AcDb3dSolid), Acad::eGeneralModelingFailure will be returned if an error occurs in the ShapeManager modeler. Other ErrorStatus return values are implementation-dependent.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getOffsetCurvesGivenPlaneNormal (self, normal: PyGe.Vector3d, dist: float)-> list :
      '''This function creates one or more entities that, together, make up the result of offsetting the curve by the distance offsetDist in the plane with normal vector normal. For many curves, the result will be a single new curve, which may not be of the same class as the original curve. For example, offsetting an AcDbEllipse results in an AcDbSpline, since the result of offsetting an ellipse does not fit the equation of an ellipse. However, in some cases it might be necessary for the offset result to be several curves. To allow for this possibility, a dynamic array of void pointers is used to hold pointers to the resulting entity or entities.To use this array of pointers, the calling application must cast the pointer(s) to the appropriate object type(s). If only a specific entity type or set of types are to be handled, then using the cast method of the class(es) desired to see if each pointer can be safely cast to that object type will work. If the actual object type is desired, then each object's isA() method may be used to get a pointer to the object's AcRxClass object, which has a name() method to get the classname of the object.If the offsetDist value is negative this is usually interpreted as being an offset to make a smaller curve (that is, for an arc it would offset to a radius that is offsetDist less than the starting curve's radius). Or, if smaller has no meaning, then a negative offsetDist may be interpreted as an offset in the direction of smaller X,Y,Z WCS coordinates. However, this is not enforced, so custom entities can interpret the sign of the offsetDist value however they wish.The entities returned in the offsetCurves arrays are dynamically allocated, but have not been added to an AcDbDatabase yet. So, the application that calls this function is responsible for their memory. If they are subsequently appended to a database, then the database takes over responsibility for their memory. Otherwise, the application is responsible for deleting them when they are no longer needed.Returns Acad::eOk if offsetting is successfully completed. If the offset distance is invalid, or if normal is a zero length vector or the entity is linear and normal is not perpendicular with the entity, then Acad::eInvalidInput is returned. Other ErrorStatus return values are implementation dependent.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getOrthoProjectedCurve (self, plane: PyGe.Plane)-> PyDb.Curve :
      '''This function creates a new curve entity that is the result of projecting the curve along the projPlane's normal onto the projPlane and sets projCurve to point to the newly created curve. projCurve is declared as type AcDbCurve to allow the returned curve to be any class derived from AcDbCurve (for example, when an AcDbArc is projected onto a plane, the result is an AcDbEllipse).The returned curve is dynamically allocated, but has not been added to an AcDbDatabase yet. So, the application that calls this function is responsible for its memory. If the curve is subsequently appended to a database, then the database takes over responsibility for its memory. Otherwise, the application is responsible for deleting it when it is no longer needed.Returns Acad::eOk if successful. Other ErrorStatus values are implementation-dependent.Returns Acad::eNotImplemented in the default implementation.'''
    ...
    def getParamAtDist (self, dist: float)-> float :
      '''This function determines the parameter of the curve at the location that is a distance of dist along the curve from the curve start, and returns the parameter in param.Returns Acad::eOk if successful. If dist is not valid for the curve, then Acad::eInvalidInput is returned. Other ErrorStatus return values are implementation-dependent.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getParamAtPoint (self, point3d: PyGe.Point3d)-> float :
      '''This function determines the parameter of the curve at point and returns the parameter in param.Returns Acad::eOk if successful. If point is not on the curve, then Acad::eInvalidInput is returned. Other ErrorStatus return values are implementation-dependent.Acad::eNotImplemented is returned by the default implementation.'''
    ...
    def getPlane (self)-> PyGe.Plane :
      '''If the entity is planar, then the plane containing the entity is returned in plane and flag is set to AcDb::kPlanar.If the entity is nonplanar, but is linear, then plane is set to an arbitrary plane that contains the entity and flag is set to AcDb::kLinear.If the entity is nonplanar and nonlinear, then plane is left unset and flag is set to AcDb::kNonPlanar.Returns Acad::eOk if successful. Other ErrorStatus return values are implementation-dependent.The default implementation is to return Acad::eNotApplicable.'''
    ...
    def getPlotStyleNameId (self)-> PyDb.ObjectId :
      '''Returns with id set to the object ID of the AcDbPlaceHolder object referenced by the entity. The AcDbPlaceHolder object resides in the plot style name dictionary, and its key in the dictionary is the plot style name.Use the AcDbDictionary::nameAt() function on the plot style name dictionary to get the plot style name string that corresponds to the ID obtained by this function.'''
    ...
    def getPointAtDist (self, dist: float)-> PyGe.Point3d :
      '''This function determines the point on the curve that is a distance of dist along the curve from the curve start, and returns the point in point. point is in WCS coordinates.Returns Acad::eOk if successful. If dist is not valid for the curve, then Acad::eInvalidInput is returned. Other ErrorStatus return values are implementation-dependent.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getPointAtParam (self, param: float)-> PyGe.Point3d :
      '''This function determines the point on the curve that corresponds to the param parameter, and returns the point in point. point is in WCS coordinates.Returns Acad::eOk if successful. If the parameter is not within the curve's range, then Acad::eInvalidInput is returned. Other ErrorStatus return values are implementation-dependent.Returns Acad::eNotImplemented in the default implementation.'''
    ...
    def getProjectedCurve (self, plane: PyGe.Plane, projDir: PyGe.Vector3d)-> PyDb.Curve :
      '''This function creates a new curve entity that is the result of projecting the curve parallel to projDir onto the projPlane and sets projCurve to point to the newly created curve. projCurve is declared as type AcDbCurve in order to allow the returned curve to be any class derived from AcDbCurve. For example, when an AcDbArc is projected onto a plane, the result is an AcDbEllipse.The returned curve is dynamically allocated, but has not been added to an AcDbDatabase yet. The application that calls this function is therefore responsible for its memory. If the curve is subsequently appended to a database, then the database takes over responsibility for its memory. Otherwise, the application is responsible for deleting it when it is no longer needed.Returns Acad::eOk if successful. If projDir is perpendicular to the projPlane's normal then Acad::eInvalidInput is returned. For the AutoCAD built-in classes that use ShapeManager (AcDbEllipse, AcDbSpline, AcDbBody, AcDbRegion, and AcDb3dSolid), Acad::eGeneralModelingFailure is returned if an error occurs in the ShapeManager modeler. Other ErrorStatus values are implementation-dependent.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getSecondDeriv (self, param: float|PyGe.Point3d)-> PyGe.Vector3d :
      '''Evaluates the second derivative at the location on the curve specified by param and sets secDeriv to the result (in WCS coordinates).Returns Acad::eOk if successful. If param is not valid for the curve, then Acad::eInvalidInput is returned. Other ErrorStatus return values are up to the implementer.For implementation, the AcGe classes provide some of the necessary functionality to make the job easier.Returns Acad::eNotImplemented in the default implementation.'''
    ...
    def getSpline (self)-> PyDb.Spline :
      '''This function creates a new AcDbSpline entity, sets it to be as close an approximation as possible to the curve, and then returns with spline pointing to the newly created spline entity.The returned spline is dynamically allocated, but has not been added to an AcDbDatabase yet. So, the application that calls this function is responsible for its memory. If the spline is subsequently appended to a database, then the database takes over responsibility for its memory. Otherwise, the application is responsible for deleting it when it is no longer needed.Returns Acad::eOk if successful. If there is an error in the ShapeManager modeler (which AcDbSpline uses), then Acad::eGeneralModelingFailure will be returned. Other ErrorStatus values are implementation-dependent.Returns Acad::eNotImplemented in the default implementation.'''
    ...
    def getSplitCurves (self, paramsOrPoints: list)-> list :
      '''This function creates one or more entities that are all subcurves of the original. The points array must contain the points on the curve that are used as the start or end points of the newly created subcurves. The first subcurve starts at the original curve's start point and ends at the first point in the points array. The second subcurve starts at the first point in the points array and ends at the second point in the points array. The third subcurve starts at the second point and ends at the third, and so on. The last subcurve starts at the last point in the points array and ends at the original curve's endpoint.If successive points are coincident (including the original curve's start to the first array point and the last array point to the original curve's end), then no subcurve is created for that pair.Pointers to all new curves are appended to the curveSegments array.The entities that are returned in the curveSegments array are dynamically allocated, but are not yet added to an AcDbDatabase. So, the application that calls this function is responsible for their memory. If they are subsequently appended to a database, then the database takes over responsibility for their memory. Otherwise, the application is responsible for deleting them when they are no longer needed.Depending on how this function is implemented, it is possible that the function might return an ErrorStatus other than Acad::eOk and still have appended some pointers to subcurves to the curveSegments array (AcDbArc does this). Typically, this would be the result of an invalid point somewhere in the middle of the points array. So, it is very important to check the size of the curveSegments array upon return to be sure that any subcurves that are created are properly dealt with.To use the pointer(s) in the curveSegments array, the calling application will need to cast the pointer(s) to the appropriate object type(s). For this function, the objects pointed to by the pointers in the curveSegments array are usually going to be of the same class as the original curve. However, this is not a requirement. To be safe, the pointers should be cast using the appropriate class's cast method.Returns Acad::eOk if successful.If points is empty or any of the points in points are not on the curve, then Acad::eInvalidInput is returned. As mentioned above, it is possible for this ErrorStatus to be returned and still have some subcurve pointers appended to the curveSegments array.For the AutoCAD built-in classes that use ShapeManager (AcDbEllipse, AcDbSpline, AcDbBody, AcDbRegion, and AcDb3dSolid), Acad::eGeneralModelingFailure is returned if an error occurs in the ShapeManager modeler.Other ErrorStatus return values are implementation-dependent.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getSplitCurvesAtParam (self, param: float)-> list :
      '''                             '''
    ...
    def getSplitCurvesAtParams (self, params: list)-> list :
      '''                             '''
    ...
    def getSplitCurvesAtPoint (self, point: PyGe.Point3d)-> list :
      '''                             '''
    ...
    def getSplitCurvesAtPoints (self, points: list)-> list :
      '''                             '''
    ...
    def getStartParam (self)-> float :
      '''This function returns with startParam set to the start parameter on the curve.Returns Acad::eOk if successful.Returns Acad::eNotImplemented in the default implementation.'''
    ...
    def getStartPoint (self)-> PyGe.Point3d :
      '''This function returns with startPoint set to the start point (in WCS coordinates) of the curve.Returns Acad::eOk if successful, and Acad::eNotImplemented in the default implementation.'''
    ...
    def getStretchPoints (self)-> list :
      '''Function usageThis function is not intended to be called by ObjectARX applications. However, it is possible to do so (for example, as a pass-through from the getGripPoints() method).Function implementation in derived classesThis function should append to the stretchPoints array any points that are to treated as stretch points for the entity.Stretch points are used by the stretch command within AutoCAD. Any stretch points that are within the crossing selection window during the stretch command, will be moved by whatever amount the user decides to "stretch" the selected entities. Any stretch points not in the crossing selection window will be left alone. This combination of some stretch points moving while others do not is what "stretches" the entity. If all stretch points are in the crossing window, then the entity is moved instead of stretched.The stretchPoints array is passed to all entities involved in the stretch operation, so the array may already contain stretch points for other entities. Therefore it is very important to append the new points rather than assigning them to any existing elements in the array.When finished appending all desired stretch points, return Acad::eOk. If anything other than Acad::eOk is returned, then this entity's stretch points will be ignored by the stretch operation.Default implementationCalls the AcDbEntity::getGripPoints() method. So, unless the entity needs to have stretch points that are different from the grip points, there is no need to override this method.'''
    ...
    def getSubentPathsAtGsMarker (self, type: PyDb.SubentType, gsMark: int, pickPoint: PyGe.Point3d, viewXform: PyGe.Matrix3d)-> list[PyDb.FullSubentPath] :
      '''Entities use various graphic primitives defined in AcGi to draw themselves. Part of this mechanism is the ability to associate an integer identifier called a graphics system marker (or, GS marker) with each primitive or with groups of primitives. Through the use of certain selection mechanisms, the GS marker for the actual subentity selected on screen can be obtained and, along with some other information passed into this function, can be used to create one or more AcDbFullSubentPath objects, each one representing a subentity and providing a more complete description of the subentity and its environment. These AcDbFullSubentPath objects can be used by several other functions for various purposes such as highlighting or unhighlighting the subentities on screen.Function usageIf the entity (of which the subentity is a part) is directly owned by the model or paper space BlockTableRecords, then leave out numInserts and entAndInsertStack so that their default value will be used.Typically the GS marker is obtained via the use of ads_ssget() followed by ads_ssnamex() (see the ObjectARX Developer's Guide for more information on this).The pickPoint can be obtained from ads_ssnamex() as well (it's the first group 5009 in the returned list).The viewXform can be calculated using the ads_trans() function on the vectors (1,0,0), (0,1,0), and (0,0,1) to translate them from DCS to WCS. The translations of these three vectors (with an extra 0 appended on to the end of each) would be used as the first three rows of the matrix. The last row is not used so it can be left as is. This argument is not used by any of the AutoCAD built-in entities.If the entity is nested inside one or more block definitions, then the numInserts and entAndInsertStack arguments must also be filled in with non-zero or non-null values. If they are not filled in, then this function will fail and return an error status. One way to get the necessary object IDs is to use ads_nentselp() to obtain the list of ads_names of the container objects. This list must then be converted to object IDs and reversed.Upon return, the subentPaths argument will point to a dynamically allocated array of one or more AcDbFullSubentPath objects. The numPaths argument will contain the number of AcDbFullSubentPath objects being returned.The calling application is responsible for deallocating the memory used by the subentPaths array. The C++ delete [ ] should be used.Return values for this function may vary depending on how the function has been implemented (see below).Function implementation in derived classesEntity classes which do not set GS markers probably should not implement this function since the GS marker is the primary (and often the only) means of subentity distinction.When implemented, this function must use the material provided in type, gsMark, pickPoint, viewXform, numInserts, and entAndInsertStack to determine which subentity or subentities meet the criteria in these arguments. Next it must create a dynamically allocated array of AcDbFullSubentPaths (using the C++ new operator) with one element for each subentity determined in the first step. Finally it must fill in each AcDbFullSubentPath object in the array with the information appropriate to the subentity it will represent.If numInserts == 0 and entAndInsertStack == NULL, it's important to check to be sure that the entity's owner is indeed the model or paper space BlockTableRecord. This can be done by using the entity's ownerId() method to obtain the objectId of its owner, and then opening up that object and using its name() method to obtain its name string. If the owner is not the model or paper space BlockTableRecord, and numInserts == 0 or entAndInsertStack == NULL, or both, then the input data is invalid and this function should set numPaths to 0, set subentPaths to NULL and then return the error status Acad::eInvalidInput.Each AcDbFullSubentPath object has two parts, an array of objectIds containing all the container objects, and an embedded AcDbSubentId object which in turn has two elements: an index value and a SubentityType.If the "main" entity (the entity on which this function is being called) is not nested within BlockReferences (that is, numInserts == 0 and entAndInsertStack == NULL), then the objectId array should contain only the objectId of the "main" entity. If the "main" entity is nested in one or more BlockReferences, then the AcDbObjectIdArray is the same as entAndInsertStack, so copying the entAndInsertStack elements into the AcDbObjectIdArray is all that's required.The SubentType data item within the embedded AcDbSubentId should be set the same as type.The index data item within the embedded AcDbSubentId can be any value you wish (it is often simply the GS marker), but if implemented, the following functions must be able to interpret them to determine the corresponding GS marker(s) or subentity (or subentities):getGsMarkersAtSubentPath()subentPtr()The pickPoint and viewXform arguments are provided as extra aids (if necessary) in determining which subentity is involved. For example, some entity types might display differently depending on the display viewpoint. The viewXform transformation matrix can be used in such cases.The viewXform argument provides a transformation matrix to transform from WCS (World Coordinate System) to DCS (display coordinate system).The display coordinate system is oriented such that the positive Z axis is coming out of the display screen towards the user, the positive X axis is horizontally from left to right on screen, and the positive Y axis is vertically upwards on screen.So, if the current viewpoint is at (1,0,0) (the viewer is always looking towards (0,0,0)) then the viewXform matrix would be:0 1 0 00 0 1 01 0 0 00 0 0 1In this matrix the last row and the last column are not used. Notice also that the third row is the DCS Z axis in WCS coordinates (which is the WCS version of the AutoCAD VIEWPOINT system variable).When this function returns, the return code to use is completely up to the implementer, but to be consistent with other existing entity class implementations of this function the following should be used:If the function succeeds, it should return Acad::eOk.If an invalid or unsupported SubentType is passed in, then numPaths should be set to 0, subentPaths should be set to NULL, and Acad::eWrongSubentityType should be returned.If an invalid GS marker (or any other data item that turns out to be needed) is passed in, then numPaths should be set to 0, subentPaths should be set to NULL, and Acad::eInvalidInput should be returned.Default implementationImmediately returns Adesk::eNotApplicable.'''
    ...
    def getTransformedCopy (self, matrix3d: PyGe.Matrix3d)-> PyDb.Entity :
      '''Function usageThis function creates a clone of the entity, applies the xform transformation matrix to the clone, and then returns with pEnt pointing to the transformed clone.Returns Acad::eOk if successful.If xform is a non-uniform scaling matrix or non-orthogonal then Acad::eCannotScaleNonUniformly or Acad::eNotImplemented is returned.WarningFor AutoCAD built-in complex entities such as polylines, this function produces a shallow clone of the header entity only, which also owns the original set of "owned" entities (such as vertices for a polyline) which are then transformed by the xform matrix. This results in a corrupt drawing (two header entities owning the same set of "owned" entities) as well as transforming the original set of "owned" entities instead of a copied set.Function implementation in derived classesThe default AcDbEntity implementation of this function should be adequate for most derived entity types. However, derived entity classes that wish to support non-uniform scaling or non-orthogonal transformations will need to override this method with their own implementation.This function must create a copy of the entity (using memory that has been dynamically allocated via the C++ new operator), apply the transformation matrix xform to the copy and then return with pEnt pointing to the transformed copy.Determining what constitutes a valid transformation matrix and whether to do a shallow clone (that is, the entity's clone() method), a deepclone (if the entity owns other objects), or no clone at all (that is, make this function a no-op), is up to the implementer.Return values for this function are also up to the implementer, but to be consistent with other existing classes the following is recommended:If the function succeeds, it should return Acad::eOk.If the function is to be a no-op, it should return Acad::eNotImplementedIf non-uniform scaling is not to be supported and a non-uniform scaling matrix is passed in, then either Acad::eCannotScaleNonUniformly or Acad::eNotImplemented should be returned.Default implementationIf the entity is uniformly scaled and orthogonal, AcDbEntity::getTransformedCopy will call the entity's clone() method to create a clone of the entity, then call AcDbEntity::transformBy() on the clone, and then return with pEnt set to point to the transformed clone. If xform is a non-uniformly scaled or a non-orthogonal matrix, then this function will return Acad::eNotImplemented.'''
    ...
    def handOverTo (self, newObject: PyDb.DbObject, keepXData: bool, keepExtDict: bool)-> None :
      '''This function provides the ability to exchange a non-database-resident object (NDBRO) in place of an existing database-resident object (DBRO) while retaining the objectId, handle, and reactor list of the DBRO. An example of this situation is when the BREAK command is used to break a circle into one or two arc segments. AcDbArc is a completely different class from AcDbCircle, so a new AcDbArc object must be substituted in place of the AcDbCircle object that is there now, yet the arc must get the handle and objectId that the circle has.To use the handOverTo() function, the object to be replaced (the AcDbCircle in the example) must be open AcDb::kForWrite. The object's handOverTo() function is called with newObject pointing to a non-database-resident object that replaces it (the AcDbArc in the example).keepXData is set to Adesk::kTrue if the xdata is to be retained or Adesk::kFalse if the xdata is to be thrown out.keepExtDict is set to Adesk::kTrue if the extension dictionary and its contents are to be retained, or set to Adesk::kFalse if the extension dictionary and its contents are to be thrown out.Once returned from this function, the replacement object (the AcDbArc in the example) is open for AcDb::kForWrite and must have its close() member called to commit the change and close out Undo recording. Then it's up to the ObjectARX application to delete the old object (the AcDbCircle in the example) from memory since it's no longer database-resident.Returns Acad::eObjectToBeDeleted if the operation is successful. If newObject is pointing to an object that is already in the database, or the object invoking handOverTo() is not database-resident, then Acad::eIllegalReplacement is returned.'''
    ...
    def hasFields (self)-> bool :
      '''Returns true if the object has one or more PyDb.Field Objects. Otherwise returns false.'''
    ...
    def hasPersistentReactor (self, id: PyDb.ObjectId)-> bool :
      '''This method returns true if objId is the object ID of a reactor attached to this object. Otherwise, it returns false.'''
    ...
    def hasXData (self, appname: str)-> bool :
      '''                             '''
    ...
    def highlight (self, path: PyDb.FullSubentPath = None, highlightAll : bool = False)-> None :
      '''Function usageThis function uses the AcDbFullSubentPathid to determine which subentity in the entity is desired. It then highlights that subentity on screen. If no AcDbFullSubentPath argument is provided, then the entire entity will be highlighted.Typically, the AcDbFullSubentPath object passed in via subId is obtained from the entity's AcDbEntity::getSubentPathsAtGsMarker() method. This guarantees that it is fully and properly filled in.This function uses the entity's getGsMarkersAtSubentPath() method to get the GS markers associated with subId. If that function does not return Acad::eOk, then this function will fail and return whatever ErrorStatus was returned by getGsMarkersAtSubentPath().If this function succeeds, then it returns Acad::eOk.It is not necessary to balance each highlight() function call with a corresponding call to unhighlight(). Calling the unhighlight() function will unhighlight the entity designated by subId regardless of how many times the highlight function has been called on it.WarningIf the entity on which this method is called has its graphics queued for regeneration (that is, changes have been made to the entity but have not yet been reflected on screen), then this method will not cause a highlight to occur. Also, calling this method on an entity that's open for write and whose graphics are queued for regeneration may terminate AutoCAD.To avoid this limitation, before calling highlight(), you should flush the entity's graphics by either calling the entity's draw() method, or calling the AcTransactionManager::flushGraphics() function.Function implementation in derived classesThe AcDbEntity::highlight() implementation does all the work necessary to highlight any subentities that correspond to the subIdFullSubentPath. So, there is no need to override this method unless you wish to do some pre-or post-processing, or you wish to disable the ability to highlight subentities.If this method is overridden and it is supposed to highlight subentities, then the AcDbEntity::highlight() method will need to be invoked at some point within this function in order to do the actual highlighting.Within the AcDbEntity::highlight() method, the getGsMarkersAtSubentPath() method of this entity is called to translate the FullSubentPath into the corresponding GS markers. So, if this function is to succeed, the getGsMarkersAtSubentPath() method needs to be implemented as well.For more information on the subIdAcDbFullSubentPath argument, see the documentation on the getGsMarkersAtSubentPath() or getSubentPathsAtGsMarker() methods.'''
    ...
    def id (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...

    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, thisGsMarker : int, otherGsMarker : int)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane, thisGsMarker : int, otherGsMarker : int)-> list : ...
    def intersectWith (self, *args, **kwargs)-> list :
      '''Overloads:
    - entity: PyDb.Entity, intType : PyDb.Intersect
    - entity: PyDb.Entity, intType : PyDb.Intersect, thisGsMarker : int, otherGsMarker : int
    - entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane
    - entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane, thisGsMarker : int, otherGsMarker : int
    
	-Function usageIt finds the intersections of the entity pointed to by pEnt and all the edges of the bounding box of this entity.The intType is used to determine how to deal with extending the two entities in order to calculate intersections. The possible AcDb::Intersect values are:AcDb::kOnBothOperandsDo not extend either entity. This results in only calculating intersections where the two entitys' geometry actually intersectAcDb::kExtendThisExtend this entity (if necessary) when calculating intersections, but do not extend the pEnt entity.AcDb::kExtendArgExtend the pEnt entity (if necessary) when calculating intersections, but do not extend this entity.AcDb::kExtendBothExtend both the pEnt entity and this entity (if necessary) when calculating intersectionsAny intersection points found are appended to the points array. All points are in WCS coordinates.The thisGsMarker and otherGsMarker arguments are intended to provide this function with information to allow it to localize the search for intersections to be between specific subentities. However, this function is not required to make use of either of these arguments (most, if not all, of the AutoCAD built-in entity classes do not). When calling this function, either or both of these arguments may be 0 in order to indicate that they should be ignored.If this function is successful it returns Acad::eOk. Return values for error conditions are dependent on the implementation of this function in the classes involved.Function implementation in derived classesThis function should do all it can to find all intersection points between the entity it's being called on and the entity pointed to by pEnt. All intersection points found should be appended to the points array. All such points must be in WCS coordinates.When implementing the intersection calculation portion of this function you should take a good look at the AcGe classes to see if they can provide any useful functionality to help in finding intersections with the geometric primitives that make up the entity this function is being called on and the pEnt entity. For example, the AcGeCurve3d class has an isOn() method that will indicate if a supplied point is on the curve and the AcGeCircArc3d class has several intersectWith() methods to find intersections with other AcGe types.If the pEnt entity is a type not recognized by this function, it is quite reasonable to call the pEnt entity's intersectWith() method passing in a pointer to this entity as the "pEnt", and all the other arguments passed into this function (remembering to convert the intType argument If necessary) to see if that entity can determine any intersection points. This is what the AutoCAD built-in classes do.Also, don't forget to take into account the intType value. The intType tells you which, if any, of the two entities should be extended to find "apparent" intersections. It is not required that apparent intersection be supported, but if it is not, then an appropriate ErrorStatus value should be returned to indicate that the call failed.The thisGsMarker and otherGsMarker arguments are provided to allow this function to determine exactly which subentities are involved in the intersection operation (for example, if this function is being called by AutoCAD as part of an intersection Osnap operation these arguments would indicate which subentities are within the osnap pickbox). For these arguments, a value less than or equal to zero indicates that that argument should not be used.If this function completes successfully (even if no intersection points are found), it should return Acad::eOk. Determining what is considered an error and what ErrorStatus return code to use for any such errors are up to the implementer -- there are no conventions in this regard.Default implementationImmediately returns Acad::eNotImplemented.-'''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isAProxy (self)-> int :
      '''Returns Adesk::kTrue if the object is a proxy object or entity. Otherwise returns Adesk::kFalse.'''
    ...
    def isAcDbObjectIdsInFlux (self)-> int :
      '''This function refers to a condition that occurs during deep clone operations. It returns Adesk::kTrue when the cloned objects' IDs have not yet been translated and thus cannot be used in any operations on the objects. This condition normally occurs only during AcEditorReactor::beginDeepCloneXlation, AcDbObject::deepClone, or AcDbObject::wblockClone. Any operations that involve AcDbObjectId references, such as symbol table records, should be postponed until after endDeepClone. AcDbObject::subClose is never called on any objects whose IDs are in flux.'''
    ...
    def isAnnotative (self)-> PyDb.AnnotativeStates :
      '''                             '''
    ...
    def isCancelling (self)-> int :
      '''Returns Adesk::kTrue if the object is currently in the middle of a cancel() call (that is, an open is being canceled and all changes made are being rolled back). Otherwise returns Adesk::kFalse.'''
    ...
    def isClosed (self)-> int :
      '''This function returns Adesk::kTrue if, and only if, the curve is closed; that is, its start point is identical to its end point. Otherwise, it returns Adesk::kFalse.Returns Acad::kFalse in the default implementation.'''
    ...
    def isEraseStatusToggled (self)-> int :
      '''Returns Adesk::kTrue if the object's erase bit has been toggled since it was opened. Otherwise returns Adesk::kFalse.'''
    ...
    def isErased (self)-> int :
      '''Returns Adesk::kTrue if the object is currently erased. Otherwise returns Adesk::kFalse.'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isModified (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called). Otherwise returns Adesk::kFalse.'''
    ...
    def isModifiedGraphics (self)-> int :
      '''Returns Adesk::kTrue if the object is derived from AcDbEntity and has had either an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called), or its recordGraphicsModified() function called with an Adesk::kTrue argument value.Otherwise it returns Adesk::kFalse.'''
    ...
    def isModifiedXData (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called) and has then had its setXData() method called. Otherwise it returns Adesk::kFalse.'''
    ...
    def isNewObject (self)-> int :
      '''Returns Adesk::kTrue if the object has not yet been closed since it was first created. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifyEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForNotify. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifying (self)-> int :
      '''Returns Adesk::kTrue if the object is in the process of sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isPeriodic (self)-> int :
      '''This function returns Adesk::kTrue if, and only if, the curve has an infinite range in both directions and there is a period value T such that there is a point on curve at (u + T) = point on curve (u), for any parameter u. If the curve is not periodic, then Adesk::kFalse is returned.The default implementation returns Adesk::kFalse.'''
    ...
    def isPersistent (self)-> int :
      '''                             '''
    ...
    def isPlanar (self)-> int :
      '''This function returns Adesk::kTrue if and only if there is a plane that contains the entity. Otherwise Adesk::kFalse is returned.'''
    ...
    def isReadEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForRead. Otherwise returns Adesk::kFalse.'''
    ...
    def isReallyClosing (self)-> int :
      '''Returns true if calling close() at this time would really close the object completely. For example, if the object is not in a transaction, and is open for read with only one reader, then Adesk::kTrue would be returned. If, on the other hand, the object is in a transaction, then Adesk::kFalse would be returned.'''
    ...
    def isTransactionResident (self)-> int :
      '''Returns Adesk::kTrue if the object is currently part of a transaction. Otherwise returns Adesk::kFalse.'''
    ...
    def isUndoRecordingDisabled (self)-> bool :
      '''Returns true if undo recording is disabled.'''
    ...
    def isUndoing (self)-> int :
      '''Returns Adesk::kTrue if the object is involved in an Undo operation at this time. Otherwise returns Adesk::kFalse.'''
    ...
    def isWriteEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForWrite and is not currently sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def layer (self)-> str :
      '''This function returns a copy of the name string in the AcDbLayerTableRecord object referenced by the entity.The calling application is responsible for deallocating the memory used by the returned string. The acutDelString() function is recommended.WarningCalling this function before the entity has had its referenced layer object ID set (that is, it's still set to AcDbObjectId::kNull) will terminate AutoCAD. If the referenced layer objectId is AcDbObjectId::kNull when the entity is added to a database, it will be set to the object ID of the database's current default layer.'''
    ...
    def layerId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the AcDbLayerTableRecord referenced by the entity. If the layerId has not been set yet, then AcDbObjectId::kNull is returned.'''
    ...
    def lineWeight (self)-> PyDb.LineWeight :
      '''This function returns the AcDb::LineWeight of the entity.'''
    ...
    def linetype (self)-> str :
      '''This function returns a copy of the name string in the AcDbLinetypeTableRecord object referenced by the entity.The calling application is responsible for deallocating the memory used by the returned string. Either the C++ delete [ ] or the C free() function may be used.Warning Calling this function before the entity has had its referenced linetype object ID set (that is, it's still set to AcDbObjectId::kNull) will terminate AutoCAD. If the referenced linetype objectId is AcDbObjectId::kNull when the entity is added to a database it will be set to the object ID of the database's current default linetype.'''
    ...
    def linetypeId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the AcDbLinetypeTableRecord referenced by the entity. If the linetypeId has not been set yet, then AcDbObjectId::kNull will be returned.'''
    ...
    def linetypeScale (self)-> float :
      '''This function returns the linetype scale factor for the entity.'''
    ...
    def list (self)-> None :
      '''Function usageThis function is intended to be called from AutoCAD whenever the entity is selected during the LIST command. However, it can be called from ObjectARX applications if desired.This function will print entity specific information to the AutoCAD command line.Function implementation in derived classesWhen implementing this function in a derived class, the first thing that should be done in the function is to make a call to assertReadEnabled(). The next thing to do is to call the parent class's list() method to allow the parent class to list it's information (the parent class should in turn call its parent class first and so on up the inheritance chain until AcDbObject is reached. This way all the entity's information will be properly printed out in order). Once the parent class's list function has been called then a series of ads_printf() calls can be used to list whatever information is desired.Default implementationLists out the entity's DXF name, the layer, the space the entity resides in (model or paper), and the entity's handle.'''
    ...
    def material (self)-> str :
      '''Returns the material name.'''
    ...
    def materialId (self)-> PyDb.ObjectId :
      '''Returns the ID of the associated AcDbMaterial object.'''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def objectId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the object. If the object is not yet database-resident, then the returned objectId will be set to AcDbObjectId::kNull.'''
    ...
    def ownerId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the owner of the object. If the object does not yet have an owner, or the ownerId data member has not yet been set using AcDbObject::setOwnerId, then the returned objectId will be set to AcDbObjectId::kNull.Appending the object to a BlockTable record, a symbol table, or a dictionary automatically calls AcDbObject::setOwnerId.'''
    ...
    def plotStyleName (self)-> str :
      '''This function returns a copy of the plotStyleName string of the entity. The caller is responsible for deallocating the returned string.The plotStyleName value is used for DXF group code 390.'''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def receiveShadows (self)-> bool :
      '''Returns a boolean value indicating whether this entity can receive shadows.'''
    ...
    def recordGraphicsModified (self)-> None :
      '''This method sets the entity's state to indicate whether or not the entity should be updated on screen when it is closed. If the entity is set not to update, then any changes made will appear the next time the entity is regenerated.If setModified is false and the entity is currently set to update its graphics on close (which is its default state), then this function sets the entity so that it will not update on screen when it is closed and objectModified notification is sent to all entity type reactors attached to the entity. If setModified is false and the entity is already set not to update its graphics on close, then this function simply returns.If setModified is true, then the entity is set to update on screen when it is closed.'''
    ...
    def releaseExtensionDictionary (self)-> None :
      '''Removes the object's extension dictionary (that is, removes the object as the owner of the dictionary object) if it exists and is empty. Once removed, this function calls the dictionary's erase() method. Any reactors attached to the extension dictionary receive normal notification appropriate to an open for write, erase, close sequence.Returns Acad::eOk if successful.If the dictionary is not empty, then this function fails and returns Acad::eContainerNotEmpty.'''
    ...
    def removeContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def removeField (self, id: str|PyDb.ObjectId)-> None :
      '''Removes the specified field.Returns Acad::eOk if successful. Otherwise, returns an AutoCAD error status.'''
    ...
    def removePersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Removes the persistent reactor specified by objId from the reactor list of the object. The object must be open AcDb::kForWrite to be able to execute this function.Returns Acad::eOk if successful. If the object is currently sending notification and is not open AcDb::kForWrite, then Acad::eWasNotifying is returned.'''
    ...
    def removeReactor (self, reactor: PyDb.EntityReactor)-> None :
      '''                             '''
    ...
    def reverseCurve (self)-> None :
      '''Reverses the parameterization of the curve. The start becomes the end and visa versa.'''
    ...
    def rolloverHit (self, nSubentId: int, nMouseFlags: int, bReset: bool)-> int :
      '''                             '''
    ...
    def setAcDbObjectIdsInFlux (self)-> None :
      '''This function must be called on any newly created objects in AcDbObject::deepClone or AcDbObject::wblockClone. It indicates that reference object IDs are not yet pointing to the correct objects. The references can be translated only when the entire deep clone operation is complete. The flag is cleared at that time.'''
    ...
    def setAnnotative (self, state : PyDb.AnnotativeStates)-> None :
      '''                             '''
    ...
    def setAttributes (self, traits: PyGi.DrawableTraits)-> int :
      '''                             '''
    ...
    def setCastShadows (self, val: bool)-> None :
      '''Sets the property to indicate whether the entity can cast shadows.'''
    ...
    def setColor (self, clr: PyDb.AcCmColor, dosubents : bool=True, db : PyDb.Database='current')-> None :
      '''Function usageThis method sets the entity's color to the color specified by color. If the entity owns subentities and doSubents == Adesk::kTrue, the color change is applied to the subentities as well. Custom classes may override this method.'''
    ...
    def setColorIndex (self, clr: int, dosubents : bool=True)-> None :
      '''Function usageThis method sets the entity's color to the AutoCAD color index color. If the entity owns subentities and doSubents == Adesk::kTrue, then the color index change will be applied to the subentities as well.'''
    ...
    def setDatabaseDefaults (self, db: PyDb.Database = 'current')-> None :
      '''This function sets the entity's:ColorLayerLinetypeLinetype scaleVisibilityPlot style nameLine weightto the default values of the database indicated by pDb: If pDb == NULL, then the current database in the AutoCAD editor is used.'''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...

    @overload
    def setField (self, field: PyDb.Field)-> PyDb.ObjectId : ...
    @overload
    def setField (self, propName: str, field: PyDb.Field)-> PyDb.ObjectId : ...
    def setField (self, *args, **kwargs)-> PyDb.ObjectId :
      '''Overloads:
    - field: PyDb.Field
    - propName: str, field: PyDb.Field
    '''
    ...
    def setFromAcGeCurve (self, curve: PyGe.Curve3d, normal: PyGe.Vector3d = PyGe.Vector3d.kZAxis, tol: PyGe.Tol = 'default')-> None :
      '''This is setFromAcGeCurve, a member of class AcDbCurve.'''
    ...
    def setLayer (self, val: str|PyDb.ObjectId, dosubents : bool=True, allowHiddenLayer : bool=False)-> None :
      '''This method sets entity to reference the AcDbLayerTableRecord identified by the name specified in newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the layer change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.'''
    ...
    def setLineWeight (self, val: PyDb.LineWeight, dosubents : bool=True)-> None :
      '''This method sets the entity to use lineweight. If the entity owns subentities and doSubents == Adesk::kTrue, then the line weight change will be applied to the subentities as well.Returns Acad::eOk if successful.Function implementation in derived classesIf this function is overridden and wishes to set the line weight of the entity, then it must call AcDbEntity::setLineWeight() passing on the lineweight and doSubents arguments.It is also possible for this function's implementation to deal directly with any subentities and pass a doSubents value of Adesk::kFalse to AcDbEntity:: setLineWeight().If the line weight setting operation is successful, then this function should return Acad::eOk. If lineweight is not an acceptable value, then this function should return Acad::eInvalidInput. Any other error return values are up to the implementer.'''
    ...
    def setLinetype (self, val: str|PyDb.ObjectId, dosubents : bool=True)-> None :
      '''Function usageThis method sets the entity to reference the AcDbLinetypeTableRecord with the name specified in newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the linetype change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.'''
    ...
    def setLinetypeScale (self, val: float, dosubents : bool=True)-> None :
      '''This method sets the entity to use newval as its linetype scale factor. newVal must be nonnegative. If the entity owns subentities and doSubents == Adesk::kTrue, then the linetype scale change will be applied to the subentities as well.'''
    ...
    def setMaterial (self, val: str|PyDb.ObjectId, dosubents : bool=True)-> None :
      '''This method sets the material reference to the specified material. The specified name must correspond to an existing AcDbMaterial object.Returns Acad::eOk when successful'''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setOwnerId (self, owner: PyDb.ObjectId)-> None :
      '''Sets the ownerId data member of the object to be objId, thus establishing a "backpointer." This backpointer is used by WBLOCK to be sure all necessary objects are written out.Returns Acad::eOk if successful.'''
    ...

    @overload
    def setPlotStyleName (self, /)-> None : ...
    @overload
    def setPlotStyleName (self, nameType: PyDb.PlotStyleNameType, doSubents: bool)-> None : ...
    @overload
    def setPlotStyleName (self, nameType: PyDb.PlotStyleNameType, newId: PyDb.ObjectId, doSubents: bool)-> None : ...
    def setPlotStyleName (self, *args, **kwargs)-> None :
      '''Overloads:
    - None: Any
    - nameType: PyDb.PlotStyleNameType, doSubents: bool
    - nameType: PyDb.PlotStyleNameType, newId: PyDb.ObjectId, doSubents: bool
    
	-This function searches the PlotStyleName dictionary for an entry with the name that matches newName and if found, sets the entity to use that plotStyleName entry. Because a lookup in the PlotStyleName dictionary is required, the entity must be database-resident for this method to succeed. The names ByLayer and ByBlock are allowed as well as user-defined names.If the entity owns subentities and doSubents == Adesk::kTrue, then the change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.Returns Acad::eOk if successful. If the entity is not database-resident, then Acad::eNoDatabase will be returned. If there is no entry in the PlotStyleName dictionary for newName, then Acad::eKeyNotFound will be returned.The plotStyleName value is used for DXF group code 390.-'''
    ...
    def setPropertiesFrom (self, entity: PyDb.Entity, dosubents : bool=True)-> None :
      '''This method copies theColorLayerLinetypeLinetype scaleVisibilityvalues from the entity pointed to by pEntity into this entity. If the entity owns subentities and doSubents == Adesk::kTrue, then the property changes will be applied to the subentities as well.Returns Acad::eOk if successful.'''
    ...
    def setReceiveShadows (self, val: bool)-> None :
      '''Sets the property indicating whether this entity can receive shadows.'''
    ...
    def setVisibility (self, val: PyDb.Visibility, dosubents : bool=True)-> None :
      '''This method sets the visibility of an entity to the value specified by newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the visibility change will be applied to the subentities as well.'''
    ...
    def setXData (self, xdata: list)-> None :
      '''Each regapp sublist (delimited by a resbuf with restype == 1001 and resval.rstring == a valid regappName string) within the resbuf chain pointed to by xdata, is placed in the xdata area of the object. If any of the regappNames in xdata are already present in the xdata area of the object, then that regappName's existing data on the object is overwritten by that regappName's new data in xdata.All resbufs with restype == 1001 must have valid regappNames for the database the object resides in (that is, the regappNames must be in the APPID table of the database).Only valid xdata group codes (1000--1071) are accepted in the restype fields of the resbufs in xdata.No "-3" group code is necessary, and in fact, is not accepted. So, the first element in the resbuf chain must be a 1001 group code with a resval.rstring set to a regappName that's already registered in the regapp table. To register a regappName, use the acdbRegApp() function.To remove an appName (and its xdata) from an object, just use a resbuf with restype == 1001, resval == and no data resbufs following it (that is, either its rbnext == NULL or the next resbuf is another 1001)This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If this function is overridden, then it should supermessage its parent in order to invoke the built-in mechanism to add the xdata to the object.Returns Acad::eOk if the xdata is successfully added to the object. If there is insufficient space in the xdata area of the object, then Acad::eXdataSizeExceeded is returned. If any of the regappNames in xdata are not in the APPID table, then Acad::eRegappIdNotFound is returned.'''
    ...
    def snoop (self,  filer : PyDb.SnoopDwgFiler)-> None :
      '''                             '''
    ...
    def swapIdWith (self, otherId: PyDb.DbObject, swapXdata: bool, swapExtDict: bool)-> None :
      '''This function swaps objectIds and handles between the object specified by otherId and the object invoking this function. Both objects must currently be database-resident and must reside in the same database. If swapXdata == Adesk::kTrue, then the objects swap extended entity data as well. If swapExtDict == Adesk::kTrue, then the objects swap extension dictionaries also.If the object specified by otherId or the object invoking this function are not database-resident, then Acad::eNoDatabase is returned. If both objects involved are not in the same database, then Acad::eWrongDatabase is returned.'''
    ...
    def transformBy (self, matrix3d: PyGe.Matrix3d)-> None :
      '''Function usageThis function provides a means by which AutoCAD and ObjectARX applications can ask the entity to apply a transformation matrix (xform) to itself.Each entity class must implement this function, so restrictions on what types of transformations are supported are up to the implementer of the entity class. The AutoCAD built-in entity classes for entity types that existed before R13 (that is, all the classes listed in the header file dbents.h such as AcDbCircle, AcDbLine, AcDbArc, AcDb2dPolyline, etc.) require that the transformation matrix represent a uniformly scaling orthogonal transformation (if it is not, then Acad::eCannotScaleNonUniformly will be returned). Other AutoCAD built-in classes have no restrictions.Returns Acad::eOk if successful. Return values for errors are implementation-dependent.Function implementation in derived classesThis function must apply the transformation matrix xform to the entity and change the entity's state to reflect the transformation. It is completely up to the implementer as to how to apply the transformation. It is also up to the implementer to decide what, if any, restrictions will be placed on the type of transformations supported. If any restrictions are desired, then it's up to the implementation of this function to enforce them.If your derived class implements transformBy() without calling the base class, you must call AcDbObject:: xDataTransformBy() or your Xdata will not be transformed.If this function successfully transforms the entity, then it should return Acad::eOk.Return values for error conditions are completely up to the implementer of this function. However, if the error is caused by a non-uniformly scaling or non-orthogonal matrix, then to be consistent with other entities that have this restriction, it is recommended that Acad::eCannotScaleNonUniformly be returned.'''
    ...
    def upgradeFromNotify (self, wasWritable: bool)-> None :
      '''Upgrades the object from being at least open AcDb::kForNotify to being open both AcDb::kForNotify and AcDb::kForWrite. The wasWritable argument is set to Adesk::kTrue if the object was already open for write, otherwise it's set to Adesk::kFalse. The wasWritable value should be saved to be passed into the downgradeToNotify() call later.This function must be followed at some point by a call to downgradeToNotify() with no open() (in any of its forms) or close() calls in between.This method should only be called from within other methods of the same object it is being called from. In other words, this method is intended to be used by an object to change it's own open status so that it can safely modify itself.upgradeFromNotify() and downgradeToNotify() call pairs are not nestable.Returns Acad::eOk if successful. If the object is not currently open AcDb::kForNotify, then Acad::eNotApplicable is returned. If the object is currently in the process of actually sending notification (that is, isNotifying() returns Adesk::kTrue), then Acad::eWasNotifying is returned.'''
    ...
    def upgradeOpen (self)-> None :
      '''If the object is currently open AcDb::kForRead with only one reader, then this function upgrades the object to open AcDb::kForWrite. In the process of changing to open for write, the object is closed, thus triggering any pertinent notification.Returns Acad::eOk if successful. If the object has more than one reader, then the open status is not changed and Adesk::eHadMultipleReaders is returned. If the object is already open AcDb::kForWrite, then Acad::eWasOpenForWrite is returned. If the object is currently sending notification, then the open status is not changed and Acad::eWasNotifying is returned.'''
    ...
    def viewportDraw (self, vpdraw: PyGi.ViewportDraw)-> None :
      '''                             '''
    ...
    def viewportDrawLogicalFlags (self, vpdraw: PyGi.ViewportDraw)-> int :
      '''                             '''
    ...
    def visibility (self)-> PyDb.Visibility :
      '''This method returns the entity's current visibility state, either AcDb::kVisible or AcDb::kInvisible.'''
    ...
    def wblockClone (self, owner: PyRx.RxObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function is almost identical to AcDbObject::deepClone, except that an AcDbWblockCloneFiler is used and ownership is not carried across database boundaries. Subcloning is based on hard owner and hard pointer connections.'''
    ...
    def worldDraw (self, wdraw: PyGi.WorldDraw)-> int :
      '''                             '''
    ...
    def xData (self, appname: str = None)-> list :
      '''Returns a linked list of resbuf structures containing a copy of the xdata for the object. If regappName == NULL is passed in, all xdata is returned, otherwise only the xdata for the specified name is returned. If not all xdata is required, but the xdata for more than one regappName is desired, then multiple calls to this member function must be made--one for each regappName.The caller of this function is responsible for releasing the memory used by the resbuf list that is returned. The most commonly used way to deallocate such a list is via the acutRelRb() function.This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If a failure accessing the xdata occurs, NULL is returned.'''
    ...
    def xDataTransformBy (self, xform: PyGe.Matrix3d)-> None :
      '''This method applies the xform transformation matrix to any XData data types 1011, 1021, 1031, 1012, 1022, 1032, 1013, 1023, 1033, 1041, and 1042 in the object's XData. See the documentation on XData for more information on the way the transformation matrix is applied to the different data types.This method should be called from within the transformBy() method on custom entities so that such entities will transform XData in the same way that the built-in AcDb entities do.Returns Acad::eOk if successful.'''
    ...
    def xmitPropagateModify (self)-> None :
      '''Within an object's close() method is a call to the object's xmitPropagateModify().The AcDbObject::xmitPropagateModify() default implementation is to inform the containing database that the object has been modified, appended to the database, or erased. The database then sends out the appropriate notification to any AcDbDatabaseReactors attached to it.Within AutoCAD, this function is used by complex entities such as polylines to allow the subentities to notify the header that they have been changed. The header can then "propagate" the notification by sending its own notification that the "complex entity" has been modified.The way this works is:The subobject class has it's xmitPropagateModify() class overridden such that it calls it's parent class's xmitPropagateModify() and also calls the owning object's recvPropagateModify().The "root" or "header" class has it's recvPropagateModify() overridden to provide an implementation that triggers "modified" notification to be sent for the "root" or "header" (which effectively represents the whole complex object).The subobject's close() triggers "modified" notification for the subobject and calls the subobject's xmitPropagateModify() function. So, when the subobject's close() is called, its xmitPropagateModify() is called. This then calls the owning object's recvPropagateModify(), which then triggers the owner to send "modified" notification.So, the result is a "modified" notification from both the subentity and the "root" or "header" entity.When overridden, this function should:Call its parent class's xmitPropagateModify() (which ultimately results in the execution of AcDbObject::xmitPropagateModify() to trigger database notification).Call its owner's recvPropagateModify() (passing in its "this" pointer) to "propagate" the notification information to the "root" owner to be sent out.'''
    ...

class CvDbEntity(PyDb.Entity):
    def __init__ (self, id: ObjectId, mode: PyDb.OpenMode=PyDb.OpenMode.kForRead, erased: bool=False)-> None :
      '''                             '''
    ...
    def addContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def addPersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Adds the database-resident object specified by objId to the reactor list of the AcDbObject object.'''
    ...
    def addReactor (self, reactor: PyDb.EntityReactor)-> None :
      '''                             '''
    ...
    def addSubentPaths (self, paths: list[PyDb.FullSubentPath])-> None :
      '''Adds one or more subentities to an entity.The prototype of this method is provided for completeness of the subentity manipulation APIs. AutoCAD will never call this method on a custom object.Returns Acad::eOk if successful. The default implementation returns Acad::eNotAvailable.'''
    ...
    def assertNotifyEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should be used inside of member functions that are only called when the object is open kForNotify. When used, it should be the first function called inside the member function.'''
    ...
    def assertReadEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that access the object's data in a read-only fashion (for example, dxfOutFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is open AcDb::kForRead.If this function is called while the object is not open, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def assertWriteEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that modify the object's data (for example, dxfInFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is indeed open for write (if it is not, then AutoCAD terminates); to trigger an immediate sending of "openedForModify" notification; to set up the notification mechanism so that "modified" and "modifiedGraphics" (if the object is derived from AcDbEntity) are sent at the appropriate times; and to ensure that graphics get updated if the object is derived from AcDbEntity.If this function is called on a database resident object, "openedForModify" will be sent if the object is not newly created, and "modified", and "modifiedGraphics" (if appropriate) notifications will be sent when the object is next closed.If recordModified is false, then the autoUndo argument is ignored, and the undo filer is not initialized, no undo recording will take place, but notifications will be sent.If autoUndo and recordModified are both true, then automatic undo recording will be performed and notifications will be sent.If autoUndo is false and recordModified is true, then there will not be any automatic undo recording, but the undo filer is initialized and the object must manually write out partial Undo records and must implement its applyPartialUndo() method. Notifications will be sent.If this function is called while the object is not open AcDb::kForWrite, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def blockId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the entity's owner, which must be an AcDbBlockTableRecord.If the entity does not have an owner yet, then AcDbObjectId::kNull will be returned.'''
    ...
    def bounds (self, ext: PyDb.Extents)-> bool :
      '''                             '''
    ...
    def cancel (self)-> None :
      '''Terminates the current open operation. All changes made to the object since it was opened are undone, the object is marked as closed, and "cancel" notification is sent.Returns Acad::eOk if successful.'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbEntity :
      '''                             '''
    ...
    def castShadows (self)-> bool :
      '''Returns a boolean value that indicates whether the entity can cast shadows. '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...

    @staticmethod
    def cloneFrom (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbEntity :
      '''                             '''
    ...
    def close (self)-> None :
      '''Closes the object. All changes made to the object since it was opened are committed to the database, the object is marked as pageable, and a "closed" notification (as well as any other appropriate notification such as "modified", "erased", and so on) is sent.Returns Acad::eOk if successful.If the object is not in an AcDbDatabase yet, then Acad::eNoDatabase is returned.If the object is sending notification, then Acad::eCloseWasNotifying is returned.If the subClose() call made within the close() method returns anything other than Acad::eOk, then that ErrorStatus is returned.'''
    ...
    def collisionType (self)-> PyDb.CollisionType :
      '''This function returns the collision detection treatment for this entity. Subclasses may override this method to customize how the class interacts in collision-aware features.'''
    ...
    def color (self)-> PyDb.Color :
      '''This function returns the full true color information for the entity within an instance of AcCmColor.The index value will be in the range 0 to 256. 0 and 256 are special values.0 indicates the entity uses the color of the BlockReference that's displaying it. If the entity is not displayed through a BlockReference (for example, it's directly owned by the model space BlockTableRecord) and its color is 0, then it will display as though its color were 7.256 indicates the entity uses the color specified in the LayerTableRecord it references.'''
    ...
    def colorIndex (self)-> int :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...
    def createExtensionDictionary (self)-> None :
      '''Creates an AcDbDictionary object and sets it up as the extension dictionary for the AcDbObject.Returns Acad::eOk if successful. If an extension dictionary already exists, Acad::eAlreadyInDb is returned.'''
    ...
    def database (self)-> PyDb.Database :
      '''Returns a pointer to the AcDbDatabase object that contains the AcDbObject.'''
    ...
    def deepClone (self, owner: PyDb.DbObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function gives control of deep clone operations to the object. In the default implementation, the object is cloned and appended to the owner object (pOwnerObject). The cloning is performed by an AcDbDeepCloneFiler. A record is also added to the idMap. Then, using the filer, any owned objects are deep cloned, with isPrimary set to Adesk::kFalse.'''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def disableUndoRecording (self, disable: bool)-> None :
      '''Turns off or on the Undo recording for the object. If disable == Adesk::kTrue, then Undo recording is turned off until this function is called with disable == Adesk::kFalse, at which time Undo recording is turned back on.'''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def downgradeOpen (self)-> None :
      '''Downgrades the object from being open AcDb::kForWrite, to being AcDb::kForRead. In the process, all changes made to the object while it was open for write are committed to the database and appropriate notification is sent.'''
    ...
    def downgradeToNotify (self, wasWritable: bool)-> None :
      '''Restores an object from being open both AcDb::kForNotify and AcDb::kForWrite, to being open just AcDb::kForNotify. The wasWritable value that was returned from the matching AcDbObject::upgradeFromNotify() call should be passed into this function to restore the proper open status.This function must have been preceded by a call to upgradeFromNotify().Returns Acad::eOk if successful.'''
    ...
    def draw (self)-> None :
      '''This function queues up the entity's graphics and flushes the graphics queue, forcing the entity and anything else in the queue to be drawn or re-drawn on-screen.Returns Acad::eOk if successful.If the entity is not in a database, then Acad::eNotInDatabase will be returned.If the entity is in a database other than the one currently loaded into the AutoCAD editor, then Acad::eNotCurrentDatabase will be returned.'''
    ...
    def drawableType (self)-> PyGi.GiDrawableType :
      '''                             '''
    ...
    def entityColor (self)-> PyDb.EntityColor :
      '''This function returns the color settings of the entity in an AcCmEntityColor form. Most clients should use the color() function, which returns the heavyweight AcCmColor object. However, if color name information is not required, this function provides faster access to the lightweight AcCmEntityColor data.'''
    ...
    def erase (self, erasing : bool=True)-> None :
      '''Sets the erase bit of the object. If erasing == Adesk::kTrue, then the erase bit is set on. If erasing == Adesk::kFalse, then the erase bit is set off.'''
    ...
    def explode (self)-> list :
      '''Function UsageThis function is primarily intended for AutoCAD to call as part of an explode operation that includes this entity. However, this function can be used by ObjectARX applications to obtain an array of pointers to non-database-resident entity objects that are what the entity considers to be its exploded parts.When calling this function, the entitySet array does not need to be empty. This function will append to it, and pointers to entities that it creates to be used in its place as the "exploded" result.If this function is successful, it will return Acad::eOk. Other return values may vary depending on how it has been implemented.Function Implementation in Derived ClassesThis function should dynamically create (using the new operator) whatever entity objects are appropriate to be used to replace the entity after an explode operation has taken place. Pointers to these entities are then appended to the entitySet array. Once the pointers have been appended, the function should return with a status of Acad::eOk.'''
    ...
    def extensionDictionary (self)-> PyDb.ObjectId :
      '''Returns the objectId of the extension dictionary owned by the object. If the object does not own an extension dictionary, then the returned objectId is set to AcDbObjectId::kNull.'''
    ...
    def getCompoundObjectTransform (self)-> PyGe.Matrix3d :
      '''This function is intended to be overridden by derived classes that are compound objects (in other words, objects that behave like blocks in the display list).A compound object has little or no geometry of its own; instead it relies on nested entities, perhaps the contents of a BlockTableRecord, to represent itself. A compound object must use the same transformation matrix for all of its contained entities. Otherwise selection and osnap will not function correctly. This is the method that the system uses to obtain that matrix from the compound object.This method should only be overridden if you return the kDrawableIsCompoundObject flag from setAttributes. The matrix you should return here is the one that you pass to pushModelTransform before you render your nested objects. You must override this method if you return the compound object flag in setAttributes, even if you don't push a transform for your nested objects. In that case you would return Acad::eOk and the identity transform in xMat.Default implementation: Returns Acad::eNotApplicable and the identity matrix in xMat.'''
    ...
    def getEcs (self)-> PyGe.Matrix3d :
      '''This function is intended to be overridden by derived classes that need to be able to provide access to an object coordinate system for objects of the class. The intent is that this function provide a transformation matrix that can be used to transform vectors or points from the object's object coordinate system (OCS) to the World Coordinate System (WCS).Default implementation: Return the identity matrix (ones along the diagonal, zeros elsewhere) in retVal.We recommend that all data stored in custom classes be stored in WCS coordinates. If this is done, then the object's OCS will be the WCS and the transformation matrix will be the identity matrix. Then this function will not need to be overridden since the identity matrix is this function's default return.'''
    ...
    def getField (self, prop: str='TEXT')-> PyDb.ObjectId :
      '''Gets the field ID. A field can be stored in an object using the property name as the key.Returns Acad::eOk if the object has a field for the specified property. Otherwise, returns an AutoCAD error status.'''
    ...
    def getFieldDictionary (self)-> PyDb.ObjectId :
      '''Returns the field dictionary ID. The field dictionary stores all the fields set in the object as property name-field object pairs. The ID will be null if there is no field in the object.'''
    ...
    def getGeomExtents (self)-> PyDb.Extents :
      '''Unimplemented at the AcDbEntity level, this method is intended to be overridden in derived classes.Derived classes should calculate and return the corner points (in WCS coordinates) of a box (with edges parallel to the WCS X, Y, and Z axes) that encloses the 3D extents of the entity, and return those points as an instance of class AcDbExtents in the "extents" parameter.Default implementation: Immediately returns Acad::eInvalidExtents.'''
    ...
    def getGeomExtents2d (self)-> PyDb.Extents2d :
      '''                             '''
    ...

    @overload
    def getGripPoints (self, /)-> tuple[Any,...] : ...
    @overload
    def getGripPoints (self, curViewUnitSize: float, gripSize: int, curViewDir: PyGe.Vector3d, bitflags: int)-> tuple[Any,...] : ...
    def getGripPoints (self, *args, **kwargs)-> tuple[Any,...] :
      '''Overloads:
    - None: Any
    - curViewUnitSize: float, gripSize: int, curViewDir: PyGe.Vector3d, bitflags: int
    
	-Function usageThis function supports "old style" grips, in applications that existed before the enhancement of grip functionality by the addition of the AcDbGripData class.This function is not intended to be called by ObjectARX applications. However, it is possible to do so (for example, as a pass-through from the getStretchPoints() method).Function implementation in derived classesThis function should append to the gripPoints array any points that are to treated as grip points for the entity.The gripPoints array is passed to all entities involved in the grip operation, so the array may already contain grip points for other entities. Therefore, it is very important to append the new points rather than assigning them to any existing elements in the array.When finished appending all desired grip points, return Acad::eOk. If anything other than Acad::eOk is returned, then grips are not activated for this entity.The osnapModes and geomIds arguments are not currently used.Default implementationImmediately returns Adesk::eNotImplemented.-'''
    ...
    def getHandle (self)-> PyDb.Handle :
      '''Fills in handle with the handle value for the object. If the object is not yet database-resident, then it will not have a handle. Use AcDbHandle::isNull to test for this condition.'''
    ...
    def getPlane (self)-> PyGe.Plane :
      '''If the entity is planar, then the plane containing the entity is returned in plane and flag is set to AcDb::kPlanar.If the entity is nonplanar, but is linear, then plane is set to an arbitrary plane that contains the entity and flag is set to AcDb::kLinear.If the entity is nonplanar and nonlinear, then plane is left unset and flag is set to AcDb::kNonPlanar.Returns Acad::eOk if successful. Other ErrorStatus return values are implementation-dependent.The default implementation is to return Acad::eNotApplicable.'''
    ...
    def getPlotStyleNameId (self)-> PyDb.ObjectId :
      '''Returns with id set to the object ID of the AcDbPlaceHolder object referenced by the entity. The AcDbPlaceHolder object resides in the plot style name dictionary, and its key in the dictionary is the plot style name.Use the AcDbDictionary::nameAt() function on the plot style name dictionary to get the plot style name string that corresponds to the ID obtained by this function.'''
    ...
    def getStretchPoints (self)-> list :
      '''Function usageThis function is not intended to be called by ObjectARX applications. However, it is possible to do so (for example, as a pass-through from the getGripPoints() method).Function implementation in derived classesThis function should append to the stretchPoints array any points that are to treated as stretch points for the entity.Stretch points are used by the stretch command within AutoCAD. Any stretch points that are within the crossing selection window during the stretch command, will be moved by whatever amount the user decides to "stretch" the selected entities. Any stretch points not in the crossing selection window will be left alone. This combination of some stretch points moving while others do not is what "stretches" the entity. If all stretch points are in the crossing window, then the entity is moved instead of stretched.The stretchPoints array is passed to all entities involved in the stretch operation, so the array may already contain stretch points for other entities. Therefore it is very important to append the new points rather than assigning them to any existing elements in the array.When finished appending all desired stretch points, return Acad::eOk. If anything other than Acad::eOk is returned, then this entity's stretch points will be ignored by the stretch operation.Default implementationCalls the AcDbEntity::getGripPoints() method. So, unless the entity needs to have stretch points that are different from the grip points, there is no need to override this method.'''
    ...
    def getSubentPathsAtGsMarker (self, type: PyDb.SubentType, gsMark: int, pickPoint: PyGe.Point3d, viewXform: PyGe.Matrix3d)-> list[PyDb.FullSubentPath] :
      '''Entities use various graphic primitives defined in AcGi to draw themselves. Part of this mechanism is the ability to associate an integer identifier called a graphics system marker (or, GS marker) with each primitive or with groups of primitives. Through the use of certain selection mechanisms, the GS marker for the actual subentity selected on screen can be obtained and, along with some other information passed into this function, can be used to create one or more AcDbFullSubentPath objects, each one representing a subentity and providing a more complete description of the subentity and its environment. These AcDbFullSubentPath objects can be used by several other functions for various purposes such as highlighting or unhighlighting the subentities on screen.Function usageIf the entity (of which the subentity is a part) is directly owned by the model or paper space BlockTableRecords, then leave out numInserts and entAndInsertStack so that their default value will be used.Typically the GS marker is obtained via the use of ads_ssget() followed by ads_ssnamex() (see the ObjectARX Developer's Guide for more information on this).The pickPoint can be obtained from ads_ssnamex() as well (it's the first group 5009 in the returned list).The viewXform can be calculated using the ads_trans() function on the vectors (1,0,0), (0,1,0), and (0,0,1) to translate them from DCS to WCS. The translations of these three vectors (with an extra 0 appended on to the end of each) would be used as the first three rows of the matrix. The last row is not used so it can be left as is. This argument is not used by any of the AutoCAD built-in entities.If the entity is nested inside one or more block definitions, then the numInserts and entAndInsertStack arguments must also be filled in with non-zero or non-null values. If they are not filled in, then this function will fail and return an error status. One way to get the necessary object IDs is to use ads_nentselp() to obtain the list of ads_names of the container objects. This list must then be converted to object IDs and reversed.Upon return, the subentPaths argument will point to a dynamically allocated array of one or more AcDbFullSubentPath objects. The numPaths argument will contain the number of AcDbFullSubentPath objects being returned.The calling application is responsible for deallocating the memory used by the subentPaths array. The C++ delete [ ] should be used.Return values for this function may vary depending on how the function has been implemented (see below).Function implementation in derived classesEntity classes which do not set GS markers probably should not implement this function since the GS marker is the primary (and often the only) means of subentity distinction.When implemented, this function must use the material provided in type, gsMark, pickPoint, viewXform, numInserts, and entAndInsertStack to determine which subentity or subentities meet the criteria in these arguments. Next it must create a dynamically allocated array of AcDbFullSubentPaths (using the C++ new operator) with one element for each subentity determined in the first step. Finally it must fill in each AcDbFullSubentPath object in the array with the information appropriate to the subentity it will represent.If numInserts == 0 and entAndInsertStack == NULL, it's important to check to be sure that the entity's owner is indeed the model or paper space BlockTableRecord. This can be done by using the entity's ownerId() method to obtain the objectId of its owner, and then opening up that object and using its name() method to obtain its name string. If the owner is not the model or paper space BlockTableRecord, and numInserts == 0 or entAndInsertStack == NULL, or both, then the input data is invalid and this function should set numPaths to 0, set subentPaths to NULL and then return the error status Acad::eInvalidInput.Each AcDbFullSubentPath object has two parts, an array of objectIds containing all the container objects, and an embedded AcDbSubentId object which in turn has two elements: an index value and a SubentityType.If the "main" entity (the entity on which this function is being called) is not nested within BlockReferences (that is, numInserts == 0 and entAndInsertStack == NULL), then the objectId array should contain only the objectId of the "main" entity. If the "main" entity is nested in one or more BlockReferences, then the AcDbObjectIdArray is the same as entAndInsertStack, so copying the entAndInsertStack elements into the AcDbObjectIdArray is all that's required.The SubentType data item within the embedded AcDbSubentId should be set the same as type.The index data item within the embedded AcDbSubentId can be any value you wish (it is often simply the GS marker), but if implemented, the following functions must be able to interpret them to determine the corresponding GS marker(s) or subentity (or subentities):getGsMarkersAtSubentPath()subentPtr()The pickPoint and viewXform arguments are provided as extra aids (if necessary) in determining which subentity is involved. For example, some entity types might display differently depending on the display viewpoint. The viewXform transformation matrix can be used in such cases.The viewXform argument provides a transformation matrix to transform from WCS (World Coordinate System) to DCS (display coordinate system).The display coordinate system is oriented such that the positive Z axis is coming out of the display screen towards the user, the positive X axis is horizontally from left to right on screen, and the positive Y axis is vertically upwards on screen.So, if the current viewpoint is at (1,0,0) (the viewer is always looking towards (0,0,0)) then the viewXform matrix would be:0 1 0 00 0 1 01 0 0 00 0 0 1In this matrix the last row and the last column are not used. Notice also that the third row is the DCS Z axis in WCS coordinates (which is the WCS version of the AutoCAD VIEWPOINT system variable).When this function returns, the return code to use is completely up to the implementer, but to be consistent with other existing entity class implementations of this function the following should be used:If the function succeeds, it should return Acad::eOk.If an invalid or unsupported SubentType is passed in, then numPaths should be set to 0, subentPaths should be set to NULL, and Acad::eWrongSubentityType should be returned.If an invalid GS marker (or any other data item that turns out to be needed) is passed in, then numPaths should be set to 0, subentPaths should be set to NULL, and Acad::eInvalidInput should be returned.Default implementationImmediately returns Adesk::eNotApplicable.'''
    ...
    def getTransformedCopy (self, matrix3d: PyGe.Matrix3d)-> PyDb.Entity :
      '''Function usageThis function creates a clone of the entity, applies the xform transformation matrix to the clone, and then returns with pEnt pointing to the transformed clone.Returns Acad::eOk if successful.If xform is a non-uniform scaling matrix or non-orthogonal then Acad::eCannotScaleNonUniformly or Acad::eNotImplemented is returned.WarningFor AutoCAD built-in complex entities such as polylines, this function produces a shallow clone of the header entity only, which also owns the original set of "owned" entities (such as vertices for a polyline) which are then transformed by the xform matrix. This results in a corrupt drawing (two header entities owning the same set of "owned" entities) as well as transforming the original set of "owned" entities instead of a copied set.Function implementation in derived classesThe default AcDbEntity implementation of this function should be adequate for most derived entity types. However, derived entity classes that wish to support non-uniform scaling or non-orthogonal transformations will need to override this method with their own implementation.This function must create a copy of the entity (using memory that has been dynamically allocated via the C++ new operator), apply the transformation matrix xform to the copy and then return with pEnt pointing to the transformed copy.Determining what constitutes a valid transformation matrix and whether to do a shallow clone (that is, the entity's clone() method), a deepclone (if the entity owns other objects), or no clone at all (that is, make this function a no-op), is up to the implementer.Return values for this function are also up to the implementer, but to be consistent with other existing classes the following is recommended:If the function succeeds, it should return Acad::eOk.If the function is to be a no-op, it should return Acad::eNotImplementedIf non-uniform scaling is not to be supported and a non-uniform scaling matrix is passed in, then either Acad::eCannotScaleNonUniformly or Acad::eNotImplemented should be returned.Default implementationIf the entity is uniformly scaled and orthogonal, AcDbEntity::getTransformedCopy will call the entity's clone() method to create a clone of the entity, then call AcDbEntity::transformBy() on the clone, and then return with pEnt set to point to the transformed clone. If xform is a non-uniformly scaled or a non-orthogonal matrix, then this function will return Acad::eNotImplemented.'''
    ...
    def handOverTo (self, newObject: PyDb.DbObject, keepXData: bool, keepExtDict: bool)-> None :
      '''This function provides the ability to exchange a non-database-resident object (NDBRO) in place of an existing database-resident object (DBRO) while retaining the objectId, handle, and reactor list of the DBRO. An example of this situation is when the BREAK command is used to break a circle into one or two arc segments. AcDbArc is a completely different class from AcDbCircle, so a new AcDbArc object must be substituted in place of the AcDbCircle object that is there now, yet the arc must get the handle and objectId that the circle has.To use the handOverTo() function, the object to be replaced (the AcDbCircle in the example) must be open AcDb::kForWrite. The object's handOverTo() function is called with newObject pointing to a non-database-resident object that replaces it (the AcDbArc in the example).keepXData is set to Adesk::kTrue if the xdata is to be retained or Adesk::kFalse if the xdata is to be thrown out.keepExtDict is set to Adesk::kTrue if the extension dictionary and its contents are to be retained, or set to Adesk::kFalse if the extension dictionary and its contents are to be thrown out.Once returned from this function, the replacement object (the AcDbArc in the example) is open for AcDb::kForWrite and must have its close() member called to commit the change and close out Undo recording. Then it's up to the ObjectARX application to delete the old object (the AcDbCircle in the example) from memory since it's no longer database-resident.Returns Acad::eObjectToBeDeleted if the operation is successful. If newObject is pointing to an object that is already in the database, or the object invoking handOverTo() is not database-resident, then Acad::eIllegalReplacement is returned.'''
    ...
    def hasFields (self)-> bool :
      '''Returns true if the object has one or more PyDb.Field Objects. Otherwise returns false.'''
    ...
    def hasPersistentReactor (self, id: PyDb.ObjectId)-> bool :
      '''This method returns true if objId is the object ID of a reactor attached to this object. Otherwise, it returns false.'''
    ...
    def hasXData (self, appname: str)-> bool :
      '''                             '''
    ...
    def highlight (self, path: PyDb.FullSubentPath = None, highlightAll : bool = False)-> None :
      '''Function usageThis function uses the AcDbFullSubentPathid to determine which subentity in the entity is desired. It then highlights that subentity on screen. If no AcDbFullSubentPath argument is provided, then the entire entity will be highlighted.Typically, the AcDbFullSubentPath object passed in via subId is obtained from the entity's AcDbEntity::getSubentPathsAtGsMarker() method. This guarantees that it is fully and properly filled in.This function uses the entity's getGsMarkersAtSubentPath() method to get the GS markers associated with subId. If that function does not return Acad::eOk, then this function will fail and return whatever ErrorStatus was returned by getGsMarkersAtSubentPath().If this function succeeds, then it returns Acad::eOk.It is not necessary to balance each highlight() function call with a corresponding call to unhighlight(). Calling the unhighlight() function will unhighlight the entity designated by subId regardless of how many times the highlight function has been called on it.WarningIf the entity on which this method is called has its graphics queued for regeneration (that is, changes have been made to the entity but have not yet been reflected on screen), then this method will not cause a highlight to occur. Also, calling this method on an entity that's open for write and whose graphics are queued for regeneration may terminate AutoCAD.To avoid this limitation, before calling highlight(), you should flush the entity's graphics by either calling the entity's draw() method, or calling the AcTransactionManager::flushGraphics() function.Function implementation in derived classesThe AcDbEntity::highlight() implementation does all the work necessary to highlight any subentities that correspond to the subIdFullSubentPath. So, there is no need to override this method unless you wish to do some pre-or post-processing, or you wish to disable the ability to highlight subentities.If this method is overridden and it is supposed to highlight subentities, then the AcDbEntity::highlight() method will need to be invoked at some point within this function in order to do the actual highlighting.Within the AcDbEntity::highlight() method, the getGsMarkersAtSubentPath() method of this entity is called to translate the FullSubentPath into the corresponding GS markers. So, if this function is to succeed, the getGsMarkersAtSubentPath() method needs to be implemented as well.For more information on the subIdAcDbFullSubentPath argument, see the documentation on the getGsMarkersAtSubentPath() or getSubentPathsAtGsMarker() methods.'''
    ...
    def id (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...

    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, thisGsMarker : int, otherGsMarker : int)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane, thisGsMarker : int, otherGsMarker : int)-> list : ...
    def intersectWith (self, *args, **kwargs)-> list :
      '''Overloads:
    - entity: PyDb.Entity, intType : PyDb.Intersect
    - entity: PyDb.Entity, intType : PyDb.Intersect, thisGsMarker : int, otherGsMarker : int
    - entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane
    - entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane, thisGsMarker : int, otherGsMarker : int
    
	-Function usageIt finds the intersections of the entity pointed to by pEnt and all the edges of the bounding box of this entity.The intType is used to determine how to deal with extending the two entities in order to calculate intersections. The possible AcDb::Intersect values are:AcDb::kOnBothOperandsDo not extend either entity. This results in only calculating intersections where the two entitys' geometry actually intersectAcDb::kExtendThisExtend this entity (if necessary) when calculating intersections, but do not extend the pEnt entity.AcDb::kExtendArgExtend the pEnt entity (if necessary) when calculating intersections, but do not extend this entity.AcDb::kExtendBothExtend both the pEnt entity and this entity (if necessary) when calculating intersectionsAny intersection points found are appended to the points array. All points are in WCS coordinates.The thisGsMarker and otherGsMarker arguments are intended to provide this function with information to allow it to localize the search for intersections to be between specific subentities. However, this function is not required to make use of either of these arguments (most, if not all, of the AutoCAD built-in entity classes do not). When calling this function, either or both of these arguments may be 0 in order to indicate that they should be ignored.If this function is successful it returns Acad::eOk. Return values for error conditions are dependent on the implementation of this function in the classes involved.Function implementation in derived classesThis function should do all it can to find all intersection points between the entity it's being called on and the entity pointed to by pEnt. All intersection points found should be appended to the points array. All such points must be in WCS coordinates.When implementing the intersection calculation portion of this function you should take a good look at the AcGe classes to see if they can provide any useful functionality to help in finding intersections with the geometric primitives that make up the entity this function is being called on and the pEnt entity. For example, the AcGeCurve3d class has an isOn() method that will indicate if a supplied point is on the curve and the AcGeCircArc3d class has several intersectWith() methods to find intersections with other AcGe types.If the pEnt entity is a type not recognized by this function, it is quite reasonable to call the pEnt entity's intersectWith() method passing in a pointer to this entity as the "pEnt", and all the other arguments passed into this function (remembering to convert the intType argument If necessary) to see if that entity can determine any intersection points. This is what the AutoCAD built-in classes do.Also, don't forget to take into account the intType value. The intType tells you which, if any, of the two entities should be extended to find "apparent" intersections. It is not required that apparent intersection be supported, but if it is not, then an appropriate ErrorStatus value should be returned to indicate that the call failed.The thisGsMarker and otherGsMarker arguments are provided to allow this function to determine exactly which subentities are involved in the intersection operation (for example, if this function is being called by AutoCAD as part of an intersection Osnap operation these arguments would indicate which subentities are within the osnap pickbox). For these arguments, a value less than or equal to zero indicates that that argument should not be used.If this function completes successfully (even if no intersection points are found), it should return Acad::eOk. Determining what is considered an error and what ErrorStatus return code to use for any such errors are up to the implementer -- there are no conventions in this regard.Default implementationImmediately returns Acad::eNotImplemented.-'''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isAProxy (self)-> int :
      '''Returns Adesk::kTrue if the object is a proxy object or entity. Otherwise returns Adesk::kFalse.'''
    ...
    def isAcDbObjectIdsInFlux (self)-> int :
      '''This function refers to a condition that occurs during deep clone operations. It returns Adesk::kTrue when the cloned objects' IDs have not yet been translated and thus cannot be used in any operations on the objects. This condition normally occurs only during AcEditorReactor::beginDeepCloneXlation, AcDbObject::deepClone, or AcDbObject::wblockClone. Any operations that involve AcDbObjectId references, such as symbol table records, should be postponed until after endDeepClone. AcDbObject::subClose is never called on any objects whose IDs are in flux.'''
    ...
    def isAnnotative (self)-> PyDb.AnnotativeStates :
      '''                             '''
    ...
    def isCancelling (self)-> int :
      '''Returns Adesk::kTrue if the object is currently in the middle of a cancel() call (that is, an open is being canceled and all changes made are being rolled back). Otherwise returns Adesk::kFalse.'''
    ...
    def isEraseStatusToggled (self)-> int :
      '''Returns Adesk::kTrue if the object's erase bit has been toggled since it was opened. Otherwise returns Adesk::kFalse.'''
    ...
    def isErased (self)-> int :
      '''Returns Adesk::kTrue if the object is currently erased. Otherwise returns Adesk::kFalse.'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isModified (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called). Otherwise returns Adesk::kFalse.'''
    ...
    def isModifiedGraphics (self)-> int :
      '''Returns Adesk::kTrue if the object is derived from AcDbEntity and has had either an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called), or its recordGraphicsModified() function called with an Adesk::kTrue argument value.Otherwise it returns Adesk::kFalse.'''
    ...
    def isModifiedXData (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called) and has then had its setXData() method called. Otherwise it returns Adesk::kFalse.'''
    ...
    def isNewObject (self)-> int :
      '''Returns Adesk::kTrue if the object has not yet been closed since it was first created. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifyEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForNotify. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifying (self)-> int :
      '''Returns Adesk::kTrue if the object is in the process of sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isPersistent (self)-> int :
      '''                             '''
    ...
    def isPlanar (self)-> int :
      '''This function returns Adesk::kTrue if and only if there is a plane that contains the entity. Otherwise Adesk::kFalse is returned.'''
    ...
    def isReadEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForRead. Otherwise returns Adesk::kFalse.'''
    ...
    def isReallyClosing (self)-> int :
      '''Returns true if calling close() at this time would really close the object completely. For example, if the object is not in a transaction, and is open for read with only one reader, then Adesk::kTrue would be returned. If, on the other hand, the object is in a transaction, then Adesk::kFalse would be returned.'''
    ...
    def isTransactionResident (self)-> int :
      '''Returns Adesk::kTrue if the object is currently part of a transaction. Otherwise returns Adesk::kFalse.'''
    ...
    def isUndoRecordingDisabled (self)-> bool :
      '''Returns true if undo recording is disabled.'''
    ...
    def isUndoing (self)-> int :
      '''Returns Adesk::kTrue if the object is involved in an Undo operation at this time. Otherwise returns Adesk::kFalse.'''
    ...
    def isWriteEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForWrite and is not currently sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def layer (self)-> str :
      '''This function returns a copy of the name string in the AcDbLayerTableRecord object referenced by the entity.The calling application is responsible for deallocating the memory used by the returned string. The acutDelString() function is recommended.WarningCalling this function before the entity has had its referenced layer object ID set (that is, it's still set to AcDbObjectId::kNull) will terminate AutoCAD. If the referenced layer objectId is AcDbObjectId::kNull when the entity is added to a database, it will be set to the object ID of the database's current default layer.'''
    ...
    def layerId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the AcDbLayerTableRecord referenced by the entity. If the layerId has not been set yet, then AcDbObjectId::kNull is returned.'''
    ...
    def lineWeight (self)-> PyDb.LineWeight :
      '''This function returns the AcDb::LineWeight of the entity.'''
    ...
    def linetype (self)-> str :
      '''This function returns a copy of the name string in the AcDbLinetypeTableRecord object referenced by the entity.The calling application is responsible for deallocating the memory used by the returned string. Either the C++ delete [ ] or the C free() function may be used.Warning Calling this function before the entity has had its referenced linetype object ID set (that is, it's still set to AcDbObjectId::kNull) will terminate AutoCAD. If the referenced linetype objectId is AcDbObjectId::kNull when the entity is added to a database it will be set to the object ID of the database's current default linetype.'''
    ...
    def linetypeId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the AcDbLinetypeTableRecord referenced by the entity. If the linetypeId has not been set yet, then AcDbObjectId::kNull will be returned.'''
    ...
    def linetypeScale (self)-> float :
      '''This function returns the linetype scale factor for the entity.'''
    ...
    def list (self)-> None :
      '''Function usageThis function is intended to be called from AutoCAD whenever the entity is selected during the LIST command. However, it can be called from ObjectARX applications if desired.This function will print entity specific information to the AutoCAD command line.Function implementation in derived classesWhen implementing this function in a derived class, the first thing that should be done in the function is to make a call to assertReadEnabled(). The next thing to do is to call the parent class's list() method to allow the parent class to list it's information (the parent class should in turn call its parent class first and so on up the inheritance chain until AcDbObject is reached. This way all the entity's information will be properly printed out in order). Once the parent class's list function has been called then a series of ads_printf() calls can be used to list whatever information is desired.Default implementationLists out the entity's DXF name, the layer, the space the entity resides in (model or paper), and the entity's handle.'''
    ...
    def material (self)-> str :
      '''Returns the material name.'''
    ...
    def materialId (self)-> PyDb.ObjectId :
      '''Returns the ID of the associated AcDbMaterial object.'''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def objectId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the object. If the object is not yet database-resident, then the returned objectId will be set to AcDbObjectId::kNull.'''
    ...
    def ownerId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the owner of the object. If the object does not yet have an owner, or the ownerId data member has not yet been set using AcDbObject::setOwnerId, then the returned objectId will be set to AcDbObjectId::kNull.Appending the object to a BlockTable record, a symbol table, or a dictionary automatically calls AcDbObject::setOwnerId.'''
    ...
    def plotStyleName (self)-> str :
      '''This function returns a copy of the plotStyleName string of the entity. The caller is responsible for deallocating the returned string.The plotStyleName value is used for DXF group code 390.'''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def receiveShadows (self)-> bool :
      '''Returns a boolean value indicating whether this entity can receive shadows.'''
    ...
    def recordGraphicsModified (self)-> None :
      '''This method sets the entity's state to indicate whether or not the entity should be updated on screen when it is closed. If the entity is set not to update, then any changes made will appear the next time the entity is regenerated.If setModified is false and the entity is currently set to update its graphics on close (which is its default state), then this function sets the entity so that it will not update on screen when it is closed and objectModified notification is sent to all entity type reactors attached to the entity. If setModified is false and the entity is already set not to update its graphics on close, then this function simply returns.If setModified is true, then the entity is set to update on screen when it is closed.'''
    ...
    def releaseExtensionDictionary (self)-> None :
      '''Removes the object's extension dictionary (that is, removes the object as the owner of the dictionary object) if it exists and is empty. Once removed, this function calls the dictionary's erase() method. Any reactors attached to the extension dictionary receive normal notification appropriate to an open for write, erase, close sequence.Returns Acad::eOk if successful.If the dictionary is not empty, then this function fails and returns Acad::eContainerNotEmpty.'''
    ...
    def removeContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def removeField (self, id: str|PyDb.ObjectId)-> None :
      '''Removes the specified field.Returns Acad::eOk if successful. Otherwise, returns an AutoCAD error status.'''
    ...
    def removePersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Removes the persistent reactor specified by objId from the reactor list of the object. The object must be open AcDb::kForWrite to be able to execute this function.Returns Acad::eOk if successful. If the object is currently sending notification and is not open AcDb::kForWrite, then Acad::eWasNotifying is returned.'''
    ...
    def removeReactor (self, reactor: PyDb.EntityReactor)-> None :
      '''                             '''
    ...
    def rolloverHit (self, nSubentId: int, nMouseFlags: int, bReset: bool)-> int :
      '''                             '''
    ...
    def setAcDbObjectIdsInFlux (self)-> None :
      '''This function must be called on any newly created objects in AcDbObject::deepClone or AcDbObject::wblockClone. It indicates that reference object IDs are not yet pointing to the correct objects. The references can be translated only when the entire deep clone operation is complete. The flag is cleared at that time.'''
    ...
    def setAnnotative (self, state : PyDb.AnnotativeStates)-> None :
      '''                             '''
    ...
    def setAttributes (self, traits: PyGi.DrawableTraits)-> int :
      '''                             '''
    ...
    def setCastShadows (self, val: bool)-> None :
      '''Sets the property to indicate whether the entity can cast shadows.'''
    ...
    def setColor (self, clr: PyDb.AcCmColor, dosubents : bool=True, db : PyDb.Database='current')-> None :
      '''Function usageThis method sets the entity's color to the color specified by color. If the entity owns subentities and doSubents == Adesk::kTrue, the color change is applied to the subentities as well. Custom classes may override this method.'''
    ...
    def setColorIndex (self, clr: int, dosubents : bool=True)-> None :
      '''Function usageThis method sets the entity's color to the AutoCAD color index color. If the entity owns subentities and doSubents == Adesk::kTrue, then the color index change will be applied to the subentities as well.'''
    ...
    def setDatabaseDefaults (self, db: PyDb.Database = 'current')-> None :
      '''This function sets the entity's:ColorLayerLinetypeLinetype scaleVisibilityPlot style nameLine weightto the default values of the database indicated by pDb: If pDb == NULL, then the current database in the AutoCAD editor is used.'''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...

    @overload
    def setField (self, field: PyDb.Field)-> PyDb.ObjectId : ...
    @overload
    def setField (self, propName: str, field: PyDb.Field)-> PyDb.ObjectId : ...
    def setField (self, *args, **kwargs)-> PyDb.ObjectId :
      '''Overloads:
    - field: PyDb.Field
    - propName: str, field: PyDb.Field
    '''
    ...
    def setLayer (self, val: str|PyDb.ObjectId, dosubents : bool=True, allowHiddenLayer : bool=False)-> None :
      '''This method sets entity to reference the AcDbLayerTableRecord identified by the name specified in newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the layer change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.'''
    ...
    def setLineWeight (self, val: PyDb.LineWeight, dosubents : bool=True)-> None :
      '''This method sets the entity to use lineweight. If the entity owns subentities and doSubents == Adesk::kTrue, then the line weight change will be applied to the subentities as well.Returns Acad::eOk if successful.Function implementation in derived classesIf this function is overridden and wishes to set the line weight of the entity, then it must call AcDbEntity::setLineWeight() passing on the lineweight and doSubents arguments.It is also possible for this function's implementation to deal directly with any subentities and pass a doSubents value of Adesk::kFalse to AcDbEntity:: setLineWeight().If the line weight setting operation is successful, then this function should return Acad::eOk. If lineweight is not an acceptable value, then this function should return Acad::eInvalidInput. Any other error return values are up to the implementer.'''
    ...
    def setLinetype (self, val: str|PyDb.ObjectId, dosubents : bool=True)-> None :
      '''Function usageThis method sets the entity to reference the AcDbLinetypeTableRecord with the name specified in newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the linetype change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.'''
    ...
    def setLinetypeScale (self, val: float, dosubents : bool=True)-> None :
      '''This method sets the entity to use newval as its linetype scale factor. newVal must be nonnegative. If the entity owns subentities and doSubents == Adesk::kTrue, then the linetype scale change will be applied to the subentities as well.'''
    ...
    def setMaterial (self, val: str|PyDb.ObjectId, dosubents : bool=True)-> None :
      '''This method sets the material reference to the specified material. The specified name must correspond to an existing AcDbMaterial object.Returns Acad::eOk when successful'''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setOwnerId (self, owner: PyDb.ObjectId)-> None :
      '''Sets the ownerId data member of the object to be objId, thus establishing a "backpointer." This backpointer is used by WBLOCK to be sure all necessary objects are written out.Returns Acad::eOk if successful.'''
    ...

    @overload
    def setPlotStyleName (self, /)-> None : ...
    @overload
    def setPlotStyleName (self, nameType: PyDb.PlotStyleNameType, doSubents: bool)-> None : ...
    @overload
    def setPlotStyleName (self, nameType: PyDb.PlotStyleNameType, newId: PyDb.ObjectId, doSubents: bool)-> None : ...
    def setPlotStyleName (self, *args, **kwargs)-> None :
      '''Overloads:
    - None: Any
    - nameType: PyDb.PlotStyleNameType, doSubents: bool
    - nameType: PyDb.PlotStyleNameType, newId: PyDb.ObjectId, doSubents: bool
    
	-This function searches the PlotStyleName dictionary for an entry with the name that matches newName and if found, sets the entity to use that plotStyleName entry. Because a lookup in the PlotStyleName dictionary is required, the entity must be database-resident for this method to succeed. The names ByLayer and ByBlock are allowed as well as user-defined names.If the entity owns subentities and doSubents == Adesk::kTrue, then the change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.Returns Acad::eOk if successful. If the entity is not database-resident, then Acad::eNoDatabase will be returned. If there is no entry in the PlotStyleName dictionary for newName, then Acad::eKeyNotFound will be returned.The plotStyleName value is used for DXF group code 390.-'''
    ...
    def setPropertiesFrom (self, entity: PyDb.Entity, dosubents : bool=True)-> None :
      '''This method copies theColorLayerLinetypeLinetype scaleVisibilityvalues from the entity pointed to by pEntity into this entity. If the entity owns subentities and doSubents == Adesk::kTrue, then the property changes will be applied to the subentities as well.Returns Acad::eOk if successful.'''
    ...
    def setReceiveShadows (self, val: bool)-> None :
      '''Sets the property indicating whether this entity can receive shadows.'''
    ...
    def setVisibility (self, val: PyDb.Visibility, dosubents : bool=True)-> None :
      '''This method sets the visibility of an entity to the value specified by newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the visibility change will be applied to the subentities as well.'''
    ...
    def setXData (self, xdata: list)-> None :
      '''Each regapp sublist (delimited by a resbuf with restype == 1001 and resval.rstring == a valid regappName string) within the resbuf chain pointed to by xdata, is placed in the xdata area of the object. If any of the regappNames in xdata are already present in the xdata area of the object, then that regappName's existing data on the object is overwritten by that regappName's new data in xdata.All resbufs with restype == 1001 must have valid regappNames for the database the object resides in (that is, the regappNames must be in the APPID table of the database).Only valid xdata group codes (1000--1071) are accepted in the restype fields of the resbufs in xdata.No "-3" group code is necessary, and in fact, is not accepted. So, the first element in the resbuf chain must be a 1001 group code with a resval.rstring set to a regappName that's already registered in the regapp table. To register a regappName, use the acdbRegApp() function.To remove an appName (and its xdata) from an object, just use a resbuf with restype == 1001, resval == and no data resbufs following it (that is, either its rbnext == NULL or the next resbuf is another 1001)This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If this function is overridden, then it should supermessage its parent in order to invoke the built-in mechanism to add the xdata to the object.Returns Acad::eOk if the xdata is successfully added to the object. If there is insufficient space in the xdata area of the object, then Acad::eXdataSizeExceeded is returned. If any of the regappNames in xdata are not in the APPID table, then Acad::eRegappIdNotFound is returned.'''
    ...
    def snoop (self,  filer : PyDb.SnoopDwgFiler)-> None :
      '''                             '''
    ...
    def swapIdWith (self, otherId: PyDb.DbObject, swapXdata: bool, swapExtDict: bool)-> None :
      '''This function swaps objectIds and handles between the object specified by otherId and the object invoking this function. Both objects must currently be database-resident and must reside in the same database. If swapXdata == Adesk::kTrue, then the objects swap extended entity data as well. If swapExtDict == Adesk::kTrue, then the objects swap extension dictionaries also.If the object specified by otherId or the object invoking this function are not database-resident, then Acad::eNoDatabase is returned. If both objects involved are not in the same database, then Acad::eWrongDatabase is returned.'''
    ...
    def transformBy (self, matrix3d: PyGe.Matrix3d)-> None :
      '''Function usageThis function provides a means by which AutoCAD and ObjectARX applications can ask the entity to apply a transformation matrix (xform) to itself.Each entity class must implement this function, so restrictions on what types of transformations are supported are up to the implementer of the entity class. The AutoCAD built-in entity classes for entity types that existed before R13 (that is, all the classes listed in the header file dbents.h such as AcDbCircle, AcDbLine, AcDbArc, AcDb2dPolyline, etc.) require that the transformation matrix represent a uniformly scaling orthogonal transformation (if it is not, then Acad::eCannotScaleNonUniformly will be returned). Other AutoCAD built-in classes have no restrictions.Returns Acad::eOk if successful. Return values for errors are implementation-dependent.Function implementation in derived classesThis function must apply the transformation matrix xform to the entity and change the entity's state to reflect the transformation. It is completely up to the implementer as to how to apply the transformation. It is also up to the implementer to decide what, if any, restrictions will be placed on the type of transformations supported. If any restrictions are desired, then it's up to the implementation of this function to enforce them.If your derived class implements transformBy() without calling the base class, you must call AcDbObject:: xDataTransformBy() or your Xdata will not be transformed.If this function successfully transforms the entity, then it should return Acad::eOk.Return values for error conditions are completely up to the implementer of this function. However, if the error is caused by a non-uniformly scaling or non-orthogonal matrix, then to be consistent with other entities that have this restriction, it is recommended that Acad::eCannotScaleNonUniformly be returned.'''
    ...
    def upgradeFromNotify (self, wasWritable: bool)-> None :
      '''Upgrades the object from being at least open AcDb::kForNotify to being open both AcDb::kForNotify and AcDb::kForWrite. The wasWritable argument is set to Adesk::kTrue if the object was already open for write, otherwise it's set to Adesk::kFalse. The wasWritable value should be saved to be passed into the downgradeToNotify() call later.This function must be followed at some point by a call to downgradeToNotify() with no open() (in any of its forms) or close() calls in between.This method should only be called from within other methods of the same object it is being called from. In other words, this method is intended to be used by an object to change it's own open status so that it can safely modify itself.upgradeFromNotify() and downgradeToNotify() call pairs are not nestable.Returns Acad::eOk if successful. If the object is not currently open AcDb::kForNotify, then Acad::eNotApplicable is returned. If the object is currently in the process of actually sending notification (that is, isNotifying() returns Adesk::kTrue), then Acad::eWasNotifying is returned.'''
    ...
    def upgradeOpen (self)-> None :
      '''If the object is currently open AcDb::kForRead with only one reader, then this function upgrades the object to open AcDb::kForWrite. In the process of changing to open for write, the object is closed, thus triggering any pertinent notification.Returns Acad::eOk if successful. If the object has more than one reader, then the open status is not changed and Adesk::eHadMultipleReaders is returned. If the object is already open AcDb::kForWrite, then Acad::eWasOpenForWrite is returned. If the object is currently sending notification, then the open status is not changed and Acad::eWasNotifying is returned.'''
    ...
    def viewportDraw (self, vpdraw: PyGi.ViewportDraw)-> None :
      '''                             '''
    ...
    def viewportDrawLogicalFlags (self, vpdraw: PyGi.ViewportDraw)-> int :
      '''                             '''
    ...
    def visibility (self)-> PyDb.Visibility :
      '''This method returns the entity's current visibility state, either AcDb::kVisible or AcDb::kInvisible.'''
    ...
    def wblockClone (self, owner: PyRx.RxObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function is almost identical to AcDbObject::deepClone, except that an AcDbWblockCloneFiler is used and ownership is not carried across database boundaries. Subcloning is based on hard owner and hard pointer connections.'''
    ...
    def worldDraw (self, wdraw: PyGi.WorldDraw)-> int :
      '''                             '''
    ...
    def xData (self, appname: str = None)-> list :
      '''Returns a linked list of resbuf structures containing a copy of the xdata for the object. If regappName == NULL is passed in, all xdata is returned, otherwise only the xdata for the specified name is returned. If not all xdata is required, but the xdata for more than one regappName is desired, then multiple calls to this member function must be made--one for each regappName.The caller of this function is responsible for releasing the memory used by the resbuf list that is returned. The most commonly used way to deallocate such a list is via the acutRelRb() function.This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If a failure accessing the xdata occurs, NULL is returned.'''
    ...
    def xDataTransformBy (self, xform: PyGe.Matrix3d)-> None :
      '''This method applies the xform transformation matrix to any XData data types 1011, 1021, 1031, 1012, 1022, 1032, 1013, 1023, 1033, 1041, and 1042 in the object's XData. See the documentation on XData for more information on the way the transformation matrix is applied to the different data types.This method should be called from within the transformBy() method on custom entities so that such entities will transform XData in the same way that the built-in AcDb entities do.Returns Acad::eOk if successful.'''
    ...
    def xmitPropagateModify (self)-> None :
      '''Within an object's close() method is a call to the object's xmitPropagateModify().The AcDbObject::xmitPropagateModify() default implementation is to inform the containing database that the object has been modified, appended to the database, or erased. The database then sends out the appropriate notification to any AcDbDatabaseReactors attached to it.Within AutoCAD, this function is used by complex entities such as polylines to allow the subentities to notify the header that they have been changed. The header can then "propagate" the notification by sending its own notification that the "complex entity" has been modified.The way this works is:The subobject class has it's xmitPropagateModify() class overridden such that it calls it's parent class's xmitPropagateModify() and also calls the owning object's recvPropagateModify().The "root" or "header" class has it's recvPropagateModify() overridden to provide an implementation that triggers "modified" notification to be sent for the "root" or "header" (which effectively represents the whole complex object).The subobject's close() triggers "modified" notification for the subobject and calls the subobject's xmitPropagateModify() function. So, when the subobject's close() is called, its xmitPropagateModify() is called. This then calls the owning object's recvPropagateModify(), which then triggers the owner to send "modified" notification.So, the result is a "modified" notification from both the subentity and the "root" or "header" entity.When overridden, this function should:Call its parent class's xmitPropagateModify() (which ultimately results in the execution of AcDbObject::xmitPropagateModify() to trigger database notification).Call its owner's recvPropagateModify() (passing in its "this" pointer) to "propagate" the notification information to the "root" owner to be sent out.'''
    ...

class CvDbFileFormatManager(CvDbObjectManager):
    def __getitem__ (self, val : int|str)-> PyDb.ObjectId :
      '''                             '''
    ...
    def __init__ (self, id: ObjectId, mode: PyDb.OpenMode=PyDb.OpenMode.kForRead, erased: bool=False)-> None :
      '''                             '''
    ...
    def addContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def addPersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Adds the database-resident object specified by objId to the reactor list of the AcDbObject object.'''
    ...
    def addReactor (self, reactor: PyDb.DbObjectReactor)-> None :
      '''Adds the transient reactor pointed to by pNewObj to the AcDbObject object's reactor list.'''
    ...
    def allFileFormats (self)-> list :
      '''                             '''
    ...
    def applicableFileFormats (self, val : str)-> list :
      '''                             '''
    ...
    def assertNotifyEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should be used inside of member functions that are only called when the object is open kForNotify. When used, it should be the first function called inside the member function.'''
    ...
    def assertReadEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that access the object's data in a read-only fashion (for example, dxfOutFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is open AcDb::kForRead.If this function is called while the object is not open, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def assertWriteEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that modify the object's data (for example, dxfInFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is indeed open for write (if it is not, then AutoCAD terminates); to trigger an immediate sending of "openedForModify" notification; to set up the notification mechanism so that "modified" and "modifiedGraphics" (if the object is derived from AcDbEntity) are sent at the appropriate times; and to ensure that graphics get updated if the object is derived from AcDbEntity.If this function is called on a database resident object, "openedForModify" will be sent if the object is not newly created, and "modified", and "modifiedGraphics" (if appropriate) notifications will be sent when the object is next closed.If recordModified is false, then the autoUndo argument is ignored, and the undo filer is not initialized, no undo recording will take place, but notifications will be sent.If autoUndo and recordModified are both true, then automatic undo recording will be performed and notifications will be sent.If autoUndo is false and recordModified is true, then there will not be any automatic undo recording, but the undo filer is initialized and the object must manually write out partial Undo records and must implement its applyPartialUndo() method. Notifications will be sent.If this function is called while the object is not open AcDb::kForWrite, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def bounds (self, ext: PyDb.Extents)-> bool :
      '''                             '''
    ...
    def cancel (self)-> None :
      '''Terminates the current open operation. All changes made to the object since it was opened are undone, the object is marked as closed, and "cancel" notification is sent.Returns Acad::eOk if successful.'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbFileFormatManager :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...

    @staticmethod
    def cloneFrom (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbFileFormatManager :
      '''                             '''
    ...
    def close (self)-> None :
      '''Closes the object. All changes made to the object since it was opened are committed to the database, the object is marked as pageable, and a "closed" notification (as well as any other appropriate notification such as "modified", "erased", and so on) is sent.Returns Acad::eOk if successful.If the object is not in an AcDbDatabase yet, then Acad::eNoDatabase is returned.If the object is sending notification, then Acad::eCloseWasNotifying is returned.If the subClose() call made within the close() method returns anything other than Acad::eOk, then that ErrorStatus is returned.'''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...
    def createExtensionDictionary (self)-> None :
      '''Creates an AcDbDictionary object and sets it up as the extension dictionary for the AcDbObject.Returns Acad::eOk if successful. If an extension dictionary already exists, Acad::eAlreadyInDb is returned.'''
    ...
    def database (self)-> PyDb.Database :
      '''Returns a pointer to the AcDbDatabase object that contains the AcDbObject.'''
    ...
    def deepClone (self, owner: PyDb.DbObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function gives control of deep clone operations to the object. In the default implementation, the object is cloned and appended to the owner object (pOwnerObject). The cloning is performed by an AcDbDeepCloneFiler. A record is also added to the idMap. Then, using the filer, any owned objects are deep cloned, with isPrimary set to Adesk::kFalse.'''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def disableUndoRecording (self, disable: bool)-> None :
      '''Turns off or on the Undo recording for the object. If disable == Adesk::kTrue, then Undo recording is turned off until this function is called with disable == Adesk::kFalse, at which time Undo recording is turned back on.'''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def downgradeOpen (self)-> None :
      '''Downgrades the object from being open AcDb::kForWrite, to being AcDb::kForRead. In the process, all changes made to the object while it was open for write are committed to the database and appropriate notification is sent.'''
    ...
    def downgradeToNotify (self, wasWritable: bool)-> None :
      '''Restores an object from being open both AcDb::kForNotify and AcDb::kForWrite, to being open just AcDb::kForNotify. The wasWritable value that was returned from the matching AcDbObject::upgradeFromNotify() call should be passed into this function to restore the proper open status.This function must have been preceded by a call to upgradeFromNotify().Returns Acad::eOk if successful.'''
    ...
    def drawableType (self)-> PyGi.GiDrawableType :
      '''                             '''
    ...
    def elementCount (self)-> int :
      '''                             '''
    ...
    def erase (self, erasing : bool=True)-> None :
      '''Sets the erase bit of the object. If erasing == Adesk::kTrue, then the erase bit is set on. If erasing == Adesk::kFalse, then the erase bit is set off.'''
    ...
    def extensionDictionary (self)-> PyDb.ObjectId :
      '''Returns the objectId of the extension dictionary owned by the object. If the object does not own an extension dictionary, then the returned objectId is set to AcDbObjectId::kNull.'''
    ...
    def getField (self, prop: str='TEXT')-> PyDb.ObjectId :
      '''Gets the field ID. A field can be stored in an object using the property name as the key.Returns Acad::eOk if the object has a field for the specified property. Otherwise, returns an AutoCAD error status.'''
    ...
    def getFieldDictionary (self)-> PyDb.ObjectId :
      '''Returns the field dictionary ID. The field dictionary stores all the fields set in the object as property name-field object pairs. The ID will be null if there is no field in the object.'''
    ...
    def getHandle (self)-> PyDb.Handle :
      '''Fills in handle with the handle value for the object. If the object is not yet database-resident, then it will not have a handle. Use AcDbHandle::isNull to test for this condition.'''
    ...

    @staticmethod
    def getManager (db: PyDb.Database)-> PyDb.ObjectId :
      '''                             '''
    ...
    def handOverTo (self, newObject: PyDb.DbObject, keepXData: bool, keepExtDict: bool)-> None :
      '''This function provides the ability to exchange a non-database-resident object (NDBRO) in place of an existing database-resident object (DBRO) while retaining the objectId, handle, and reactor list of the DBRO. An example of this situation is when the BREAK command is used to break a circle into one or two arc segments. AcDbArc is a completely different class from AcDbCircle, so a new AcDbArc object must be substituted in place of the AcDbCircle object that is there now, yet the arc must get the handle and objectId that the circle has.To use the handOverTo() function, the object to be replaced (the AcDbCircle in the example) must be open AcDb::kForWrite. The object's handOverTo() function is called with newObject pointing to a non-database-resident object that replaces it (the AcDbArc in the example).keepXData is set to Adesk::kTrue if the xdata is to be retained or Adesk::kFalse if the xdata is to be thrown out.keepExtDict is set to Adesk::kTrue if the extension dictionary and its contents are to be retained, or set to Adesk::kFalse if the extension dictionary and its contents are to be thrown out.Once returned from this function, the replacement object (the AcDbArc in the example) is open for AcDb::kForWrite and must have its close() member called to commit the change and close out Undo recording. Then it's up to the ObjectARX application to delete the old object (the AcDbCircle in the example) from memory since it's no longer database-resident.Returns Acad::eObjectToBeDeleted if the operation is successful. If newObject is pointing to an object that is already in the database, or the object invoking handOverTo() is not database-resident, then Acad::eIllegalReplacement is returned.'''
    ...
    def has1 (self, *args, **kwargs)-> bool :
      '''has1( (CvDbObjectManager)arg1, (ObjectId)arg2) -> bool :

    C++ signature :
        bool has1(class PyBrxCvDbObjectManager {lvalue},class PyDbObjectId)'''
    ...
    def has2 (self, id : str|PyDb.ObjectId)-> bool :
      '''                             '''
    ...
    def hasFields (self)-> bool :
      '''Returns true if the object has one or more PyDb.Field Objects. Otherwise returns false.'''
    ...
    def hasPersistentReactor (self, id: PyDb.ObjectId)-> bool :
      '''This method returns true if objId is the object ID of a reactor attached to this object. Otherwise, it returns false.'''
    ...
    def hasXData (self, appname: str)-> bool :
      '''                             '''
    ...
    def id (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def idAt (self, val : int|str)-> PyDb.ObjectId :
      '''                             '''
    ...
    def ids (self)-> list :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isAProxy (self)-> int :
      '''Returns Adesk::kTrue if the object is a proxy object or entity. Otherwise returns Adesk::kFalse.'''
    ...
    def isAcDbObjectIdsInFlux (self)-> int :
      '''This function refers to a condition that occurs during deep clone operations. It returns Adesk::kTrue when the cloned objects' IDs have not yet been translated and thus cannot be used in any operations on the objects. This condition normally occurs only during AcEditorReactor::beginDeepCloneXlation, AcDbObject::deepClone, or AcDbObject::wblockClone. Any operations that involve AcDbObjectId references, such as symbol table records, should be postponed until after endDeepClone. AcDbObject::subClose is never called on any objects whose IDs are in flux.'''
    ...
    def isAnnotative (self)-> PyDb.AnnotativeStates :
      '''                             '''
    ...
    def isCancelling (self)-> int :
      '''Returns Adesk::kTrue if the object is currently in the middle of a cancel() call (that is, an open is being canceled and all changes made are being rolled back). Otherwise returns Adesk::kFalse.'''
    ...
    def isEraseStatusToggled (self)-> int :
      '''Returns Adesk::kTrue if the object's erase bit has been toggled since it was opened. Otherwise returns Adesk::kFalse.'''
    ...
    def isErased (self)-> int :
      '''Returns Adesk::kTrue if the object is currently erased. Otherwise returns Adesk::kFalse.'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isModified (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called). Otherwise returns Adesk::kFalse.'''
    ...
    def isModifiedGraphics (self)-> int :
      '''Returns Adesk::kTrue if the object is derived from AcDbEntity and has had either an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called), or its recordGraphicsModified() function called with an Adesk::kTrue argument value.Otherwise it returns Adesk::kFalse.'''
    ...
    def isModifiedXData (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called) and has then had its setXData() method called. Otherwise it returns Adesk::kFalse.'''
    ...
    def isNewObject (self)-> int :
      '''Returns Adesk::kTrue if the object has not yet been closed since it was first created. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifyEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForNotify. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifying (self)-> int :
      '''Returns Adesk::kTrue if the object is in the process of sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isPersistent (self)-> int :
      '''                             '''
    ...
    def isReadEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForRead. Otherwise returns Adesk::kFalse.'''
    ...
    def isReallyClosing (self)-> int :
      '''Returns true if calling close() at this time would really close the object completely. For example, if the object is not in a transaction, and is open for read with only one reader, then Adesk::kTrue would be returned. If, on the other hand, the object is in a transaction, then Adesk::kFalse would be returned.'''
    ...
    def isTransactionResident (self)-> int :
      '''Returns Adesk::kTrue if the object is currently part of a transaction. Otherwise returns Adesk::kFalse.'''
    ...
    def isUndoRecordingDisabled (self)-> bool :
      '''Returns true if undo recording is disabled.'''
    ...
    def isUndoing (self)-> int :
      '''Returns Adesk::kTrue if the object is involved in an Undo operation at this time. Otherwise returns Adesk::kFalse.'''
    ...
    def isWriteEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForWrite and is not currently sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def nameAt (self, val : int)-> str :
      '''                             '''
    ...
    def objectId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the object. If the object is not yet database-resident, then the returned objectId will be set to AcDbObjectId::kNull.'''
    ...

    @staticmethod
    def openManager (db: PyDb.Database,mode: PyDb.OpenMode)-> PyBrxCv.CvDbFileFormatManager :
      '''                             '''
    ...
    def ownerId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the owner of the object. If the object does not yet have an owner, or the ownerId data member has not yet been set using AcDbObject::setOwnerId, then the returned objectId will be set to AcDbObjectId::kNull.Appending the object to a BlockTable record, a symbol table, or a dictionary automatically calls AcDbObject::setOwnerId.'''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def releaseExtensionDictionary (self)-> None :
      '''Removes the object's extension dictionary (that is, removes the object as the owner of the dictionary object) if it exists and is empty. Once removed, this function calls the dictionary's erase() method. Any reactors attached to the extension dictionary receive normal notification appropriate to an open for write, erase, close sequence.Returns Acad::eOk if successful.If the dictionary is not empty, then this function fails and returns Acad::eContainerNotEmpty.'''
    ...
    def remove1 (self)-> bool :
      '''                             '''
    ...
    def remove2 (self, id : str|PyDb.ObjectId)-> bool :
      '''                             '''
    ...
    def removeContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def removeField (self, id: str|PyDb.ObjectId)-> None :
      '''Removes the specified field.Returns Acad::eOk if successful. Otherwise, returns an AutoCAD error status.'''
    ...
    def removePersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Removes the persistent reactor specified by objId from the reactor list of the object. The object must be open AcDb::kForWrite to be able to execute this function.Returns Acad::eOk if successful. If the object is currently sending notification and is not open AcDb::kForWrite, then Acad::eWasNotifying is returned.'''
    ...
    def removeReactor (self, reactor: PyDb.DbObjectReactor)-> None :
      '''Removes reactor pointed to by pNewObj from the object's reactor list. The object may be open AcDb::kForRead or AcDb::kForWrite when this function is called.'''
    ...
    def rolloverHit (self, nSubentId: int, nMouseFlags: int, bReset: bool)-> int :
      '''                             '''
    ...
    def setAcDbObjectIdsInFlux (self)-> None :
      '''This function must be called on any newly created objects in AcDbObject::deepClone or AcDbObject::wblockClone. It indicates that reference object IDs are not yet pointing to the correct objects. The references can be translated only when the entire deep clone operation is complete. The flag is cleared at that time.'''
    ...
    def setAnnotative (self, state : PyDb.AnnotativeStates)-> None :
      '''                             '''
    ...
    def setAttributes (self, traits: PyGi.DrawableTraits)-> int :
      '''                             '''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...

    @overload
    def setField (self, field: PyDb.Field)-> PyDb.ObjectId : ...
    @overload
    def setField (self, propName: str, field: PyDb.Field)-> PyDb.ObjectId : ...
    def setField (self, *args, **kwargs)-> PyDb.ObjectId :
      '''Overloads:
    - field: PyDb.Field
    - propName: str, field: PyDb.Field
    '''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setOwnerId (self, owner: PyDb.ObjectId)-> None :
      '''Sets the ownerId data member of the object to be objId, thus establishing a "backpointer." This backpointer is used by WBLOCK to be sure all necessary objects are written out.Returns Acad::eOk if successful.'''
    ...
    def setXData (self, xdata: list)-> None :
      '''Each regapp sublist (delimited by a resbuf with restype == 1001 and resval.rstring == a valid regappName string) within the resbuf chain pointed to by xdata, is placed in the xdata area of the object. If any of the regappNames in xdata are already present in the xdata area of the object, then that regappName's existing data on the object is overwritten by that regappName's new data in xdata.All resbufs with restype == 1001 must have valid regappNames for the database the object resides in (that is, the regappNames must be in the APPID table of the database).Only valid xdata group codes (1000--1071) are accepted in the restype fields of the resbufs in xdata.No "-3" group code is necessary, and in fact, is not accepted. So, the first element in the resbuf chain must be a 1001 group code with a resval.rstring set to a regappName that's already registered in the regapp table. To register a regappName, use the acdbRegApp() function.To remove an appName (and its xdata) from an object, just use a resbuf with restype == 1001, resval == and no data resbufs following it (that is, either its rbnext == NULL or the next resbuf is another 1001)This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If this function is overridden, then it should supermessage its parent in order to invoke the built-in mechanism to add the xdata to the object.Returns Acad::eOk if the xdata is successfully added to the object. If there is insufficient space in the xdata area of the object, then Acad::eXdataSizeExceeded is returned. If any of the regappNames in xdata are not in the APPID table, then Acad::eRegappIdNotFound is returned.'''
    ...
    def snoop (self,  filer : PyDb.SnoopDwgFiler)-> None :
      '''                             '''
    ...
    def swapIdWith (self, otherId: PyDb.DbObject, swapXdata: bool, swapExtDict: bool)-> None :
      '''This function swaps objectIds and handles between the object specified by otherId and the object invoking this function. Both objects must currently be database-resident and must reside in the same database. If swapXdata == Adesk::kTrue, then the objects swap extended entity data as well. If swapExtDict == Adesk::kTrue, then the objects swap extension dictionaries also.If the object specified by otherId or the object invoking this function are not database-resident, then Acad::eNoDatabase is returned. If both objects involved are not in the same database, then Acad::eWrongDatabase is returned.'''
    ...
    def upgradeFromNotify (self, wasWritable: bool)-> None :
      '''Upgrades the object from being at least open AcDb::kForNotify to being open both AcDb::kForNotify and AcDb::kForWrite. The wasWritable argument is set to Adesk::kTrue if the object was already open for write, otherwise it's set to Adesk::kFalse. The wasWritable value should be saved to be passed into the downgradeToNotify() call later.This function must be followed at some point by a call to downgradeToNotify() with no open() (in any of its forms) or close() calls in between.This method should only be called from within other methods of the same object it is being called from. In other words, this method is intended to be used by an object to change it's own open status so that it can safely modify itself.upgradeFromNotify() and downgradeToNotify() call pairs are not nestable.Returns Acad::eOk if successful. If the object is not currently open AcDb::kForNotify, then Acad::eNotApplicable is returned. If the object is currently in the process of actually sending notification (that is, isNotifying() returns Adesk::kTrue), then Acad::eWasNotifying is returned.'''
    ...
    def upgradeOpen (self)-> None :
      '''If the object is currently open AcDb::kForRead with only one reader, then this function upgrades the object to open AcDb::kForWrite. In the process of changing to open for write, the object is closed, thus triggering any pertinent notification.Returns Acad::eOk if successful. If the object has more than one reader, then the open status is not changed and Adesk::eHadMultipleReaders is returned. If the object is already open AcDb::kForWrite, then Acad::eWasOpenForWrite is returned. If the object is currently sending notification, then the open status is not changed and Acad::eWasNotifying is returned.'''
    ...
    def viewportDraw (self, vpdraw: PyGi.ViewportDraw)-> None :
      '''                             '''
    ...
    def viewportDrawLogicalFlags (self, vpdraw: PyGi.ViewportDraw)-> int :
      '''                             '''
    ...
    def wblockClone (self, owner: PyRx.RxObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function is almost identical to AcDbObject::deepClone, except that an AcDbWblockCloneFiler is used and ownership is not carried across database boundaries. Subcloning is based on hard owner and hard pointer connections.'''
    ...
    def worldDraw (self, wdraw: PyGi.WorldDraw)-> int :
      '''                             '''
    ...
    def xData (self, appname: str = None)-> list :
      '''Returns a linked list of resbuf structures containing a copy of the xdata for the object. If regappName == NULL is passed in, all xdata is returned, otherwise only the xdata for the specified name is returned. If not all xdata is required, but the xdata for more than one regappName is desired, then multiple calls to this member function must be made--one for each regappName.The caller of this function is responsible for releasing the memory used by the resbuf list that is returned. The most commonly used way to deallocate such a list is via the acutRelRb() function.This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If a failure accessing the xdata occurs, NULL is returned.'''
    ...
    def xDataTransformBy (self, xform: PyGe.Matrix3d)-> None :
      '''This method applies the xform transformation matrix to any XData data types 1011, 1021, 1031, 1012, 1022, 1032, 1013, 1023, 1033, 1041, and 1042 in the object's XData. See the documentation on XData for more information on the way the transformation matrix is applied to the different data types.This method should be called from within the transformBy() method on custom entities so that such entities will transform XData in the same way that the built-in AcDb entities do.Returns Acad::eOk if successful.'''
    ...
    def xmitPropagateModify (self)-> None :
      '''Within an object's close() method is a call to the object's xmitPropagateModify().The AcDbObject::xmitPropagateModify() default implementation is to inform the containing database that the object has been modified, appended to the database, or erased. The database then sends out the appropriate notification to any AcDbDatabaseReactors attached to it.Within AutoCAD, this function is used by complex entities such as polylines to allow the subentities to notify the header that they have been changed. The header can then "propagate" the notification by sending its own notification that the "complex entity" has been modified.The way this works is:The subobject class has it's xmitPropagateModify() class overridden such that it calls it's parent class's xmitPropagateModify() and also calls the owning object's recvPropagateModify().The "root" or "header" class has it's recvPropagateModify() overridden to provide an implementation that triggers "modified" notification to be sent for the "root" or "header" (which effectively represents the whole complex object).The subobject's close() triggers "modified" notification for the subobject and calls the subobject's xmitPropagateModify() function. So, when the subobject's close() is called, its xmitPropagateModify() is called. This then calls the owning object's recvPropagateModify(), which then triggers the owner to send "modified" notification.So, the result is a "modified" notification from both the subentity and the "root" or "header" entity.When overridden, this function should:Call its parent class's xmitPropagateModify() (which ultimately results in the execution of AcDbObject::xmitPropagateModify() to trigger database notification).Call its owner's recvPropagateModify() (passing in its "this" pointer) to "propagate" the notification information to the "root" owner to be sent out.'''
    ...

class CvDbGrading(CvDbEntity):
    def __init__ (self, id: ObjectId, mode: PyDb.OpenMode=PyDb.OpenMode.kForRead, erased: bool=False)-> None :
      '''                             '''
    ...
    def addContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def addPersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Adds the database-resident object specified by objId to the reactor list of the AcDbObject object.'''
    ...
    def addReactor (self, reactor: PyDb.EntityReactor)-> None :
      '''                             '''
    ...
    def addSubentPaths (self, paths: list[PyDb.FullSubentPath])-> None :
      '''Adds one or more subentities to an entity.The prototype of this method is provided for completeness of the subentity manipulation APIs. AutoCAD will never call this method on a custom object.Returns Acad::eOk if successful. The default implementation returns Acad::eNotAvailable.'''
    ...
    def assertNotifyEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should be used inside of member functions that are only called when the object is open kForNotify. When used, it should be the first function called inside the member function.'''
    ...
    def assertReadEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that access the object's data in a read-only fashion (for example, dxfOutFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is open AcDb::kForRead.If this function is called while the object is not open, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def assertWriteEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that modify the object's data (for example, dxfInFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is indeed open for write (if it is not, then AutoCAD terminates); to trigger an immediate sending of "openedForModify" notification; to set up the notification mechanism so that "modified" and "modifiedGraphics" (if the object is derived from AcDbEntity) are sent at the appropriate times; and to ensure that graphics get updated if the object is derived from AcDbEntity.If this function is called on a database resident object, "openedForModify" will be sent if the object is not newly created, and "modified", and "modifiedGraphics" (if appropriate) notifications will be sent when the object is next closed.If recordModified is false, then the autoUndo argument is ignored, and the undo filer is not initialized, no undo recording will take place, but notifications will be sent.If autoUndo and recordModified are both true, then automatic undo recording will be performed and notifications will be sent.If autoUndo is false and recordModified is true, then there will not be any automatic undo recording, but the undo filer is initialized and the object must manually write out partial Undo records and must implement its applyPartialUndo() method. Notifications will be sent.If this function is called while the object is not open AcDb::kForWrite, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def blockId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the entity's owner, which must be an AcDbBlockTableRecord.If the entity does not have an owner yet, then AcDbObjectId::kNull will be returned.'''
    ...
    def bounds (self, ext: PyDb.Extents)-> bool :
      '''                             '''
    ...
    def cancel (self)-> None :
      '''Terminates the current open operation. All changes made to the object since it was opened are undone, the object is marked as closed, and "cancel" notification is sent.Returns Acad::eOk if successful.'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbGrading :
      '''                             '''
    ...
    def castShadows (self)-> bool :
      '''Returns a boolean value that indicates whether the entity can cast shadows. '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...

    @staticmethod
    def cloneFrom (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbGrading :
      '''                             '''
    ...
    def close (self)-> None :
      '''Closes the object. All changes made to the object since it was opened are committed to the database, the object is marked as pageable, and a "closed" notification (as well as any other appropriate notification such as "modified", "erased", and so on) is sent.Returns Acad::eOk if successful.If the object is not in an AcDbDatabase yet, then Acad::eNoDatabase is returned.If the object is sending notification, then Acad::eCloseWasNotifying is returned.If the subClose() call made within the close() method returns anything other than Acad::eOk, then that ErrorStatus is returned.'''
    ...
    def collisionType (self)-> PyDb.CollisionType :
      '''This function returns the collision detection treatment for this entity. Subclasses may override this method to customize how the class interacts in collision-aware features.'''
    ...
    def color (self)-> PyDb.Color :
      '''This function returns the full true color information for the entity within an instance of AcCmColor.The index value will be in the range 0 to 256. 0 and 256 are special values.0 indicates the entity uses the color of the BlockReference that's displaying it. If the entity is not displayed through a BlockReference (for example, it's directly owned by the model space BlockTableRecord) and its color is 0, then it will display as though its color were 7.256 indicates the entity uses the color specified in the LayerTableRecord it references.'''
    ...
    def colorIndex (self)-> int :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...
    def createExtensionDictionary (self)-> None :
      '''Creates an AcDbDictionary object and sets it up as the extension dictionary for the AcDbObject.Returns Acad::eOk if successful. If an extension dictionary already exists, Acad::eAlreadyInDb is returned.'''
    ...
    def database (self)-> PyDb.Database :
      '''Returns a pointer to the AcDbDatabase object that contains the AcDbObject.'''
    ...
    def deepClone (self, owner: PyDb.DbObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function gives control of deep clone operations to the object. In the default implementation, the object is cloned and appended to the owner object (pOwnerObject). The cloning is performed by an AcDbDeepCloneFiler. A record is also added to the idMap. Then, using the filer, any owned objects are deep cloned, with isPrimary set to Adesk::kFalse.'''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def disableUndoRecording (self, disable: bool)-> None :
      '''Turns off or on the Undo recording for the object. If disable == Adesk::kTrue, then Undo recording is turned off until this function is called with disable == Adesk::kFalse, at which time Undo recording is turned back on.'''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def downgradeOpen (self)-> None :
      '''Downgrades the object from being open AcDb::kForWrite, to being AcDb::kForRead. In the process, all changes made to the object while it was open for write are committed to the database and appropriate notification is sent.'''
    ...
    def downgradeToNotify (self, wasWritable: bool)-> None :
      '''Restores an object from being open both AcDb::kForNotify and AcDb::kForWrite, to being open just AcDb::kForNotify. The wasWritable value that was returned from the matching AcDbObject::upgradeFromNotify() call should be passed into this function to restore the proper open status.This function must have been preceded by a call to upgradeFromNotify().Returns Acad::eOk if successful.'''
    ...
    def draw (self)-> None :
      '''This function queues up the entity's graphics and flushes the graphics queue, forcing the entity and anything else in the queue to be drawn or re-drawn on-screen.Returns Acad::eOk if successful.If the entity is not in a database, then Acad::eNotInDatabase will be returned.If the entity is in a database other than the one currently loaded into the AutoCAD editor, then Acad::eNotCurrentDatabase will be returned.'''
    ...
    def drawableType (self)-> PyGi.GiDrawableType :
      '''                             '''
    ...
    def entityColor (self)-> PyDb.EntityColor :
      '''This function returns the color settings of the entity in an AcCmEntityColor form. Most clients should use the color() function, which returns the heavyweight AcCmColor object. However, if color name information is not required, this function provides faster access to the lightweight AcCmEntityColor data.'''
    ...
    def erase (self, erasing : bool=True)-> None :
      '''Sets the erase bit of the object. If erasing == Adesk::kTrue, then the erase bit is set on. If erasing == Adesk::kFalse, then the erase bit is set off.'''
    ...
    def explode (self)-> list :
      '''Function UsageThis function is primarily intended for AutoCAD to call as part of an explode operation that includes this entity. However, this function can be used by ObjectARX applications to obtain an array of pointers to non-database-resident entity objects that are what the entity considers to be its exploded parts.When calling this function, the entitySet array does not need to be empty. This function will append to it, and pointers to entities that it creates to be used in its place as the "exploded" result.If this function is successful, it will return Acad::eOk. Other return values may vary depending on how it has been implemented.Function Implementation in Derived ClassesThis function should dynamically create (using the new operator) whatever entity objects are appropriate to be used to replace the entity after an explode operation has taken place. Pointers to these entities are then appended to the entitySet array. Once the pointers have been appended, the function should return with a status of Acad::eOk.'''
    ...
    def extensionDictionary (self)-> PyDb.ObjectId :
      '''Returns the objectId of the extension dictionary owned by the object. If the object does not own an extension dictionary, then the returned objectId is set to AcDbObjectId::kNull.'''
    ...
    def getCalculationCurve (self)-> PyGe.Curve3d :
      '''                             '''
    ...
    def getCalculationMethod (self)-> PyBrxCv.GradingCalculationMethod :
      '''                             '''
    ...
    def getCompoundObjectTransform (self)-> PyGe.Matrix3d :
      '''This function is intended to be overridden by derived classes that are compound objects (in other words, objects that behave like blocks in the display list).A compound object has little or no geometry of its own; instead it relies on nested entities, perhaps the contents of a BlockTableRecord, to represent itself. A compound object must use the same transformation matrix for all of its contained entities. Otherwise selection and osnap will not function correctly. This is the method that the system uses to obtain that matrix from the compound object.This method should only be overridden if you return the kDrawableIsCompoundObject flag from setAttributes. The matrix you should return here is the one that you pass to pushModelTransform before you render your nested objects. You must override this method if you return the compound object flag in setAttributes, even if you don't push a transform for your nested objects. In that case you would return Acad::eOk and the identity transform in xMat.Default implementation: Returns Acad::eNotApplicable and the identity matrix in xMat.'''
    ...
    def getEcs (self)-> PyGe.Matrix3d :
      '''This function is intended to be overridden by derived classes that need to be able to provide access to an object coordinate system for objects of the class. The intent is that this function provide a transformation matrix that can be used to transform vectors or points from the object's object coordinate system (OCS) to the World Coordinate System (WCS).Default implementation: Return the identity matrix (ones along the diagonal, zeros elsewhere) in retVal.We recommend that all data stored in custom classes be stored in WCS coordinates. If this is done, then the object's OCS will be the WCS and the transformation matrix will be the identity matrix. Then this function will not need to be overridden since the identity matrix is this function's default return.'''
    ...
    def getField (self, prop: str='TEXT')-> PyDb.ObjectId :
      '''Gets the field ID. A field can be stored in an object using the property name as the key.Returns Acad::eOk if the object has a field for the specified property. Otherwise, returns an AutoCAD error status.'''
    ...
    def getFieldDictionary (self)-> PyDb.ObjectId :
      '''Returns the field dictionary ID. The field dictionary stores all the fields set in the object as property name-field object pairs. The ID will be null if there is no field in the object.'''
    ...
    def getGeomExtents (self)-> PyDb.Extents :
      '''Unimplemented at the AcDbEntity level, this method is intended to be overridden in derived classes.Derived classes should calculate and return the corner points (in WCS coordinates) of a box (with edges parallel to the WCS X, Y, and Z axes) that encloses the 3D extents of the entity, and return those points as an instance of class AcDbExtents in the "extents" parameter.Default implementation: Immediately returns Acad::eInvalidExtents.'''
    ...
    def getGeomExtents2d (self)-> PyDb.Extents2d :
      '''                             '''
    ...
    def getGradingVisualStyle (self)-> PyBrxCv.GradingVisualStyle :
      '''                             '''
    ...

    @overload
    def getGripPoints (self, /)-> tuple[Any,...] : ...
    @overload
    def getGripPoints (self, curViewUnitSize: float, gripSize: int, curViewDir: PyGe.Vector3d, bitflags: int)-> tuple[Any,...] : ...
    def getGripPoints (self, *args, **kwargs)-> tuple[Any,...] :
      '''Overloads:
    - None: Any
    - curViewUnitSize: float, gripSize: int, curViewDir: PyGe.Vector3d, bitflags: int
    
	-Function usageThis function supports "old style" grips, in applications that existed before the enhancement of grip functionality by the addition of the AcDbGripData class.This function is not intended to be called by ObjectARX applications. However, it is possible to do so (for example, as a pass-through from the getStretchPoints() method).Function implementation in derived classesThis function should append to the gripPoints array any points that are to treated as grip points for the entity.The gripPoints array is passed to all entities involved in the grip operation, so the array may already contain grip points for other entities. Therefore, it is very important to append the new points rather than assigning them to any existing elements in the array.When finished appending all desired grip points, return Acad::eOk. If anything other than Acad::eOk is returned, then grips are not activated for this entity.The osnapModes and geomIds arguments are not currently used.Default implementationImmediately returns Adesk::eNotImplemented.-'''
    ...
    def getHandle (self)-> PyDb.Handle :
      '''Fills in handle with the handle value for the object. If the object is not yet database-resident, then it will not have a handle. Use AcDbHandle::isNull to test for this condition.'''
    ...
    def getInputEntityId (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def getIsAssociative (self)-> bool :
      '''                             '''
    ...
    def getIsDrawInfill (self)-> bool :
      '''                             '''
    ...
    def getMidOrdinateDist (self)-> float :
      '''                             '''
    ...
    def getPlane (self)-> PyGe.Plane :
      '''If the entity is planar, then the plane containing the entity is returned in plane and flag is set to AcDb::kPlanar.If the entity is nonplanar, but is linear, then plane is set to an arbitrary plane that contains the entity and flag is set to AcDb::kLinear.If the entity is nonplanar and nonlinear, then plane is left unset and flag is set to AcDb::kNonPlanar.Returns Acad::eOk if successful. Other ErrorStatus return values are implementation-dependent.The default implementation is to return Acad::eNotApplicable.'''
    ...
    def getPlotStyleNameId (self)-> PyDb.ObjectId :
      '''Returns with id set to the object ID of the AcDbPlaceHolder object referenced by the entity. The AcDbPlaceHolder object resides in the plot style name dictionary, and its key in the dictionary is the plot style name.Use the AcDbDictionary::nameAt() function on the plot style name dictionary to get the plot style name string that corresponds to the ID obtained by this function.'''
    ...
    def getRegionEnd (self)-> float :
      '''                             '''
    ...
    def getRegionStart (self)-> float :
      '''                             '''
    ...
    def getSegmentMaxAngle (self)-> float :
      '''                             '''
    ...
    def getSegmentMaxLength (self)-> float :
      '''                             '''
    ...
    def getStretchPoints (self)-> list :
      '''Function usageThis function is not intended to be called by ObjectARX applications. However, it is possible to do so (for example, as a pass-through from the getGripPoints() method).Function implementation in derived classesThis function should append to the stretchPoints array any points that are to treated as stretch points for the entity.Stretch points are used by the stretch command within AutoCAD. Any stretch points that are within the crossing selection window during the stretch command, will be moved by whatever amount the user decides to "stretch" the selected entities. Any stretch points not in the crossing selection window will be left alone. This combination of some stretch points moving while others do not is what "stretches" the entity. If all stretch points are in the crossing window, then the entity is moved instead of stretched.The stretchPoints array is passed to all entities involved in the stretch operation, so the array may already contain stretch points for other entities. Therefore it is very important to append the new points rather than assigning them to any existing elements in the array.When finished appending all desired stretch points, return Acad::eOk. If anything other than Acad::eOk is returned, then this entity's stretch points will be ignored by the stretch operation.Default implementationCalls the AcDbEntity::getGripPoints() method. So, unless the entity needs to have stretch points that are different from the grip points, there is no need to override this method.'''
    ...
    def getSubentPathsAtGsMarker (self, type: PyDb.SubentType, gsMark: int, pickPoint: PyGe.Point3d, viewXform: PyGe.Matrix3d)-> list[PyDb.FullSubentPath] :
      '''Entities use various graphic primitives defined in AcGi to draw themselves. Part of this mechanism is the ability to associate an integer identifier called a graphics system marker (or, GS marker) with each primitive or with groups of primitives. Through the use of certain selection mechanisms, the GS marker for the actual subentity selected on screen can be obtained and, along with some other information passed into this function, can be used to create one or more AcDbFullSubentPath objects, each one representing a subentity and providing a more complete description of the subentity and its environment. These AcDbFullSubentPath objects can be used by several other functions for various purposes such as highlighting or unhighlighting the subentities on screen.Function usageIf the entity (of which the subentity is a part) is directly owned by the model or paper space BlockTableRecords, then leave out numInserts and entAndInsertStack so that their default value will be used.Typically the GS marker is obtained via the use of ads_ssget() followed by ads_ssnamex() (see the ObjectARX Developer's Guide for more information on this).The pickPoint can be obtained from ads_ssnamex() as well (it's the first group 5009 in the returned list).The viewXform can be calculated using the ads_trans() function on the vectors (1,0,0), (0,1,0), and (0,0,1) to translate them from DCS to WCS. The translations of these three vectors (with an extra 0 appended on to the end of each) would be used as the first three rows of the matrix. The last row is not used so it can be left as is. This argument is not used by any of the AutoCAD built-in entities.If the entity is nested inside one or more block definitions, then the numInserts and entAndInsertStack arguments must also be filled in with non-zero or non-null values. If they are not filled in, then this function will fail and return an error status. One way to get the necessary object IDs is to use ads_nentselp() to obtain the list of ads_names of the container objects. This list must then be converted to object IDs and reversed.Upon return, the subentPaths argument will point to a dynamically allocated array of one or more AcDbFullSubentPath objects. The numPaths argument will contain the number of AcDbFullSubentPath objects being returned.The calling application is responsible for deallocating the memory used by the subentPaths array. The C++ delete [ ] should be used.Return values for this function may vary depending on how the function has been implemented (see below).Function implementation in derived classesEntity classes which do not set GS markers probably should not implement this function since the GS marker is the primary (and often the only) means of subentity distinction.When implemented, this function must use the material provided in type, gsMark, pickPoint, viewXform, numInserts, and entAndInsertStack to determine which subentity or subentities meet the criteria in these arguments. Next it must create a dynamically allocated array of AcDbFullSubentPaths (using the C++ new operator) with one element for each subentity determined in the first step. Finally it must fill in each AcDbFullSubentPath object in the array with the information appropriate to the subentity it will represent.If numInserts == 0 and entAndInsertStack == NULL, it's important to check to be sure that the entity's owner is indeed the model or paper space BlockTableRecord. This can be done by using the entity's ownerId() method to obtain the objectId of its owner, and then opening up that object and using its name() method to obtain its name string. If the owner is not the model or paper space BlockTableRecord, and numInserts == 0 or entAndInsertStack == NULL, or both, then the input data is invalid and this function should set numPaths to 0, set subentPaths to NULL and then return the error status Acad::eInvalidInput.Each AcDbFullSubentPath object has two parts, an array of objectIds containing all the container objects, and an embedded AcDbSubentId object which in turn has two elements: an index value and a SubentityType.If the "main" entity (the entity on which this function is being called) is not nested within BlockReferences (that is, numInserts == 0 and entAndInsertStack == NULL), then the objectId array should contain only the objectId of the "main" entity. If the "main" entity is nested in one or more BlockReferences, then the AcDbObjectIdArray is the same as entAndInsertStack, so copying the entAndInsertStack elements into the AcDbObjectIdArray is all that's required.The SubentType data item within the embedded AcDbSubentId should be set the same as type.The index data item within the embedded AcDbSubentId can be any value you wish (it is often simply the GS marker), but if implemented, the following functions must be able to interpret them to determine the corresponding GS marker(s) or subentity (or subentities):getGsMarkersAtSubentPath()subentPtr()The pickPoint and viewXform arguments are provided as extra aids (if necessary) in determining which subentity is involved. For example, some entity types might display differently depending on the display viewpoint. The viewXform transformation matrix can be used in such cases.The viewXform argument provides a transformation matrix to transform from WCS (World Coordinate System) to DCS (display coordinate system).The display coordinate system is oriented such that the positive Z axis is coming out of the display screen towards the user, the positive X axis is horizontally from left to right on screen, and the positive Y axis is vertically upwards on screen.So, if the current viewpoint is at (1,0,0) (the viewer is always looking towards (0,0,0)) then the viewXform matrix would be:0 1 0 00 0 1 01 0 0 00 0 0 1In this matrix the last row and the last column are not used. Notice also that the third row is the DCS Z axis in WCS coordinates (which is the WCS version of the AutoCAD VIEWPOINT system variable).When this function returns, the return code to use is completely up to the implementer, but to be consistent with other existing entity class implementations of this function the following should be used:If the function succeeds, it should return Acad::eOk.If an invalid or unsupported SubentType is passed in, then numPaths should be set to 0, subentPaths should be set to NULL, and Acad::eWrongSubentityType should be returned.If an invalid GS marker (or any other data item that turns out to be needed) is passed in, then numPaths should be set to 0, subentPaths should be set to NULL, and Acad::eInvalidInput should be returned.Default implementationImmediately returns Adesk::eNotApplicable.'''
    ...
    def getTransformedCopy (self, matrix3d: PyGe.Matrix3d)-> PyDb.Entity :
      '''Function usageThis function creates a clone of the entity, applies the xform transformation matrix to the clone, and then returns with pEnt pointing to the transformed clone.Returns Acad::eOk if successful.If xform is a non-uniform scaling matrix or non-orthogonal then Acad::eCannotScaleNonUniformly or Acad::eNotImplemented is returned.WarningFor AutoCAD built-in complex entities such as polylines, this function produces a shallow clone of the header entity only, which also owns the original set of "owned" entities (such as vertices for a polyline) which are then transformed by the xform matrix. This results in a corrupt drawing (two header entities owning the same set of "owned" entities) as well as transforming the original set of "owned" entities instead of a copied set.Function implementation in derived classesThe default AcDbEntity implementation of this function should be adequate for most derived entity types. However, derived entity classes that wish to support non-uniform scaling or non-orthogonal transformations will need to override this method with their own implementation.This function must create a copy of the entity (using memory that has been dynamically allocated via the C++ new operator), apply the transformation matrix xform to the copy and then return with pEnt pointing to the transformed copy.Determining what constitutes a valid transformation matrix and whether to do a shallow clone (that is, the entity's clone() method), a deepclone (if the entity owns other objects), or no clone at all (that is, make this function a no-op), is up to the implementer.Return values for this function are also up to the implementer, but to be consistent with other existing classes the following is recommended:If the function succeeds, it should return Acad::eOk.If the function is to be a no-op, it should return Acad::eNotImplementedIf non-uniform scaling is not to be supported and a non-uniform scaling matrix is passed in, then either Acad::eCannotScaleNonUniformly or Acad::eNotImplemented should be returned.Default implementationIf the entity is uniformly scaled and orthogonal, AcDbEntity::getTransformedCopy will call the entity's clone() method to create a clone of the entity, then call AcDbEntity::transformBy() on the clone, and then return with pEnt set to point to the transformed clone. If xform is a non-uniformly scaled or a non-orthogonal matrix, then this function will return Acad::eNotImplemented.'''
    ...
    def handOverTo (self, newObject: PyDb.DbObject, keepXData: bool, keepExtDict: bool)-> None :
      '''This function provides the ability to exchange a non-database-resident object (NDBRO) in place of an existing database-resident object (DBRO) while retaining the objectId, handle, and reactor list of the DBRO. An example of this situation is when the BREAK command is used to break a circle into one or two arc segments. AcDbArc is a completely different class from AcDbCircle, so a new AcDbArc object must be substituted in place of the AcDbCircle object that is there now, yet the arc must get the handle and objectId that the circle has.To use the handOverTo() function, the object to be replaced (the AcDbCircle in the example) must be open AcDb::kForWrite. The object's handOverTo() function is called with newObject pointing to a non-database-resident object that replaces it (the AcDbArc in the example).keepXData is set to Adesk::kTrue if the xdata is to be retained or Adesk::kFalse if the xdata is to be thrown out.keepExtDict is set to Adesk::kTrue if the extension dictionary and its contents are to be retained, or set to Adesk::kFalse if the extension dictionary and its contents are to be thrown out.Once returned from this function, the replacement object (the AcDbArc in the example) is open for AcDb::kForWrite and must have its close() member called to commit the change and close out Undo recording. Then it's up to the ObjectARX application to delete the old object (the AcDbCircle in the example) from memory since it's no longer database-resident.Returns Acad::eObjectToBeDeleted if the operation is successful. If newObject is pointing to an object that is already in the database, or the object invoking handOverTo() is not database-resident, then Acad::eIllegalReplacement is returned.'''
    ...
    def hasFields (self)-> bool :
      '''Returns true if the object has one or more PyDb.Field Objects. Otherwise returns false.'''
    ...
    def hasPersistentReactor (self, id: PyDb.ObjectId)-> bool :
      '''This method returns true if objId is the object ID of a reactor attached to this object. Otherwise, it returns false.'''
    ...
    def hasXData (self, appname: str)-> bool :
      '''                             '''
    ...
    def highlight (self, path: PyDb.FullSubentPath = None, highlightAll : bool = False)-> None :
      '''Function usageThis function uses the AcDbFullSubentPathid to determine which subentity in the entity is desired. It then highlights that subentity on screen. If no AcDbFullSubentPath argument is provided, then the entire entity will be highlighted.Typically, the AcDbFullSubentPath object passed in via subId is obtained from the entity's AcDbEntity::getSubentPathsAtGsMarker() method. This guarantees that it is fully and properly filled in.This function uses the entity's getGsMarkersAtSubentPath() method to get the GS markers associated with subId. If that function does not return Acad::eOk, then this function will fail and return whatever ErrorStatus was returned by getGsMarkersAtSubentPath().If this function succeeds, then it returns Acad::eOk.It is not necessary to balance each highlight() function call with a corresponding call to unhighlight(). Calling the unhighlight() function will unhighlight the entity designated by subId regardless of how many times the highlight function has been called on it.WarningIf the entity on which this method is called has its graphics queued for regeneration (that is, changes have been made to the entity but have not yet been reflected on screen), then this method will not cause a highlight to occur. Also, calling this method on an entity that's open for write and whose graphics are queued for regeneration may terminate AutoCAD.To avoid this limitation, before calling highlight(), you should flush the entity's graphics by either calling the entity's draw() method, or calling the AcTransactionManager::flushGraphics() function.Function implementation in derived classesThe AcDbEntity::highlight() implementation does all the work necessary to highlight any subentities that correspond to the subIdFullSubentPath. So, there is no need to override this method unless you wish to do some pre-or post-processing, or you wish to disable the ability to highlight subentities.If this method is overridden and it is supposed to highlight subentities, then the AcDbEntity::highlight() method will need to be invoked at some point within this function in order to do the actual highlighting.Within the AcDbEntity::highlight() method, the getGsMarkersAtSubentPath() method of this entity is called to translate the FullSubentPath into the corresponding GS markers. So, if this function is to succeed, the getGsMarkersAtSubentPath() method needs to be implemented as well.For more information on the subIdAcDbFullSubentPath argument, see the documentation on the getGsMarkersAtSubentPath() or getSubentPathsAtGsMarker() methods.'''
    ...
    def id (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...

    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, thisGsMarker : int, otherGsMarker : int)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane, thisGsMarker : int, otherGsMarker : int)-> list : ...
    def intersectWith (self, *args, **kwargs)-> list :
      '''Overloads:
    - entity: PyDb.Entity, intType : PyDb.Intersect
    - entity: PyDb.Entity, intType : PyDb.Intersect, thisGsMarker : int, otherGsMarker : int
    - entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane
    - entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane, thisGsMarker : int, otherGsMarker : int
    
	-Function usageIt finds the intersections of the entity pointed to by pEnt and all the edges of the bounding box of this entity.The intType is used to determine how to deal with extending the two entities in order to calculate intersections. The possible AcDb::Intersect values are:AcDb::kOnBothOperandsDo not extend either entity. This results in only calculating intersections where the two entitys' geometry actually intersectAcDb::kExtendThisExtend this entity (if necessary) when calculating intersections, but do not extend the pEnt entity.AcDb::kExtendArgExtend the pEnt entity (if necessary) when calculating intersections, but do not extend this entity.AcDb::kExtendBothExtend both the pEnt entity and this entity (if necessary) when calculating intersectionsAny intersection points found are appended to the points array. All points are in WCS coordinates.The thisGsMarker and otherGsMarker arguments are intended to provide this function with information to allow it to localize the search for intersections to be between specific subentities. However, this function is not required to make use of either of these arguments (most, if not all, of the AutoCAD built-in entity classes do not). When calling this function, either or both of these arguments may be 0 in order to indicate that they should be ignored.If this function is successful it returns Acad::eOk. Return values for error conditions are dependent on the implementation of this function in the classes involved.Function implementation in derived classesThis function should do all it can to find all intersection points between the entity it's being called on and the entity pointed to by pEnt. All intersection points found should be appended to the points array. All such points must be in WCS coordinates.When implementing the intersection calculation portion of this function you should take a good look at the AcGe classes to see if they can provide any useful functionality to help in finding intersections with the geometric primitives that make up the entity this function is being called on and the pEnt entity. For example, the AcGeCurve3d class has an isOn() method that will indicate if a supplied point is on the curve and the AcGeCircArc3d class has several intersectWith() methods to find intersections with other AcGe types.If the pEnt entity is a type not recognized by this function, it is quite reasonable to call the pEnt entity's intersectWith() method passing in a pointer to this entity as the "pEnt", and all the other arguments passed into this function (remembering to convert the intType argument If necessary) to see if that entity can determine any intersection points. This is what the AutoCAD built-in classes do.Also, don't forget to take into account the intType value. The intType tells you which, if any, of the two entities should be extended to find "apparent" intersections. It is not required that apparent intersection be supported, but if it is not, then an appropriate ErrorStatus value should be returned to indicate that the call failed.The thisGsMarker and otherGsMarker arguments are provided to allow this function to determine exactly which subentities are involved in the intersection operation (for example, if this function is being called by AutoCAD as part of an intersection Osnap operation these arguments would indicate which subentities are within the osnap pickbox). For these arguments, a value less than or equal to zero indicates that that argument should not be used.If this function completes successfully (even if no intersection points are found), it should return Acad::eOk. Determining what is considered an error and what ErrorStatus return code to use for any such errors are up to the implementer -- there are no conventions in this regard.Default implementationImmediately returns Acad::eNotImplemented.-'''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isAProxy (self)-> int :
      '''Returns Adesk::kTrue if the object is a proxy object or entity. Otherwise returns Adesk::kFalse.'''
    ...
    def isAcDbObjectIdsInFlux (self)-> int :
      '''This function refers to a condition that occurs during deep clone operations. It returns Adesk::kTrue when the cloned objects' IDs have not yet been translated and thus cannot be used in any operations on the objects. This condition normally occurs only during AcEditorReactor::beginDeepCloneXlation, AcDbObject::deepClone, or AcDbObject::wblockClone. Any operations that involve AcDbObjectId references, such as symbol table records, should be postponed until after endDeepClone. AcDbObject::subClose is never called on any objects whose IDs are in flux.'''
    ...
    def isAnnotative (self)-> PyDb.AnnotativeStates :
      '''                             '''
    ...
    def isCancelling (self)-> int :
      '''Returns Adesk::kTrue if the object is currently in the middle of a cancel() call (that is, an open is being canceled and all changes made are being rolled back). Otherwise returns Adesk::kFalse.'''
    ...
    def isClosed (self)-> bool :
      '''                             '''
    ...
    def isEraseStatusToggled (self)-> int :
      '''Returns Adesk::kTrue if the object's erase bit has been toggled since it was opened. Otherwise returns Adesk::kFalse.'''
    ...
    def isErased (self)-> int :
      '''Returns Adesk::kTrue if the object is currently erased. Otherwise returns Adesk::kFalse.'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isModified (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called). Otherwise returns Adesk::kFalse.'''
    ...
    def isModifiedGraphics (self)-> int :
      '''Returns Adesk::kTrue if the object is derived from AcDbEntity and has had either an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called), or its recordGraphicsModified() function called with an Adesk::kTrue argument value.Otherwise it returns Adesk::kFalse.'''
    ...
    def isModifiedXData (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called) and has then had its setXData() method called. Otherwise it returns Adesk::kFalse.'''
    ...
    def isNewObject (self)-> int :
      '''Returns Adesk::kTrue if the object has not yet been closed since it was first created. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifyEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForNotify. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifying (self)-> int :
      '''Returns Adesk::kTrue if the object is in the process of sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isPersistent (self)-> int :
      '''                             '''
    ...
    def isPlanar (self)-> int :
      '''This function returns Adesk::kTrue if and only if there is a plane that contains the entity. Otherwise Adesk::kFalse is returned.'''
    ...
    def isReadEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForRead. Otherwise returns Adesk::kFalse.'''
    ...
    def isReallyClosing (self)-> int :
      '''Returns true if calling close() at this time would really close the object completely. For example, if the object is not in a transaction, and is open for read with only one reader, then Adesk::kTrue would be returned. If, on the other hand, the object is in a transaction, then Adesk::kFalse would be returned.'''
    ...
    def isTransactionResident (self)-> int :
      '''Returns Adesk::kTrue if the object is currently part of a transaction. Otherwise returns Adesk::kFalse.'''
    ...
    def isUndoRecordingDisabled (self)-> bool :
      '''Returns true if undo recording is disabled.'''
    ...
    def isUndoing (self)-> int :
      '''Returns Adesk::kTrue if the object is involved in an Undo operation at this time. Otherwise returns Adesk::kFalse.'''
    ...
    def isWriteEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForWrite and is not currently sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def layer (self)-> str :
      '''This function returns a copy of the name string in the AcDbLayerTableRecord object referenced by the entity.The calling application is responsible for deallocating the memory used by the returned string. The acutDelString() function is recommended.WarningCalling this function before the entity has had its referenced layer object ID set (that is, it's still set to AcDbObjectId::kNull) will terminate AutoCAD. If the referenced layer objectId is AcDbObjectId::kNull when the entity is added to a database, it will be set to the object ID of the database's current default layer.'''
    ...
    def layerId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the AcDbLayerTableRecord referenced by the entity. If the layerId has not been set yet, then AcDbObjectId::kNull is returned.'''
    ...
    def lineWeight (self)-> PyDb.LineWeight :
      '''This function returns the AcDb::LineWeight of the entity.'''
    ...
    def linetype (self)-> str :
      '''This function returns a copy of the name string in the AcDbLinetypeTableRecord object referenced by the entity.The calling application is responsible for deallocating the memory used by the returned string. Either the C++ delete [ ] or the C free() function may be used.Warning Calling this function before the entity has had its referenced linetype object ID set (that is, it's still set to AcDbObjectId::kNull) will terminate AutoCAD. If the referenced linetype objectId is AcDbObjectId::kNull when the entity is added to a database it will be set to the object ID of the database's current default linetype.'''
    ...
    def linetypeId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the AcDbLinetypeTableRecord referenced by the entity. If the linetypeId has not been set yet, then AcDbObjectId::kNull will be returned.'''
    ...
    def linetypeScale (self)-> float :
      '''This function returns the linetype scale factor for the entity.'''
    ...
    def list (self)-> None :
      '''Function usageThis function is intended to be called from AutoCAD whenever the entity is selected during the LIST command. However, it can be called from ObjectARX applications if desired.This function will print entity specific information to the AutoCAD command line.Function implementation in derived classesWhen implementing this function in a derived class, the first thing that should be done in the function is to make a call to assertReadEnabled(). The next thing to do is to call the parent class's list() method to allow the parent class to list it's information (the parent class should in turn call its parent class first and so on up the inheritance chain until AcDbObject is reached. This way all the entity's information will be properly printed out in order). Once the parent class's list function has been called then a series of ads_printf() calls can be used to list whatever information is desired.Default implementationLists out the entity's DXF name, the layer, the space the entity resides in (model or paper), and the entity's handle.'''
    ...
    def material (self)-> str :
      '''Returns the material name.'''
    ...
    def materialId (self)-> PyDb.ObjectId :
      '''Returns the ID of the associated AcDbMaterial object.'''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def objectId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the object. If the object is not yet database-resident, then the returned objectId will be set to AcDbObjectId::kNull.'''
    ...
    def ownerId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the owner of the object. If the object does not yet have an owner, or the ownerId data member has not yet been set using AcDbObject::setOwnerId, then the returned objectId will be set to AcDbObjectId::kNull.Appending the object to a BlockTable record, a symbol table, or a dictionary automatically calls AcDbObject::setOwnerId.'''
    ...
    def plotStyleName (self)-> str :
      '''This function returns a copy of the plotStyleName string of the entity. The caller is responsible for deallocating the returned string.The plotStyleName value is used for DXF group code 390.'''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def receiveShadows (self)-> bool :
      '''Returns a boolean value indicating whether this entity can receive shadows.'''
    ...
    def recordGraphicsModified (self)-> None :
      '''This method sets the entity's state to indicate whether or not the entity should be updated on screen when it is closed. If the entity is set not to update, then any changes made will appear the next time the entity is regenerated.If setModified is false and the entity is currently set to update its graphics on close (which is its default state), then this function sets the entity so that it will not update on screen when it is closed and objectModified notification is sent to all entity type reactors attached to the entity. If setModified is false and the entity is already set not to update its graphics on close, then this function simply returns.If setModified is true, then the entity is set to update on screen when it is closed.'''
    ...
    def releaseExtensionDictionary (self)-> None :
      '''Removes the object's extension dictionary (that is, removes the object as the owner of the dictionary object) if it exists and is empty. Once removed, this function calls the dictionary's erase() method. Any reactors attached to the extension dictionary receive normal notification appropriate to an open for write, erase, close sequence.Returns Acad::eOk if successful.If the dictionary is not empty, then this function fails and returns Acad::eContainerNotEmpty.'''
    ...
    def removeContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def removeField (self, id: str|PyDb.ObjectId)-> None :
      '''Removes the specified field.Returns Acad::eOk if successful. Otherwise, returns an AutoCAD error status.'''
    ...
    def removePersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Removes the persistent reactor specified by objId from the reactor list of the object. The object must be open AcDb::kForWrite to be able to execute this function.Returns Acad::eOk if successful. If the object is currently sending notification and is not open AcDb::kForWrite, then Acad::eWasNotifying is returned.'''
    ...
    def removeReactor (self, reactor: PyDb.EntityReactor)-> None :
      '''                             '''
    ...
    def resultDayLight (self)-> list :
      '''                             '''
    ...
    def rolloverHit (self, nSubentId: int, nMouseFlags: int, bReset: bool)-> int :
      '''                             '''
    ...
    def rule (self)-> PyBrxCv.CvGradingRule :
      '''                             '''
    ...
    def setAcDbObjectIdsInFlux (self)-> None :
      '''This function must be called on any newly created objects in AcDbObject::deepClone or AcDbObject::wblockClone. It indicates that reference object IDs are not yet pointing to the correct objects. The references can be translated only when the entire deep clone operation is complete. The flag is cleared at that time.'''
    ...
    def setAnnotative (self, state : PyDb.AnnotativeStates)-> None :
      '''                             '''
    ...
    def setAttributes (self, traits: PyGi.DrawableTraits)-> int :
      '''                             '''
    ...
    def setCalculationMethod (self, val : PyBrxCv.GradingCalculationMethod)-> bool :
      '''                             '''
    ...
    def setCastShadows (self, val: bool)-> None :
      '''Sets the property to indicate whether the entity can cast shadows.'''
    ...
    def setColor (self, clr: PyDb.AcCmColor, dosubents : bool=True, db : PyDb.Database='current')-> None :
      '''Function usageThis method sets the entity's color to the color specified by color. If the entity owns subentities and doSubents == Adesk::kTrue, the color change is applied to the subentities as well. Custom classes may override this method.'''
    ...
    def setColorIndex (self, clr: int, dosubents : bool=True)-> None :
      '''Function usageThis method sets the entity's color to the AutoCAD color index color. If the entity owns subentities and doSubents == Adesk::kTrue, then the color index change will be applied to the subentities as well.'''
    ...
    def setDatabaseDefaults (self, db: PyDb.Database = 'current')-> None :
      '''This function sets the entity's:ColorLayerLinetypeLinetype scaleVisibilityPlot style nameLine weightto the default values of the database indicated by pDb: If pDb == NULL, then the current database in the AutoCAD editor is used.'''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...
    def setDrawInfill (self, val : bool)-> PyBrxCv.GradingStatus :
      '''                             '''
    ...

    @overload
    def setField (self, field: PyDb.Field)-> PyDb.ObjectId : ...
    @overload
    def setField (self, propName: str, field: PyDb.Field)-> PyDb.ObjectId : ...
    def setField (self, *args, **kwargs)-> PyDb.ObjectId :
      '''Overloads:
    - field: PyDb.Field
    - propName: str, field: PyDb.Field
    '''
    ...
    def setGradingVisualStyle (self, val : PyBrxCv.GradingVisualStyle)-> bool :
      '''                             '''
    ...
    def setInputData (self, curve: PyGe.Curve3d)-> PyBrxCv.GradingStatus :
      '''                             '''
    ...
    def setInputDataId (self, id : PyDb.ObjectId)-> PyBrxCv.GradingStatus :
      '''                             '''
    ...
    def setIsAssociative (self, val : bool)-> bool :
      '''                             '''
    ...
    def setLayer (self, val: str|PyDb.ObjectId, dosubents : bool=True, allowHiddenLayer : bool=False)-> None :
      '''This method sets entity to reference the AcDbLayerTableRecord identified by the name specified in newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the layer change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.'''
    ...
    def setLineWeight (self, val: PyDb.LineWeight, dosubents : bool=True)-> None :
      '''This method sets the entity to use lineweight. If the entity owns subentities and doSubents == Adesk::kTrue, then the line weight change will be applied to the subentities as well.Returns Acad::eOk if successful.Function implementation in derived classesIf this function is overridden and wishes to set the line weight of the entity, then it must call AcDbEntity::setLineWeight() passing on the lineweight and doSubents arguments.It is also possible for this function's implementation to deal directly with any subentities and pass a doSubents value of Adesk::kFalse to AcDbEntity:: setLineWeight().If the line weight setting operation is successful, then this function should return Acad::eOk. If lineweight is not an acceptable value, then this function should return Acad::eInvalidInput. Any other error return values are up to the implementer.'''
    ...
    def setLinetype (self, val: str|PyDb.ObjectId, dosubents : bool=True)-> None :
      '''Function usageThis method sets the entity to reference the AcDbLinetypeTableRecord with the name specified in newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the linetype change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.'''
    ...
    def setLinetypeScale (self, val: float, dosubents : bool=True)-> None :
      '''This method sets the entity to use newval as its linetype scale factor. newVal must be nonnegative. If the entity owns subentities and doSubents == Adesk::kTrue, then the linetype scale change will be applied to the subentities as well.'''
    ...
    def setMaterial (self, val: str|PyDb.ObjectId, dosubents : bool=True)-> None :
      '''This method sets the material reference to the specified material. The specified name must correspond to an existing AcDbMaterial object.Returns Acad::eOk when successful'''
    ...
    def setMidOrdinateDist (self, val : float)-> PyBrxCv.GradingStatus :
      '''                             '''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setOwnerId (self, owner: PyDb.ObjectId)-> None :
      '''Sets the ownerId data member of the object to be objId, thus establishing a "backpointer." This backpointer is used by WBLOCK to be sure all necessary objects are written out.Returns Acad::eOk if successful.'''
    ...

    @overload
    def setPlotStyleName (self, /)-> None : ...
    @overload
    def setPlotStyleName (self, nameType: PyDb.PlotStyleNameType, doSubents: bool)-> None : ...
    @overload
    def setPlotStyleName (self, nameType: PyDb.PlotStyleNameType, newId: PyDb.ObjectId, doSubents: bool)-> None : ...
    def setPlotStyleName (self, *args, **kwargs)-> None :
      '''Overloads:
    - None: Any
    - nameType: PyDb.PlotStyleNameType, doSubents: bool
    - nameType: PyDb.PlotStyleNameType, newId: PyDb.ObjectId, doSubents: bool
    
	-This function searches the PlotStyleName dictionary for an entry with the name that matches newName and if found, sets the entity to use that plotStyleName entry. Because a lookup in the PlotStyleName dictionary is required, the entity must be database-resident for this method to succeed. The names ByLayer and ByBlock are allowed as well as user-defined names.If the entity owns subentities and doSubents == Adesk::kTrue, then the change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.Returns Acad::eOk if successful. If the entity is not database-resident, then Acad::eNoDatabase will be returned. If there is no entry in the PlotStyleName dictionary for newName, then Acad::eKeyNotFound will be returned.The plotStyleName value is used for DXF group code 390.-'''
    ...
    def setPropertiesFrom (self, entity: PyDb.Entity, dosubents : bool=True)-> None :
      '''This method copies theColorLayerLinetypeLinetype scaleVisibilityvalues from the entity pointed to by pEntity into this entity. If the entity owns subentities and doSubents == Adesk::kTrue, then the property changes will be applied to the subentities as well.Returns Acad::eOk if successful.'''
    ...
    def setReceiveShadows (self, val: bool)-> None :
      '''Sets the property indicating whether this entity can receive shadows.'''
    ...
    def setRegionEnd (self, val : float)-> PyBrxCv.GradingStatus :
      '''                             '''
    ...
    def setRegionStart (self, val : float)-> PyBrxCv.GradingStatus :
      '''                             '''
    ...
    def setRule (self, val : PyBrxCv.CvGradingRule)-> PyBrxCv.GradingStatus :
      '''                             '''
    ...
    def setSegmentMaxAngle (self, val : float)-> PyBrxCv.GradingStatus :
      '''                             '''
    ...
    def setSegmentMaxLength (self, val : float)-> PyBrxCv.GradingStatus :
      '''                             '''
    ...
    def setVisibility (self, val: PyDb.Visibility, dosubents : bool=True)-> None :
      '''This method sets the visibility of an entity to the value specified by newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the visibility change will be applied to the subentities as well.'''
    ...
    def setXData (self, xdata: list)-> None :
      '''Each regapp sublist (delimited by a resbuf with restype == 1001 and resval.rstring == a valid regappName string) within the resbuf chain pointed to by xdata, is placed in the xdata area of the object. If any of the regappNames in xdata are already present in the xdata area of the object, then that regappName's existing data on the object is overwritten by that regappName's new data in xdata.All resbufs with restype == 1001 must have valid regappNames for the database the object resides in (that is, the regappNames must be in the APPID table of the database).Only valid xdata group codes (1000--1071) are accepted in the restype fields of the resbufs in xdata.No "-3" group code is necessary, and in fact, is not accepted. So, the first element in the resbuf chain must be a 1001 group code with a resval.rstring set to a regappName that's already registered in the regapp table. To register a regappName, use the acdbRegApp() function.To remove an appName (and its xdata) from an object, just use a resbuf with restype == 1001, resval == and no data resbufs following it (that is, either its rbnext == NULL or the next resbuf is another 1001)This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If this function is overridden, then it should supermessage its parent in order to invoke the built-in mechanism to add the xdata to the object.Returns Acad::eOk if the xdata is successfully added to the object. If there is insufficient space in the xdata area of the object, then Acad::eXdataSizeExceeded is returned. If any of the regappNames in xdata are not in the APPID table, then Acad::eRegappIdNotFound is returned.'''
    ...
    def snoop (self,  filer : PyDb.SnoopDwgFiler)-> None :
      '''                             '''
    ...
    def swapIdWith (self, otherId: PyDb.DbObject, swapXdata: bool, swapExtDict: bool)-> None :
      '''This function swaps objectIds and handles between the object specified by otherId and the object invoking this function. Both objects must currently be database-resident and must reside in the same database. If swapXdata == Adesk::kTrue, then the objects swap extended entity data as well. If swapExtDict == Adesk::kTrue, then the objects swap extension dictionaries also.If the object specified by otherId or the object invoking this function are not database-resident, then Acad::eNoDatabase is returned. If both objects involved are not in the same database, then Acad::eWrongDatabase is returned.'''
    ...
    def targetSurface (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def transformBy (self, matrix3d: PyGe.Matrix3d)-> None :
      '''Function usageThis function provides a means by which AutoCAD and ObjectARX applications can ask the entity to apply a transformation matrix (xform) to itself.Each entity class must implement this function, so restrictions on what types of transformations are supported are up to the implementer of the entity class. The AutoCAD built-in entity classes for entity types that existed before R13 (that is, all the classes listed in the header file dbents.h such as AcDbCircle, AcDbLine, AcDbArc, AcDb2dPolyline, etc.) require that the transformation matrix represent a uniformly scaling orthogonal transformation (if it is not, then Acad::eCannotScaleNonUniformly will be returned). Other AutoCAD built-in classes have no restrictions.Returns Acad::eOk if successful. Return values for errors are implementation-dependent.Function implementation in derived classesThis function must apply the transformation matrix xform to the entity and change the entity's state to reflect the transformation. It is completely up to the implementer as to how to apply the transformation. It is also up to the implementer to decide what, if any, restrictions will be placed on the type of transformations supported. If any restrictions are desired, then it's up to the implementation of this function to enforce them.If your derived class implements transformBy() without calling the base class, you must call AcDbObject:: xDataTransformBy() or your Xdata will not be transformed.If this function successfully transforms the entity, then it should return Acad::eOk.Return values for error conditions are completely up to the implementer of this function. However, if the error is caused by a non-uniformly scaling or non-orthogonal matrix, then to be consistent with other entities that have this restriction, it is recommended that Acad::eCannotScaleNonUniformly be returned.'''
    ...
    def update (self, val : bool)-> PyBrxCv.GradingStatus :
      '''                             '''
    ...
    def upgradeFromNotify (self, wasWritable: bool)-> None :
      '''Upgrades the object from being at least open AcDb::kForNotify to being open both AcDb::kForNotify and AcDb::kForWrite. The wasWritable argument is set to Adesk::kTrue if the object was already open for write, otherwise it's set to Adesk::kFalse. The wasWritable value should be saved to be passed into the downgradeToNotify() call later.This function must be followed at some point by a call to downgradeToNotify() with no open() (in any of its forms) or close() calls in between.This method should only be called from within other methods of the same object it is being called from. In other words, this method is intended to be used by an object to change it's own open status so that it can safely modify itself.upgradeFromNotify() and downgradeToNotify() call pairs are not nestable.Returns Acad::eOk if successful. If the object is not currently open AcDb::kForNotify, then Acad::eNotApplicable is returned. If the object is currently in the process of actually sending notification (that is, isNotifying() returns Adesk::kTrue), then Acad::eWasNotifying is returned.'''
    ...
    def upgradeOpen (self)-> None :
      '''If the object is currently open AcDb::kForRead with only one reader, then this function upgrades the object to open AcDb::kForWrite. In the process of changing to open for write, the object is closed, thus triggering any pertinent notification.Returns Acad::eOk if successful. If the object has more than one reader, then the open status is not changed and Adesk::eHadMultipleReaders is returned. If the object is already open AcDb::kForWrite, then Acad::eWasOpenForWrite is returned. If the object is currently sending notification, then the open status is not changed and Acad::eWasNotifying is returned.'''
    ...
    def viewportDraw (self, vpdraw: PyGi.ViewportDraw)-> None :
      '''                             '''
    ...
    def viewportDrawLogicalFlags (self, vpdraw: PyGi.ViewportDraw)-> int :
      '''                             '''
    ...
    def visibility (self)-> PyDb.Visibility :
      '''This method returns the entity's current visibility state, either AcDb::kVisible or AcDb::kInvisible.'''
    ...
    def wblockClone (self, owner: PyRx.RxObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function is almost identical to AcDbObject::deepClone, except that an AcDbWblockCloneFiler is used and ownership is not carried across database boundaries. Subcloning is based on hard owner and hard pointer connections.'''
    ...
    def worldDraw (self, wdraw: PyGi.WorldDraw)-> int :
      '''                             '''
    ...
    def xData (self, appname: str = None)-> list :
      '''Returns a linked list of resbuf structures containing a copy of the xdata for the object. If regappName == NULL is passed in, all xdata is returned, otherwise only the xdata for the specified name is returned. If not all xdata is required, but the xdata for more than one regappName is desired, then multiple calls to this member function must be made--one for each regappName.The caller of this function is responsible for releasing the memory used by the resbuf list that is returned. The most commonly used way to deallocate such a list is via the acutRelRb() function.This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If a failure accessing the xdata occurs, NULL is returned.'''
    ...
    def xDataTransformBy (self, xform: PyGe.Matrix3d)-> None :
      '''This method applies the xform transformation matrix to any XData data types 1011, 1021, 1031, 1012, 1022, 1032, 1013, 1023, 1033, 1041, and 1042 in the object's XData. See the documentation on XData for more information on the way the transformation matrix is applied to the different data types.This method should be called from within the transformBy() method on custom entities so that such entities will transform XData in the same way that the built-in AcDb entities do.Returns Acad::eOk if successful.'''
    ...
    def xmitPropagateModify (self)-> None :
      '''Within an object's close() method is a call to the object's xmitPropagateModify().The AcDbObject::xmitPropagateModify() default implementation is to inform the containing database that the object has been modified, appended to the database, or erased. The database then sends out the appropriate notification to any AcDbDatabaseReactors attached to it.Within AutoCAD, this function is used by complex entities such as polylines to allow the subentities to notify the header that they have been changed. The header can then "propagate" the notification by sending its own notification that the "complex entity" has been modified.The way this works is:The subobject class has it's xmitPropagateModify() class overridden such that it calls it's parent class's xmitPropagateModify() and also calls the owning object's recvPropagateModify().The "root" or "header" class has it's recvPropagateModify() overridden to provide an implementation that triggers "modified" notification to be sent for the "root" or "header" (which effectively represents the whole complex object).The subobject's close() triggers "modified" notification for the subobject and calls the subobject's xmitPropagateModify() function. So, when the subobject's close() is called, its xmitPropagateModify() is called. This then calls the owning object's recvPropagateModify(), which then triggers the owner to send "modified" notification.So, the result is a "modified" notification from both the subentity and the "root" or "header" entity.When overridden, this function should:Call its parent class's xmitPropagateModify() (which ultimately results in the execution of AcDbObject::xmitPropagateModify() to trigger database notification).Call its owner's recvPropagateModify() (passing in its "this" pointer) to "propagate" the notification information to the "root" owner to be sent out.'''
    ...

class CvDbHAlignment(CvDbCurve):
    def __init__ (self, id: ObjectId, mode: PyDb.OpenMode=PyDb.OpenMode.kForRead, erased: bool=False)-> None :
      '''                             '''
    ...
    def addArcAuto (self, prevId: int, nextId: int)-> int :
      '''                             '''
    ...

    @overload
    def addArcBetween (self, prevId: int, nextId: int, passThroughPoint: PyGe.Point2d)-> int : ...
    @overload
    def addArcBetween (self, prevId: int, nextId: int, parameter: float, paramType: PyBrxCv.EArcParameterType, isGreaterThan180: bool, arcType: PyBrxCv.ArcType)-> int : ...
    def addArcBetween (self, *args, **kwargs)-> int :
      '''Overloads:
    - prevId: int, nextId: int, passThroughPoint: PyGe.Point2d
    - prevId: int, nextId: int, parameter: float, paramType: PyBrxCv.EArcParameterType, isGreaterThan180: bool, arcType: PyBrxCv.ArcType
    '''
    ...

    @overload
    def addArcFixed (self, center: PyGe.Point2d, radius: float, clockwise: bool)-> int : ...
    @overload
    def addArcFixed (self, startPoint: PyGe.Point2d, midPoint: PyGe.Point2d, endPoint: PyGe.Point2d)-> int : ...
    def addArcFixed (self, *args, **kwargs)-> int :
      '''Overloads:
    - center: PyGe.Point2d, radius: float, clockwise: bool
    - startPoint: PyGe.Point2d, midPoint: PyGe.Point2d, endPoint: PyGe.Point2d
    '''
    ...

    @overload
    def addArcFrom (self, prevId: int, passThroughPoint: PyGe.Point2d)-> int : ...
    @overload
    def addArcFrom (self, prevId: int, passThroughPoint: PyGe.Point2d, direction: PyGe.Vector2d)-> int : ...
    @overload
    def addArcFrom (self, prevId: int, passThroughPoint: PyGe.Point2d, radius: float, isGreaterThan180: bool, arcType: PyBrxCv.ArcType)-> int : ...
    @overload
    def addArcFrom (self, prevId: int, radius: float, paramValue: float, paramType: PyBrxCv.ArcType, isClockwise: bool)-> int : ...
    def addArcFrom (self, *args, **kwargs)-> int :
      '''Overloads:
    - prevId: int, passThroughPoint: PyGe.Point2d
    - prevId: int, passThroughPoint: PyGe.Point2d, direction: PyGe.Vector2d
    - prevId: int, passThroughPoint: PyGe.Point2d, radius: float, isGreaterThan180: bool, arcType: PyBrxCv.ArcType
    - prevId: int, radius: float, paramValue: float, paramType: PyBrxCv.ArcType, isClockwise: bool
    '''
    ...

    @overload
    def addArcTo (self, nextId: int, passThroughPoint: PyGe.Point2d)-> int : ...
    @overload
    def addArcTo (self, nextId: int, passThroughPoint: PyGe.Point2d, direction: PyGe.Vector2d)-> int : ...
    @overload
    def addArcTo (self, nextId: int, passThroughPoint: PyGe.Point2d, radius: float, isGreaterThan180: bool, arcType: PyBrxCv.ArcType)-> int : ...
    @overload
    def addArcTo (self, nextId: int, radius: float, paramValue: float, paramType: PyBrxCv.ArcType, isClockwise: bool)-> int : ...
    def addArcTo (self, *args, **kwargs)-> int :
      '''Overloads:
    - nextId: int, passThroughPoint: PyGe.Point2d
    - nextId: int, passThroughPoint: PyGe.Point2d, direction: PyGe.Vector2d
    - nextId: int, passThroughPoint: PyGe.Point2d, radius: float, isGreaterThan180: bool, arcType: PyBrxCv.ArcType
    - nextId: int, radius: float, paramValue: float, paramType: PyBrxCv.ArcType, isClockwise: bool
    '''
    ...
    def addCSSTo (self, nextId: int, spiral1Param: float, spiral2Param: float, spiralParamType, radius: float, passThroughPoint: PyGe.Point2d, spiralDef : PyBrxCv.SpiralDefinitionType)-> int :
      '''                             '''
    ...

    @overload
    def addCSTo (self, nextId: int, spiralParam: float, spiralParamType: PyBrxCv.EArcParameterType, radius: float,  passThroughPoint: PyGe.Point2d, isGreaterThan180: bool, spiralDefinition: PyBrxCv.SpiralDefinitionType)-> int : ...
    @overload
    def addCSTo (self, nextId: int, spiralParam: float, spiralParamType: PyBrxCv.EArcParameterType, radius: float,  arcLength: float, isClockwise: bool, spiralDefinition: PyBrxCv.SpiralDefinitionType)-> int : ...
    def addCSTo (self, *args, **kwargs)-> int :
      '''Overloads:
    - nextId: int, spiralParam: float, spiralParamType: PyBrxCv.EArcParameterType, radius: float,  passThroughPoint: PyGe.Point2d, isGreaterThan180: bool, spiralDefinition: PyBrxCv.SpiralDefinitionType
    - nextId: int, spiralParam: float, spiralParamType: PyBrxCv.EArcParameterType, radius: float,  arcLength: float, isClockwise: bool, spiralDefinition: PyBrxCv.SpiralDefinitionType
    '''
    ...
    def addContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def addLineBetween (self, prevId: int, nextId: int)-> int :
      '''                             '''
    ...

    @overload
    def addLineFixed (self, prevId : int, length: float)-> int : ...
    @overload
    def addLineFixed (self, start: PyGe.Point2d, end: PyGe.Point2d)-> int : ...
    def addLineFixed (self, *args, **kwargs)-> int :
      '''Overloads:
    - prevId : int, length: float
    - start: PyGe.Point2d, end: PyGe.Point2d
    '''
    ...

    @overload
    def addLineFrom (self, prevId : int, length: float)-> int : ...
    @overload
    def addLineFrom (self, prevId : int, to: PyGe.Point2d)-> int : ...
    def addLineFrom (self, *args, **kwargs)-> int :
      '''Overloads:
    - prevId : int, length: float
    - prevId : int, to: PyGe.Point2d
    '''
    ...

    @overload
    def addLineTo (self, nextId : int, length: float)-> int : ...
    @overload
    def addLineTo (self, nextId : int, to: PyGe.Point2d)-> int : ...
    def addLineTo (self, *args, **kwargs)-> int :
      '''Overloads:
    - nextId : int, length: float
    - nextId : int, to: PyGe.Point2d
    '''
    ...
    def addPersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Adds the database-resident object specified by objId to the reactor list of the AcDbObject object.'''
    ...
    def addReactor (self, reactor: PyDb.EntityReactor)-> None :
      '''                             '''
    ...

    @overload
    def addSCFrom (self, prevId: int, spiralParam: float, spiralParamType: PyBrxCv.EArcParameterType, radius: float,  passThroughPoint: PyGe.Point2d, isGreaterThan180: bool, spiralDefinition: PyBrxCv.SpiralDefinitionType)-> int : ...
    @overload
    def addSCFrom (self, prevId: int, spiralParam: float, spiralParamType: PyBrxCv.EArcParameterType, radius: float,  arcLength: float, isClockwise: bool, spiralDefinition: PyBrxCv.SpiralDefinitionType)-> int : ...
    def addSCFrom (self, *args, **kwargs)-> int :
      '''Overloads:
    - prevId: int, spiralParam: float, spiralParamType: PyBrxCv.EArcParameterType, radius: float,  passThroughPoint: PyGe.Point2d, isGreaterThan180: bool, spiralDefinition: PyBrxCv.SpiralDefinitionType
    - prevId: int, spiralParam: float, spiralParamType: PyBrxCv.EArcParameterType, radius: float,  arcLength: float, isClockwise: bool, spiralDefinition: PyBrxCv.SpiralDefinitionType
    '''
    ...
    def addSCSAuto (self, prevId: int, nextId: int)-> int :
      '''                             '''
    ...
    def addSCSBetween (self, prevId: int, nextId: int, spiral1: float, spiral2: float, spiralType: PyBrxCv.SpiralParameterType, radius: float, spiralDef: PyBrxCv.SpiralDefinitionType)-> int :
      '''                             '''
    ...
    def addSSBetween (self, prevId: int, nextId: int, spiralRatio: float, spiralParamType : PyBrxCv.SpiralParameterType, spiralDef : PyBrxCv.SpiralDefinitionType)-> int :
      '''                             '''
    ...
    def addSSCFrom (self, prevId: int, spiral1Param: float, spiral2Param: float, spiralParamType, radius: float, passThroughPoint: PyGe.Point2d, spiralDef : PyBrxCv.SpiralDefinitionType)-> int :
      '''                             '''
    ...

    @overload
    def addSTFrom (self, prevId: int, spiralParam: float, spiralParamType: PyBrxCv.EArcParameterType, passThroughPoint: PyGe.Point2d,  spiralDefinition: PyBrxCv.SpiralDefinitionType)-> int : ...
    @overload
    def addSTFrom (self, prevId: int, spiralParam: float, spiralParamType: PyBrxCv.EArcParameterType, tangentLength: float,  spiralDefinition: PyBrxCv.SpiralDefinitionType)-> int : ...
    def addSTFrom (self, *args, **kwargs)-> int :
      '''Overloads:
    - prevId: int, spiralParam: float, spiralParamType: PyBrxCv.EArcParameterType, passThroughPoint: PyGe.Point2d,  spiralDefinition: PyBrxCv.SpiralDefinitionType
    - prevId: int, spiralParam: float, spiralParamType: PyBrxCv.EArcParameterType, tangentLength: float,  spiralDefinition: PyBrxCv.SpiralDefinitionType
    '''
    ...
    def addSTSBetween (self, prevId: int, nextId: int, spiral1Param: float, spiral2Param: float, spiralType : PyBrxCv.SpiralParameterType, spiralDef : PyBrxCv.SpiralDefinitionType)-> int :
      '''                             '''
    ...
    def addSpiralBetween (self, prevId: int, nextId: int, spiralDef: PyBrxCv.SpiralDefinitionType)-> int :
      '''                             '''
    ...
    def addSpiralFrom (self, prevId: int, radius: float, length: float, isClockwise: bool, spiralDef : PyBrxCv.SpiralDefinitionType)-> int :
      '''                             '''
    ...
    def addSpiralTo (self, nextId: int, radius: float, length: float, isClockwise: bool, spiralDef : PyBrxCv.SpiralDefinitionType)-> int :
      '''                             '''
    ...
    def addSubentPaths (self, paths: list[PyDb.FullSubentPath])-> None :
      '''Adds one or more subentities to an entity.The prototype of this method is provided for completeness of the subentity manipulation APIs. AutoCAD will never call this method on a custom object.Returns Acad::eOk if successful. The default implementation returns Acad::eNotAvailable.'''
    ...

    @overload
    def addTSTo (self, nextId: int, spiralParam: float, spiralParamType: PyBrxCv.EArcParameterType, passThroughPoint: PyGe.Point2d,  spiralDefinition: PyBrxCv.SpiralDefinitionType)-> int : ...
    @overload
    def addTSTo (self, nextId: int, spiralParam: float, spiralParamType: PyBrxCv.EArcParameterType, tangentLength: float,  spiralDefinition: PyBrxCv.SpiralDefinitionType)-> int : ...
    def addTSTo (self, *args, **kwargs)-> int :
      '''Overloads:
    - nextId: int, spiralParam: float, spiralParamType: PyBrxCv.EArcParameterType, passThroughPoint: PyGe.Point2d,  spiralDefinition: PyBrxCv.SpiralDefinitionType
    - nextId: int, spiralParam: float, spiralParamType: PyBrxCv.EArcParameterType, tangentLength: float,  spiralDefinition: PyBrxCv.SpiralDefinitionType
    '''
    ...
    def alignment3dAt (self, index: int)-> PyDb.ObjectId :
      '''                             '''
    ...
    def alignment3dCount (self)-> int :
      '''                             '''
    ...
    def assertNotifyEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should be used inside of member functions that are only called when the object is open kForNotify. When used, it should be the first function called inside the member function.'''
    ...
    def assertReadEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that access the object's data in a read-only fashion (for example, dxfOutFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is open AcDb::kForRead.If this function is called while the object is not open, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def assertWriteEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that modify the object's data (for example, dxfInFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is indeed open for write (if it is not, then AutoCAD terminates); to trigger an immediate sending of "openedForModify" notification; to set up the notification mechanism so that "modified" and "modifiedGraphics" (if the object is derived from AcDbEntity) are sent at the appropriate times; and to ensure that graphics get updated if the object is derived from AcDbEntity.If this function is called on a database resident object, "openedForModify" will be sent if the object is not newly created, and "modified", and "modifiedGraphics" (if appropriate) notifications will be sent when the object is next closed.If recordModified is false, then the autoUndo argument is ignored, and the undo filer is not initialized, no undo recording will take place, but notifications will be sent.If autoUndo and recordModified are both true, then automatic undo recording will be performed and notifications will be sent.If autoUndo is false and recordModified is true, then there will not be any automatic undo recording, but the undo filer is initialized and the object must manually write out partial Undo records and must implement its applyPartialUndo() method. Notifications will be sent.If this function is called while the object is not open AcDb::kForWrite, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def blockId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the entity's owner, which must be an AcDbBlockTableRecord.If the entity does not have an owner yet, then AcDbObjectId::kNull will be returned.'''
    ...
    def bounds (self, ext: PyDb.Extents)-> bool :
      '''                             '''
    ...
    def cancel (self)-> None :
      '''Terminates the current open operation. All changes made to the object since it was opened are undone, the object is marked as closed, and "cancel" notification is sent.Returns Acad::eOk if successful.'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbHAlignment :
      '''                             '''
    ...
    def castShadows (self)-> bool :
      '''Returns a boolean value that indicates whether the entity can cast shadows. '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...

    @staticmethod
    def cloneFrom (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbHAlignment :
      '''                             '''
    ...
    def close (self)-> None :
      '''Closes the object. All changes made to the object since it was opened are committed to the database, the object is marked as pageable, and a "closed" notification (as well as any other appropriate notification such as "modified", "erased", and so on) is sent.Returns Acad::eOk if successful.If the object is not in an AcDbDatabase yet, then Acad::eNoDatabase is returned.If the object is sending notification, then Acad::eCloseWasNotifying is returned.If the subClose() call made within the close() method returns anything other than Acad::eOk, then that ErrorStatus is returned.'''
    ...
    def collisionType (self)-> PyDb.CollisionType :
      '''This function returns the collision detection treatment for this entity. Subclasses may override this method to customize how the class interacts in collision-aware features.'''
    ...
    def color (self)-> PyDb.Color :
      '''This function returns the full true color information for the entity within an instance of AcCmColor.The index value will be in the range 0 to 256. 0 and 256 are special values.0 indicates the entity uses the color of the BlockReference that's displaying it. If the entity is not displayed through a BlockReference (for example, it's directly owned by the model space BlockTableRecord) and its color is 0, then it will display as though its color were 7.256 indicates the entity uses the color specified in the LayerTableRecord it references.'''
    ...
    def colorIndex (self)-> int :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...
    def createExtensionDictionary (self)-> None :
      '''Creates an AcDbDictionary object and sets it up as the extension dictionary for the AcDbObject.Returns Acad::eOk if successful. If an extension dictionary already exists, Acad::eAlreadyInDb is returned.'''
    ...

    @staticmethod
    def createFromAcGeCurve (curve: PyGe.Curve3d,normal: PyGe.Vector3d = PyGe.Vector3d.kZAxis,tol: PyGe.Tol = 'default')-> PyDb.Curve :
      '''This is createFromAcGeCurve, a member of class AcDbCurve.'''
    ...
    def curveAtPI (self, pi: PyBrxCv.CvDbHAlignmentPI)-> int :
      '''                             '''
    ...
    def curveElementColor (self)-> int :
      '''                             '''
    ...
    def database (self)-> PyDb.Database :
      '''Returns a pointer to the AcDbDatabase object that contains the AcDbObject.'''
    ...
    def deepClone (self, owner: PyDb.DbObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function gives control of deep clone operations to the object. In the default implementation, the object is cloned and appended to the owner object (pOwnerObject). The cloning is performed by an AcDbDeepCloneFiler. A record is also added to the idMap. Then, using the filer, any owned objects are deep cloned, with isPrimary set to Adesk::kFalse.'''
    ...
    def deleteElement (self, id: int)-> bool :
      '''                             '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def disableUndoRecording (self, disable: bool)-> None :
      '''Turns off or on the Undo recording for the object. If disable == Adesk::kTrue, then Undo recording is turned off until this function is called with disable == Adesk::kFalse, at which time Undo recording is turned back on.'''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def downgradeOpen (self)-> None :
      '''Downgrades the object from being open AcDb::kForWrite, to being AcDb::kForRead. In the process, all changes made to the object while it was open for write are committed to the database and appropriate notification is sent.'''
    ...
    def downgradeToNotify (self, wasWritable: bool)-> None :
      '''Restores an object from being open both AcDb::kForNotify and AcDb::kForWrite, to being open just AcDb::kForNotify. The wasWritable value that was returned from the matching AcDbObject::upgradeFromNotify() call should be passed into this function to restore the proper open status.This function must have been preceded by a call to upgradeFromNotify().Returns Acad::eOk if successful.'''
    ...
    def draw (self)-> None :
      '''This function queues up the entity's graphics and flushes the graphics queue, forcing the entity and anything else in the queue to be drawn or re-drawn on-screen.Returns Acad::eOk if successful.If the entity is not in a database, then Acad::eNotInDatabase will be returned.If the entity is in a database other than the one currently loaded into the AutoCAD editor, then Acad::eNotCurrentDatabase will be returned.'''
    ...
    def drawableType (self)-> PyGi.GiDrawableType :
      '''                             '''
    ...
    def elementAtId (self, Id: int)-> PyBrxCv.CvDbHAlignmentElement :
      '''                             '''
    ...
    def elementAtStation (self, station: float)-> PyBrxCv.CvDbHAlignmentElement :
      '''                             '''
    ...
    def elementCount (self)-> int :
      '''                             '''
    ...
    def elementExtensionColor (self)-> int :
      '''                             '''
    ...
    def entityColor (self)-> PyDb.EntityColor :
      '''This function returns the color settings of the entity in an AcCmEntityColor form. Most clients should use the color() function, which returns the heavyweight AcCmColor object. However, if color name information is not required, this function provides faster access to the lightweight AcCmEntityColor data.'''
    ...
    def erase (self, erasing : bool=True)-> None :
      '''Sets the erase bit of the object. If erasing == Adesk::kTrue, then the erase bit is set on. If erasing == Adesk::kFalse, then the erase bit is set off.'''
    ...
    def explode (self)-> list :
      '''Function UsageThis function is primarily intended for AutoCAD to call as part of an explode operation that includes this entity. However, this function can be used by ObjectARX applications to obtain an array of pointers to non-database-resident entity objects that are what the entity considers to be its exploded parts.When calling this function, the entitySet array does not need to be empty. This function will append to it, and pointers to entities that it creates to be used in its place as the "exploded" result.If this function is successful, it will return Acad::eOk. Other return values may vary depending on how it has been implemented.Function Implementation in Derived ClassesThis function should dynamically create (using the new operator) whatever entity objects are appropriate to be used to replace the entity after an explode operation has taken place. Pointers to these entities are then appended to the entitySet array. Once the pointers have been appended, the function should return with a status of Acad::eOk.'''
    ...

    @overload
    def extend (self, newParam: float)-> None : ...
    @overload
    def extend (self, extendStart: bool, toPoint: PyGe.Point3d)-> None : ...
    def extend (self, *args, **kwargs)-> None :
      '''Overloads:
    - newParam: float
    - extendStart: bool, toPoint: PyGe.Point3d
    
	-This function extends the beginning or end of the curve to the new point determined by the newParam value.If newParam is less than the curve's start parameter, then the curve is reset to start at newParam. If newParam is greater than the curve's end parameter, then the curve is reset to end at newParam.Returns Acad::eOk if successful. If newParam's first period value is between the curve's start and end, then Acad::eInvalidInput will be returned.The function implementation in derived classes must be able to interpret the newParam value, decide if it is beyond the existing curve end or before the curve beginning, and then extend the curve in the appropriate direction to the newParam value.Return ErrorStatus values are up to the implementer, but to be consistent with built-in classes, the following return values are recommended:Acad::eOkFunction completed successfully.Acad::eInvalidInputThe parameter was not acceptable for some reason (for example, if its first period lies within the existing curve so that it would be a trim rather than an extension).The default implementation returns Acad::eNotImplemented.-'''
    ...
    def extensionDictionary (self)-> PyDb.ObjectId :
      '''Returns the objectId of the extension dictionary owned by the object. If the object does not own an extension dictionary, then the returned objectId is set to AcDbObjectId::kNull.'''
    ...
    def firstElementId (self)-> int :
      '''                             '''
    ...
    def firstLineElementId (self)-> int :
      '''                             '''
    ...
    def getAcGeCurve (self, tol: PyGe.Tol = 'default')-> PyGe.Curve3d :
      '''This is getAcGeCurve, a member of class AcDbCurve.'''
    ...
    def getArea (self)-> float :
      '''This function returns with area set to the area inside the curve. For the AutoCAD built-in classes, the curve must lie on a plane. If the curve is not closed, its start and end points are considered as connected by a line segment that closes it.Returns Acad::eOk if successful. For the AutoCAD built-in classes, Acad::eInvalidInput is returned if the curve is not planar. Other return values are possible for custom entity classes depending on how they were implemented.This function must be able to calculate a bounded area value for the curve.While the AutoCAD built-in classes require the curve to be planar, no such restriction need be made for custom entity classes unless desired by the implementer.ErrorStatus return values are up to the implementer, but the following are recommended to be consistent with existing classes:Acad::eOkFunction completed successfully.Acad::eInvalidInputThe area was not calculable (for example, the curve was not planar).The default implementation's return value is Acad::eNotImplemented.'''
    ...
    def getClosestPointTo (self, point3d: PyGe.Point3d, direction: PyGe.Vector3d=None, extend: bool=False)-> PyGe.Point3d :
      '''This function projects the curve onto the plane defined by givenPnt and normal, finds the point on the projected curve that is nearest to givenPnt, then projects this nearest point back onto the original curve and sets pointOnCurve to the result.If extend == Adesk::kTrue, then the curve is extended along its path to find the closest point.Returns Acad::eOk if successful. Return values for errors are dependent on the implementation.In derived classes; this function needs to be able to project the curve onto a plane determined by a point (givenPnt) and a normal vector (normal), extend the curve's projection if necessary (if extend==Adesk::kTrue), find the point on the projected curve that is nearest to givenPnt, then project the point found back onto the original curve (or its path if it was extended) and set pointOnCurve to the end result.Use of AcGe classes may be helpful in doing some of the projection and nearest point calculation work.If the operation is successful, this function returns Acad::eOk. Return values for errors are dependent upon the error and the implementer. See header file acdh.h for a list of possible ErrorStatus values.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getCompoundObjectTransform (self)-> PyGe.Matrix3d :
      '''This function is intended to be overridden by derived classes that are compound objects (in other words, objects that behave like blocks in the display list).A compound object has little or no geometry of its own; instead it relies on nested entities, perhaps the contents of a BlockTableRecord, to represent itself. A compound object must use the same transformation matrix for all of its contained entities. Otherwise selection and osnap will not function correctly. This is the method that the system uses to obtain that matrix from the compound object.This method should only be overridden if you return the kDrawableIsCompoundObject flag from setAttributes. The matrix you should return here is the one that you pass to pushModelTransform before you render your nested objects. You must override this method if you return the compound object flag in setAttributes, even if you don't push a transform for your nested objects. In that case you would return Acad::eOk and the identity transform in xMat.Default implementation: Returns Acad::eNotApplicable and the identity matrix in xMat.'''
    ...
    def getDistAtParam (self, param: float)-> float :
      '''Calculates the length of the curve's segment from the curve's start point to the point specified by param.Returns Acad::eOk if successful, or Acad::eInvalidInput if param is out of range. For other errors, the implementer must decide what return value to use. See the acdb.h header file for possible ErrorStatus values.In the default implementation, the function returns Acad::eNotImplemented.'''
    ...
    def getDistAtPoint (self, point3d: PyGe.Point3d)-> float :
      '''Calculates the length of the curve's segment between the curve's start point and point and returns the length in distance.Returns Acad::eOk if successful, or Acad::eInvalidInput if the point is not on the curve. For other errors, the implementer must decide what return value to use. See the acdb.h header file for possible ErrorStatus values.Returns Acad::eNotImplemented in the default implementation.'''
    ...
    def getEcs (self)-> PyGe.Matrix3d :
      '''This function is intended to be overridden by derived classes that need to be able to provide access to an object coordinate system for objects of the class. The intent is that this function provide a transformation matrix that can be used to transform vectors or points from the object's object coordinate system (OCS) to the World Coordinate System (WCS).Default implementation: Return the identity matrix (ones along the diagonal, zeros elsewhere) in retVal.We recommend that all data stored in custom classes be stored in WCS coordinates. If this is done, then the object's OCS will be the WCS and the transformation matrix will be the identity matrix. Then this function will not need to be overridden since the identity matrix is this function's default return.'''
    ...
    def getElementId (self, gsMarker: int)-> int :
      '''                             '''
    ...
    def getEndParam (self)-> float :
      '''The implementation of this function in derived classes should return with endParam set to the parameter of the endpoint of the curve.Returns Acad::eOk if successful.By default, the function returns Acad::eNotImplemented.'''
    ...
    def getEndPoint (self)-> PyGe.Point3d :
      '''In this class and in derived classes, this function returns with endPoint set to the end point (in WCS coordinates) of the curve.Returns Acad::eOk if successful.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getField (self, prop: str='TEXT')-> PyDb.ObjectId :
      '''Gets the field ID. A field can be stored in an object using the property name as the key.Returns Acad::eOk if the object has a field for the specified property. Otherwise, returns an AutoCAD error status.'''
    ...
    def getFieldDictionary (self)-> PyDb.ObjectId :
      '''Returns the field dictionary ID. The field dictionary stores all the fields set in the object as property name-field object pairs. The ID will be null if there is no field in the object.'''
    ...
    def getFirstDeriv (self, param: float|PyGe.Point3d)-> PyGe.Vector3d :
      '''Here and in derived classes, this function is implemented to evaluate the first derivative at the location on the curve specified by param, and sets firstDeriv to the result (in WCS coordinates).Returns Acad::eOk if successful. If param is not valid for the curve, then Acad::eInvalidInput is returned. Other ErrorStatus return values are up to the implementer.For implementation, the AcGe classes may provide some of the necessary functionality to make the job easier.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getGeomExtents (self)-> PyDb.Extents :
      '''Unimplemented at the AcDbEntity level, this method is intended to be overridden in derived classes.Derived classes should calculate and return the corner points (in WCS coordinates) of a box (with edges parallel to the WCS X, Y, and Z axes) that encloses the 3D extents of the entity, and return those points as an instance of class AcDbExtents in the "extents" parameter.Default implementation: Immediately returns Acad::eInvalidExtents.'''
    ...
    def getGeomExtents2d (self)-> PyDb.Extents2d :
      '''                             '''
    ...

    @overload
    def getGripPoints (self, /)-> tuple[Any,...] : ...
    @overload
    def getGripPoints (self, curViewUnitSize: float, gripSize: int, curViewDir: PyGe.Vector3d, bitflags: int)-> tuple[Any,...] : ...
    def getGripPoints (self, *args, **kwargs)-> tuple[Any,...] :
      '''Overloads:
    - None: Any
    - curViewUnitSize: float, gripSize: int, curViewDir: PyGe.Vector3d, bitflags: int
    
	-Function usageThis function supports "old style" grips, in applications that existed before the enhancement of grip functionality by the addition of the AcDbGripData class.This function is not intended to be called by ObjectARX applications. However, it is possible to do so (for example, as a pass-through from the getStretchPoints() method).Function implementation in derived classesThis function should append to the gripPoints array any points that are to treated as grip points for the entity.The gripPoints array is passed to all entities involved in the grip operation, so the array may already contain grip points for other entities. Therefore, it is very important to append the new points rather than assigning them to any existing elements in the array.When finished appending all desired grip points, return Acad::eOk. If anything other than Acad::eOk is returned, then grips are not activated for this entity.The osnapModes and geomIds arguments are not currently used.Default implementationImmediately returns Adesk::eNotImplemented.-'''
    ...
    def getHandle (self)-> PyDb.Handle :
      '''Fills in handle with the handle value for the object. If the object is not yet database-resident, then it will not have a handle. Use AcDbHandle::isNull to test for this condition.'''
    ...
    def getOffsetCurves (self, dist: float)-> list :
      '''This function creates one or more entities that together make up the result of offsetting the curve by the distance offsetDist. For many curves, the result is a single new curve. (This single new curve may not be of the same class as the original curve. For example, offsetting an AcDbEllipse results in an AcDbSpline, since the result of offsetting an ellipse does NOT fit the equation of an ellipse.)In some cases, it might be necessary for the offset result to be several curves. (The result may even be several curves that would form a single curve if they were joined end-to-end.) To allow for this possibility, a dynamic array of void pointers is used to hold pointers to the resulting entity or entities.To use this array of pointers, the calling application needs to cast the pointer(s) to the appropriate object type(s). If only a specific entity type or set of types are to be handled, then use the cast method of the class(es) desired to see if each pointer can be safely cast to that object type. If the actual object type (class name) is desired, then each object's isA() method may be used to get a pointer to the object's AcRxClass object, which has a name() method.If the offsetDist value is negative, it is usually interpreted as being an offset to make a smaller curve (that is, for an arc it would offset to a radius that is offsetDist less than the starting curve's radius). If the negative value has no meaning in terms of making the curve smaller, a negative offsetDist may be interpreted as an offset in the direction of smaller X,Y,Z WCS coordinates. This is not enforced, so custom entities can interpret the sign of the offsetDist value however they want.The entities returned in the offsetCurves array are dynamically allocated, but have not been added to an AcDbDatabase yet. So, the application that calls this function is responsible for their memory. If they are subsequently appended to a database, then the database takes over responsibility for their memory. Otherwise, the application is responsible for deleting them when they are no longer needed.Returns Acad::eOk if offsetting is successfully completed. If the offset distance is invalid (for example, if you are offsetting an arc such that the offset result would be a negative radius), then Acad::eInvalidInput is returned. For the AutoCAD built-in classes that use ShapeManager (AcDbBody, AcDbRegion, and AcDb3dSolid), Acad::eGeneralModelingFailure will be returned if an error occurs in the ShapeManager modeler. Other ErrorStatus return values are implementation-dependent.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getOffsetCurvesGivenPlaneNormal (self, normal: PyGe.Vector3d, dist: float)-> list :
      '''This function creates one or more entities that, together, make up the result of offsetting the curve by the distance offsetDist in the plane with normal vector normal. For many curves, the result will be a single new curve, which may not be of the same class as the original curve. For example, offsetting an AcDbEllipse results in an AcDbSpline, since the result of offsetting an ellipse does not fit the equation of an ellipse. However, in some cases it might be necessary for the offset result to be several curves. To allow for this possibility, a dynamic array of void pointers is used to hold pointers to the resulting entity or entities.To use this array of pointers, the calling application must cast the pointer(s) to the appropriate object type(s). If only a specific entity type or set of types are to be handled, then using the cast method of the class(es) desired to see if each pointer can be safely cast to that object type will work. If the actual object type is desired, then each object's isA() method may be used to get a pointer to the object's AcRxClass object, which has a name() method to get the classname of the object.If the offsetDist value is negative this is usually interpreted as being an offset to make a smaller curve (that is, for an arc it would offset to a radius that is offsetDist less than the starting curve's radius). Or, if smaller has no meaning, then a negative offsetDist may be interpreted as an offset in the direction of smaller X,Y,Z WCS coordinates. However, this is not enforced, so custom entities can interpret the sign of the offsetDist value however they wish.The entities returned in the offsetCurves arrays are dynamically allocated, but have not been added to an AcDbDatabase yet. So, the application that calls this function is responsible for their memory. If they are subsequently appended to a database, then the database takes over responsibility for their memory. Otherwise, the application is responsible for deleting them when they are no longer needed.Returns Acad::eOk if offsetting is successfully completed. If the offset distance is invalid, or if normal is a zero length vector or the entity is linear and normal is not perpendicular with the entity, then Acad::eInvalidInput is returned. Other ErrorStatus return values are implementation dependent.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getOrthoProjectedCurve (self, plane: PyGe.Plane)-> PyDb.Curve :
      '''This function creates a new curve entity that is the result of projecting the curve along the projPlane's normal onto the projPlane and sets projCurve to point to the newly created curve. projCurve is declared as type AcDbCurve to allow the returned curve to be any class derived from AcDbCurve (for example, when an AcDbArc is projected onto a plane, the result is an AcDbEllipse).The returned curve is dynamically allocated, but has not been added to an AcDbDatabase yet. So, the application that calls this function is responsible for its memory. If the curve is subsequently appended to a database, then the database takes over responsibility for its memory. Otherwise, the application is responsible for deleting it when it is no longer needed.Returns Acad::eOk if successful. Other ErrorStatus values are implementation-dependent.Returns Acad::eNotImplemented in the default implementation.'''
    ...
    def getPIsArray (self)-> list :
      '''                             '''
    ...
    def getParamAtDist (self, dist: float)-> float :
      '''This function determines the parameter of the curve at the location that is a distance of dist along the curve from the curve start, and returns the parameter in param.Returns Acad::eOk if successful. If dist is not valid for the curve, then Acad::eInvalidInput is returned. Other ErrorStatus return values are implementation-dependent.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getParamAtPoint (self, point3d: PyGe.Point3d)-> float :
      '''This function determines the parameter of the curve at point and returns the parameter in param.Returns Acad::eOk if successful. If point is not on the curve, then Acad::eInvalidInput is returned. Other ErrorStatus return values are implementation-dependent.Acad::eNotImplemented is returned by the default implementation.'''
    ...
    def getPlane (self)-> PyGe.Plane :
      '''If the entity is planar, then the plane containing the entity is returned in plane and flag is set to AcDb::kPlanar.If the entity is nonplanar, but is linear, then plane is set to an arbitrary plane that contains the entity and flag is set to AcDb::kLinear.If the entity is nonplanar and nonlinear, then plane is left unset and flag is set to AcDb::kNonPlanar.Returns Acad::eOk if successful. Other ErrorStatus return values are implementation-dependent.The default implementation is to return Acad::eNotApplicable.'''
    ...
    def getPlotStyleNameId (self)-> PyDb.ObjectId :
      '''Returns with id set to the object ID of the AcDbPlaceHolder object referenced by the entity. The AcDbPlaceHolder object resides in the plot style name dictionary, and its key in the dictionary is the plot style name.Use the AcDbDictionary::nameAt() function on the plot style name dictionary to get the plot style name string that corresponds to the ID obtained by this function.'''
    ...
    def getPointAtDist (self, dist: float)-> PyGe.Point3d :
      '''This function determines the point on the curve that is a distance of dist along the curve from the curve start, and returns the point in point. point is in WCS coordinates.Returns Acad::eOk if successful. If dist is not valid for the curve, then Acad::eInvalidInput is returned. Other ErrorStatus return values are implementation-dependent.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getPointAtParam (self, param: float)-> PyGe.Point3d :
      '''This function determines the point on the curve that corresponds to the param parameter, and returns the point in point. point is in WCS coordinates.Returns Acad::eOk if successful. If the parameter is not within the curve's range, then Acad::eInvalidInput is returned. Other ErrorStatus return values are implementation-dependent.Returns Acad::eNotImplemented in the default implementation.'''
    ...
    def getPointAtStation (self, station: float)-> tuple[Any,...] :
      '''                             '''
    ...
    def getProjectedCurve (self, plane: PyGe.Plane, projDir: PyGe.Vector3d)-> PyDb.Curve :
      '''This function creates a new curve entity that is the result of projecting the curve parallel to projDir onto the projPlane and sets projCurve to point to the newly created curve. projCurve is declared as type AcDbCurve in order to allow the returned curve to be any class derived from AcDbCurve. For example, when an AcDbArc is projected onto a plane, the result is an AcDbEllipse.The returned curve is dynamically allocated, but has not been added to an AcDbDatabase yet. The application that calls this function is therefore responsible for its memory. If the curve is subsequently appended to a database, then the database takes over responsibility for its memory. Otherwise, the application is responsible for deleting it when it is no longer needed.Returns Acad::eOk if successful. If projDir is perpendicular to the projPlane's normal then Acad::eInvalidInput is returned. For the AutoCAD built-in classes that use ShapeManager (AcDbEllipse, AcDbSpline, AcDbBody, AcDbRegion, and AcDb3dSolid), Acad::eGeneralModelingFailure is returned if an error occurs in the ShapeManager modeler. Other ErrorStatus values are implementation-dependent.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getRadius (self, param: float)-> float :
      '''                             '''
    ...
    def getSecondDeriv (self, param: float|PyGe.Point3d)-> PyGe.Vector3d :
      '''Evaluates the second derivative at the location on the curve specified by param and sets secDeriv to the result (in WCS coordinates).Returns Acad::eOk if successful. If param is not valid for the curve, then Acad::eInvalidInput is returned. Other ErrorStatus return values are up to the implementer.For implementation, the AcGe classes provide some of the necessary functionality to make the job easier.Returns Acad::eNotImplemented in the default implementation.'''
    ...
    def getSpline (self)-> PyDb.Spline :
      '''This function creates a new AcDbSpline entity, sets it to be as close an approximation as possible to the curve, and then returns with spline pointing to the newly created spline entity.The returned spline is dynamically allocated, but has not been added to an AcDbDatabase yet. So, the application that calls this function is responsible for its memory. If the spline is subsequently appended to a database, then the database takes over responsibility for its memory. Otherwise, the application is responsible for deleting it when it is no longer needed.Returns Acad::eOk if successful. If there is an error in the ShapeManager modeler (which AcDbSpline uses), then Acad::eGeneralModelingFailure will be returned. Other ErrorStatus values are implementation-dependent.Returns Acad::eNotImplemented in the default implementation.'''
    ...
    def getSplitCurves (self, paramsOrPoints: list)-> list :
      '''This function creates one or more entities that are all subcurves of the original. The points array must contain the points on the curve that are used as the start or end points of the newly created subcurves. The first subcurve starts at the original curve's start point and ends at the first point in the points array. The second subcurve starts at the first point in the points array and ends at the second point in the points array. The third subcurve starts at the second point and ends at the third, and so on. The last subcurve starts at the last point in the points array and ends at the original curve's endpoint.If successive points are coincident (including the original curve's start to the first array point and the last array point to the original curve's end), then no subcurve is created for that pair.Pointers to all new curves are appended to the curveSegments array.The entities that are returned in the curveSegments array are dynamically allocated, but are not yet added to an AcDbDatabase. So, the application that calls this function is responsible for their memory. If they are subsequently appended to a database, then the database takes over responsibility for their memory. Otherwise, the application is responsible for deleting them when they are no longer needed.Depending on how this function is implemented, it is possible that the function might return an ErrorStatus other than Acad::eOk and still have appended some pointers to subcurves to the curveSegments array (AcDbArc does this). Typically, this would be the result of an invalid point somewhere in the middle of the points array. So, it is very important to check the size of the curveSegments array upon return to be sure that any subcurves that are created are properly dealt with.To use the pointer(s) in the curveSegments array, the calling application will need to cast the pointer(s) to the appropriate object type(s). For this function, the objects pointed to by the pointers in the curveSegments array are usually going to be of the same class as the original curve. However, this is not a requirement. To be safe, the pointers should be cast using the appropriate class's cast method.Returns Acad::eOk if successful.If points is empty or any of the points in points are not on the curve, then Acad::eInvalidInput is returned. As mentioned above, it is possible for this ErrorStatus to be returned and still have some subcurve pointers appended to the curveSegments array.For the AutoCAD built-in classes that use ShapeManager (AcDbEllipse, AcDbSpline, AcDbBody, AcDbRegion, and AcDb3dSolid), Acad::eGeneralModelingFailure is returned if an error occurs in the ShapeManager modeler.Other ErrorStatus return values are implementation-dependent.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getSplitCurvesAtParam (self, param: float)-> list :
      '''                             '''
    ...
    def getSplitCurvesAtParams (self, params: list)-> list :
      '''                             '''
    ...
    def getSplitCurvesAtPoint (self, point: PyGe.Point3d)-> list :
      '''                             '''
    ...
    def getSplitCurvesAtPoints (self, points: list)-> list :
      '''                             '''
    ...
    def getStartParam (self)-> float :
      '''This function returns with startParam set to the start parameter on the curve.Returns Acad::eOk if successful.Returns Acad::eNotImplemented in the default implementation.'''
    ...
    def getStartPoint (self)-> PyGe.Point3d :
      '''This function returns with startPoint set to the start point (in WCS coordinates) of the curve.Returns Acad::eOk if successful, and Acad::eNotImplemented in the default implementation.'''
    ...

    @overload
    def getStationAtPoint (self, station: PyGe.Point2d)-> tuple[Any,...] : ...
    @overload
    def getStationAtPoint (self, station: PyGe.Point2d,fromStation: float, toStation: float)-> tuple[Any,...] : ...
    def getStationAtPoint (self, *args, **kwargs)-> tuple[Any,...] :
      '''Overloads:
    - station: PyGe.Point2d
    - station: PyGe.Point2d,fromStation: float, toStation: float
    '''
    ...
    def getStretchPoints (self)-> list :
      '''Function usageThis function is not intended to be called by ObjectARX applications. However, it is possible to do so (for example, as a pass-through from the getGripPoints() method).Function implementation in derived classesThis function should append to the stretchPoints array any points that are to treated as stretch points for the entity.Stretch points are used by the stretch command within AutoCAD. Any stretch points that are within the crossing selection window during the stretch command, will be moved by whatever amount the user decides to "stretch" the selected entities. Any stretch points not in the crossing selection window will be left alone. This combination of some stretch points moving while others do not is what "stretches" the entity. If all stretch points are in the crossing window, then the entity is moved instead of stretched.The stretchPoints array is passed to all entities involved in the stretch operation, so the array may already contain stretch points for other entities. Therefore it is very important to append the new points rather than assigning them to any existing elements in the array.When finished appending all desired stretch points, return Acad::eOk. If anything other than Acad::eOk is returned, then this entity's stretch points will be ignored by the stretch operation.Default implementationCalls the AcDbEntity::getGripPoints() method. So, unless the entity needs to have stretch points that are different from the grip points, there is no need to override this method.'''
    ...
    def getSubentPathsAtGsMarker (self, type: PyDb.SubentType, gsMark: int, pickPoint: PyGe.Point3d, viewXform: PyGe.Matrix3d)-> list[PyDb.FullSubentPath] :
      '''Entities use various graphic primitives defined in AcGi to draw themselves. Part of this mechanism is the ability to associate an integer identifier called a graphics system marker (or, GS marker) with each primitive or with groups of primitives. Through the use of certain selection mechanisms, the GS marker for the actual subentity selected on screen can be obtained and, along with some other information passed into this function, can be used to create one or more AcDbFullSubentPath objects, each one representing a subentity and providing a more complete description of the subentity and its environment. These AcDbFullSubentPath objects can be used by several other functions for various purposes such as highlighting or unhighlighting the subentities on screen.Function usageIf the entity (of which the subentity is a part) is directly owned by the model or paper space BlockTableRecords, then leave out numInserts and entAndInsertStack so that their default value will be used.Typically the GS marker is obtained via the use of ads_ssget() followed by ads_ssnamex() (see the ObjectARX Developer's Guide for more information on this).The pickPoint can be obtained from ads_ssnamex() as well (it's the first group 5009 in the returned list).The viewXform can be calculated using the ads_trans() function on the vectors (1,0,0), (0,1,0), and (0,0,1) to translate them from DCS to WCS. The translations of these three vectors (with an extra 0 appended on to the end of each) would be used as the first three rows of the matrix. The last row is not used so it can be left as is. This argument is not used by any of the AutoCAD built-in entities.If the entity is nested inside one or more block definitions, then the numInserts and entAndInsertStack arguments must also be filled in with non-zero or non-null values. If they are not filled in, then this function will fail and return an error status. One way to get the necessary object IDs is to use ads_nentselp() to obtain the list of ads_names of the container objects. This list must then be converted to object IDs and reversed.Upon return, the subentPaths argument will point to a dynamically allocated array of one or more AcDbFullSubentPath objects. The numPaths argument will contain the number of AcDbFullSubentPath objects being returned.The calling application is responsible for deallocating the memory used by the subentPaths array. The C++ delete [ ] should be used.Return values for this function may vary depending on how the function has been implemented (see below).Function implementation in derived classesEntity classes which do not set GS markers probably should not implement this function since the GS marker is the primary (and often the only) means of subentity distinction.When implemented, this function must use the material provided in type, gsMark, pickPoint, viewXform, numInserts, and entAndInsertStack to determine which subentity or subentities meet the criteria in these arguments. Next it must create a dynamically allocated array of AcDbFullSubentPaths (using the C++ new operator) with one element for each subentity determined in the first step. Finally it must fill in each AcDbFullSubentPath object in the array with the information appropriate to the subentity it will represent.If numInserts == 0 and entAndInsertStack == NULL, it's important to check to be sure that the entity's owner is indeed the model or paper space BlockTableRecord. This can be done by using the entity's ownerId() method to obtain the objectId of its owner, and then opening up that object and using its name() method to obtain its name string. If the owner is not the model or paper space BlockTableRecord, and numInserts == 0 or entAndInsertStack == NULL, or both, then the input data is invalid and this function should set numPaths to 0, set subentPaths to NULL and then return the error status Acad::eInvalidInput.Each AcDbFullSubentPath object has two parts, an array of objectIds containing all the container objects, and an embedded AcDbSubentId object which in turn has two elements: an index value and a SubentityType.If the "main" entity (the entity on which this function is being called) is not nested within BlockReferences (that is, numInserts == 0 and entAndInsertStack == NULL), then the objectId array should contain only the objectId of the "main" entity. If the "main" entity is nested in one or more BlockReferences, then the AcDbObjectIdArray is the same as entAndInsertStack, so copying the entAndInsertStack elements into the AcDbObjectIdArray is all that's required.The SubentType data item within the embedded AcDbSubentId should be set the same as type.The index data item within the embedded AcDbSubentId can be any value you wish (it is often simply the GS marker), but if implemented, the following functions must be able to interpret them to determine the corresponding GS marker(s) or subentity (or subentities):getGsMarkersAtSubentPath()subentPtr()The pickPoint and viewXform arguments are provided as extra aids (if necessary) in determining which subentity is involved. For example, some entity types might display differently depending on the display viewpoint. The viewXform transformation matrix can be used in such cases.The viewXform argument provides a transformation matrix to transform from WCS (World Coordinate System) to DCS (display coordinate system).The display coordinate system is oriented such that the positive Z axis is coming out of the display screen towards the user, the positive X axis is horizontally from left to right on screen, and the positive Y axis is vertically upwards on screen.So, if the current viewpoint is at (1,0,0) (the viewer is always looking towards (0,0,0)) then the viewXform matrix would be:0 1 0 00 0 1 01 0 0 00 0 0 1In this matrix the last row and the last column are not used. Notice also that the third row is the DCS Z axis in WCS coordinates (which is the WCS version of the AutoCAD VIEWPOINT system variable).When this function returns, the return code to use is completely up to the implementer, but to be consistent with other existing entity class implementations of this function the following should be used:If the function succeeds, it should return Acad::eOk.If an invalid or unsupported SubentType is passed in, then numPaths should be set to 0, subentPaths should be set to NULL, and Acad::eWrongSubentityType should be returned.If an invalid GS marker (or any other data item that turns out to be needed) is passed in, then numPaths should be set to 0, subentPaths should be set to NULL, and Acad::eInvalidInput should be returned.Default implementationImmediately returns Adesk::eNotApplicable.'''
    ...
    def getTransformedCopy (self, matrix3d: PyGe.Matrix3d)-> PyDb.Entity :
      '''Function usageThis function creates a clone of the entity, applies the xform transformation matrix to the clone, and then returns with pEnt pointing to the transformed clone.Returns Acad::eOk if successful.If xform is a non-uniform scaling matrix or non-orthogonal then Acad::eCannotScaleNonUniformly or Acad::eNotImplemented is returned.WarningFor AutoCAD built-in complex entities such as polylines, this function produces a shallow clone of the header entity only, which also owns the original set of "owned" entities (such as vertices for a polyline) which are then transformed by the xform matrix. This results in a corrupt drawing (two header entities owning the same set of "owned" entities) as well as transforming the original set of "owned" entities instead of a copied set.Function implementation in derived classesThe default AcDbEntity implementation of this function should be adequate for most derived entity types. However, derived entity classes that wish to support non-uniform scaling or non-orthogonal transformations will need to override this method with their own implementation.This function must create a copy of the entity (using memory that has been dynamically allocated via the C++ new operator), apply the transformation matrix xform to the copy and then return with pEnt pointing to the transformed copy.Determining what constitutes a valid transformation matrix and whether to do a shallow clone (that is, the entity's clone() method), a deepclone (if the entity owns other objects), or no clone at all (that is, make this function a no-op), is up to the implementer.Return values for this function are also up to the implementer, but to be consistent with other existing classes the following is recommended:If the function succeeds, it should return Acad::eOk.If the function is to be a no-op, it should return Acad::eNotImplementedIf non-uniform scaling is not to be supported and a non-uniform scaling matrix is passed in, then either Acad::eCannotScaleNonUniformly or Acad::eNotImplemented should be returned.Default implementationIf the entity is uniformly scaled and orthogonal, AcDbEntity::getTransformedCopy will call the entity's clone() method to create a clone of the entity, then call AcDbEntity::transformBy() on the clone, and then return with pEnt set to point to the transformed clone. If xform is a non-uniformly scaled or a non-orthogonal matrix, then this function will return Acad::eNotImplemented.'''
    ...
    def getUnorderedElementIds (self)-> list :
      '''                             '''
    ...
    def handOverTo (self, newObject: PyDb.DbObject, keepXData: bool, keepExtDict: bool)-> None :
      '''This function provides the ability to exchange a non-database-resident object (NDBRO) in place of an existing database-resident object (DBRO) while retaining the objectId, handle, and reactor list of the DBRO. An example of this situation is when the BREAK command is used to break a circle into one or two arc segments. AcDbArc is a completely different class from AcDbCircle, so a new AcDbArc object must be substituted in place of the AcDbCircle object that is there now, yet the arc must get the handle and objectId that the circle has.To use the handOverTo() function, the object to be replaced (the AcDbCircle in the example) must be open AcDb::kForWrite. The object's handOverTo() function is called with newObject pointing to a non-database-resident object that replaces it (the AcDbArc in the example).keepXData is set to Adesk::kTrue if the xdata is to be retained or Adesk::kFalse if the xdata is to be thrown out.keepExtDict is set to Adesk::kTrue if the extension dictionary and its contents are to be retained, or set to Adesk::kFalse if the extension dictionary and its contents are to be thrown out.Once returned from this function, the replacement object (the AcDbArc in the example) is open for AcDb::kForWrite and must have its close() member called to commit the change and close out Undo recording. Then it's up to the ObjectARX application to delete the old object (the AcDbCircle in the example) from memory since it's no longer database-resident.Returns Acad::eObjectToBeDeleted if the operation is successful. If newObject is pointing to an object that is already in the database, or the object invoking handOverTo() is not database-resident, then Acad::eIllegalReplacement is returned.'''
    ...
    def hasFields (self)-> bool :
      '''Returns true if the object has one or more PyDb.Field Objects. Otherwise returns false.'''
    ...
    def hasPersistentReactor (self, id: PyDb.ObjectId)-> bool :
      '''This method returns true if objId is the object ID of a reactor attached to this object. Otherwise, it returns false.'''
    ...
    def hasXData (self, appname: str)-> bool :
      '''                             '''
    ...
    def highlight (self, path: PyDb.FullSubentPath = None, highlightAll : bool = False)-> None :
      '''Function usageThis function uses the AcDbFullSubentPathid to determine which subentity in the entity is desired. It then highlights that subentity on screen. If no AcDbFullSubentPath argument is provided, then the entire entity will be highlighted.Typically, the AcDbFullSubentPath object passed in via subId is obtained from the entity's AcDbEntity::getSubentPathsAtGsMarker() method. This guarantees that it is fully and properly filled in.This function uses the entity's getGsMarkersAtSubentPath() method to get the GS markers associated with subId. If that function does not return Acad::eOk, then this function will fail and return whatever ErrorStatus was returned by getGsMarkersAtSubentPath().If this function succeeds, then it returns Acad::eOk.It is not necessary to balance each highlight() function call with a corresponding call to unhighlight(). Calling the unhighlight() function will unhighlight the entity designated by subId regardless of how many times the highlight function has been called on it.WarningIf the entity on which this method is called has its graphics queued for regeneration (that is, changes have been made to the entity but have not yet been reflected on screen), then this method will not cause a highlight to occur. Also, calling this method on an entity that's open for write and whose graphics are queued for regeneration may terminate AutoCAD.To avoid this limitation, before calling highlight(), you should flush the entity's graphics by either calling the entity's draw() method, or calling the AcTransactionManager::flushGraphics() function.Function implementation in derived classesThe AcDbEntity::highlight() implementation does all the work necessary to highlight any subentities that correspond to the subIdFullSubentPath. So, there is no need to override this method unless you wish to do some pre-or post-processing, or you wish to disable the ability to highlight subentities.If this method is overridden and it is supposed to highlight subentities, then the AcDbEntity::highlight() method will need to be invoked at some point within this function in order to do the actual highlighting.Within the AcDbEntity::highlight() method, the getGsMarkersAtSubentPath() method of this entity is called to translate the FullSubentPath into the corresponding GS markers. So, if this function is to succeed, the getGsMarkersAtSubentPath() method needs to be implemented as well.For more information on the subIdAcDbFullSubentPath argument, see the documentation on the getGsMarkersAtSubentPath() or getSubentPathsAtGsMarker() methods.'''
    ...
    def id (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def insertLineFixed (self, start: PyGe.Point2d, end: PyGe.Point2d, prevId: int)-> int :
      '''                             '''
    ...

    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, thisGsMarker : int, otherGsMarker : int)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane, thisGsMarker : int, otherGsMarker : int)-> list : ...
    def intersectWith (self, *args, **kwargs)-> list :
      '''Overloads:
    - entity: PyDb.Entity, intType : PyDb.Intersect
    - entity: PyDb.Entity, intType : PyDb.Intersect, thisGsMarker : int, otherGsMarker : int
    - entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane
    - entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane, thisGsMarker : int, otherGsMarker : int
    
	-Function usageIt finds the intersections of the entity pointed to by pEnt and all the edges of the bounding box of this entity.The intType is used to determine how to deal with extending the two entities in order to calculate intersections. The possible AcDb::Intersect values are:AcDb::kOnBothOperandsDo not extend either entity. This results in only calculating intersections where the two entitys' geometry actually intersectAcDb::kExtendThisExtend this entity (if necessary) when calculating intersections, but do not extend the pEnt entity.AcDb::kExtendArgExtend the pEnt entity (if necessary) when calculating intersections, but do not extend this entity.AcDb::kExtendBothExtend both the pEnt entity and this entity (if necessary) when calculating intersectionsAny intersection points found are appended to the points array. All points are in WCS coordinates.The thisGsMarker and otherGsMarker arguments are intended to provide this function with information to allow it to localize the search for intersections to be between specific subentities. However, this function is not required to make use of either of these arguments (most, if not all, of the AutoCAD built-in entity classes do not). When calling this function, either or both of these arguments may be 0 in order to indicate that they should be ignored.If this function is successful it returns Acad::eOk. Return values for error conditions are dependent on the implementation of this function in the classes involved.Function implementation in derived classesThis function should do all it can to find all intersection points between the entity it's being called on and the entity pointed to by pEnt. All intersection points found should be appended to the points array. All such points must be in WCS coordinates.When implementing the intersection calculation portion of this function you should take a good look at the AcGe classes to see if they can provide any useful functionality to help in finding intersections with the geometric primitives that make up the entity this function is being called on and the pEnt entity. For example, the AcGeCurve3d class has an isOn() method that will indicate if a supplied point is on the curve and the AcGeCircArc3d class has several intersectWith() methods to find intersections with other AcGe types.If the pEnt entity is a type not recognized by this function, it is quite reasonable to call the pEnt entity's intersectWith() method passing in a pointer to this entity as the "pEnt", and all the other arguments passed into this function (remembering to convert the intType argument If necessary) to see if that entity can determine any intersection points. This is what the AutoCAD built-in classes do.Also, don't forget to take into account the intType value. The intType tells you which, if any, of the two entities should be extended to find "apparent" intersections. It is not required that apparent intersection be supported, but if it is not, then an appropriate ErrorStatus value should be returned to indicate that the call failed.The thisGsMarker and otherGsMarker arguments are provided to allow this function to determine exactly which subentities are involved in the intersection operation (for example, if this function is being called by AutoCAD as part of an intersection Osnap operation these arguments would indicate which subentities are within the osnap pickbox). For these arguments, a value less than or equal to zero indicates that that argument should not be used.If this function completes successfully (even if no intersection points are found), it should return Acad::eOk. Determining what is considered an error and what ErrorStatus return code to use for any such errors are up to the implementer -- there are no conventions in this regard.Default implementationImmediately returns Acad::eNotImplemented.-'''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isAProxy (self)-> int :
      '''Returns Adesk::kTrue if the object is a proxy object or entity. Otherwise returns Adesk::kFalse.'''
    ...
    def isAcDbObjectIdsInFlux (self)-> int :
      '''This function refers to a condition that occurs during deep clone operations. It returns Adesk::kTrue when the cloned objects' IDs have not yet been translated and thus cannot be used in any operations on the objects. This condition normally occurs only during AcEditorReactor::beginDeepCloneXlation, AcDbObject::deepClone, or AcDbObject::wblockClone. Any operations that involve AcDbObjectId references, such as symbol table records, should be postponed until after endDeepClone. AcDbObject::subClose is never called on any objects whose IDs are in flux.'''
    ...
    def isAnnotative (self)-> PyDb.AnnotativeStates :
      '''                             '''
    ...
    def isCancelling (self)-> int :
      '''Returns Adesk::kTrue if the object is currently in the middle of a cancel() call (that is, an open is being canceled and all changes made are being rolled back). Otherwise returns Adesk::kFalse.'''
    ...
    def isClosed (self)-> int :
      '''This function returns Adesk::kTrue if, and only if, the curve is closed; that is, its start point is identical to its end point. Otherwise, it returns Adesk::kFalse.Returns Acad::kFalse in the default implementation.'''
    ...
    def isEraseStatusToggled (self)-> int :
      '''Returns Adesk::kTrue if the object's erase bit has been toggled since it was opened. Otherwise returns Adesk::kFalse.'''
    ...
    def isErased (self)-> int :
      '''Returns Adesk::kTrue if the object is currently erased. Otherwise returns Adesk::kFalse.'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isModified (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called). Otherwise returns Adesk::kFalse.'''
    ...
    def isModifiedGraphics (self)-> int :
      '''Returns Adesk::kTrue if the object is derived from AcDbEntity and has had either an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called), or its recordGraphicsModified() function called with an Adesk::kTrue argument value.Otherwise it returns Adesk::kFalse.'''
    ...
    def isModifiedXData (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called) and has then had its setXData() method called. Otherwise it returns Adesk::kFalse.'''
    ...
    def isNewObject (self)-> int :
      '''Returns Adesk::kTrue if the object has not yet been closed since it was first created. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifyEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForNotify. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifying (self)-> int :
      '''Returns Adesk::kTrue if the object is in the process of sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isPeriodic (self)-> int :
      '''This function returns Adesk::kTrue if, and only if, the curve has an infinite range in both directions and there is a period value T such that there is a point on curve at (u + T) = point on curve (u), for any parameter u. If the curve is not periodic, then Adesk::kFalse is returned.The default implementation returns Adesk::kFalse.'''
    ...
    def isPersistent (self)-> int :
      '''                             '''
    ...
    def isPlanar (self)-> int :
      '''This function returns Adesk::kTrue if and only if there is a plane that contains the entity. Otherwise Adesk::kFalse is returned.'''
    ...
    def isReadEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForRead. Otherwise returns Adesk::kFalse.'''
    ...
    def isReallyClosing (self)-> int :
      '''Returns true if calling close() at this time would really close the object completely. For example, if the object is not in a transaction, and is open for read with only one reader, then Adesk::kTrue would be returned. If, on the other hand, the object is in a transaction, then Adesk::kFalse would be returned.'''
    ...
    def isTransactionResident (self)-> int :
      '''Returns Adesk::kTrue if the object is currently part of a transaction. Otherwise returns Adesk::kFalse.'''
    ...
    def isUndoRecordingDisabled (self)-> bool :
      '''Returns true if undo recording is disabled.'''
    ...
    def isUndoing (self)-> int :
      '''Returns Adesk::kTrue if the object is involved in an Undo operation at this time. Otherwise returns Adesk::kFalse.'''
    ...
    def isWriteEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForWrite and is not currently sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def lastElementId (self)-> int :
      '''                             '''
    ...
    def layer (self)-> str :
      '''This function returns a copy of the name string in the AcDbLayerTableRecord object referenced by the entity.The calling application is responsible for deallocating the memory used by the returned string. The acutDelString() function is recommended.WarningCalling this function before the entity has had its referenced layer object ID set (that is, it's still set to AcDbObjectId::kNull) will terminate AutoCAD. If the referenced layer objectId is AcDbObjectId::kNull when the entity is added to a database, it will be set to the object ID of the database's current default layer.'''
    ...
    def layerId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the AcDbLayerTableRecord referenced by the entity. If the layerId has not been set yet, then AcDbObjectId::kNull is returned.'''
    ...
    def length (self)-> float :
      '''                             '''
    ...
    def lineElementColor (self)-> int :
      '''                             '''
    ...
    def lineWeight (self)-> PyDb.LineWeight :
      '''This function returns the AcDb::LineWeight of the entity.'''
    ...
    def linetype (self)-> str :
      '''This function returns a copy of the name string in the AcDbLinetypeTableRecord object referenced by the entity.The calling application is responsible for deallocating the memory used by the returned string. Either the C++ delete [ ] or the C free() function may be used.Warning Calling this function before the entity has had its referenced linetype object ID set (that is, it's still set to AcDbObjectId::kNull) will terminate AutoCAD. If the referenced linetype objectId is AcDbObjectId::kNull when the entity is added to a database it will be set to the object ID of the database's current default linetype.'''
    ...
    def linetypeId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the AcDbLinetypeTableRecord referenced by the entity. If the linetypeId has not been set yet, then AcDbObjectId::kNull will be returned.'''
    ...
    def linetypeScale (self)-> float :
      '''This function returns the linetype scale factor for the entity.'''
    ...
    def list (self)-> None :
      '''Function usageThis function is intended to be called from AutoCAD whenever the entity is selected during the LIST command. However, it can be called from ObjectARX applications if desired.This function will print entity specific information to the AutoCAD command line.Function implementation in derived classesWhen implementing this function in a derived class, the first thing that should be done in the function is to make a call to assertReadEnabled(). The next thing to do is to call the parent class's list() method to allow the parent class to list it's information (the parent class should in turn call its parent class first and so on up the inheritance chain until AcDbObject is reached. This way all the entity's information will be properly printed out in order). Once the parent class's list function has been called then a series of ads_printf() calls can be used to list whatever information is desired.Default implementationLists out the entity's DXF name, the layer, the space the entity resides in (model or paper), and the entity's handle.'''
    ...
    def material (self)-> str :
      '''Returns the material name.'''
    ...
    def materialId (self)-> PyDb.ObjectId :
      '''Returns the ID of the associated AcDbMaterial object.'''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def nextLineElementId (self, Id: int)-> int :
      '''                             '''
    ...
    def objectId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the object. If the object is not yet database-resident, then the returned objectId will be set to AcDbObjectId::kNull.'''
    ...
    def ownerId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the owner of the object. If the object does not yet have an owner, or the ownerId data member has not yet been set using AcDbObject::setOwnerId, then the returned objectId will be set to AcDbObjectId::kNull.Appending the object to a BlockTable record, a symbol table, or a dictionary automatically calls AcDbObject::setOwnerId.'''
    ...
    def plotStyleName (self)-> str :
      '''This function returns a copy of the plotStyleName string of the entity. The caller is responsible for deallocating the returned string.The plotStyleName value is used for DXF group code 390.'''
    ...
    def previousLineElementId (self, Id: int)-> int :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def receiveShadows (self)-> bool :
      '''Returns a boolean value indicating whether this entity can receive shadows.'''
    ...
    def recordGraphicsModified (self)-> None :
      '''This method sets the entity's state to indicate whether or not the entity should be updated on screen when it is closed. If the entity is set not to update, then any changes made will appear the next time the entity is regenerated.If setModified is false and the entity is currently set to update its graphics on close (which is its default state), then this function sets the entity so that it will not update on screen when it is closed and objectModified notification is sent to all entity type reactors attached to the entity. If setModified is false and the entity is already set not to update its graphics on close, then this function simply returns.If setModified is true, then the entity is set to update on screen when it is closed.'''
    ...
    def releaseExtensionDictionary (self)-> None :
      '''Removes the object's extension dictionary (that is, removes the object as the owner of the dictionary object) if it exists and is empty. Once removed, this function calls the dictionary's erase() method. Any reactors attached to the extension dictionary receive normal notification appropriate to an open for write, erase, close sequence.Returns Acad::eOk if successful.If the dictionary is not empty, then this function fails and returns Acad::eContainerNotEmpty.'''
    ...
    def removeContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def removeField (self, id: str|PyDb.ObjectId)-> None :
      '''Removes the specified field.Returns Acad::eOk if successful. Otherwise, returns an AutoCAD error status.'''
    ...
    def removePersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Removes the persistent reactor specified by objId from the reactor list of the object. The object must be open AcDb::kForWrite to be able to execute this function.Returns Acad::eOk if successful. If the object is currently sending notification and is not open AcDb::kForWrite, then Acad::eWasNotifying is returned.'''
    ...
    def removeReactor (self, reactor: PyDb.EntityReactor)-> None :
      '''                             '''
    ...
    def reverseCurve (self)-> None :
      '''Reverses the parameterization of the curve. The start becomes the end and visa versa.'''
    ...
    def rolloverHit (self, nSubentId: int, nMouseFlags: int, bReset: bool)-> int :
      '''                             '''
    ...
    def setAcDbObjectIdsInFlux (self)-> None :
      '''This function must be called on any newly created objects in AcDbObject::deepClone or AcDbObject::wblockClone. It indicates that reference object IDs are not yet pointing to the correct objects. The references can be translated only when the entire deep clone operation is complete. The flag is cleared at that time.'''
    ...
    def setAnnotative (self, state : PyDb.AnnotativeStates)-> None :
      '''                             '''
    ...
    def setAttributes (self, traits: PyGi.DrawableTraits)-> int :
      '''                             '''
    ...
    def setCastShadows (self, val: bool)-> None :
      '''Sets the property to indicate whether the entity can cast shadows.'''
    ...
    def setColor (self, clr: PyDb.AcCmColor, dosubents : bool=True, db : PyDb.Database='current')-> None :
      '''Function usageThis method sets the entity's color to the color specified by color. If the entity owns subentities and doSubents == Adesk::kTrue, the color change is applied to the subentities as well. Custom classes may override this method.'''
    ...
    def setColorIndex (self, clr: int, dosubents : bool=True)-> None :
      '''Function usageThis method sets the entity's color to the AutoCAD color index color. If the entity owns subentities and doSubents == Adesk::kTrue, then the color index change will be applied to the subentities as well.'''
    ...
    def setCurveElementColor (self, colACI: int)-> bool :
      '''                             '''
    ...
    def setDatabaseDefaults (self, db: PyDb.Database = 'current')-> None :
      '''This function sets the entity's:ColorLayerLinetypeLinetype scaleVisibilityPlot style nameLine weightto the default values of the database indicated by pDb: If pDb == NULL, then the current database in the AutoCAD editor is used.'''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...
    def setElementExtensionColor (self, colACI: int)-> bool :
      '''                             '''
    ...

    @overload
    def setField (self, field: PyDb.Field)-> PyDb.ObjectId : ...
    @overload
    def setField (self, propName: str, field: PyDb.Field)-> PyDb.ObjectId : ...
    def setField (self, *args, **kwargs)-> PyDb.ObjectId :
      '''Overloads:
    - field: PyDb.Field
    - propName: str, field: PyDb.Field
    '''
    ...
    def setFromAcGeCurve (self, curve: PyGe.Curve3d, normal: PyGe.Vector3d = PyGe.Vector3d.kZAxis, tol: PyGe.Tol = 'default')-> None :
      '''This is setFromAcGeCurve, a member of class AcDbCurve.'''
    ...
    def setLayer (self, val: str|PyDb.ObjectId, dosubents : bool=True, allowHiddenLayer : bool=False)-> None :
      '''This method sets entity to reference the AcDbLayerTableRecord identified by the name specified in newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the layer change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.'''
    ...
    def setLineElementColor (self, colACI: int)-> bool :
      '''                             '''
    ...
    def setLineWeight (self, val: PyDb.LineWeight, dosubents : bool=True)-> None :
      '''This method sets the entity to use lineweight. If the entity owns subentities and doSubents == Adesk::kTrue, then the line weight change will be applied to the subentities as well.Returns Acad::eOk if successful.Function implementation in derived classesIf this function is overridden and wishes to set the line weight of the entity, then it must call AcDbEntity::setLineWeight() passing on the lineweight and doSubents arguments.It is also possible for this function's implementation to deal directly with any subentities and pass a doSubents value of Adesk::kFalse to AcDbEntity:: setLineWeight().If the line weight setting operation is successful, then this function should return Acad::eOk. If lineweight is not an acceptable value, then this function should return Acad::eInvalidInput. Any other error return values are up to the implementer.'''
    ...
    def setLinetype (self, val: str|PyDb.ObjectId, dosubents : bool=True)-> None :
      '''Function usageThis method sets the entity to reference the AcDbLinetypeTableRecord with the name specified in newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the linetype change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.'''
    ...
    def setLinetypeScale (self, val: float, dosubents : bool=True)-> None :
      '''This method sets the entity to use newval as its linetype scale factor. newVal must be nonnegative. If the entity owns subentities and doSubents == Adesk::kTrue, then the linetype scale change will be applied to the subentities as well.'''
    ...
    def setMaterial (self, val: str|PyDb.ObjectId, dosubents : bool=True)-> None :
      '''This method sets the material reference to the specified material. The specified name must correspond to an existing AcDbMaterial object.Returns Acad::eOk when successful'''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setOwnerId (self, owner: PyDb.ObjectId)-> None :
      '''Sets the ownerId data member of the object to be objId, thus establishing a "backpointer." This backpointer is used by WBLOCK to be sure all necessary objects are written out.Returns Acad::eOk if successful.'''
    ...

    @overload
    def setPlotStyleName (self, /)-> None : ...
    @overload
    def setPlotStyleName (self, nameType: PyDb.PlotStyleNameType, doSubents: bool)-> None : ...
    @overload
    def setPlotStyleName (self, nameType: PyDb.PlotStyleNameType, newId: PyDb.ObjectId, doSubents: bool)-> None : ...
    def setPlotStyleName (self, *args, **kwargs)-> None :
      '''Overloads:
    - None: Any
    - nameType: PyDb.PlotStyleNameType, doSubents: bool
    - nameType: PyDb.PlotStyleNameType, newId: PyDb.ObjectId, doSubents: bool
    
	-This function searches the PlotStyleName dictionary for an entry with the name that matches newName and if found, sets the entity to use that plotStyleName entry. Because a lookup in the PlotStyleName dictionary is required, the entity must be database-resident for this method to succeed. The names ByLayer and ByBlock are allowed as well as user-defined names.If the entity owns subentities and doSubents == Adesk::kTrue, then the change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.Returns Acad::eOk if successful. If the entity is not database-resident, then Acad::eNoDatabase will be returned. If there is no entry in the PlotStyleName dictionary for newName, then Acad::eKeyNotFound will be returned.The plotStyleName value is used for DXF group code 390.-'''
    ...
    def setPropertiesFrom (self, entity: PyDb.Entity, dosubents : bool=True)-> None :
      '''This method copies theColorLayerLinetypeLinetype scaleVisibilityvalues from the entity pointed to by pEntity into this entity. If the entity owns subentities and doSubents == Adesk::kTrue, then the property changes will be applied to the subentities as well.Returns Acad::eOk if successful.'''
    ...
    def setReceiveShadows (self, val: bool)-> None :
      '''Sets the property indicating whether this entity can receive shadows.'''
    ...
    def setSpiralElementColor (self, colACI: int)-> bool :
      '''                             '''
    ...
    def setStationEquations (self, val: PyBrxCv.CvStationEquations)-> bool :
      '''                             '''
    ...
    def setStyle (self, style: int)-> bool :
      '''                             '''
    ...
    def setTangentExtensionColor (self, colACI: int)-> bool :
      '''                             '''
    ...
    def setVisibility (self, val: PyDb.Visibility, dosubents : bool=True)-> None :
      '''This method sets the visibility of an entity to the value specified by newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the visibility change will be applied to the subentities as well.'''
    ...
    def setXData (self, xdata: list)-> None :
      '''Each regapp sublist (delimited by a resbuf with restype == 1001 and resval.rstring == a valid regappName string) within the resbuf chain pointed to by xdata, is placed in the xdata area of the object. If any of the regappNames in xdata are already present in the xdata area of the object, then that regappName's existing data on the object is overwritten by that regappName's new data in xdata.All resbufs with restype == 1001 must have valid regappNames for the database the object resides in (that is, the regappNames must be in the APPID table of the database).Only valid xdata group codes (1000--1071) are accepted in the restype fields of the resbufs in xdata.No "-3" group code is necessary, and in fact, is not accepted. So, the first element in the resbuf chain must be a 1001 group code with a resval.rstring set to a regappName that's already registered in the regapp table. To register a regappName, use the acdbRegApp() function.To remove an appName (and its xdata) from an object, just use a resbuf with restype == 1001, resval == and no data resbufs following it (that is, either its rbnext == NULL or the next resbuf is another 1001)This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If this function is overridden, then it should supermessage its parent in order to invoke the built-in mechanism to add the xdata to the object.Returns Acad::eOk if the xdata is successfully added to the object. If there is insufficient space in the xdata area of the object, then Acad::eXdataSizeExceeded is returned. If any of the regappNames in xdata are not in the APPID table, then Acad::eRegappIdNotFound is returned.'''
    ...
    def snoop (self,  filer : PyDb.SnoopDwgFiler)-> None :
      '''                             '''
    ...
    def spiralElementColor (self)-> int :
      '''                             '''
    ...
    def stationEquations (self)-> PyBrxCv.CvStationEquations :
      '''                             '''
    ...
    def style (self)-> int :
      '''                             '''
    ...
    def swapIdWith (self, otherId: PyDb.DbObject, swapXdata: bool, swapExtDict: bool)-> None :
      '''This function swaps objectIds and handles between the object specified by otherId and the object invoking this function. Both objects must currently be database-resident and must reside in the same database. If swapXdata == Adesk::kTrue, then the objects swap extended entity data as well. If swapExtDict == Adesk::kTrue, then the objects swap extension dictionaries also.If the object specified by otherId or the object invoking this function are not database-resident, then Acad::eNoDatabase is returned. If both objects involved are not in the same database, then Acad::eWrongDatabase is returned.'''
    ...
    def tangentExtensionColor (self)-> int :
      '''                             '''
    ...
    def transformBy (self, matrix3d: PyGe.Matrix3d)-> None :
      '''Function usageThis function provides a means by which AutoCAD and ObjectARX applications can ask the entity to apply a transformation matrix (xform) to itself.Each entity class must implement this function, so restrictions on what types of transformations are supported are up to the implementer of the entity class. The AutoCAD built-in entity classes for entity types that existed before R13 (that is, all the classes listed in the header file dbents.h such as AcDbCircle, AcDbLine, AcDbArc, AcDb2dPolyline, etc.) require that the transformation matrix represent a uniformly scaling orthogonal transformation (if it is not, then Acad::eCannotScaleNonUniformly will be returned). Other AutoCAD built-in classes have no restrictions.Returns Acad::eOk if successful. Return values for errors are implementation-dependent.Function implementation in derived classesThis function must apply the transformation matrix xform to the entity and change the entity's state to reflect the transformation. It is completely up to the implementer as to how to apply the transformation. It is also up to the implementer to decide what, if any, restrictions will be placed on the type of transformations supported. If any restrictions are desired, then it's up to the implementation of this function to enforce them.If your derived class implements transformBy() without calling the base class, you must call AcDbObject:: xDataTransformBy() or your Xdata will not be transformed.If this function successfully transforms the entity, then it should return Acad::eOk.Return values for error conditions are completely up to the implementer of this function. However, if the error is caused by a non-uniformly scaling or non-orthogonal matrix, then to be consistent with other entities that have this restriction, it is recommended that Acad::eCannotScaleNonUniformly be returned.'''
    ...
    def update (self)-> bool :
      '''                             '''
    ...
    def upgradeFromNotify (self, wasWritable: bool)-> None :
      '''Upgrades the object from being at least open AcDb::kForNotify to being open both AcDb::kForNotify and AcDb::kForWrite. The wasWritable argument is set to Adesk::kTrue if the object was already open for write, otherwise it's set to Adesk::kFalse. The wasWritable value should be saved to be passed into the downgradeToNotify() call later.This function must be followed at some point by a call to downgradeToNotify() with no open() (in any of its forms) or close() calls in between.This method should only be called from within other methods of the same object it is being called from. In other words, this method is intended to be used by an object to change it's own open status so that it can safely modify itself.upgradeFromNotify() and downgradeToNotify() call pairs are not nestable.Returns Acad::eOk if successful. If the object is not currently open AcDb::kForNotify, then Acad::eNotApplicable is returned. If the object is currently in the process of actually sending notification (that is, isNotifying() returns Adesk::kTrue), then Acad::eWasNotifying is returned.'''
    ...
    def upgradeOpen (self)-> None :
      '''If the object is currently open AcDb::kForRead with only one reader, then this function upgrades the object to open AcDb::kForWrite. In the process of changing to open for write, the object is closed, thus triggering any pertinent notification.Returns Acad::eOk if successful. If the object has more than one reader, then the open status is not changed and Adesk::eHadMultipleReaders is returned. If the object is already open AcDb::kForWrite, then Acad::eWasOpenForWrite is returned. If the object is currently sending notification, then the open status is not changed and Acad::eWasNotifying is returned.'''
    ...
    def verticalAlignmentAt (self, index: int)-> PyDb.ObjectId :
      '''                             '''
    ...
    def verticalAlignmentCount (self)-> int :
      '''                             '''
    ...
    def verticalAlignmentViewAt (self, index: int)-> PyDb.ObjectId :
      '''                             '''
    ...
    def verticalAlignmentViewCount (self)-> int :
      '''                             '''
    ...
    def viewportDraw (self, vpdraw: PyGi.ViewportDraw)-> None :
      '''                             '''
    ...
    def viewportDrawLogicalFlags (self, vpdraw: PyGi.ViewportDraw)-> int :
      '''                             '''
    ...
    def visibility (self)-> PyDb.Visibility :
      '''This method returns the entity's current visibility state, either AcDb::kVisible or AcDb::kInvisible.'''
    ...
    def wblockClone (self, owner: PyRx.RxObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function is almost identical to AcDbObject::deepClone, except that an AcDbWblockCloneFiler is used and ownership is not carried across database boundaries. Subcloning is based on hard owner and hard pointer connections.'''
    ...
    def worldDraw (self, wdraw: PyGi.WorldDraw)-> int :
      '''                             '''
    ...
    def xData (self, appname: str = None)-> list :
      '''Returns a linked list of resbuf structures containing a copy of the xdata for the object. If regappName == NULL is passed in, all xdata is returned, otherwise only the xdata for the specified name is returned. If not all xdata is required, but the xdata for more than one regappName is desired, then multiple calls to this member function must be made--one for each regappName.The caller of this function is responsible for releasing the memory used by the resbuf list that is returned. The most commonly used way to deallocate such a list is via the acutRelRb() function.This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If a failure accessing the xdata occurs, NULL is returned.'''
    ...
    def xDataTransformBy (self, xform: PyGe.Matrix3d)-> None :
      '''This method applies the xform transformation matrix to any XData data types 1011, 1021, 1031, 1012, 1022, 1032, 1013, 1023, 1033, 1041, and 1042 in the object's XData. See the documentation on XData for more information on the way the transformation matrix is applied to the different data types.This method should be called from within the transformBy() method on custom entities so that such entities will transform XData in the same way that the built-in AcDb entities do.Returns Acad::eOk if successful.'''
    ...
    def xmitPropagateModify (self)-> None :
      '''Within an object's close() method is a call to the object's xmitPropagateModify().The AcDbObject::xmitPropagateModify() default implementation is to inform the containing database that the object has been modified, appended to the database, or erased. The database then sends out the appropriate notification to any AcDbDatabaseReactors attached to it.Within AutoCAD, this function is used by complex entities such as polylines to allow the subentities to notify the header that they have been changed. The header can then "propagate" the notification by sending its own notification that the "complex entity" has been modified.The way this works is:The subobject class has it's xmitPropagateModify() class overridden such that it calls it's parent class's xmitPropagateModify() and also calls the owning object's recvPropagateModify().The "root" or "header" class has it's recvPropagateModify() overridden to provide an implementation that triggers "modified" notification to be sent for the "root" or "header" (which effectively represents the whole complex object).The subobject's close() triggers "modified" notification for the subobject and calls the subobject's xmitPropagateModify() function. So, when the subobject's close() is called, its xmitPropagateModify() is called. This then calls the owning object's recvPropagateModify(), which then triggers the owner to send "modified" notification.So, the result is a "modified" notification from both the subentity and the "root" or "header" entity.When overridden, this function should:Call its parent class's xmitPropagateModify() (which ultimately results in the execution of AcDbObject::xmitPropagateModify() to trigger database notification).Call its owner's recvPropagateModify() (passing in its "this" pointer) to "propagate" the notification information to the "root" owner to be sent out.'''
    ...

class CvDbHAlignmentArc(CvDbHAlignmentCurve):
    def __init__ (self)-> None :
      '''                             '''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbHAlignmentArc :
      '''                             '''
    ...
    def center (self)-> PyGe.Point2d :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def endPoint (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def endStation (self)-> float :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isClockwise (self)-> bool :
      '''                             '''
    ...
    def isCompound (self)-> bool :
      '''                             '''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isLessThan180 (self)-> bool :
      '''                             '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isSubentity (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def length (self)-> float :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def nextId (self)-> int :
      '''                             '''
    ...
    def paramLength (self)-> float :
      '''                             '''
    ...
    def parameterConstraint (self)-> PyBrxCv.HAlignmentParameterConstraint :
      '''                             '''
    ...
    def passThroughPoint1 (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def passThroughPoint2 (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def passThroughPoint3 (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def previousId (self)-> int :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def radius (self)-> float :
      '''                             '''
    ...
    def setCenter (self, pt : PyGe.Point2d)-> bool :
      '''                             '''
    ...
    def setClockwise (self, val : bool)-> bool :
      '''                             '''
    ...
    def setCompound (self, val : bool)-> bool :
      '''                             '''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...
    def setLessThan180 (self, val : bool)-> bool :
      '''                             '''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setNextId (self, val : int)-> bool :
      '''                             '''
    ...
    def setParamLength (self, val : float)-> bool :
      '''                             '''
    ...
    def setParameterConstraint (self, val : PyBrxCv.EParameterConstraint)-> bool :
      '''                             '''
    ...
    def setPassThroughPoint1 (self, pt : PyGe.Point2d)-> bool :
      '''                             '''
    ...
    def setPassThroughPoint2 (self, pt : PyGe.Point2d)-> bool :
      '''                             '''
    ...
    def setPassThroughPoint3 (self, pt : PyGe.Point2d)-> bool :
      '''                             '''
    ...
    def setPreviousId (self, val : int)-> bool :
      '''                             '''
    ...
    def setRadius (self, val : float)-> bool :
      '''                             '''
    ...
    def setTangencyConstraint (self, val : PyBrxCv.ETangencyConstraint)-> bool :
      '''                             '''
    ...
    def startPoint (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def startStation (self)-> float :
      '''                             '''
    ...
    def tangencyConstraint (self)-> PyBrxCv.HAlignmentTangencyConstraint :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.HAlignmentElementType :
      '''                             '''
    ...

class CvDbHAlignmentCurve(CvDbHAlignmentElement):
    def __init__ (self, *args, **kwargs)-> None :
      '''Raises an exception
This class cannot be instantiated from Python'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbHAlignmentCurve :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def endPoint (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def endStation (self)-> float :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isSubentity (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def length (self)-> float :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def nextId (self)-> int :
      '''                             '''
    ...
    def parameterConstraint (self)-> PyBrxCv.HAlignmentParameterConstraint :
      '''                             '''
    ...
    def previousId (self)-> int :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setNextId (self, val : int)-> bool :
      '''                             '''
    ...
    def setParameterConstraint (self, val : PyBrxCv.EParameterConstraint)-> bool :
      '''                             '''
    ...
    def setPreviousId (self, val : int)-> bool :
      '''                             '''
    ...
    def setTangencyConstraint (self, val : PyBrxCv.ETangencyConstraint)-> bool :
      '''                             '''
    ...
    def startPoint (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def startStation (self)-> float :
      '''                             '''
    ...
    def tangencyConstraint (self)-> PyBrxCv.HAlignmentTangencyConstraint :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.HAlignmentElementType :
      '''                             '''
    ...

class CvDbHAlignmentElement(CvDbSubObject):
    def __init__ (self, *args, **kwargs)-> None :
      '''Raises an exception
This class cannot be instantiated from Python'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbHAlignmentElement :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isSubentity (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def nextId (self)-> int :
      '''                             '''
    ...
    def parameterConstraint (self)-> PyBrxCv.HAlignmentParameterConstraint :
      '''                             '''
    ...
    def previousId (self)-> int :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setNextId (self, val : int)-> bool :
      '''                             '''
    ...
    def setParameterConstraint (self, val : PyBrxCv.EParameterConstraint)-> bool :
      '''                             '''
    ...
    def setPreviousId (self, val : int)-> bool :
      '''                             '''
    ...
    def setTangencyConstraint (self, val : PyBrxCv.ETangencyConstraint)-> bool :
      '''                             '''
    ...
    def tangencyConstraint (self)-> PyBrxCv.HAlignmentTangencyConstraint :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.HAlignmentElementType :
      '''                             '''
    ...

class CvDbHAlignmentLine(CvDbHAlignmentCurve):
    def __init__ (self)-> None :
      '''                             '''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbHAlignmentLine :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def endPoint (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def endStation (self)-> float :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isSubentity (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def length (self)-> float :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def nextId (self)-> int :
      '''                             '''
    ...
    def paramLength (self)-> float :
      '''                             '''
    ...
    def parameterConstraint (self)-> PyBrxCv.HAlignmentParameterConstraint :
      '''                             '''
    ...
    def passThroughPoint1 (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def passThroughPoint2 (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def previousId (self)-> int :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setNextId (self, val : int)-> bool :
      '''                             '''
    ...
    def setParamLength (self, val : float)-> bool :
      '''                             '''
    ...
    def setParameterConstraint (self, val : PyBrxCv.EParameterConstraint)-> bool :
      '''                             '''
    ...
    def setPassThroughPoint1 (self, pt : PyGe.Point2d)-> bool :
      '''                             '''
    ...
    def setPassThroughPoint2 (self, pt : PyGe.Point2d)-> bool :
      '''                             '''
    ...
    def setPreviousId (self, val : int)-> bool :
      '''                             '''
    ...
    def setTangencyConstraint (self, val : PyBrxCv.ETangencyConstraint)-> bool :
      '''                             '''
    ...
    def startPoint (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def startStation (self)-> float :
      '''                             '''
    ...
    def tangencyConstraint (self)-> PyBrxCv.HAlignmentTangencyConstraint :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.HAlignmentElementType :
      '''                             '''
    ...

class CvDbHAlignmentPI(CvDbHAlignmentElement):
    def __init__ (self)-> None :
      '''                             '''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbHAlignmentPI :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isSubentity (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def location (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def nextId (self)-> int :
      '''                             '''
    ...
    def parameterConstraint (self)-> PyBrxCv.HAlignmentParameterConstraint :
      '''                             '''
    ...
    def previousId (self)-> int :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setNextId (self, val : int)-> bool :
      '''                             '''
    ...
    def setParameterConstraint (self, val : PyBrxCv.EParameterConstraint)-> bool :
      '''                             '''
    ...
    def setPreviousId (self, val : int)-> bool :
      '''                             '''
    ...
    def setTangencyConstraint (self, val : PyBrxCv.ETangencyConstraint)-> bool :
      '''                             '''
    ...
    def tangencyConstraint (self)-> PyBrxCv.HAlignmentTangencyConstraint :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.HAlignmentElementType :
      '''                             '''
    ...

class CvDbHAlignmentSCS(CvDbHAlignmentCurve):
    def __init__ (self)-> None :
      '''                             '''
    ...
    def arc (self)-> PyBrxCv.CvDbHAlignmentArc :
      '''                             '''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbHAlignmentSCS :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def endPoint (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def endStation (self)-> float :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isSubentity (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def length (self)-> float :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def nextId (self)-> int :
      '''                             '''
    ...
    def parameterConstraint (self)-> PyBrxCv.HAlignmentParameterConstraint :
      '''                             '''
    ...
    def previousId (self)-> int :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setNextId (self, val : int)-> bool :
      '''                             '''
    ...
    def setParameterConstraint (self, val : PyBrxCv.EParameterConstraint)-> bool :
      '''                             '''
    ...
    def setPreviousId (self, val : int)-> bool :
      '''                             '''
    ...
    def setTangencyConstraint (self, val : PyBrxCv.ETangencyConstraint)-> bool :
      '''                             '''
    ...
    def spiralIn (self)-> PyBrxCv.CvDbHAlignmentSpiral :
      '''                             '''
    ...
    def spiralOut (self)-> PyBrxCv.CvDbHAlignmentSpiral :
      '''                             '''
    ...
    def startPoint (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def startStation (self)-> float :
      '''                             '''
    ...
    def tangencyConstraint (self)-> PyBrxCv.HAlignmentTangencyConstraint :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.HAlignmentElementType :
      '''                             '''
    ...

class CvDbHAlignmentSSCSS(CvDbHAlignmentCurve):
    def __init__ (self)-> None :
      '''                             '''
    ...
    def arc (self)-> PyBrxCv.CvDbHAlignmentArc :
      '''                             '''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbHAlignmentSSCSS :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def endPoint (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def endStation (self)-> float :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isSubentity (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def length (self)-> float :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def nextId (self)-> int :
      '''                             '''
    ...
    def parameterConstraint (self)-> PyBrxCv.HAlignmentParameterConstraint :
      '''                             '''
    ...
    def previousId (self)-> int :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setNextId (self, val : int)-> bool :
      '''                             '''
    ...
    def setParameterConstraint (self, val : PyBrxCv.EParameterConstraint)-> bool :
      '''                             '''
    ...
    def setPreviousId (self, val : int)-> bool :
      '''                             '''
    ...
    def setTangencyConstraint (self, val : PyBrxCv.ETangencyConstraint)-> bool :
      '''                             '''
    ...
    def spiral1 (self)-> PyBrxCv.CvDbHAlignmentSpiral :
      '''                             '''
    ...
    def spiral2 (self)-> PyBrxCv.CvDbHAlignmentSpiral :
      '''                             '''
    ...
    def spiral3 (self)-> PyBrxCv.CvDbHAlignmentSpiral :
      '''                             '''
    ...
    def spiral4 (self)-> PyBrxCv.CvDbHAlignmentSpiral :
      '''                             '''
    ...
    def startPoint (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def startStation (self)-> float :
      '''                             '''
    ...
    def tangencyConstraint (self)-> PyBrxCv.HAlignmentTangencyConstraint :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.HAlignmentElementType :
      '''                             '''
    ...

class CvDbHAlignmentSTS(CvDbHAlignmentCurve):
    def __init__ (self)-> None :
      '''                             '''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbHAlignmentSTS :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def endPoint (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def endStation (self)-> float :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isSubentity (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def length (self)-> float :
      '''                             '''
    ...
    def line (self)-> PyBrxCv.CvDbHAlignmentLine :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def nextId (self)-> int :
      '''                             '''
    ...
    def parameterConstraint (self)-> PyBrxCv.HAlignmentParameterConstraint :
      '''                             '''
    ...
    def previousId (self)-> int :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setNextId (self, val : int)-> bool :
      '''                             '''
    ...
    def setParameterConstraint (self, val : PyBrxCv.EParameterConstraint)-> bool :
      '''                             '''
    ...
    def setPreviousId (self, val : int)-> bool :
      '''                             '''
    ...
    def setTangencyConstraint (self, val : PyBrxCv.ETangencyConstraint)-> bool :
      '''                             '''
    ...
    def spiralIn (self)-> PyBrxCv.CvDbHAlignmentSpiral :
      '''                             '''
    ...
    def spiralOut (self)-> PyBrxCv.CvDbHAlignmentSpiral :
      '''                             '''
    ...
    def spiralRatio (self)-> float :
      '''                             '''
    ...
    def startPoint (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def startStation (self)-> float :
      '''                             '''
    ...
    def tangencyConstraint (self)-> PyBrxCv.HAlignmentTangencyConstraint :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.HAlignmentElementType :
      '''                             '''
    ...

class CvDbHAlignmentSpiral(CvDbHAlignmentCurve):
    def __init__ (self)-> None :
      '''                             '''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbHAlignmentSpiral :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def endDirection (self)-> float :
      '''                             '''
    ...
    def endPoint (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def endStation (self)-> float :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isCompound (self)-> bool :
      '''                             '''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isSubentity (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def length (self)-> float :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def nextId (self)-> int :
      '''                             '''
    ...
    def paramA (self)-> float :
      '''                             '''
    ...
    def paramLength (self)-> float :
      '''                             '''
    ...
    def parameterConstraint (self)-> PyBrxCv.HAlignmentParameterConstraint :
      '''                             '''
    ...
    def previousId (self)-> int :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def radiusIn (self)-> float :
      '''                             '''
    ...
    def radiusOut (self)-> float :
      '''                             '''
    ...
    def setClockwise (self, val : bool)-> bool :
      '''                             '''
    ...
    def setCompound (self, val : float)-> bool :
      '''                             '''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...
    def setEndDirection (self, val : float)-> bool :
      '''                             '''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setNextId (self, val : int)-> bool :
      '''                             '''
    ...
    def setParamA (self, val : float)-> bool :
      '''                             '''
    ...
    def setParamLength (self, val : float)-> bool :
      '''                             '''
    ...
    def setParameterConstraint (self, val : PyBrxCv.EParameterConstraint)-> bool :
      '''                             '''
    ...
    def setPreviousId (self, val : int)-> bool :
      '''                             '''
    ...
    def setRadiusIn (self, val : float)-> bool :
      '''                             '''
    ...
    def setRadiusOut (self, val : float)-> bool :
      '''                             '''
    ...
    def setSpiralCurveType (self, val : PyBrxCv.ESpiralCurveType)-> bool :
      '''                             '''
    ...
    def setSpiralDefinition (self, val : PyBrxCv.ESpiralDefinitionType)-> bool :
      '''                             '''
    ...
    def setTangencyConstraint (self, val : PyBrxCv.ETangencyConstraint)-> bool :
      '''                             '''
    ...
    def spiralCurveType (self)-> PyBrxCv.SpiralCurveType :
      '''                             '''
    ...
    def spiralDefinition (self)-> PyBrxCv.SpiralDefinitionTypeSpiral :
      '''                             '''
    ...
    def startDirection (self)-> float :
      '''                             '''
    ...
    def startPoint (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def startStation (self)-> float :
      '''                             '''
    ...
    def tangencyConstraint (self)-> PyBrxCv.HAlignmentTangencyConstraint :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.HAlignmentElementType :
      '''                             '''
    ...

class CvDbObject(PyDb.DbObject):
    def __init__ (self, id: ObjectId, mode: PyDb.OpenMode=PyDb.OpenMode.kForRead, erased: bool=False)-> None :
      '''                             '''
    ...
    def addContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def addPersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Adds the database-resident object specified by objId to the reactor list of the AcDbObject object.'''
    ...
    def addReactor (self, reactor: PyDb.DbObjectReactor)-> None :
      '''Adds the transient reactor pointed to by pNewObj to the AcDbObject object's reactor list.'''
    ...
    def assertNotifyEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should be used inside of member functions that are only called when the object is open kForNotify. When used, it should be the first function called inside the member function.'''
    ...
    def assertReadEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that access the object's data in a read-only fashion (for example, dxfOutFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is open AcDb::kForRead.If this function is called while the object is not open, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def assertWriteEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that modify the object's data (for example, dxfInFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is indeed open for write (if it is not, then AutoCAD terminates); to trigger an immediate sending of "openedForModify" notification; to set up the notification mechanism so that "modified" and "modifiedGraphics" (if the object is derived from AcDbEntity) are sent at the appropriate times; and to ensure that graphics get updated if the object is derived from AcDbEntity.If this function is called on a database resident object, "openedForModify" will be sent if the object is not newly created, and "modified", and "modifiedGraphics" (if appropriate) notifications will be sent when the object is next closed.If recordModified is false, then the autoUndo argument is ignored, and the undo filer is not initialized, no undo recording will take place, but notifications will be sent.If autoUndo and recordModified are both true, then automatic undo recording will be performed and notifications will be sent.If autoUndo is false and recordModified is true, then there will not be any automatic undo recording, but the undo filer is initialized and the object must manually write out partial Undo records and must implement its applyPartialUndo() method. Notifications will be sent.If this function is called while the object is not open AcDb::kForWrite, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def bounds (self, ext: PyDb.Extents)-> bool :
      '''                             '''
    ...
    def cancel (self)-> None :
      '''Terminates the current open operation. All changes made to the object since it was opened are undone, the object is marked as closed, and "cancel" notification is sent.Returns Acad::eOk if successful.'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbObject :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...

    @staticmethod
    def cloneFrom (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbObject :
      '''                             '''
    ...
    def close (self)-> None :
      '''Closes the object. All changes made to the object since it was opened are committed to the database, the object is marked as pageable, and a "closed" notification (as well as any other appropriate notification such as "modified", "erased", and so on) is sent.Returns Acad::eOk if successful.If the object is not in an AcDbDatabase yet, then Acad::eNoDatabase is returned.If the object is sending notification, then Acad::eCloseWasNotifying is returned.If the subClose() call made within the close() method returns anything other than Acad::eOk, then that ErrorStatus is returned.'''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...
    def createExtensionDictionary (self)-> None :
      '''Creates an AcDbDictionary object and sets it up as the extension dictionary for the AcDbObject.Returns Acad::eOk if successful. If an extension dictionary already exists, Acad::eAlreadyInDb is returned.'''
    ...
    def database (self)-> PyDb.Database :
      '''Returns a pointer to the AcDbDatabase object that contains the AcDbObject.'''
    ...
    def deepClone (self, owner: PyDb.DbObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function gives control of deep clone operations to the object. In the default implementation, the object is cloned and appended to the owner object (pOwnerObject). The cloning is performed by an AcDbDeepCloneFiler. A record is also added to the idMap. Then, using the filer, any owned objects are deep cloned, with isPrimary set to Adesk::kFalse.'''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def disableUndoRecording (self, disable: bool)-> None :
      '''Turns off or on the Undo recording for the object. If disable == Adesk::kTrue, then Undo recording is turned off until this function is called with disable == Adesk::kFalse, at which time Undo recording is turned back on.'''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def downgradeOpen (self)-> None :
      '''Downgrades the object from being open AcDb::kForWrite, to being AcDb::kForRead. In the process, all changes made to the object while it was open for write are committed to the database and appropriate notification is sent.'''
    ...
    def downgradeToNotify (self, wasWritable: bool)-> None :
      '''Restores an object from being open both AcDb::kForNotify and AcDb::kForWrite, to being open just AcDb::kForNotify. The wasWritable value that was returned from the matching AcDbObject::upgradeFromNotify() call should be passed into this function to restore the proper open status.This function must have been preceded by a call to upgradeFromNotify().Returns Acad::eOk if successful.'''
    ...
    def drawableType (self)-> PyGi.GiDrawableType :
      '''                             '''
    ...
    def erase (self, erasing : bool=True)-> None :
      '''Sets the erase bit of the object. If erasing == Adesk::kTrue, then the erase bit is set on. If erasing == Adesk::kFalse, then the erase bit is set off.'''
    ...
    def extensionDictionary (self)-> PyDb.ObjectId :
      '''Returns the objectId of the extension dictionary owned by the object. If the object does not own an extension dictionary, then the returned objectId is set to AcDbObjectId::kNull.'''
    ...
    def getField (self, prop: str='TEXT')-> PyDb.ObjectId :
      '''Gets the field ID. A field can be stored in an object using the property name as the key.Returns Acad::eOk if the object has a field for the specified property. Otherwise, returns an AutoCAD error status.'''
    ...
    def getFieldDictionary (self)-> PyDb.ObjectId :
      '''Returns the field dictionary ID. The field dictionary stores all the fields set in the object as property name-field object pairs. The ID will be null if there is no field in the object.'''
    ...
    def getHandle (self)-> PyDb.Handle :
      '''Fills in handle with the handle value for the object. If the object is not yet database-resident, then it will not have a handle. Use AcDbHandle::isNull to test for this condition.'''
    ...
    def handOverTo (self, newObject: PyDb.DbObject, keepXData: bool, keepExtDict: bool)-> None :
      '''This function provides the ability to exchange a non-database-resident object (NDBRO) in place of an existing database-resident object (DBRO) while retaining the objectId, handle, and reactor list of the DBRO. An example of this situation is when the BREAK command is used to break a circle into one or two arc segments. AcDbArc is a completely different class from AcDbCircle, so a new AcDbArc object must be substituted in place of the AcDbCircle object that is there now, yet the arc must get the handle and objectId that the circle has.To use the handOverTo() function, the object to be replaced (the AcDbCircle in the example) must be open AcDb::kForWrite. The object's handOverTo() function is called with newObject pointing to a non-database-resident object that replaces it (the AcDbArc in the example).keepXData is set to Adesk::kTrue if the xdata is to be retained or Adesk::kFalse if the xdata is to be thrown out.keepExtDict is set to Adesk::kTrue if the extension dictionary and its contents are to be retained, or set to Adesk::kFalse if the extension dictionary and its contents are to be thrown out.Once returned from this function, the replacement object (the AcDbArc in the example) is open for AcDb::kForWrite and must have its close() member called to commit the change and close out Undo recording. Then it's up to the ObjectARX application to delete the old object (the AcDbCircle in the example) from memory since it's no longer database-resident.Returns Acad::eObjectToBeDeleted if the operation is successful. If newObject is pointing to an object that is already in the database, or the object invoking handOverTo() is not database-resident, then Acad::eIllegalReplacement is returned.'''
    ...
    def hasFields (self)-> bool :
      '''Returns true if the object has one or more PyDb.Field Objects. Otherwise returns false.'''
    ...
    def hasPersistentReactor (self, id: PyDb.ObjectId)-> bool :
      '''This method returns true if objId is the object ID of a reactor attached to this object. Otherwise, it returns false.'''
    ...
    def hasXData (self, appname: str)-> bool :
      '''                             '''
    ...
    def id (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isAProxy (self)-> int :
      '''Returns Adesk::kTrue if the object is a proxy object or entity. Otherwise returns Adesk::kFalse.'''
    ...
    def isAcDbObjectIdsInFlux (self)-> int :
      '''This function refers to a condition that occurs during deep clone operations. It returns Adesk::kTrue when the cloned objects' IDs have not yet been translated and thus cannot be used in any operations on the objects. This condition normally occurs only during AcEditorReactor::beginDeepCloneXlation, AcDbObject::deepClone, or AcDbObject::wblockClone. Any operations that involve AcDbObjectId references, such as symbol table records, should be postponed until after endDeepClone. AcDbObject::subClose is never called on any objects whose IDs are in flux.'''
    ...
    def isAnnotative (self)-> PyDb.AnnotativeStates :
      '''                             '''
    ...
    def isCancelling (self)-> int :
      '''Returns Adesk::kTrue if the object is currently in the middle of a cancel() call (that is, an open is being canceled and all changes made are being rolled back). Otherwise returns Adesk::kFalse.'''
    ...
    def isEraseStatusToggled (self)-> int :
      '''Returns Adesk::kTrue if the object's erase bit has been toggled since it was opened. Otherwise returns Adesk::kFalse.'''
    ...
    def isErased (self)-> int :
      '''Returns Adesk::kTrue if the object is currently erased. Otherwise returns Adesk::kFalse.'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isModified (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called). Otherwise returns Adesk::kFalse.'''
    ...
    def isModifiedGraphics (self)-> int :
      '''Returns Adesk::kTrue if the object is derived from AcDbEntity and has had either an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called), or its recordGraphicsModified() function called with an Adesk::kTrue argument value.Otherwise it returns Adesk::kFalse.'''
    ...
    def isModifiedXData (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called) and has then had its setXData() method called. Otherwise it returns Adesk::kFalse.'''
    ...
    def isNewObject (self)-> int :
      '''Returns Adesk::kTrue if the object has not yet been closed since it was first created. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifyEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForNotify. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifying (self)-> int :
      '''Returns Adesk::kTrue if the object is in the process of sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isPersistent (self)-> int :
      '''                             '''
    ...
    def isReadEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForRead. Otherwise returns Adesk::kFalse.'''
    ...
    def isReallyClosing (self)-> int :
      '''Returns true if calling close() at this time would really close the object completely. For example, if the object is not in a transaction, and is open for read with only one reader, then Adesk::kTrue would be returned. If, on the other hand, the object is in a transaction, then Adesk::kFalse would be returned.'''
    ...
    def isTransactionResident (self)-> int :
      '''Returns Adesk::kTrue if the object is currently part of a transaction. Otherwise returns Adesk::kFalse.'''
    ...
    def isUndoRecordingDisabled (self)-> bool :
      '''Returns true if undo recording is disabled.'''
    ...
    def isUndoing (self)-> int :
      '''Returns Adesk::kTrue if the object is involved in an Undo operation at this time. Otherwise returns Adesk::kFalse.'''
    ...
    def isWriteEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForWrite and is not currently sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def objectId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the object. If the object is not yet database-resident, then the returned objectId will be set to AcDbObjectId::kNull.'''
    ...
    def ownerId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the owner of the object. If the object does not yet have an owner, or the ownerId data member has not yet been set using AcDbObject::setOwnerId, then the returned objectId will be set to AcDbObjectId::kNull.Appending the object to a BlockTable record, a symbol table, or a dictionary automatically calls AcDbObject::setOwnerId.'''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def releaseExtensionDictionary (self)-> None :
      '''Removes the object's extension dictionary (that is, removes the object as the owner of the dictionary object) if it exists and is empty. Once removed, this function calls the dictionary's erase() method. Any reactors attached to the extension dictionary receive normal notification appropriate to an open for write, erase, close sequence.Returns Acad::eOk if successful.If the dictionary is not empty, then this function fails and returns Acad::eContainerNotEmpty.'''
    ...
    def removeContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def removeField (self, id: str|PyDb.ObjectId)-> None :
      '''Removes the specified field.Returns Acad::eOk if successful. Otherwise, returns an AutoCAD error status.'''
    ...
    def removePersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Removes the persistent reactor specified by objId from the reactor list of the object. The object must be open AcDb::kForWrite to be able to execute this function.Returns Acad::eOk if successful. If the object is currently sending notification and is not open AcDb::kForWrite, then Acad::eWasNotifying is returned.'''
    ...
    def removeReactor (self, reactor: PyDb.DbObjectReactor)-> None :
      '''Removes reactor pointed to by pNewObj from the object's reactor list. The object may be open AcDb::kForRead or AcDb::kForWrite when this function is called.'''
    ...
    def rolloverHit (self, nSubentId: int, nMouseFlags: int, bReset: bool)-> int :
      '''                             '''
    ...
    def setAcDbObjectIdsInFlux (self)-> None :
      '''This function must be called on any newly created objects in AcDbObject::deepClone or AcDbObject::wblockClone. It indicates that reference object IDs are not yet pointing to the correct objects. The references can be translated only when the entire deep clone operation is complete. The flag is cleared at that time.'''
    ...
    def setAnnotative (self, state : PyDb.AnnotativeStates)-> None :
      '''                             '''
    ...
    def setAttributes (self, traits: PyGi.DrawableTraits)-> int :
      '''                             '''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...

    @overload
    def setField (self, field: PyDb.Field)-> PyDb.ObjectId : ...
    @overload
    def setField (self, propName: str, field: PyDb.Field)-> PyDb.ObjectId : ...
    def setField (self, *args, **kwargs)-> PyDb.ObjectId :
      '''Overloads:
    - field: PyDb.Field
    - propName: str, field: PyDb.Field
    '''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setOwnerId (self, owner: PyDb.ObjectId)-> None :
      '''Sets the ownerId data member of the object to be objId, thus establishing a "backpointer." This backpointer is used by WBLOCK to be sure all necessary objects are written out.Returns Acad::eOk if successful.'''
    ...
    def setXData (self, xdata: list)-> None :
      '''Each regapp sublist (delimited by a resbuf with restype == 1001 and resval.rstring == a valid regappName string) within the resbuf chain pointed to by xdata, is placed in the xdata area of the object. If any of the regappNames in xdata are already present in the xdata area of the object, then that regappName's existing data on the object is overwritten by that regappName's new data in xdata.All resbufs with restype == 1001 must have valid regappNames for the database the object resides in (that is, the regappNames must be in the APPID table of the database).Only valid xdata group codes (1000--1071) are accepted in the restype fields of the resbufs in xdata.No "-3" group code is necessary, and in fact, is not accepted. So, the first element in the resbuf chain must be a 1001 group code with a resval.rstring set to a regappName that's already registered in the regapp table. To register a regappName, use the acdbRegApp() function.To remove an appName (and its xdata) from an object, just use a resbuf with restype == 1001, resval == and no data resbufs following it (that is, either its rbnext == NULL or the next resbuf is another 1001)This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If this function is overridden, then it should supermessage its parent in order to invoke the built-in mechanism to add the xdata to the object.Returns Acad::eOk if the xdata is successfully added to the object. If there is insufficient space in the xdata area of the object, then Acad::eXdataSizeExceeded is returned. If any of the regappNames in xdata are not in the APPID table, then Acad::eRegappIdNotFound is returned.'''
    ...
    def snoop (self,  filer : PyDb.SnoopDwgFiler)-> None :
      '''                             '''
    ...
    def swapIdWith (self, otherId: PyDb.DbObject, swapXdata: bool, swapExtDict: bool)-> None :
      '''This function swaps objectIds and handles between the object specified by otherId and the object invoking this function. Both objects must currently be database-resident and must reside in the same database. If swapXdata == Adesk::kTrue, then the objects swap extended entity data as well. If swapExtDict == Adesk::kTrue, then the objects swap extension dictionaries also.If the object specified by otherId or the object invoking this function are not database-resident, then Acad::eNoDatabase is returned. If both objects involved are not in the same database, then Acad::eWrongDatabase is returned.'''
    ...
    def upgradeFromNotify (self, wasWritable: bool)-> None :
      '''Upgrades the object from being at least open AcDb::kForNotify to being open both AcDb::kForNotify and AcDb::kForWrite. The wasWritable argument is set to Adesk::kTrue if the object was already open for write, otherwise it's set to Adesk::kFalse. The wasWritable value should be saved to be passed into the downgradeToNotify() call later.This function must be followed at some point by a call to downgradeToNotify() with no open() (in any of its forms) or close() calls in between.This method should only be called from within other methods of the same object it is being called from. In other words, this method is intended to be used by an object to change it's own open status so that it can safely modify itself.upgradeFromNotify() and downgradeToNotify() call pairs are not nestable.Returns Acad::eOk if successful. If the object is not currently open AcDb::kForNotify, then Acad::eNotApplicable is returned. If the object is currently in the process of actually sending notification (that is, isNotifying() returns Adesk::kTrue), then Acad::eWasNotifying is returned.'''
    ...
    def upgradeOpen (self)-> None :
      '''If the object is currently open AcDb::kForRead with only one reader, then this function upgrades the object to open AcDb::kForWrite. In the process of changing to open for write, the object is closed, thus triggering any pertinent notification.Returns Acad::eOk if successful. If the object has more than one reader, then the open status is not changed and Adesk::eHadMultipleReaders is returned. If the object is already open AcDb::kForWrite, then Acad::eWasOpenForWrite is returned. If the object is currently sending notification, then the open status is not changed and Acad::eWasNotifying is returned.'''
    ...
    def viewportDraw (self, vpdraw: PyGi.ViewportDraw)-> None :
      '''                             '''
    ...
    def viewportDrawLogicalFlags (self, vpdraw: PyGi.ViewportDraw)-> int :
      '''                             '''
    ...
    def wblockClone (self, owner: PyRx.RxObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function is almost identical to AcDbObject::deepClone, except that an AcDbWblockCloneFiler is used and ownership is not carried across database boundaries. Subcloning is based on hard owner and hard pointer connections.'''
    ...
    def worldDraw (self, wdraw: PyGi.WorldDraw)-> int :
      '''                             '''
    ...
    def xData (self, appname: str = None)-> list :
      '''Returns a linked list of resbuf structures containing a copy of the xdata for the object. If regappName == NULL is passed in, all xdata is returned, otherwise only the xdata for the specified name is returned. If not all xdata is required, but the xdata for more than one regappName is desired, then multiple calls to this member function must be made--one for each regappName.The caller of this function is responsible for releasing the memory used by the resbuf list that is returned. The most commonly used way to deallocate such a list is via the acutRelRb() function.This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If a failure accessing the xdata occurs, NULL is returned.'''
    ...
    def xDataTransformBy (self, xform: PyGe.Matrix3d)-> None :
      '''This method applies the xform transformation matrix to any XData data types 1011, 1021, 1031, 1012, 1022, 1032, 1013, 1023, 1033, 1041, and 1042 in the object's XData. See the documentation on XData for more information on the way the transformation matrix is applied to the different data types.This method should be called from within the transformBy() method on custom entities so that such entities will transform XData in the same way that the built-in AcDb entities do.Returns Acad::eOk if successful.'''
    ...
    def xmitPropagateModify (self)-> None :
      '''Within an object's close() method is a call to the object's xmitPropagateModify().The AcDbObject::xmitPropagateModify() default implementation is to inform the containing database that the object has been modified, appended to the database, or erased. The database then sends out the appropriate notification to any AcDbDatabaseReactors attached to it.Within AutoCAD, this function is used by complex entities such as polylines to allow the subentities to notify the header that they have been changed. The header can then "propagate" the notification by sending its own notification that the "complex entity" has been modified.The way this works is:The subobject class has it's xmitPropagateModify() class overridden such that it calls it's parent class's xmitPropagateModify() and also calls the owning object's recvPropagateModify().The "root" or "header" class has it's recvPropagateModify() overridden to provide an implementation that triggers "modified" notification to be sent for the "root" or "header" (which effectively represents the whole complex object).The subobject's close() triggers "modified" notification for the subobject and calls the subobject's xmitPropagateModify() function. So, when the subobject's close() is called, its xmitPropagateModify() is called. This then calls the owning object's recvPropagateModify(), which then triggers the owner to send "modified" notification.So, the result is a "modified" notification from both the subentity and the "root" or "header" entity.When overridden, this function should:Call its parent class's xmitPropagateModify() (which ultimately results in the execution of AcDbObject::xmitPropagateModify() to trigger database notification).Call its owner's recvPropagateModify() (passing in its "this" pointer) to "propagate" the notification information to the "root" owner to be sent out.'''
    ...

class CvDbObjectManager(CvDbObject):
    def __getitem__ (self, val : int|str)-> PyDb.ObjectId :
      '''                             '''
    ...
    def __init__ (self, id: ObjectId, mode: PyDb.OpenMode=PyDb.OpenMode.kForRead, erased: bool=False)-> None :
      '''                             '''
    ...
    def addContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def addPersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Adds the database-resident object specified by objId to the reactor list of the AcDbObject object.'''
    ...
    def addReactor (self, reactor: PyDb.DbObjectReactor)-> None :
      '''Adds the transient reactor pointed to by pNewObj to the AcDbObject object's reactor list.'''
    ...
    def assertNotifyEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should be used inside of member functions that are only called when the object is open kForNotify. When used, it should be the first function called inside the member function.'''
    ...
    def assertReadEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that access the object's data in a read-only fashion (for example, dxfOutFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is open AcDb::kForRead.If this function is called while the object is not open, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def assertWriteEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that modify the object's data (for example, dxfInFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is indeed open for write (if it is not, then AutoCAD terminates); to trigger an immediate sending of "openedForModify" notification; to set up the notification mechanism so that "modified" and "modifiedGraphics" (if the object is derived from AcDbEntity) are sent at the appropriate times; and to ensure that graphics get updated if the object is derived from AcDbEntity.If this function is called on a database resident object, "openedForModify" will be sent if the object is not newly created, and "modified", and "modifiedGraphics" (if appropriate) notifications will be sent when the object is next closed.If recordModified is false, then the autoUndo argument is ignored, and the undo filer is not initialized, no undo recording will take place, but notifications will be sent.If autoUndo and recordModified are both true, then automatic undo recording will be performed and notifications will be sent.If autoUndo is false and recordModified is true, then there will not be any automatic undo recording, but the undo filer is initialized and the object must manually write out partial Undo records and must implement its applyPartialUndo() method. Notifications will be sent.If this function is called while the object is not open AcDb::kForWrite, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def bounds (self, ext: PyDb.Extents)-> bool :
      '''                             '''
    ...
    def cancel (self)-> None :
      '''Terminates the current open operation. All changes made to the object since it was opened are undone, the object is marked as closed, and "cancel" notification is sent.Returns Acad::eOk if successful.'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbObjectManager :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...

    @staticmethod
    def cloneFrom (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbObjectManager :
      '''                             '''
    ...
    def close (self)-> None :
      '''Closes the object. All changes made to the object since it was opened are committed to the database, the object is marked as pageable, and a "closed" notification (as well as any other appropriate notification such as "modified", "erased", and so on) is sent.Returns Acad::eOk if successful.If the object is not in an AcDbDatabase yet, then Acad::eNoDatabase is returned.If the object is sending notification, then Acad::eCloseWasNotifying is returned.If the subClose() call made within the close() method returns anything other than Acad::eOk, then that ErrorStatus is returned.'''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...
    def createExtensionDictionary (self)-> None :
      '''Creates an AcDbDictionary object and sets it up as the extension dictionary for the AcDbObject.Returns Acad::eOk if successful. If an extension dictionary already exists, Acad::eAlreadyInDb is returned.'''
    ...
    def database (self)-> PyDb.Database :
      '''Returns a pointer to the AcDbDatabase object that contains the AcDbObject.'''
    ...
    def deepClone (self, owner: PyDb.DbObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function gives control of deep clone operations to the object. In the default implementation, the object is cloned and appended to the owner object (pOwnerObject). The cloning is performed by an AcDbDeepCloneFiler. A record is also added to the idMap. Then, using the filer, any owned objects are deep cloned, with isPrimary set to Adesk::kFalse.'''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def disableUndoRecording (self, disable: bool)-> None :
      '''Turns off or on the Undo recording for the object. If disable == Adesk::kTrue, then Undo recording is turned off until this function is called with disable == Adesk::kFalse, at which time Undo recording is turned back on.'''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def downgradeOpen (self)-> None :
      '''Downgrades the object from being open AcDb::kForWrite, to being AcDb::kForRead. In the process, all changes made to the object while it was open for write are committed to the database and appropriate notification is sent.'''
    ...
    def downgradeToNotify (self, wasWritable: bool)-> None :
      '''Restores an object from being open both AcDb::kForNotify and AcDb::kForWrite, to being open just AcDb::kForNotify. The wasWritable value that was returned from the matching AcDbObject::upgradeFromNotify() call should be passed into this function to restore the proper open status.This function must have been preceded by a call to upgradeFromNotify().Returns Acad::eOk if successful.'''
    ...
    def drawableType (self)-> PyGi.GiDrawableType :
      '''                             '''
    ...
    def elementCount (self)-> int :
      '''                             '''
    ...
    def erase (self, erasing : bool=True)-> None :
      '''Sets the erase bit of the object. If erasing == Adesk::kTrue, then the erase bit is set on. If erasing == Adesk::kFalse, then the erase bit is set off.'''
    ...
    def extensionDictionary (self)-> PyDb.ObjectId :
      '''Returns the objectId of the extension dictionary owned by the object. If the object does not own an extension dictionary, then the returned objectId is set to AcDbObjectId::kNull.'''
    ...
    def getField (self, prop: str='TEXT')-> PyDb.ObjectId :
      '''Gets the field ID. A field can be stored in an object using the property name as the key.Returns Acad::eOk if the object has a field for the specified property. Otherwise, returns an AutoCAD error status.'''
    ...
    def getFieldDictionary (self)-> PyDb.ObjectId :
      '''Returns the field dictionary ID. The field dictionary stores all the fields set in the object as property name-field object pairs. The ID will be null if there is no field in the object.'''
    ...
    def getHandle (self)-> PyDb.Handle :
      '''Fills in handle with the handle value for the object. If the object is not yet database-resident, then it will not have a handle. Use AcDbHandle::isNull to test for this condition.'''
    ...
    def handOverTo (self, newObject: PyDb.DbObject, keepXData: bool, keepExtDict: bool)-> None :
      '''This function provides the ability to exchange a non-database-resident object (NDBRO) in place of an existing database-resident object (DBRO) while retaining the objectId, handle, and reactor list of the DBRO. An example of this situation is when the BREAK command is used to break a circle into one or two arc segments. AcDbArc is a completely different class from AcDbCircle, so a new AcDbArc object must be substituted in place of the AcDbCircle object that is there now, yet the arc must get the handle and objectId that the circle has.To use the handOverTo() function, the object to be replaced (the AcDbCircle in the example) must be open AcDb::kForWrite. The object's handOverTo() function is called with newObject pointing to a non-database-resident object that replaces it (the AcDbArc in the example).keepXData is set to Adesk::kTrue if the xdata is to be retained or Adesk::kFalse if the xdata is to be thrown out.keepExtDict is set to Adesk::kTrue if the extension dictionary and its contents are to be retained, or set to Adesk::kFalse if the extension dictionary and its contents are to be thrown out.Once returned from this function, the replacement object (the AcDbArc in the example) is open for AcDb::kForWrite and must have its close() member called to commit the change and close out Undo recording. Then it's up to the ObjectARX application to delete the old object (the AcDbCircle in the example) from memory since it's no longer database-resident.Returns Acad::eObjectToBeDeleted if the operation is successful. If newObject is pointing to an object that is already in the database, or the object invoking handOverTo() is not database-resident, then Acad::eIllegalReplacement is returned.'''
    ...
    def has1 (self, *args, **kwargs)-> bool :
      '''has1( (CvDbObjectManager)arg1, (ObjectId)arg2) -> bool :

    C++ signature :
        bool has1(class PyBrxCvDbObjectManager {lvalue},class PyDbObjectId)'''
    ...
    def has2 (self, id : str|PyDb.ObjectId)-> bool :
      '''                             '''
    ...
    def hasFields (self)-> bool :
      '''Returns true if the object has one or more PyDb.Field Objects. Otherwise returns false.'''
    ...
    def hasPersistentReactor (self, id: PyDb.ObjectId)-> bool :
      '''This method returns true if objId is the object ID of a reactor attached to this object. Otherwise, it returns false.'''
    ...
    def hasXData (self, appname: str)-> bool :
      '''                             '''
    ...
    def id (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def idAt (self, val : int|str)-> PyDb.ObjectId :
      '''                             '''
    ...
    def ids (self)-> list :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isAProxy (self)-> int :
      '''Returns Adesk::kTrue if the object is a proxy object or entity. Otherwise returns Adesk::kFalse.'''
    ...
    def isAcDbObjectIdsInFlux (self)-> int :
      '''This function refers to a condition that occurs during deep clone operations. It returns Adesk::kTrue when the cloned objects' IDs have not yet been translated and thus cannot be used in any operations on the objects. This condition normally occurs only during AcEditorReactor::beginDeepCloneXlation, AcDbObject::deepClone, or AcDbObject::wblockClone. Any operations that involve AcDbObjectId references, such as symbol table records, should be postponed until after endDeepClone. AcDbObject::subClose is never called on any objects whose IDs are in flux.'''
    ...
    def isAnnotative (self)-> PyDb.AnnotativeStates :
      '''                             '''
    ...
    def isCancelling (self)-> int :
      '''Returns Adesk::kTrue if the object is currently in the middle of a cancel() call (that is, an open is being canceled and all changes made are being rolled back). Otherwise returns Adesk::kFalse.'''
    ...
    def isEraseStatusToggled (self)-> int :
      '''Returns Adesk::kTrue if the object's erase bit has been toggled since it was opened. Otherwise returns Adesk::kFalse.'''
    ...
    def isErased (self)-> int :
      '''Returns Adesk::kTrue if the object is currently erased. Otherwise returns Adesk::kFalse.'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isModified (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called). Otherwise returns Adesk::kFalse.'''
    ...
    def isModifiedGraphics (self)-> int :
      '''Returns Adesk::kTrue if the object is derived from AcDbEntity and has had either an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called), or its recordGraphicsModified() function called with an Adesk::kTrue argument value.Otherwise it returns Adesk::kFalse.'''
    ...
    def isModifiedXData (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called) and has then had its setXData() method called. Otherwise it returns Adesk::kFalse.'''
    ...
    def isNewObject (self)-> int :
      '''Returns Adesk::kTrue if the object has not yet been closed since it was first created. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifyEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForNotify. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifying (self)-> int :
      '''Returns Adesk::kTrue if the object is in the process of sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isPersistent (self)-> int :
      '''                             '''
    ...
    def isReadEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForRead. Otherwise returns Adesk::kFalse.'''
    ...
    def isReallyClosing (self)-> int :
      '''Returns true if calling close() at this time would really close the object completely. For example, if the object is not in a transaction, and is open for read with only one reader, then Adesk::kTrue would be returned. If, on the other hand, the object is in a transaction, then Adesk::kFalse would be returned.'''
    ...
    def isTransactionResident (self)-> int :
      '''Returns Adesk::kTrue if the object is currently part of a transaction. Otherwise returns Adesk::kFalse.'''
    ...
    def isUndoRecordingDisabled (self)-> bool :
      '''Returns true if undo recording is disabled.'''
    ...
    def isUndoing (self)-> int :
      '''Returns Adesk::kTrue if the object is involved in an Undo operation at this time. Otherwise returns Adesk::kFalse.'''
    ...
    def isWriteEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForWrite and is not currently sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def nameAt (self, val : int)-> str :
      '''                             '''
    ...
    def objectId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the object. If the object is not yet database-resident, then the returned objectId will be set to AcDbObjectId::kNull.'''
    ...
    def ownerId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the owner of the object. If the object does not yet have an owner, or the ownerId data member has not yet been set using AcDbObject::setOwnerId, then the returned objectId will be set to AcDbObjectId::kNull.Appending the object to a BlockTable record, a symbol table, or a dictionary automatically calls AcDbObject::setOwnerId.'''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def releaseExtensionDictionary (self)-> None :
      '''Removes the object's extension dictionary (that is, removes the object as the owner of the dictionary object) if it exists and is empty. Once removed, this function calls the dictionary's erase() method. Any reactors attached to the extension dictionary receive normal notification appropriate to an open for write, erase, close sequence.Returns Acad::eOk if successful.If the dictionary is not empty, then this function fails and returns Acad::eContainerNotEmpty.'''
    ...
    def remove1 (self)-> bool :
      '''                             '''
    ...
    def remove2 (self, id : str|PyDb.ObjectId)-> bool :
      '''                             '''
    ...
    def removeContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def removeField (self, id: str|PyDb.ObjectId)-> None :
      '''Removes the specified field.Returns Acad::eOk if successful. Otherwise, returns an AutoCAD error status.'''
    ...
    def removePersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Removes the persistent reactor specified by objId from the reactor list of the object. The object must be open AcDb::kForWrite to be able to execute this function.Returns Acad::eOk if successful. If the object is currently sending notification and is not open AcDb::kForWrite, then Acad::eWasNotifying is returned.'''
    ...
    def removeReactor (self, reactor: PyDb.DbObjectReactor)-> None :
      '''Removes reactor pointed to by pNewObj from the object's reactor list. The object may be open AcDb::kForRead or AcDb::kForWrite when this function is called.'''
    ...
    def rolloverHit (self, nSubentId: int, nMouseFlags: int, bReset: bool)-> int :
      '''                             '''
    ...
    def setAcDbObjectIdsInFlux (self)-> None :
      '''This function must be called on any newly created objects in AcDbObject::deepClone or AcDbObject::wblockClone. It indicates that reference object IDs are not yet pointing to the correct objects. The references can be translated only when the entire deep clone operation is complete. The flag is cleared at that time.'''
    ...
    def setAnnotative (self, state : PyDb.AnnotativeStates)-> None :
      '''                             '''
    ...
    def setAttributes (self, traits: PyGi.DrawableTraits)-> int :
      '''                             '''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...

    @overload
    def setField (self, field: PyDb.Field)-> PyDb.ObjectId : ...
    @overload
    def setField (self, propName: str, field: PyDb.Field)-> PyDb.ObjectId : ...
    def setField (self, *args, **kwargs)-> PyDb.ObjectId :
      '''Overloads:
    - field: PyDb.Field
    - propName: str, field: PyDb.Field
    '''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setOwnerId (self, owner: PyDb.ObjectId)-> None :
      '''Sets the ownerId data member of the object to be objId, thus establishing a "backpointer." This backpointer is used by WBLOCK to be sure all necessary objects are written out.Returns Acad::eOk if successful.'''
    ...
    def setXData (self, xdata: list)-> None :
      '''Each regapp sublist (delimited by a resbuf with restype == 1001 and resval.rstring == a valid regappName string) within the resbuf chain pointed to by xdata, is placed in the xdata area of the object. If any of the regappNames in xdata are already present in the xdata area of the object, then that regappName's existing data on the object is overwritten by that regappName's new data in xdata.All resbufs with restype == 1001 must have valid regappNames for the database the object resides in (that is, the regappNames must be in the APPID table of the database).Only valid xdata group codes (1000--1071) are accepted in the restype fields of the resbufs in xdata.No "-3" group code is necessary, and in fact, is not accepted. So, the first element in the resbuf chain must be a 1001 group code with a resval.rstring set to a regappName that's already registered in the regapp table. To register a regappName, use the acdbRegApp() function.To remove an appName (and its xdata) from an object, just use a resbuf with restype == 1001, resval == and no data resbufs following it (that is, either its rbnext == NULL or the next resbuf is another 1001)This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If this function is overridden, then it should supermessage its parent in order to invoke the built-in mechanism to add the xdata to the object.Returns Acad::eOk if the xdata is successfully added to the object. If there is insufficient space in the xdata area of the object, then Acad::eXdataSizeExceeded is returned. If any of the regappNames in xdata are not in the APPID table, then Acad::eRegappIdNotFound is returned.'''
    ...
    def snoop (self,  filer : PyDb.SnoopDwgFiler)-> None :
      '''                             '''
    ...
    def swapIdWith (self, otherId: PyDb.DbObject, swapXdata: bool, swapExtDict: bool)-> None :
      '''This function swaps objectIds and handles between the object specified by otherId and the object invoking this function. Both objects must currently be database-resident and must reside in the same database. If swapXdata == Adesk::kTrue, then the objects swap extended entity data as well. If swapExtDict == Adesk::kTrue, then the objects swap extension dictionaries also.If the object specified by otherId or the object invoking this function are not database-resident, then Acad::eNoDatabase is returned. If both objects involved are not in the same database, then Acad::eWrongDatabase is returned.'''
    ...
    def upgradeFromNotify (self, wasWritable: bool)-> None :
      '''Upgrades the object from being at least open AcDb::kForNotify to being open both AcDb::kForNotify and AcDb::kForWrite. The wasWritable argument is set to Adesk::kTrue if the object was already open for write, otherwise it's set to Adesk::kFalse. The wasWritable value should be saved to be passed into the downgradeToNotify() call later.This function must be followed at some point by a call to downgradeToNotify() with no open() (in any of its forms) or close() calls in between.This method should only be called from within other methods of the same object it is being called from. In other words, this method is intended to be used by an object to change it's own open status so that it can safely modify itself.upgradeFromNotify() and downgradeToNotify() call pairs are not nestable.Returns Acad::eOk if successful. If the object is not currently open AcDb::kForNotify, then Acad::eNotApplicable is returned. If the object is currently in the process of actually sending notification (that is, isNotifying() returns Adesk::kTrue), then Acad::eWasNotifying is returned.'''
    ...
    def upgradeOpen (self)-> None :
      '''If the object is currently open AcDb::kForRead with only one reader, then this function upgrades the object to open AcDb::kForWrite. In the process of changing to open for write, the object is closed, thus triggering any pertinent notification.Returns Acad::eOk if successful. If the object has more than one reader, then the open status is not changed and Adesk::eHadMultipleReaders is returned. If the object is already open AcDb::kForWrite, then Acad::eWasOpenForWrite is returned. If the object is currently sending notification, then the open status is not changed and Acad::eWasNotifying is returned.'''
    ...
    def viewportDraw (self, vpdraw: PyGi.ViewportDraw)-> None :
      '''                             '''
    ...
    def viewportDrawLogicalFlags (self, vpdraw: PyGi.ViewportDraw)-> int :
      '''                             '''
    ...
    def wblockClone (self, owner: PyRx.RxObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function is almost identical to AcDbObject::deepClone, except that an AcDbWblockCloneFiler is used and ownership is not carried across database boundaries. Subcloning is based on hard owner and hard pointer connections.'''
    ...
    def worldDraw (self, wdraw: PyGi.WorldDraw)-> int :
      '''                             '''
    ...
    def xData (self, appname: str = None)-> list :
      '''Returns a linked list of resbuf structures containing a copy of the xdata for the object. If regappName == NULL is passed in, all xdata is returned, otherwise only the xdata for the specified name is returned. If not all xdata is required, but the xdata for more than one regappName is desired, then multiple calls to this member function must be made--one for each regappName.The caller of this function is responsible for releasing the memory used by the resbuf list that is returned. The most commonly used way to deallocate such a list is via the acutRelRb() function.This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If a failure accessing the xdata occurs, NULL is returned.'''
    ...
    def xDataTransformBy (self, xform: PyGe.Matrix3d)-> None :
      '''This method applies the xform transformation matrix to any XData data types 1011, 1021, 1031, 1012, 1022, 1032, 1013, 1023, 1033, 1041, and 1042 in the object's XData. See the documentation on XData for more information on the way the transformation matrix is applied to the different data types.This method should be called from within the transformBy() method on custom entities so that such entities will transform XData in the same way that the built-in AcDb entities do.Returns Acad::eOk if successful.'''
    ...
    def xmitPropagateModify (self)-> None :
      '''Within an object's close() method is a call to the object's xmitPropagateModify().The AcDbObject::xmitPropagateModify() default implementation is to inform the containing database that the object has been modified, appended to the database, or erased. The database then sends out the appropriate notification to any AcDbDatabaseReactors attached to it.Within AutoCAD, this function is used by complex entities such as polylines to allow the subentities to notify the header that they have been changed. The header can then "propagate" the notification by sending its own notification that the "complex entity" has been modified.The way this works is:The subobject class has it's xmitPropagateModify() class overridden such that it calls it's parent class's xmitPropagateModify() and also calls the owning object's recvPropagateModify().The "root" or "header" class has it's recvPropagateModify() overridden to provide an implementation that triggers "modified" notification to be sent for the "root" or "header" (which effectively represents the whole complex object).The subobject's close() triggers "modified" notification for the subobject and calls the subobject's xmitPropagateModify() function. So, when the subobject's close() is called, its xmitPropagateModify() is called. This then calls the owning object's recvPropagateModify(), which then triggers the owner to send "modified" notification.So, the result is a "modified" notification from both the subentity and the "root" or "header" entity.When overridden, this function should:Call its parent class's xmitPropagateModify() (which ultimately results in the execution of AcDbObject::xmitPropagateModify() to trigger database notification).Call its owner's recvPropagateModify() (passing in its "this" pointer) to "propagate" the notification information to the "root" owner to be sent out.'''
    ...

class CvDbPoint(CvDbEntity):
    def __init__ (self, id: ObjectId, mode: PyDb.OpenMode=PyDb.OpenMode.kForRead, erased: bool=False)-> None :
      '''                             '''
    ...
    def addContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def addPersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Adds the database-resident object specified by objId to the reactor list of the AcDbObject object.'''
    ...
    def addReactor (self, reactor: PyDb.EntityReactor)-> None :
      '''                             '''
    ...
    def addSubentPaths (self, paths: list[PyDb.FullSubentPath])-> None :
      '''Adds one or more subentities to an entity.The prototype of this method is provided for completeness of the subentity manipulation APIs. AutoCAD will never call this method on a custom object.Returns Acad::eOk if successful. The default implementation returns Acad::eNotAvailable.'''
    ...
    def assertNotifyEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should be used inside of member functions that are only called when the object is open kForNotify. When used, it should be the first function called inside the member function.'''
    ...
    def assertReadEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that access the object's data in a read-only fashion (for example, dxfOutFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is open AcDb::kForRead.If this function is called while the object is not open, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def assertWriteEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that modify the object's data (for example, dxfInFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is indeed open for write (if it is not, then AutoCAD terminates); to trigger an immediate sending of "openedForModify" notification; to set up the notification mechanism so that "modified" and "modifiedGraphics" (if the object is derived from AcDbEntity) are sent at the appropriate times; and to ensure that graphics get updated if the object is derived from AcDbEntity.If this function is called on a database resident object, "openedForModify" will be sent if the object is not newly created, and "modified", and "modifiedGraphics" (if appropriate) notifications will be sent when the object is next closed.If recordModified is false, then the autoUndo argument is ignored, and the undo filer is not initialized, no undo recording will take place, but notifications will be sent.If autoUndo and recordModified are both true, then automatic undo recording will be performed and notifications will be sent.If autoUndo is false and recordModified is true, then there will not be any automatic undo recording, but the undo filer is initialized and the object must manually write out partial Undo records and must implement its applyPartialUndo() method. Notifications will be sent.If this function is called while the object is not open AcDb::kForWrite, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def blockId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the entity's owner, which must be an AcDbBlockTableRecord.If the entity does not have an owner yet, then AcDbObjectId::kNull will be returned.'''
    ...
    def bounds (self, ext: PyDb.Extents)-> bool :
      '''                             '''
    ...
    def cancel (self)-> None :
      '''Terminates the current open operation. All changes made to the object since it was opened are undone, the object is marked as closed, and "cancel" notification is sent.Returns Acad::eOk if successful.'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbPoint :
      '''                             '''
    ...
    def castShadows (self)-> bool :
      '''Returns a boolean value that indicates whether the entity can cast shadows. '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...

    @staticmethod
    def cloneFrom (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbPoint :
      '''                             '''
    ...
    def close (self)-> None :
      '''Closes the object. All changes made to the object since it was opened are committed to the database, the object is marked as pageable, and a "closed" notification (as well as any other appropriate notification such as "modified", "erased", and so on) is sent.Returns Acad::eOk if successful.If the object is not in an AcDbDatabase yet, then Acad::eNoDatabase is returned.If the object is sending notification, then Acad::eCloseWasNotifying is returned.If the subClose() call made within the close() method returns anything other than Acad::eOk, then that ErrorStatus is returned.'''
    ...
    def collisionType (self)-> PyDb.CollisionType :
      '''This function returns the collision detection treatment for this entity. Subclasses may override this method to customize how the class interacts in collision-aware features.'''
    ...
    def color (self)-> PyDb.Color :
      '''This function returns the full true color information for the entity within an instance of AcCmColor.The index value will be in the range 0 to 256. 0 and 256 are special values.0 indicates the entity uses the color of the BlockReference that's displaying it. If the entity is not displayed through a BlockReference (for example, it's directly owned by the model space BlockTableRecord) and its color is 0, then it will display as though its color were 7.256 indicates the entity uses the color specified in the LayerTableRecord it references.'''
    ...
    def colorIndex (self)-> int :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...
    def createExtensionDictionary (self)-> None :
      '''Creates an AcDbDictionary object and sets it up as the extension dictionary for the AcDbObject.Returns Acad::eOk if successful. If an extension dictionary already exists, Acad::eAlreadyInDb is returned.'''
    ...
    def database (self)-> PyDb.Database :
      '''Returns a pointer to the AcDbDatabase object that contains the AcDbObject.'''
    ...
    def deepClone (self, owner: PyDb.DbObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function gives control of deep clone operations to the object. In the default implementation, the object is cloned and appended to the owner object (pOwnerObject). The cloning is performed by an AcDbDeepCloneFiler. A record is also added to the idMap. Then, using the filer, any owned objects are deep cloned, with isPrimary set to Adesk::kFalse.'''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def disableUndoRecording (self, disable: bool)-> None :
      '''Turns off or on the Undo recording for the object. If disable == Adesk::kTrue, then Undo recording is turned off until this function is called with disable == Adesk::kFalse, at which time Undo recording is turned back on.'''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def downgradeOpen (self)-> None :
      '''Downgrades the object from being open AcDb::kForWrite, to being AcDb::kForRead. In the process, all changes made to the object while it was open for write are committed to the database and appropriate notification is sent.'''
    ...
    def downgradeToNotify (self, wasWritable: bool)-> None :
      '''Restores an object from being open both AcDb::kForNotify and AcDb::kForWrite, to being open just AcDb::kForNotify. The wasWritable value that was returned from the matching AcDbObject::upgradeFromNotify() call should be passed into this function to restore the proper open status.This function must have been preceded by a call to upgradeFromNotify().Returns Acad::eOk if successful.'''
    ...
    def draw (self)-> None :
      '''This function queues up the entity's graphics and flushes the graphics queue, forcing the entity and anything else in the queue to be drawn or re-drawn on-screen.Returns Acad::eOk if successful.If the entity is not in a database, then Acad::eNotInDatabase will be returned.If the entity is in a database other than the one currently loaded into the AutoCAD editor, then Acad::eNotCurrentDatabase will be returned.'''
    ...
    def drawableType (self)-> PyGi.GiDrawableType :
      '''                             '''
    ...
    def easting (self)-> float :
      '''                             '''
    ...
    def elevation (self)-> float :
      '''                             '''
    ...
    def entityColor (self)-> PyDb.EntityColor :
      '''This function returns the color settings of the entity in an AcCmEntityColor form. Most clients should use the color() function, which returns the heavyweight AcCmColor object. However, if color name information is not required, this function provides faster access to the lightweight AcCmEntityColor data.'''
    ...
    def erase (self, erasing : bool=True)-> None :
      '''Sets the erase bit of the object. If erasing == Adesk::kTrue, then the erase bit is set on. If erasing == Adesk::kFalse, then the erase bit is set off.'''
    ...
    def explode (self)-> list :
      '''Function UsageThis function is primarily intended for AutoCAD to call as part of an explode operation that includes this entity. However, this function can be used by ObjectARX applications to obtain an array of pointers to non-database-resident entity objects that are what the entity considers to be its exploded parts.When calling this function, the entitySet array does not need to be empty. This function will append to it, and pointers to entities that it creates to be used in its place as the "exploded" result.If this function is successful, it will return Acad::eOk. Other return values may vary depending on how it has been implemented.Function Implementation in Derived ClassesThis function should dynamically create (using the new operator) whatever entity objects are appropriate to be used to replace the entity after an explode operation has taken place. Pointers to these entities are then appended to the entitySet array. Once the pointers have been appended, the function should return with a status of Acad::eOk.'''
    ...
    def extensionDictionary (self)-> PyDb.ObjectId :
      '''Returns the objectId of the extension dictionary owned by the object. If the object does not own an extension dictionary, then the returned objectId is set to AcDbObjectId::kNull.'''
    ...
    def fullDescription (self)-> str :
      '''                             '''
    ...
    def getCompoundObjectTransform (self)-> PyGe.Matrix3d :
      '''This function is intended to be overridden by derived classes that are compound objects (in other words, objects that behave like blocks in the display list).A compound object has little or no geometry of its own; instead it relies on nested entities, perhaps the contents of a BlockTableRecord, to represent itself. A compound object must use the same transformation matrix for all of its contained entities. Otherwise selection and osnap will not function correctly. This is the method that the system uses to obtain that matrix from the compound object.This method should only be overridden if you return the kDrawableIsCompoundObject flag from setAttributes. The matrix you should return here is the one that you pass to pushModelTransform before you render your nested objects. You must override this method if you return the compound object flag in setAttributes, even if you don't push a transform for your nested objects. In that case you would return Acad::eOk and the identity transform in xMat.Default implementation: Returns Acad::eNotApplicable and the identity matrix in xMat.'''
    ...
    def getEcs (self)-> PyGe.Matrix3d :
      '''This function is intended to be overridden by derived classes that need to be able to provide access to an object coordinate system for objects of the class. The intent is that this function provide a transformation matrix that can be used to transform vectors or points from the object's object coordinate system (OCS) to the World Coordinate System (WCS).Default implementation: Return the identity matrix (ones along the diagonal, zeros elsewhere) in retVal.We recommend that all data stored in custom classes be stored in WCS coordinates. If this is done, then the object's OCS will be the WCS and the transformation matrix will be the identity matrix. Then this function will not need to be overridden since the identity matrix is this function's default return.'''
    ...
    def getField (self, prop: str='TEXT')-> PyDb.ObjectId :
      '''Gets the field ID. A field can be stored in an object using the property name as the key.Returns Acad::eOk if the object has a field for the specified property. Otherwise, returns an AutoCAD error status.'''
    ...
    def getFieldDictionary (self)-> PyDb.ObjectId :
      '''Returns the field dictionary ID. The field dictionary stores all the fields set in the object as property name-field object pairs. The ID will be null if there is no field in the object.'''
    ...
    def getGeomExtents (self)-> PyDb.Extents :
      '''Unimplemented at the AcDbEntity level, this method is intended to be overridden in derived classes.Derived classes should calculate and return the corner points (in WCS coordinates) of a box (with edges parallel to the WCS X, Y, and Z axes) that encloses the 3D extents of the entity, and return those points as an instance of class AcDbExtents in the "extents" parameter.Default implementation: Immediately returns Acad::eInvalidExtents.'''
    ...
    def getGeomExtents2d (self)-> PyDb.Extents2d :
      '''                             '''
    ...

    @overload
    def getGripPoints (self, /)-> tuple[Any,...] : ...
    @overload
    def getGripPoints (self, curViewUnitSize: float, gripSize: int, curViewDir: PyGe.Vector3d, bitflags: int)-> tuple[Any,...] : ...
    def getGripPoints (self, *args, **kwargs)-> tuple[Any,...] :
      '''Overloads:
    - None: Any
    - curViewUnitSize: float, gripSize: int, curViewDir: PyGe.Vector3d, bitflags: int
    
	-Function usageThis function supports "old style" grips, in applications that existed before the enhancement of grip functionality by the addition of the AcDbGripData class.This function is not intended to be called by ObjectARX applications. However, it is possible to do so (for example, as a pass-through from the getStretchPoints() method).Function implementation in derived classesThis function should append to the gripPoints array any points that are to treated as grip points for the entity.The gripPoints array is passed to all entities involved in the grip operation, so the array may already contain grip points for other entities. Therefore, it is very important to append the new points rather than assigning them to any existing elements in the array.When finished appending all desired grip points, return Acad::eOk. If anything other than Acad::eOk is returned, then grips are not activated for this entity.The osnapModes and geomIds arguments are not currently used.Default implementationImmediately returns Adesk::eNotImplemented.-'''
    ...
    def getHandle (self)-> PyDb.Handle :
      '''Fills in handle with the handle value for the object. If the object is not yet database-resident, then it will not have a handle. Use AcDbHandle::isNull to test for this condition.'''
    ...
    def getPlane (self)-> PyGe.Plane :
      '''If the entity is planar, then the plane containing the entity is returned in plane and flag is set to AcDb::kPlanar.If the entity is nonplanar, but is linear, then plane is set to an arbitrary plane that contains the entity and flag is set to AcDb::kLinear.If the entity is nonplanar and nonlinear, then plane is left unset and flag is set to AcDb::kNonPlanar.Returns Acad::eOk if successful. Other ErrorStatus return values are implementation-dependent.The default implementation is to return Acad::eNotApplicable.'''
    ...
    def getPlotStyleNameId (self)-> PyDb.ObjectId :
      '''Returns with id set to the object ID of the AcDbPlaceHolder object referenced by the entity. The AcDbPlaceHolder object resides in the plot style name dictionary, and its key in the dictionary is the plot style name.Use the AcDbDictionary::nameAt() function on the plot style name dictionary to get the plot style name string that corresponds to the ID obtained by this function.'''
    ...
    def getStretchPoints (self)-> list :
      '''Function usageThis function is not intended to be called by ObjectARX applications. However, it is possible to do so (for example, as a pass-through from the getGripPoints() method).Function implementation in derived classesThis function should append to the stretchPoints array any points that are to treated as stretch points for the entity.Stretch points are used by the stretch command within AutoCAD. Any stretch points that are within the crossing selection window during the stretch command, will be moved by whatever amount the user decides to "stretch" the selected entities. Any stretch points not in the crossing selection window will be left alone. This combination of some stretch points moving while others do not is what "stretches" the entity. If all stretch points are in the crossing window, then the entity is moved instead of stretched.The stretchPoints array is passed to all entities involved in the stretch operation, so the array may already contain stretch points for other entities. Therefore it is very important to append the new points rather than assigning them to any existing elements in the array.When finished appending all desired stretch points, return Acad::eOk. If anything other than Acad::eOk is returned, then this entity's stretch points will be ignored by the stretch operation.Default implementationCalls the AcDbEntity::getGripPoints() method. So, unless the entity needs to have stretch points that are different from the grip points, there is no need to override this method.'''
    ...
    def getSubentPathsAtGsMarker (self, type: PyDb.SubentType, gsMark: int, pickPoint: PyGe.Point3d, viewXform: PyGe.Matrix3d)-> list[PyDb.FullSubentPath] :
      '''Entities use various graphic primitives defined in AcGi to draw themselves. Part of this mechanism is the ability to associate an integer identifier called a graphics system marker (or, GS marker) with each primitive or with groups of primitives. Through the use of certain selection mechanisms, the GS marker for the actual subentity selected on screen can be obtained and, along with some other information passed into this function, can be used to create one or more AcDbFullSubentPath objects, each one representing a subentity and providing a more complete description of the subentity and its environment. These AcDbFullSubentPath objects can be used by several other functions for various purposes such as highlighting or unhighlighting the subentities on screen.Function usageIf the entity (of which the subentity is a part) is directly owned by the model or paper space BlockTableRecords, then leave out numInserts and entAndInsertStack so that their default value will be used.Typically the GS marker is obtained via the use of ads_ssget() followed by ads_ssnamex() (see the ObjectARX Developer's Guide for more information on this).The pickPoint can be obtained from ads_ssnamex() as well (it's the first group 5009 in the returned list).The viewXform can be calculated using the ads_trans() function on the vectors (1,0,0), (0,1,0), and (0,0,1) to translate them from DCS to WCS. The translations of these three vectors (with an extra 0 appended on to the end of each) would be used as the first three rows of the matrix. The last row is not used so it can be left as is. This argument is not used by any of the AutoCAD built-in entities.If the entity is nested inside one or more block definitions, then the numInserts and entAndInsertStack arguments must also be filled in with non-zero or non-null values. If they are not filled in, then this function will fail and return an error status. One way to get the necessary object IDs is to use ads_nentselp() to obtain the list of ads_names of the container objects. This list must then be converted to object IDs and reversed.Upon return, the subentPaths argument will point to a dynamically allocated array of one or more AcDbFullSubentPath objects. The numPaths argument will contain the number of AcDbFullSubentPath objects being returned.The calling application is responsible for deallocating the memory used by the subentPaths array. The C++ delete [ ] should be used.Return values for this function may vary depending on how the function has been implemented (see below).Function implementation in derived classesEntity classes which do not set GS markers probably should not implement this function since the GS marker is the primary (and often the only) means of subentity distinction.When implemented, this function must use the material provided in type, gsMark, pickPoint, viewXform, numInserts, and entAndInsertStack to determine which subentity or subentities meet the criteria in these arguments. Next it must create a dynamically allocated array of AcDbFullSubentPaths (using the C++ new operator) with one element for each subentity determined in the first step. Finally it must fill in each AcDbFullSubentPath object in the array with the information appropriate to the subentity it will represent.If numInserts == 0 and entAndInsertStack == NULL, it's important to check to be sure that the entity's owner is indeed the model or paper space BlockTableRecord. This can be done by using the entity's ownerId() method to obtain the objectId of its owner, and then opening up that object and using its name() method to obtain its name string. If the owner is not the model or paper space BlockTableRecord, and numInserts == 0 or entAndInsertStack == NULL, or both, then the input data is invalid and this function should set numPaths to 0, set subentPaths to NULL and then return the error status Acad::eInvalidInput.Each AcDbFullSubentPath object has two parts, an array of objectIds containing all the container objects, and an embedded AcDbSubentId object which in turn has two elements: an index value and a SubentityType.If the "main" entity (the entity on which this function is being called) is not nested within BlockReferences (that is, numInserts == 0 and entAndInsertStack == NULL), then the objectId array should contain only the objectId of the "main" entity. If the "main" entity is nested in one or more BlockReferences, then the AcDbObjectIdArray is the same as entAndInsertStack, so copying the entAndInsertStack elements into the AcDbObjectIdArray is all that's required.The SubentType data item within the embedded AcDbSubentId should be set the same as type.The index data item within the embedded AcDbSubentId can be any value you wish (it is often simply the GS marker), but if implemented, the following functions must be able to interpret them to determine the corresponding GS marker(s) or subentity (or subentities):getGsMarkersAtSubentPath()subentPtr()The pickPoint and viewXform arguments are provided as extra aids (if necessary) in determining which subentity is involved. For example, some entity types might display differently depending on the display viewpoint. The viewXform transformation matrix can be used in such cases.The viewXform argument provides a transformation matrix to transform from WCS (World Coordinate System) to DCS (display coordinate system).The display coordinate system is oriented such that the positive Z axis is coming out of the display screen towards the user, the positive X axis is horizontally from left to right on screen, and the positive Y axis is vertically upwards on screen.So, if the current viewpoint is at (1,0,0) (the viewer is always looking towards (0,0,0)) then the viewXform matrix would be:0 1 0 00 0 1 01 0 0 00 0 0 1In this matrix the last row and the last column are not used. Notice also that the third row is the DCS Z axis in WCS coordinates (which is the WCS version of the AutoCAD VIEWPOINT system variable).When this function returns, the return code to use is completely up to the implementer, but to be consistent with other existing entity class implementations of this function the following should be used:If the function succeeds, it should return Acad::eOk.If an invalid or unsupported SubentType is passed in, then numPaths should be set to 0, subentPaths should be set to NULL, and Acad::eWrongSubentityType should be returned.If an invalid GS marker (or any other data item that turns out to be needed) is passed in, then numPaths should be set to 0, subentPaths should be set to NULL, and Acad::eInvalidInput should be returned.Default implementationImmediately returns Adesk::eNotApplicable.'''
    ...
    def getTransformedCopy (self, matrix3d: PyGe.Matrix3d)-> PyDb.Entity :
      '''Function usageThis function creates a clone of the entity, applies the xform transformation matrix to the clone, and then returns with pEnt pointing to the transformed clone.Returns Acad::eOk if successful.If xform is a non-uniform scaling matrix or non-orthogonal then Acad::eCannotScaleNonUniformly or Acad::eNotImplemented is returned.WarningFor AutoCAD built-in complex entities such as polylines, this function produces a shallow clone of the header entity only, which also owns the original set of "owned" entities (such as vertices for a polyline) which are then transformed by the xform matrix. This results in a corrupt drawing (two header entities owning the same set of "owned" entities) as well as transforming the original set of "owned" entities instead of a copied set.Function implementation in derived classesThe default AcDbEntity implementation of this function should be adequate for most derived entity types. However, derived entity classes that wish to support non-uniform scaling or non-orthogonal transformations will need to override this method with their own implementation.This function must create a copy of the entity (using memory that has been dynamically allocated via the C++ new operator), apply the transformation matrix xform to the copy and then return with pEnt pointing to the transformed copy.Determining what constitutes a valid transformation matrix and whether to do a shallow clone (that is, the entity's clone() method), a deepclone (if the entity owns other objects), or no clone at all (that is, make this function a no-op), is up to the implementer.Return values for this function are also up to the implementer, but to be consistent with other existing classes the following is recommended:If the function succeeds, it should return Acad::eOk.If the function is to be a no-op, it should return Acad::eNotImplementedIf non-uniform scaling is not to be supported and a non-uniform scaling matrix is passed in, then either Acad::eCannotScaleNonUniformly or Acad::eNotImplemented should be returned.Default implementationIf the entity is uniformly scaled and orthogonal, AcDbEntity::getTransformedCopy will call the entity's clone() method to create a clone of the entity, then call AcDbEntity::transformBy() on the clone, and then return with pEnt set to point to the transformed clone. If xform is a non-uniformly scaled or a non-orthogonal matrix, then this function will return Acad::eNotImplemented.'''
    ...
    def handOverTo (self, newObject: PyDb.DbObject, keepXData: bool, keepExtDict: bool)-> None :
      '''This function provides the ability to exchange a non-database-resident object (NDBRO) in place of an existing database-resident object (DBRO) while retaining the objectId, handle, and reactor list of the DBRO. An example of this situation is when the BREAK command is used to break a circle into one or two arc segments. AcDbArc is a completely different class from AcDbCircle, so a new AcDbArc object must be substituted in place of the AcDbCircle object that is there now, yet the arc must get the handle and objectId that the circle has.To use the handOverTo() function, the object to be replaced (the AcDbCircle in the example) must be open AcDb::kForWrite. The object's handOverTo() function is called with newObject pointing to a non-database-resident object that replaces it (the AcDbArc in the example).keepXData is set to Adesk::kTrue if the xdata is to be retained or Adesk::kFalse if the xdata is to be thrown out.keepExtDict is set to Adesk::kTrue if the extension dictionary and its contents are to be retained, or set to Adesk::kFalse if the extension dictionary and its contents are to be thrown out.Once returned from this function, the replacement object (the AcDbArc in the example) is open for AcDb::kForWrite and must have its close() member called to commit the change and close out Undo recording. Then it's up to the ObjectARX application to delete the old object (the AcDbCircle in the example) from memory since it's no longer database-resident.Returns Acad::eObjectToBeDeleted if the operation is successful. If newObject is pointing to an object that is already in the database, or the object invoking handOverTo() is not database-resident, then Acad::eIllegalReplacement is returned.'''
    ...
    def hasFields (self)-> bool :
      '''Returns true if the object has one or more PyDb.Field Objects. Otherwise returns false.'''
    ...
    def hasPersistentReactor (self, id: PyDb.ObjectId)-> bool :
      '''This method returns true if objId is the object ID of a reactor attached to this object. Otherwise, it returns false.'''
    ...
    def hasXData (self, appname: str)-> bool :
      '''                             '''
    ...
    def highlight (self, path: PyDb.FullSubentPath = None, highlightAll : bool = False)-> None :
      '''Function usageThis function uses the AcDbFullSubentPathid to determine which subentity in the entity is desired. It then highlights that subentity on screen. If no AcDbFullSubentPath argument is provided, then the entire entity will be highlighted.Typically, the AcDbFullSubentPath object passed in via subId is obtained from the entity's AcDbEntity::getSubentPathsAtGsMarker() method. This guarantees that it is fully and properly filled in.This function uses the entity's getGsMarkersAtSubentPath() method to get the GS markers associated with subId. If that function does not return Acad::eOk, then this function will fail and return whatever ErrorStatus was returned by getGsMarkersAtSubentPath().If this function succeeds, then it returns Acad::eOk.It is not necessary to balance each highlight() function call with a corresponding call to unhighlight(). Calling the unhighlight() function will unhighlight the entity designated by subId regardless of how many times the highlight function has been called on it.WarningIf the entity on which this method is called has its graphics queued for regeneration (that is, changes have been made to the entity but have not yet been reflected on screen), then this method will not cause a highlight to occur. Also, calling this method on an entity that's open for write and whose graphics are queued for regeneration may terminate AutoCAD.To avoid this limitation, before calling highlight(), you should flush the entity's graphics by either calling the entity's draw() method, or calling the AcTransactionManager::flushGraphics() function.Function implementation in derived classesThe AcDbEntity::highlight() implementation does all the work necessary to highlight any subentities that correspond to the subIdFullSubentPath. So, there is no need to override this method unless you wish to do some pre-or post-processing, or you wish to disable the ability to highlight subentities.If this method is overridden and it is supposed to highlight subentities, then the AcDbEntity::highlight() method will need to be invoked at some point within this function in order to do the actual highlighting.Within the AcDbEntity::highlight() method, the getGsMarkersAtSubentPath() method of this entity is called to translate the FullSubentPath into the corresponding GS markers. So, if this function is to succeed, the getGsMarkersAtSubentPath() method needs to be implemented as well.For more information on the subIdAcDbFullSubentPath argument, see the documentation on the getGsMarkersAtSubentPath() or getSubentPathsAtGsMarker() methods.'''
    ...
    def id (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...

    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, thisGsMarker : int, otherGsMarker : int)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane, thisGsMarker : int, otherGsMarker : int)-> list : ...
    def intersectWith (self, *args, **kwargs)-> list :
      '''Overloads:
    - entity: PyDb.Entity, intType : PyDb.Intersect
    - entity: PyDb.Entity, intType : PyDb.Intersect, thisGsMarker : int, otherGsMarker : int
    - entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane
    - entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane, thisGsMarker : int, otherGsMarker : int
    
	-Function usageIt finds the intersections of the entity pointed to by pEnt and all the edges of the bounding box of this entity.The intType is used to determine how to deal with extending the two entities in order to calculate intersections. The possible AcDb::Intersect values are:AcDb::kOnBothOperandsDo not extend either entity. This results in only calculating intersections where the two entitys' geometry actually intersectAcDb::kExtendThisExtend this entity (if necessary) when calculating intersections, but do not extend the pEnt entity.AcDb::kExtendArgExtend the pEnt entity (if necessary) when calculating intersections, but do not extend this entity.AcDb::kExtendBothExtend both the pEnt entity and this entity (if necessary) when calculating intersectionsAny intersection points found are appended to the points array. All points are in WCS coordinates.The thisGsMarker and otherGsMarker arguments are intended to provide this function with information to allow it to localize the search for intersections to be between specific subentities. However, this function is not required to make use of either of these arguments (most, if not all, of the AutoCAD built-in entity classes do not). When calling this function, either or both of these arguments may be 0 in order to indicate that they should be ignored.If this function is successful it returns Acad::eOk. Return values for error conditions are dependent on the implementation of this function in the classes involved.Function implementation in derived classesThis function should do all it can to find all intersection points between the entity it's being called on and the entity pointed to by pEnt. All intersection points found should be appended to the points array. All such points must be in WCS coordinates.When implementing the intersection calculation portion of this function you should take a good look at the AcGe classes to see if they can provide any useful functionality to help in finding intersections with the geometric primitives that make up the entity this function is being called on and the pEnt entity. For example, the AcGeCurve3d class has an isOn() method that will indicate if a supplied point is on the curve and the AcGeCircArc3d class has several intersectWith() methods to find intersections with other AcGe types.If the pEnt entity is a type not recognized by this function, it is quite reasonable to call the pEnt entity's intersectWith() method passing in a pointer to this entity as the "pEnt", and all the other arguments passed into this function (remembering to convert the intType argument If necessary) to see if that entity can determine any intersection points. This is what the AutoCAD built-in classes do.Also, don't forget to take into account the intType value. The intType tells you which, if any, of the two entities should be extended to find "apparent" intersections. It is not required that apparent intersection be supported, but if it is not, then an appropriate ErrorStatus value should be returned to indicate that the call failed.The thisGsMarker and otherGsMarker arguments are provided to allow this function to determine exactly which subentities are involved in the intersection operation (for example, if this function is being called by AutoCAD as part of an intersection Osnap operation these arguments would indicate which subentities are within the osnap pickbox). For these arguments, a value less than or equal to zero indicates that that argument should not be used.If this function completes successfully (even if no intersection points are found), it should return Acad::eOk. Determining what is considered an error and what ErrorStatus return code to use for any such errors are up to the implementer -- there are no conventions in this regard.Default implementationImmediately returns Acad::eNotImplemented.-'''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isAProxy (self)-> int :
      '''Returns Adesk::kTrue if the object is a proxy object or entity. Otherwise returns Adesk::kFalse.'''
    ...
    def isAcDbObjectIdsInFlux (self)-> int :
      '''This function refers to a condition that occurs during deep clone operations. It returns Adesk::kTrue when the cloned objects' IDs have not yet been translated and thus cannot be used in any operations on the objects. This condition normally occurs only during AcEditorReactor::beginDeepCloneXlation, AcDbObject::deepClone, or AcDbObject::wblockClone. Any operations that involve AcDbObjectId references, such as symbol table records, should be postponed until after endDeepClone. AcDbObject::subClose is never called on any objects whose IDs are in flux.'''
    ...
    def isAnnotative (self)-> PyDb.AnnotativeStates :
      '''                             '''
    ...
    def isCancelling (self)-> int :
      '''Returns Adesk::kTrue if the object is currently in the middle of a cancel() call (that is, an open is being canceled and all changes made are being rolled back). Otherwise returns Adesk::kFalse.'''
    ...
    def isEraseStatusToggled (self)-> int :
      '''Returns Adesk::kTrue if the object's erase bit has been toggled since it was opened. Otherwise returns Adesk::kFalse.'''
    ...
    def isErased (self)-> int :
      '''Returns Adesk::kTrue if the object is currently erased. Otherwise returns Adesk::kFalse.'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isLabelDragged (self)-> bool :
      '''                             '''
    ...
    def isLabelPinned (self)-> bool :
      '''                             '''
    ...
    def isModified (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called). Otherwise returns Adesk::kFalse.'''
    ...
    def isModifiedGraphics (self)-> int :
      '''Returns Adesk::kTrue if the object is derived from AcDbEntity and has had either an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called), or its recordGraphicsModified() function called with an Adesk::kTrue argument value.Otherwise it returns Adesk::kFalse.'''
    ...
    def isModifiedXData (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called) and has then had its setXData() method called. Otherwise it returns Adesk::kFalse.'''
    ...
    def isNewObject (self)-> int :
      '''Returns Adesk::kTrue if the object has not yet been closed since it was first created. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifyEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForNotify. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifying (self)-> int :
      '''Returns Adesk::kTrue if the object is in the process of sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isPersistent (self)-> int :
      '''                             '''
    ...
    def isPlanar (self)-> int :
      '''This function returns Adesk::kTrue if and only if there is a plane that contains the entity. Otherwise Adesk::kFalse is returned.'''
    ...
    def isReadEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForRead. Otherwise returns Adesk::kFalse.'''
    ...
    def isReallyClosing (self)-> int :
      '''Returns true if calling close() at this time would really close the object completely. For example, if the object is not in a transaction, and is open for read with only one reader, then Adesk::kTrue would be returned. If, on the other hand, the object is in a transaction, then Adesk::kFalse would be returned.'''
    ...
    def isTransactionResident (self)-> int :
      '''Returns Adesk::kTrue if the object is currently part of a transaction. Otherwise returns Adesk::kFalse.'''
    ...
    def isUndoRecordingDisabled (self)-> bool :
      '''Returns true if undo recording is disabled.'''
    ...
    def isUndoing (self)-> int :
      '''Returns Adesk::kTrue if the object is involved in an Undo operation at this time. Otherwise returns Adesk::kFalse.'''
    ...
    def isWriteEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForWrite and is not currently sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def labelId (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def labelLeaderVertices (self)-> list :
      '''                             '''
    ...
    def labelPosition (self)-> PyGe.Point3d :
      '''                             '''
    ...
    def labelRotation (self)-> float :
      '''                             '''
    ...
    def layer (self)-> str :
      '''This function returns a copy of the name string in the AcDbLayerTableRecord object referenced by the entity.The calling application is responsible for deallocating the memory used by the returned string. The acutDelString() function is recommended.WarningCalling this function before the entity has had its referenced layer object ID set (that is, it's still set to AcDbObjectId::kNull) will terminate AutoCAD. If the referenced layer objectId is AcDbObjectId::kNull when the entity is added to a database, it will be set to the object ID of the database's current default layer.'''
    ...
    def layerId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the AcDbLayerTableRecord referenced by the entity. If the layerId has not been set yet, then AcDbObjectId::kNull is returned.'''
    ...
    def lineWeight (self)-> PyDb.LineWeight :
      '''This function returns the AcDb::LineWeight of the entity.'''
    ...
    def linetype (self)-> str :
      '''This function returns a copy of the name string in the AcDbLinetypeTableRecord object referenced by the entity.The calling application is responsible for deallocating the memory used by the returned string. Either the C++ delete [ ] or the C free() function may be used.Warning Calling this function before the entity has had its referenced linetype object ID set (that is, it's still set to AcDbObjectId::kNull) will terminate AutoCAD. If the referenced linetype objectId is AcDbObjectId::kNull when the entity is added to a database it will be set to the object ID of the database's current default linetype.'''
    ...
    def linetypeId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the AcDbLinetypeTableRecord referenced by the entity. If the linetypeId has not been set yet, then AcDbObjectId::kNull will be returned.'''
    ...
    def linetypeScale (self)-> float :
      '''This function returns the linetype scale factor for the entity.'''
    ...
    def list (self)-> None :
      '''Function usageThis function is intended to be called from AutoCAD whenever the entity is selected during the LIST command. However, it can be called from ObjectARX applications if desired.This function will print entity specific information to the AutoCAD command line.Function implementation in derived classesWhen implementing this function in a derived class, the first thing that should be done in the function is to make a call to assertReadEnabled(). The next thing to do is to call the parent class's list() method to allow the parent class to list it's information (the parent class should in turn call its parent class first and so on up the inheritance chain until AcDbObject is reached. This way all the entity's information will be properly printed out in order). Once the parent class's list function has been called then a series of ads_printf() calls can be used to list whatever information is desired.Default implementationLists out the entity's DXF name, the layer, the space the entity resides in (model or paper), and the entity's handle.'''
    ...
    def material (self)-> str :
      '''Returns the material name.'''
    ...
    def materialId (self)-> PyDb.ObjectId :
      '''Returns the ID of the associated AcDbMaterial object.'''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def northing (self)-> float :
      '''                             '''
    ...
    def number (self)-> int :
      '''                             '''
    ...
    def objectId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the object. If the object is not yet database-resident, then the returned objectId will be set to AcDbObjectId::kNull.'''
    ...
    def ownerId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the owner of the object. If the object does not yet have an owner, or the ownerId data member has not yet been set using AcDbObject::setOwnerId, then the returned objectId will be set to AcDbObjectId::kNull.Appending the object to a BlockTable record, a symbol table, or a dictionary automatically calls AcDbObject::setOwnerId.'''
    ...
    def plotStyleName (self)-> str :
      '''This function returns a copy of the plotStyleName string of the entity. The caller is responsible for deallocating the returned string.The plotStyleName value is used for DXF group code 390.'''
    ...
    def pointGroupsIds (self)-> list :
      '''                             '''
    ...
    def pointGroupsNames (self)-> list :
      '''                             '''
    ...
    def position (self)-> PyGe.Point3d :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def rawDescription (self)-> str :
      '''                             '''
    ...
    def receiveShadows (self)-> bool :
      '''Returns a boolean value indicating whether this entity can receive shadows.'''
    ...
    def recordGraphicsModified (self)-> None :
      '''This method sets the entity's state to indicate whether or not the entity should be updated on screen when it is closed. If the entity is set not to update, then any changes made will appear the next time the entity is regenerated.If setModified is false and the entity is currently set to update its graphics on close (which is its default state), then this function sets the entity so that it will not update on screen when it is closed and objectModified notification is sent to all entity type reactors attached to the entity. If setModified is false and the entity is already set not to update its graphics on close, then this function simply returns.If setModified is true, then the entity is set to update on screen when it is closed.'''
    ...
    def referencedEntityAt (self, val : int)-> PyBrxCv.CvDbPointReferencedEntity :
      '''                             '''
    ...
    def referencedEntityCount (self)-> int :
      '''                             '''
    ...
    def releaseExtensionDictionary (self)-> None :
      '''Removes the object's extension dictionary (that is, removes the object as the owner of the dictionary object) if it exists and is empty. Once removed, this function calls the dictionary's erase() method. Any reactors attached to the extension dictionary receive normal notification appropriate to an open for write, erase, close sequence.Returns Acad::eOk if successful.If the dictionary is not empty, then this function fails and returns Acad::eContainerNotEmpty.'''
    ...
    def removeContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def removeField (self, id: str|PyDb.ObjectId)-> None :
      '''Removes the specified field.Returns Acad::eOk if successful. Otherwise, returns an AutoCAD error status.'''
    ...
    def removePersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Removes the persistent reactor specified by objId from the reactor list of the object. The object must be open AcDb::kForWrite to be able to execute this function.Returns Acad::eOk if successful. If the object is currently sending notification and is not open AcDb::kForWrite, then Acad::eWasNotifying is returned.'''
    ...
    def removeReactor (self, reactor: PyDb.EntityReactor)-> None :
      '''                             '''
    ...
    def resetLabel (self)-> bool :
      '''                             '''
    ...
    def rolloverHit (self, nSubentId: int, nMouseFlags: int, bReset: bool)-> int :
      '''                             '''
    ...
    def setAcDbObjectIdsInFlux (self)-> None :
      '''This function must be called on any newly created objects in AcDbObject::deepClone or AcDbObject::wblockClone. It indicates that reference object IDs are not yet pointing to the correct objects. The references can be translated only when the entire deep clone operation is complete. The flag is cleared at that time.'''
    ...
    def setAnnotative (self, state : PyDb.AnnotativeStates)-> None :
      '''                             '''
    ...
    def setAttributes (self, traits: PyGi.DrawableTraits)-> int :
      '''                             '''
    ...
    def setCastShadows (self, val: bool)-> None :
      '''Sets the property to indicate whether the entity can cast shadows.'''
    ...
    def setColor (self, clr: PyDb.AcCmColor, dosubents : bool=True, db : PyDb.Database='current')-> None :
      '''Function usageThis method sets the entity's color to the color specified by color. If the entity owns subentities and doSubents == Adesk::kTrue, the color change is applied to the subentities as well. Custom classes may override this method.'''
    ...
    def setColorIndex (self, clr: int, dosubents : bool=True)-> None :
      '''Function usageThis method sets the entity's color to the AutoCAD color index color. If the entity owns subentities and doSubents == Adesk::kTrue, then the color index change will be applied to the subentities as well.'''
    ...
    def setDatabaseDefaults (self, db: PyDb.Database = 'current')-> None :
      '''This function sets the entity's:ColorLayerLinetypeLinetype scaleVisibilityPlot style nameLine weightto the default values of the database indicated by pDb: If pDb == NULL, then the current database in the AutoCAD editor is used.'''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...
    def setEasting (self, val : float)-> bool :
      '''                             '''
    ...
    def setElevation (self, val : float)-> bool :
      '''                             '''
    ...

    @overload
    def setField (self, field: PyDb.Field)-> PyDb.ObjectId : ...
    @overload
    def setField (self, propName: str, field: PyDb.Field)-> PyDb.ObjectId : ...
    def setField (self, *args, **kwargs)-> PyDb.ObjectId :
      '''Overloads:
    - field: PyDb.Field
    - propName: str, field: PyDb.Field
    '''
    ...
    def setLabelId (self, id : PyDb.ObjectId)-> bool :
      '''                             '''
    ...
    def setLabelLeaderVertices (self, vertices : list[PyGe.Point3d])-> bool :
      '''                             '''
    ...
    def setLabelPinned (self, val : bool)-> bool :
      '''                             '''
    ...
    def setLabelPosition (self, pt : PyGe.Point3d)-> bool :
      '''                             '''
    ...
    def setLabelRotation (self, val : float)-> bool :
      '''                             '''
    ...
    def setLayer (self, val: str|PyDb.ObjectId, dosubents : bool=True, allowHiddenLayer : bool=False)-> None :
      '''This method sets entity to reference the AcDbLayerTableRecord identified by the name specified in newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the layer change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.'''
    ...
    def setLineWeight (self, val: PyDb.LineWeight, dosubents : bool=True)-> None :
      '''This method sets the entity to use lineweight. If the entity owns subentities and doSubents == Adesk::kTrue, then the line weight change will be applied to the subentities as well.Returns Acad::eOk if successful.Function implementation in derived classesIf this function is overridden and wishes to set the line weight of the entity, then it must call AcDbEntity::setLineWeight() passing on the lineweight and doSubents arguments.It is also possible for this function's implementation to deal directly with any subentities and pass a doSubents value of Adesk::kFalse to AcDbEntity:: setLineWeight().If the line weight setting operation is successful, then this function should return Acad::eOk. If lineweight is not an acceptable value, then this function should return Acad::eInvalidInput. Any other error return values are up to the implementer.'''
    ...
    def setLinetype (self, val: str|PyDb.ObjectId, dosubents : bool=True)-> None :
      '''Function usageThis method sets the entity to reference the AcDbLinetypeTableRecord with the name specified in newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the linetype change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.'''
    ...
    def setLinetypeScale (self, val: float, dosubents : bool=True)-> None :
      '''This method sets the entity to use newval as its linetype scale factor. newVal must be nonnegative. If the entity owns subentities and doSubents == Adesk::kTrue, then the linetype scale change will be applied to the subentities as well.'''
    ...
    def setMaterial (self, val: str|PyDb.ObjectId, dosubents : bool=True)-> None :
      '''This method sets the material reference to the specified material. The specified name must correspond to an existing AcDbMaterial object.Returns Acad::eOk when successful'''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setNorthing (self, val : float)-> bool :
      '''                             '''
    ...
    def setNumber (self, val : int)-> bool :
      '''                             '''
    ...
    def setOwnerId (self, owner: PyDb.ObjectId)-> None :
      '''Sets the ownerId data member of the object to be objId, thus establishing a "backpointer." This backpointer is used by WBLOCK to be sure all necessary objects are written out.Returns Acad::eOk if successful.'''
    ...

    @overload
    def setPlotStyleName (self, /)-> None : ...
    @overload
    def setPlotStyleName (self, nameType: PyDb.PlotStyleNameType, doSubents: bool)-> None : ...
    @overload
    def setPlotStyleName (self, nameType: PyDb.PlotStyleNameType, newId: PyDb.ObjectId, doSubents: bool)-> None : ...
    def setPlotStyleName (self, *args, **kwargs)-> None :
      '''Overloads:
    - None: Any
    - nameType: PyDb.PlotStyleNameType, doSubents: bool
    - nameType: PyDb.PlotStyleNameType, newId: PyDb.ObjectId, doSubents: bool
    
	-This function searches the PlotStyleName dictionary for an entry with the name that matches newName and if found, sets the entity to use that plotStyleName entry. Because a lookup in the PlotStyleName dictionary is required, the entity must be database-resident for this method to succeed. The names ByLayer and ByBlock are allowed as well as user-defined names.If the entity owns subentities and doSubents == Adesk::kTrue, then the change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.Returns Acad::eOk if successful. If the entity is not database-resident, then Acad::eNoDatabase will be returned. If there is no entry in the PlotStyleName dictionary for newName, then Acad::eKeyNotFound will be returned.The plotStyleName value is used for DXF group code 390.-'''
    ...
    def setPosition (self, pt : PyGe.Point3d)-> bool :
      '''                             '''
    ...
    def setPropertiesFrom (self, entity: PyDb.Entity, dosubents : bool=True)-> None :
      '''This method copies theColorLayerLinetypeLinetype scaleVisibilityvalues from the entity pointed to by pEntity into this entity. If the entity owns subentities and doSubents == Adesk::kTrue, then the property changes will be applied to the subentities as well.Returns Acad::eOk if successful.'''
    ...
    def setRawDescription (self, val : str)-> bool :
      '''                             '''
    ...
    def setReceiveShadows (self, val: bool)-> None :
      '''Sets the property indicating whether this entity can receive shadows.'''
    ...
    def setSymbolId (self, id : PyDb.ObjectId)-> bool :
      '''                             '''
    ...
    def setSymbolRotation (self, val : float)-> bool :
      '''                             '''
    ...
    def setVisibility (self, val: PyDb.Visibility, dosubents : bool=True)-> None :
      '''This method sets the visibility of an entity to the value specified by newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the visibility change will be applied to the subentities as well.'''
    ...
    def setXData (self, xdata: list)-> None :
      '''Each regapp sublist (delimited by a resbuf with restype == 1001 and resval.rstring == a valid regappName string) within the resbuf chain pointed to by xdata, is placed in the xdata area of the object. If any of the regappNames in xdata are already present in the xdata area of the object, then that regappName's existing data on the object is overwritten by that regappName's new data in xdata.All resbufs with restype == 1001 must have valid regappNames for the database the object resides in (that is, the regappNames must be in the APPID table of the database).Only valid xdata group codes (1000--1071) are accepted in the restype fields of the resbufs in xdata.No "-3" group code is necessary, and in fact, is not accepted. So, the first element in the resbuf chain must be a 1001 group code with a resval.rstring set to a regappName that's already registered in the regapp table. To register a regappName, use the acdbRegApp() function.To remove an appName (and its xdata) from an object, just use a resbuf with restype == 1001, resval == and no data resbufs following it (that is, either its rbnext == NULL or the next resbuf is another 1001)This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If this function is overridden, then it should supermessage its parent in order to invoke the built-in mechanism to add the xdata to the object.Returns Acad::eOk if the xdata is successfully added to the object. If there is insufficient space in the xdata area of the object, then Acad::eXdataSizeExceeded is returned. If any of the regappNames in xdata are not in the APPID table, then Acad::eRegappIdNotFound is returned.'''
    ...
    def snoop (self,  filer : PyDb.SnoopDwgFiler)-> None :
      '''                             '''
    ...
    def swapIdWith (self, otherId: PyDb.DbObject, swapXdata: bool, swapExtDict: bool)-> None :
      '''This function swaps objectIds and handles between the object specified by otherId and the object invoking this function. Both objects must currently be database-resident and must reside in the same database. If swapXdata == Adesk::kTrue, then the objects swap extended entity data as well. If swapExtDict == Adesk::kTrue, then the objects swap extension dictionaries also.If the object specified by otherId or the object invoking this function are not database-resident, then Acad::eNoDatabase is returned. If both objects involved are not in the same database, then Acad::eWrongDatabase is returned.'''
    ...
    def symbolId (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def symbolRotation (self)-> float :
      '''                             '''
    ...
    def transformBy (self, matrix3d: PyGe.Matrix3d)-> None :
      '''Function usageThis function provides a means by which AutoCAD and ObjectARX applications can ask the entity to apply a transformation matrix (xform) to itself.Each entity class must implement this function, so restrictions on what types of transformations are supported are up to the implementer of the entity class. The AutoCAD built-in entity classes for entity types that existed before R13 (that is, all the classes listed in the header file dbents.h such as AcDbCircle, AcDbLine, AcDbArc, AcDb2dPolyline, etc.) require that the transformation matrix represent a uniformly scaling orthogonal transformation (if it is not, then Acad::eCannotScaleNonUniformly will be returned). Other AutoCAD built-in classes have no restrictions.Returns Acad::eOk if successful. Return values for errors are implementation-dependent.Function implementation in derived classesThis function must apply the transformation matrix xform to the entity and change the entity's state to reflect the transformation. It is completely up to the implementer as to how to apply the transformation. It is also up to the implementer to decide what, if any, restrictions will be placed on the type of transformations supported. If any restrictions are desired, then it's up to the implementation of this function to enforce them.If your derived class implements transformBy() without calling the base class, you must call AcDbObject:: xDataTransformBy() or your Xdata will not be transformed.If this function successfully transforms the entity, then it should return Acad::eOk.Return values for error conditions are completely up to the implementer of this function. However, if the error is caused by a non-uniformly scaling or non-orthogonal matrix, then to be consistent with other entities that have this restriction, it is recommended that Acad::eCannotScaleNonUniformly be returned.'''
    ...
    def update (self)-> bool :
      '''                             '''
    ...
    def upgradeFromNotify (self, wasWritable: bool)-> None :
      '''Upgrades the object from being at least open AcDb::kForNotify to being open both AcDb::kForNotify and AcDb::kForWrite. The wasWritable argument is set to Adesk::kTrue if the object was already open for write, otherwise it's set to Adesk::kFalse. The wasWritable value should be saved to be passed into the downgradeToNotify() call later.This function must be followed at some point by a call to downgradeToNotify() with no open() (in any of its forms) or close() calls in between.This method should only be called from within other methods of the same object it is being called from. In other words, this method is intended to be used by an object to change it's own open status so that it can safely modify itself.upgradeFromNotify() and downgradeToNotify() call pairs are not nestable.Returns Acad::eOk if successful. If the object is not currently open AcDb::kForNotify, then Acad::eNotApplicable is returned. If the object is currently in the process of actually sending notification (that is, isNotifying() returns Adesk::kTrue), then Acad::eWasNotifying is returned.'''
    ...
    def upgradeOpen (self)-> None :
      '''If the object is currently open AcDb::kForRead with only one reader, then this function upgrades the object to open AcDb::kForWrite. In the process of changing to open for write, the object is closed, thus triggering any pertinent notification.Returns Acad::eOk if successful. If the object has more than one reader, then the open status is not changed and Adesk::eHadMultipleReaders is returned. If the object is already open AcDb::kForWrite, then Acad::eWasOpenForWrite is returned. If the object is currently sending notification, then the open status is not changed and Acad::eWasNotifying is returned.'''
    ...
    def viewportDraw (self, vpdraw: PyGi.ViewportDraw)-> None :
      '''                             '''
    ...
    def viewportDrawLogicalFlags (self, vpdraw: PyGi.ViewportDraw)-> int :
      '''                             '''
    ...
    def visibility (self)-> PyDb.Visibility :
      '''This method returns the entity's current visibility state, either AcDb::kVisible or AcDb::kInvisible.'''
    ...
    def wblockClone (self, owner: PyRx.RxObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function is almost identical to AcDbObject::deepClone, except that an AcDbWblockCloneFiler is used and ownership is not carried across database boundaries. Subcloning is based on hard owner and hard pointer connections.'''
    ...
    def worldDraw (self, wdraw: PyGi.WorldDraw)-> int :
      '''                             '''
    ...
    def xData (self, appname: str = None)-> list :
      '''Returns a linked list of resbuf structures containing a copy of the xdata for the object. If regappName == NULL is passed in, all xdata is returned, otherwise only the xdata for the specified name is returned. If not all xdata is required, but the xdata for more than one regappName is desired, then multiple calls to this member function must be made--one for each regappName.The caller of this function is responsible for releasing the memory used by the resbuf list that is returned. The most commonly used way to deallocate such a list is via the acutRelRb() function.This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If a failure accessing the xdata occurs, NULL is returned.'''
    ...
    def xDataTransformBy (self, xform: PyGe.Matrix3d)-> None :
      '''This method applies the xform transformation matrix to any XData data types 1011, 1021, 1031, 1012, 1022, 1032, 1013, 1023, 1033, 1041, and 1042 in the object's XData. See the documentation on XData for more information on the way the transformation matrix is applied to the different data types.This method should be called from within the transformBy() method on custom entities so that such entities will transform XData in the same way that the built-in AcDb entities do.Returns Acad::eOk if successful.'''
    ...
    def xmitPropagateModify (self)-> None :
      '''Within an object's close() method is a call to the object's xmitPropagateModify().The AcDbObject::xmitPropagateModify() default implementation is to inform the containing database that the object has been modified, appended to the database, or erased. The database then sends out the appropriate notification to any AcDbDatabaseReactors attached to it.Within AutoCAD, this function is used by complex entities such as polylines to allow the subentities to notify the header that they have been changed. The header can then "propagate" the notification by sending its own notification that the "complex entity" has been modified.The way this works is:The subobject class has it's xmitPropagateModify() class overridden such that it calls it's parent class's xmitPropagateModify() and also calls the owning object's recvPropagateModify().The "root" or "header" class has it's recvPropagateModify() overridden to provide an implementation that triggers "modified" notification to be sent for the "root" or "header" (which effectively represents the whole complex object).The subobject's close() triggers "modified" notification for the subobject and calls the subobject's xmitPropagateModify() function. So, when the subobject's close() is called, its xmitPropagateModify() is called. This then calls the owning object's recvPropagateModify(), which then triggers the owner to send "modified" notification.So, the result is a "modified" notification from both the subentity and the "root" or "header" entity.When overridden, this function should:Call its parent class's xmitPropagateModify() (which ultimately results in the execution of AcDbObject::xmitPropagateModify() to trigger database notification).Call its owner's recvPropagateModify() (passing in its "this" pointer) to "propagate" the notification information to the "root" owner to be sent out.'''
    ...

class CvDbPointGroup(CvDbObject):
    def __init__ (self, id: ObjectId, mode: PyDb.OpenMode=PyDb.OpenMode.kForRead, erased: bool=False)-> None :
      '''                             '''
    ...
    def addContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def addPersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Adds the database-resident object specified by objId to the reactor list of the AcDbObject object.'''
    ...
    def addReactor (self, reactor: PyDb.DbObjectReactor)-> None :
      '''Adds the transient reactor pointed to by pNewObj to the AcDbObject object's reactor list.'''
    ...
    def assertNotifyEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should be used inside of member functions that are only called when the object is open kForNotify. When used, it should be the first function called inside the member function.'''
    ...
    def assertReadEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that access the object's data in a read-only fashion (for example, dxfOutFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is open AcDb::kForRead.If this function is called while the object is not open, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def assertWriteEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that modify the object's data (for example, dxfInFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is indeed open for write (if it is not, then AutoCAD terminates); to trigger an immediate sending of "openedForModify" notification; to set up the notification mechanism so that "modified" and "modifiedGraphics" (if the object is derived from AcDbEntity) are sent at the appropriate times; and to ensure that graphics get updated if the object is derived from AcDbEntity.If this function is called on a database resident object, "openedForModify" will be sent if the object is not newly created, and "modified", and "modifiedGraphics" (if appropriate) notifications will be sent when the object is next closed.If recordModified is false, then the autoUndo argument is ignored, and the undo filer is not initialized, no undo recording will take place, but notifications will be sent.If autoUndo and recordModified are both true, then automatic undo recording will be performed and notifications will be sent.If autoUndo is false and recordModified is true, then there will not be any automatic undo recording, but the undo filer is initialized and the object must manually write out partial Undo records and must implement its applyPartialUndo() method. Notifications will be sent.If this function is called while the object is not open AcDb::kForWrite, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def bounds (self, ext: PyDb.Extents)-> bool :
      '''                             '''
    ...
    def cancel (self)-> None :
      '''Terminates the current open operation. All changes made to the object since it was opened are undone, the object is marked as closed, and "cancel" notification is sent.Returns Acad::eOk if successful.'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbPointGroup :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...

    @staticmethod
    def cloneFrom (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbPointGroup :
      '''                             '''
    ...
    def close (self)-> None :
      '''Closes the object. All changes made to the object since it was opened are committed to the database, the object is marked as pageable, and a "closed" notification (as well as any other appropriate notification such as "modified", "erased", and so on) is sent.Returns Acad::eOk if successful.If the object is not in an AcDbDatabase yet, then Acad::eNoDatabase is returned.If the object is sending notification, then Acad::eCloseWasNotifying is returned.If the subClose() call made within the close() method returns anything other than Acad::eOk, then that ErrorStatus is returned.'''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...
    def createExtensionDictionary (self)-> None :
      '''Creates an AcDbDictionary object and sets it up as the extension dictionary for the AcDbObject.Returns Acad::eOk if successful. If an extension dictionary already exists, Acad::eAlreadyInDb is returned.'''
    ...
    def database (self)-> PyDb.Database :
      '''Returns a pointer to the AcDbDatabase object that contains the AcDbObject.'''
    ...
    def deepClone (self, owner: PyDb.DbObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function gives control of deep clone operations to the object. In the default implementation, the object is cloned and appended to the owner object (pOwnerObject). The cloning is performed by an AcDbDeepCloneFiler. A record is also added to the idMap. Then, using the filer, any owned objects are deep cloned, with isPrimary set to Adesk::kFalse.'''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def disableUndoRecording (self, disable: bool)-> None :
      '''Turns off or on the Undo recording for the object. If disable == Adesk::kTrue, then Undo recording is turned off until this function is called with disable == Adesk::kFalse, at which time Undo recording is turned back on.'''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def downgradeOpen (self)-> None :
      '''Downgrades the object from being open AcDb::kForWrite, to being AcDb::kForRead. In the process, all changes made to the object while it was open for write are committed to the database and appropriate notification is sent.'''
    ...
    def downgradeToNotify (self, wasWritable: bool)-> None :
      '''Restores an object from being open both AcDb::kForNotify and AcDb::kForWrite, to being open just AcDb::kForNotify. The wasWritable value that was returned from the matching AcDbObject::upgradeFromNotify() call should be passed into this function to restore the proper open status.This function must have been preceded by a call to upgradeFromNotify().Returns Acad::eOk if successful.'''
    ...
    def drawableType (self)-> PyGi.GiDrawableType :
      '''                             '''
    ...
    def erase (self, erasing : bool=True)-> None :
      '''Sets the erase bit of the object. If erasing == Adesk::kTrue, then the erase bit is set on. If erasing == Adesk::kFalse, then the erase bit is set off.'''
    ...
    def excludeElevations (self, *args, **kwargs)-> str :
      '''excludeElevations( (CvDbPointGroup)arg1) -> str :

    C++ signature :
        class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > excludeElevations(class PyBrxCvDbPointGroup {lvalue})'''
    ...
    def excludeFullDescriptions (self)-> str :
      '''                             '''
    ...
    def excludeNames (self)-> str :
      '''                             '''
    ...
    def excludeNumbers (self)-> str :
      '''                             '''
    ...
    def excludeRawDescriptions (self)-> str :
      '''                             '''
    ...
    def excludeUserAttributesKeys (self)-> str :
      '''                             '''
    ...
    def excludeUserAttributesValues (self)-> str :
      '''                             '''
    ...
    def extensionDictionary (self)-> PyDb.ObjectId :
      '''Returns the objectId of the extension dictionary owned by the object. If the object does not own an extension dictionary, then the returned objectId is set to AcDbObjectId::kNull.'''
    ...
    def getField (self, prop: str='TEXT')-> PyDb.ObjectId :
      '''Gets the field ID. A field can be stored in an object using the property name as the key.Returns Acad::eOk if the object has a field for the specified property. Otherwise, returns an AutoCAD error status.'''
    ...
    def getFieldDictionary (self)-> PyDb.ObjectId :
      '''Returns the field dictionary ID. The field dictionary stores all the fields set in the object as property name-field object pairs. The ID will be null if there is no field in the object.'''
    ...
    def getHandle (self)-> PyDb.Handle :
      '''Fills in handle with the handle value for the object. If the object is not yet database-resident, then it will not have a handle. Use AcDbHandle::isNull to test for this condition.'''
    ...
    def handOverTo (self, newObject: PyDb.DbObject, keepXData: bool, keepExtDict: bool)-> None :
      '''This function provides the ability to exchange a non-database-resident object (NDBRO) in place of an existing database-resident object (DBRO) while retaining the objectId, handle, and reactor list of the DBRO. An example of this situation is when the BREAK command is used to break a circle into one or two arc segments. AcDbArc is a completely different class from AcDbCircle, so a new AcDbArc object must be substituted in place of the AcDbCircle object that is there now, yet the arc must get the handle and objectId that the circle has.To use the handOverTo() function, the object to be replaced (the AcDbCircle in the example) must be open AcDb::kForWrite. The object's handOverTo() function is called with newObject pointing to a non-database-resident object that replaces it (the AcDbArc in the example).keepXData is set to Adesk::kTrue if the xdata is to be retained or Adesk::kFalse if the xdata is to be thrown out.keepExtDict is set to Adesk::kTrue if the extension dictionary and its contents are to be retained, or set to Adesk::kFalse if the extension dictionary and its contents are to be thrown out.Once returned from this function, the replacement object (the AcDbArc in the example) is open for AcDb::kForWrite and must have its close() member called to commit the change and close out Undo recording. Then it's up to the ObjectARX application to delete the old object (the AcDbCircle in the example) from memory since it's no longer database-resident.Returns Acad::eObjectToBeDeleted if the operation is successful. If newObject is pointing to an object that is already in the database, or the object invoking handOverTo() is not database-resident, then Acad::eIllegalReplacement is returned.'''
    ...
    def hasFields (self)-> bool :
      '''Returns true if the object has one or more PyDb.Field Objects. Otherwise returns false.'''
    ...
    def hasPersistentReactor (self, id: PyDb.ObjectId)-> bool :
      '''This method returns true if objId is the object ID of a reactor attached to this object. Otherwise, it returns false.'''
    ...
    def hasPoint (self, val : int)-> PyDb.ObjectId :
      '''                             '''
    ...
    def hasXData (self, appname: str)-> bool :
      '''                             '''
    ...
    def id (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def includeElevations (self)-> str :
      '''                             '''
    ...
    def includeFullDescriptions (self)-> str :
      '''                             '''
    ...
    def includeNames (self)-> str :
      '''                             '''
    ...
    def includeNumbers (self)-> str :
      '''                             '''
    ...
    def includeRawDescriptions (self)-> str :
      '''                             '''
    ...
    def includeUserAttributesKeys (self)-> str :
      '''                             '''
    ...
    def includeUserAttributesValues (self)-> str :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isAProxy (self)-> int :
      '''Returns Adesk::kTrue if the object is a proxy object or entity. Otherwise returns Adesk::kFalse.'''
    ...
    def isAcDbObjectIdsInFlux (self)-> int :
      '''This function refers to a condition that occurs during deep clone operations. It returns Adesk::kTrue when the cloned objects' IDs have not yet been translated and thus cannot be used in any operations on the objects. This condition normally occurs only during AcEditorReactor::beginDeepCloneXlation, AcDbObject::deepClone, or AcDbObject::wblockClone. Any operations that involve AcDbObjectId references, such as symbol table records, should be postponed until after endDeepClone. AcDbObject::subClose is never called on any objects whose IDs are in flux.'''
    ...
    def isAnnotative (self)-> PyDb.AnnotativeStates :
      '''                             '''
    ...
    def isApplicable (self)-> bool :
      '''                             '''
    ...
    def isCancelling (self)-> int :
      '''Returns Adesk::kTrue if the object is currently in the middle of a cancel() call (that is, an open is being canceled and all changes made are being rolled back). Otherwise returns Adesk::kFalse.'''
    ...
    def isEditable (self)-> bool :
      '''                             '''
    ...
    def isEraseStatusToggled (self)-> int :
      '''Returns Adesk::kTrue if the object's erase bit has been toggled since it was opened. Otherwise returns Adesk::kFalse.'''
    ...
    def isErased (self)-> int :
      '''Returns Adesk::kTrue if the object is currently erased. Otherwise returns Adesk::kFalse.'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isModified (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called). Otherwise returns Adesk::kFalse.'''
    ...
    def isModifiedGraphics (self)-> int :
      '''Returns Adesk::kTrue if the object is derived from AcDbEntity and has had either an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called), or its recordGraphicsModified() function called with an Adesk::kTrue argument value.Otherwise it returns Adesk::kFalse.'''
    ...
    def isModifiedXData (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called) and has then had its setXData() method called. Otherwise it returns Adesk::kFalse.'''
    ...
    def isNewObject (self)-> int :
      '''Returns Adesk::kTrue if the object has not yet been closed since it was first created. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifyEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForNotify. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifying (self)-> int :
      '''Returns Adesk::kTrue if the object is in the process of sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isPersistent (self)-> int :
      '''                             '''
    ...
    def isReadEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForRead. Otherwise returns Adesk::kFalse.'''
    ...
    def isReallyClosing (self)-> int :
      '''Returns true if calling close() at this time would really close the object completely. For example, if the object is not in a transaction, and is open for read with only one reader, then Adesk::kTrue would be returned. If, on the other hand, the object is in a transaction, then Adesk::kFalse would be returned.'''
    ...
    def isTransactionResident (self)-> int :
      '''Returns Adesk::kTrue if the object is currently part of a transaction. Otherwise returns Adesk::kFalse.'''
    ...
    def isUndoRecordingDisabled (self)-> bool :
      '''Returns true if undo recording is disabled.'''
    ...
    def isUndoing (self)-> int :
      '''Returns Adesk::kTrue if the object is involved in an Undo operation at this time. Otherwise returns Adesk::kFalse.'''
    ...
    def isWriteEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForWrite and is not currently sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def objectId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the object. If the object is not yet database-resident, then the returned objectId will be set to AcDbObjectId::kNull.'''
    ...
    def ownerId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the owner of the object. If the object does not yet have an owner, or the ownerId data member has not yet been set using AcDbObject::setOwnerId, then the returned objectId will be set to AcDbObjectId::kNull.Appending the object to a BlockTable record, a symbol table, or a dictionary automatically calls AcDbObject::setOwnerId.'''
    ...
    def pointCount (self)-> int :
      '''                             '''
    ...
    def pointIds (self)-> list :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def releaseExtensionDictionary (self)-> None :
      '''Removes the object's extension dictionary (that is, removes the object as the owner of the dictionary object) if it exists and is empty. Once removed, this function calls the dictionary's erase() method. Any reactors attached to the extension dictionary receive normal notification appropriate to an open for write, erase, close sequence.Returns Acad::eOk if successful.If the dictionary is not empty, then this function fails and returns Acad::eContainerNotEmpty.'''
    ...
    def removeContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def removeField (self, id: str|PyDb.ObjectId)-> None :
      '''Removes the specified field.Returns Acad::eOk if successful. Otherwise, returns an AutoCAD error status.'''
    ...
    def removePersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Removes the persistent reactor specified by objId from the reactor list of the object. The object must be open AcDb::kForWrite to be able to execute this function.Returns Acad::eOk if successful. If the object is currently sending notification and is not open AcDb::kForWrite, then Acad::eWasNotifying is returned.'''
    ...
    def removeReactor (self, reactor: PyDb.DbObjectReactor)-> None :
      '''Removes reactor pointed to by pNewObj from the object's reactor list. The object may be open AcDb::kForRead or AcDb::kForWrite when this function is called.'''
    ...
    def rolloverHit (self, nSubentId: int, nMouseFlags: int, bReset: bool)-> int :
      '''                             '''
    ...
    def setAcDbObjectIdsInFlux (self)-> None :
      '''This function must be called on any newly created objects in AcDbObject::deepClone or AcDbObject::wblockClone. It indicates that reference object IDs are not yet pointing to the correct objects. The references can be translated only when the entire deep clone operation is complete. The flag is cleared at that time.'''
    ...
    def setAnnotative (self, state : PyDb.AnnotativeStates)-> None :
      '''                             '''
    ...
    def setAttributes (self, traits: PyGi.DrawableTraits)-> int :
      '''                             '''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...
    def setExcludeElevations (self, filter : str)-> bool :
      '''                             '''
    ...
    def setExcludeFullDescriptions (self, filter : str)-> bool :
      '''                             '''
    ...
    def setExcludeNames (self, filter : str)-> bool :
      '''                             '''
    ...
    def setExcludeNumbers (self, filter : str)-> bool :
      '''                             '''
    ...
    def setExcludeRawDescriptions (self, filter : str)-> bool :
      '''                             '''
    ...
    def setExcludeUserAttributesKeys (self, filter : str)-> bool :
      '''                             '''
    ...

    @overload
    def setField (self, field: PyDb.Field)-> PyDb.ObjectId : ...
    @overload
    def setField (self, propName: str, field: PyDb.Field)-> PyDb.ObjectId : ...
    def setField (self, *args, **kwargs)-> PyDb.ObjectId :
      '''Overloads:
    - field: PyDb.Field
    - propName: str, field: PyDb.Field
    '''
    ...
    def setIncludeElevations (self, filter : str)-> bool :
      '''                             '''
    ...
    def setIncludeFullDescriptions (self, filter : str)-> bool :
      '''                             '''
    ...
    def setIncludeNames (self, filter : str)-> bool :
      '''                             '''
    ...
    def setIncludeNumbers (self, filter : str)-> bool :
      '''                             '''
    ...
    def setIncludeRawDescriptions (self, filter : str)-> bool :
      '''                             '''
    ...
    def setIncludeUserAttributesKeys (self, filter : str)-> bool :
      '''                             '''
    ...
    def setIncludeUserAttributesValues (self, filter : str)-> bool :
      '''                             '''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setOwnerId (self, owner: PyDb.ObjectId)-> None :
      '''Sets the ownerId data member of the object to be objId, thus establishing a "backpointer." This backpointer is used by WBLOCK to be sure all necessary objects are written out.Returns Acad::eOk if successful.'''
    ...
    def setXData (self, xdata: list)-> None :
      '''Each regapp sublist (delimited by a resbuf with restype == 1001 and resval.rstring == a valid regappName string) within the resbuf chain pointed to by xdata, is placed in the xdata area of the object. If any of the regappNames in xdata are already present in the xdata area of the object, then that regappName's existing data on the object is overwritten by that regappName's new data in xdata.All resbufs with restype == 1001 must have valid regappNames for the database the object resides in (that is, the regappNames must be in the APPID table of the database).Only valid xdata group codes (1000--1071) are accepted in the restype fields of the resbufs in xdata.No "-3" group code is necessary, and in fact, is not accepted. So, the first element in the resbuf chain must be a 1001 group code with a resval.rstring set to a regappName that's already registered in the regapp table. To register a regappName, use the acdbRegApp() function.To remove an appName (and its xdata) from an object, just use a resbuf with restype == 1001, resval == and no data resbufs following it (that is, either its rbnext == NULL or the next resbuf is another 1001)This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If this function is overridden, then it should supermessage its parent in order to invoke the built-in mechanism to add the xdata to the object.Returns Acad::eOk if the xdata is successfully added to the object. If there is insufficient space in the xdata area of the object, then Acad::eXdataSizeExceeded is returned. If any of the regappNames in xdata are not in the APPID table, then Acad::eRegappIdNotFound is returned.'''
    ...
    def snoop (self,  filer : PyDb.SnoopDwgFiler)-> None :
      '''                             '''
    ...
    def swapIdWith (self, otherId: PyDb.DbObject, swapXdata: bool, swapExtDict: bool)-> None :
      '''This function swaps objectIds and handles between the object specified by otherId and the object invoking this function. Both objects must currently be database-resident and must reside in the same database. If swapXdata == Adesk::kTrue, then the objects swap extended entity data as well. If swapExtDict == Adesk::kTrue, then the objects swap extension dictionaries also.If the object specified by otherId or the object invoking this function are not database-resident, then Acad::eNoDatabase is returned. If both objects involved are not in the same database, then Acad::eWrongDatabase is returned.'''
    ...
    def update (self)-> bool :
      '''                             '''
    ...
    def updateNeeded (self)-> bool :
      '''                             '''
    ...
    def upgradeFromNotify (self, wasWritable: bool)-> None :
      '''Upgrades the object from being at least open AcDb::kForNotify to being open both AcDb::kForNotify and AcDb::kForWrite. The wasWritable argument is set to Adesk::kTrue if the object was already open for write, otherwise it's set to Adesk::kFalse. The wasWritable value should be saved to be passed into the downgradeToNotify() call later.This function must be followed at some point by a call to downgradeToNotify() with no open() (in any of its forms) or close() calls in between.This method should only be called from within other methods of the same object it is being called from. In other words, this method is intended to be used by an object to change it's own open status so that it can safely modify itself.upgradeFromNotify() and downgradeToNotify() call pairs are not nestable.Returns Acad::eOk if successful. If the object is not currently open AcDb::kForNotify, then Acad::eNotApplicable is returned. If the object is currently in the process of actually sending notification (that is, isNotifying() returns Adesk::kTrue), then Acad::eWasNotifying is returned.'''
    ...
    def upgradeOpen (self)-> None :
      '''If the object is currently open AcDb::kForRead with only one reader, then this function upgrades the object to open AcDb::kForWrite. In the process of changing to open for write, the object is closed, thus triggering any pertinent notification.Returns Acad::eOk if successful. If the object has more than one reader, then the open status is not changed and Adesk::eHadMultipleReaders is returned. If the object is already open AcDb::kForWrite, then Acad::eWasOpenForWrite is returned. If the object is currently sending notification, then the open status is not changed and Acad::eWasNotifying is returned.'''
    ...
    def viewportDraw (self, vpdraw: PyGi.ViewportDraw)-> None :
      '''                             '''
    ...
    def viewportDrawLogicalFlags (self, vpdraw: PyGi.ViewportDraw)-> int :
      '''                             '''
    ...
    def wblockClone (self, owner: PyRx.RxObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function is almost identical to AcDbObject::deepClone, except that an AcDbWblockCloneFiler is used and ownership is not carried across database boundaries. Subcloning is based on hard owner and hard pointer connections.'''
    ...
    def worldDraw (self, wdraw: PyGi.WorldDraw)-> int :
      '''                             '''
    ...
    def xData (self, appname: str = None)-> list :
      '''Returns a linked list of resbuf structures containing a copy of the xdata for the object. If regappName == NULL is passed in, all xdata is returned, otherwise only the xdata for the specified name is returned. If not all xdata is required, but the xdata for more than one regappName is desired, then multiple calls to this member function must be made--one for each regappName.The caller of this function is responsible for releasing the memory used by the resbuf list that is returned. The most commonly used way to deallocate such a list is via the acutRelRb() function.This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If a failure accessing the xdata occurs, NULL is returned.'''
    ...
    def xDataTransformBy (self, xform: PyGe.Matrix3d)-> None :
      '''This method applies the xform transformation matrix to any XData data types 1011, 1021, 1031, 1012, 1022, 1032, 1013, 1023, 1033, 1041, and 1042 in the object's XData. See the documentation on XData for more information on the way the transformation matrix is applied to the different data types.This method should be called from within the transformBy() method on custom entities so that such entities will transform XData in the same way that the built-in AcDb entities do.Returns Acad::eOk if successful.'''
    ...
    def xmitPropagateModify (self)-> None :
      '''Within an object's close() method is a call to the object's xmitPropagateModify().The AcDbObject::xmitPropagateModify() default implementation is to inform the containing database that the object has been modified, appended to the database, or erased. The database then sends out the appropriate notification to any AcDbDatabaseReactors attached to it.Within AutoCAD, this function is used by complex entities such as polylines to allow the subentities to notify the header that they have been changed. The header can then "propagate" the notification by sending its own notification that the "complex entity" has been modified.The way this works is:The subobject class has it's xmitPropagateModify() class overridden such that it calls it's parent class's xmitPropagateModify() and also calls the owning object's recvPropagateModify().The "root" or "header" class has it's recvPropagateModify() overridden to provide an implementation that triggers "modified" notification to be sent for the "root" or "header" (which effectively represents the whole complex object).The subobject's close() triggers "modified" notification for the subobject and calls the subobject's xmitPropagateModify() function. So, when the subobject's close() is called, its xmitPropagateModify() is called. This then calls the owning object's recvPropagateModify(), which then triggers the owner to send "modified" notification.So, the result is a "modified" notification from both the subentity and the "root" or "header" entity.When overridden, this function should:Call its parent class's xmitPropagateModify() (which ultimately results in the execution of AcDbObject::xmitPropagateModify() to trigger database notification).Call its owner's recvPropagateModify() (passing in its "this" pointer) to "propagate" the notification information to the "root" owner to be sent out.'''
    ...

class CvDbPointGroupManager(CvDbObjectManager):
    def __getitem__ (self, val : int|str)-> PyDb.ObjectId :
      '''                             '''
    ...
    def __init__ (self, id: ObjectId, mode: PyDb.OpenMode=PyDb.OpenMode.kForRead, erased: bool=False)-> None :
      '''                             '''
    ...
    def addContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def addPersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Adds the database-resident object specified by objId to the reactor list of the AcDbObject object.'''
    ...
    def addReactor (self, reactor: PyDb.DbObjectReactor)-> None :
      '''Adds the transient reactor pointed to by pNewObj to the AcDbObject object's reactor list.'''
    ...
    def assertNotifyEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should be used inside of member functions that are only called when the object is open kForNotify. When used, it should be the first function called inside the member function.'''
    ...
    def assertReadEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that access the object's data in a read-only fashion (for example, dxfOutFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is open AcDb::kForRead.If this function is called while the object is not open, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def assertWriteEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that modify the object's data (for example, dxfInFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is indeed open for write (if it is not, then AutoCAD terminates); to trigger an immediate sending of "openedForModify" notification; to set up the notification mechanism so that "modified" and "modifiedGraphics" (if the object is derived from AcDbEntity) are sent at the appropriate times; and to ensure that graphics get updated if the object is derived from AcDbEntity.If this function is called on a database resident object, "openedForModify" will be sent if the object is not newly created, and "modified", and "modifiedGraphics" (if appropriate) notifications will be sent when the object is next closed.If recordModified is false, then the autoUndo argument is ignored, and the undo filer is not initialized, no undo recording will take place, but notifications will be sent.If autoUndo and recordModified are both true, then automatic undo recording will be performed and notifications will be sent.If autoUndo is false and recordModified is true, then there will not be any automatic undo recording, but the undo filer is initialized and the object must manually write out partial Undo records and must implement its applyPartialUndo() method. Notifications will be sent.If this function is called while the object is not open AcDb::kForWrite, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def bounds (self, ext: PyDb.Extents)-> bool :
      '''                             '''
    ...
    def cancel (self)-> None :
      '''Terminates the current open operation. All changes made to the object since it was opened are undone, the object is marked as closed, and "cancel" notification is sent.Returns Acad::eOk if successful.'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbPointGroupManager :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...

    @staticmethod
    def cloneFrom (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbPointGroupManager :
      '''                             '''
    ...
    def close (self)-> None :
      '''Closes the object. All changes made to the object since it was opened are committed to the database, the object is marked as pageable, and a "closed" notification (as well as any other appropriate notification such as "modified", "erased", and so on) is sent.Returns Acad::eOk if successful.If the object is not in an AcDbDatabase yet, then Acad::eNoDatabase is returned.If the object is sending notification, then Acad::eCloseWasNotifying is returned.If the subClose() call made within the close() method returns anything other than Acad::eOk, then that ErrorStatus is returned.'''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...
    def createExtensionDictionary (self)-> None :
      '''Creates an AcDbDictionary object and sets it up as the extension dictionary for the AcDbObject.Returns Acad::eOk if successful. If an extension dictionary already exists, Acad::eAlreadyInDb is returned.'''
    ...
    def createPointGroup (self, val : str)-> PyDb.ObjectId :
      '''                             '''
    ...
    def database (self)-> PyDb.Database :
      '''Returns a pointer to the AcDbDatabase object that contains the AcDbObject.'''
    ...
    def deepClone (self, owner: PyDb.DbObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function gives control of deep clone operations to the object. In the default implementation, the object is cloned and appended to the owner object (pOwnerObject). The cloning is performed by an AcDbDeepCloneFiler. A record is also added to the idMap. Then, using the filer, any owned objects are deep cloned, with isPrimary set to Adesk::kFalse.'''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def disableUndoRecording (self, disable: bool)-> None :
      '''Turns off or on the Undo recording for the object. If disable == Adesk::kTrue, then Undo recording is turned off until this function is called with disable == Adesk::kFalse, at which time Undo recording is turned back on.'''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def downgradeOpen (self)-> None :
      '''Downgrades the object from being open AcDb::kForWrite, to being AcDb::kForRead. In the process, all changes made to the object while it was open for write are committed to the database and appropriate notification is sent.'''
    ...
    def downgradeToNotify (self, wasWritable: bool)-> None :
      '''Restores an object from being open both AcDb::kForNotify and AcDb::kForWrite, to being open just AcDb::kForNotify. The wasWritable value that was returned from the matching AcDbObject::upgradeFromNotify() call should be passed into this function to restore the proper open status.This function must have been preceded by a call to upgradeFromNotify().Returns Acad::eOk if successful.'''
    ...
    def drawableType (self)-> PyGi.GiDrawableType :
      '''                             '''
    ...
    def elementCount (self)-> int :
      '''                             '''
    ...
    def erase (self, erasing : bool=True)-> None :
      '''Sets the erase bit of the object. If erasing == Adesk::kTrue, then the erase bit is set on. If erasing == Adesk::kFalse, then the erase bit is set off.'''
    ...
    def extensionDictionary (self)-> PyDb.ObjectId :
      '''Returns the objectId of the extension dictionary owned by the object. If the object does not own an extension dictionary, then the returned objectId is set to AcDbObjectId::kNull.'''
    ...
    def getField (self, prop: str='TEXT')-> PyDb.ObjectId :
      '''Gets the field ID. A field can be stored in an object using the property name as the key.Returns Acad::eOk if the object has a field for the specified property. Otherwise, returns an AutoCAD error status.'''
    ...
    def getFieldDictionary (self)-> PyDb.ObjectId :
      '''Returns the field dictionary ID. The field dictionary stores all the fields set in the object as property name-field object pairs. The ID will be null if there is no field in the object.'''
    ...
    def getHandle (self)-> PyDb.Handle :
      '''Fills in handle with the handle value for the object. If the object is not yet database-resident, then it will not have a handle. Use AcDbHandle::isNull to test for this condition.'''
    ...

    @staticmethod
    def getManagerId (db: PyDb.Database)-> PyDb.ObjectId :
      '''                             '''
    ...
    def groupsWithPoint (self, val : int)-> list :
      '''                             '''
    ...
    def handOverTo (self, newObject: PyDb.DbObject, keepXData: bool, keepExtDict: bool)-> None :
      '''This function provides the ability to exchange a non-database-resident object (NDBRO) in place of an existing database-resident object (DBRO) while retaining the objectId, handle, and reactor list of the DBRO. An example of this situation is when the BREAK command is used to break a circle into one or two arc segments. AcDbArc is a completely different class from AcDbCircle, so a new AcDbArc object must be substituted in place of the AcDbCircle object that is there now, yet the arc must get the handle and objectId that the circle has.To use the handOverTo() function, the object to be replaced (the AcDbCircle in the example) must be open AcDb::kForWrite. The object's handOverTo() function is called with newObject pointing to a non-database-resident object that replaces it (the AcDbArc in the example).keepXData is set to Adesk::kTrue if the xdata is to be retained or Adesk::kFalse if the xdata is to be thrown out.keepExtDict is set to Adesk::kTrue if the extension dictionary and its contents are to be retained, or set to Adesk::kFalse if the extension dictionary and its contents are to be thrown out.Once returned from this function, the replacement object (the AcDbArc in the example) is open for AcDb::kForWrite and must have its close() member called to commit the change and close out Undo recording. Then it's up to the ObjectARX application to delete the old object (the AcDbCircle in the example) from memory since it's no longer database-resident.Returns Acad::eObjectToBeDeleted if the operation is successful. If newObject is pointing to an object that is already in the database, or the object invoking handOverTo() is not database-resident, then Acad::eIllegalReplacement is returned.'''
    ...
    def has1 (self, *args, **kwargs)-> bool :
      '''has1( (CvDbObjectManager)arg1, (ObjectId)arg2) -> bool :

    C++ signature :
        bool has1(class PyBrxCvDbObjectManager {lvalue},class PyDbObjectId)'''
    ...
    def has2 (self, id : str|PyDb.ObjectId)-> bool :
      '''                             '''
    ...
    def hasFields (self)-> bool :
      '''Returns true if the object has one or more PyDb.Field Objects. Otherwise returns false.'''
    ...
    def hasPersistentReactor (self, id: PyDb.ObjectId)-> bool :
      '''This method returns true if objId is the object ID of a reactor attached to this object. Otherwise, it returns false.'''
    ...
    def hasXData (self, appname: str)-> bool :
      '''                             '''
    ...
    def id (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def idAt (self, val : int|str)-> PyDb.ObjectId :
      '''                             '''
    ...
    def ids (self)-> list :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isAProxy (self)-> int :
      '''Returns Adesk::kTrue if the object is a proxy object or entity. Otherwise returns Adesk::kFalse.'''
    ...
    def isAcDbObjectIdsInFlux (self)-> int :
      '''This function refers to a condition that occurs during deep clone operations. It returns Adesk::kTrue when the cloned objects' IDs have not yet been translated and thus cannot be used in any operations on the objects. This condition normally occurs only during AcEditorReactor::beginDeepCloneXlation, AcDbObject::deepClone, or AcDbObject::wblockClone. Any operations that involve AcDbObjectId references, such as symbol table records, should be postponed until after endDeepClone. AcDbObject::subClose is never called on any objects whose IDs are in flux.'''
    ...
    def isAnnotative (self)-> PyDb.AnnotativeStates :
      '''                             '''
    ...
    def isCancelling (self)-> int :
      '''Returns Adesk::kTrue if the object is currently in the middle of a cancel() call (that is, an open is being canceled and all changes made are being rolled back). Otherwise returns Adesk::kFalse.'''
    ...
    def isEraseStatusToggled (self)-> int :
      '''Returns Adesk::kTrue if the object's erase bit has been toggled since it was opened. Otherwise returns Adesk::kFalse.'''
    ...
    def isErased (self)-> int :
      '''Returns Adesk::kTrue if the object is currently erased. Otherwise returns Adesk::kFalse.'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isModified (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called). Otherwise returns Adesk::kFalse.'''
    ...
    def isModifiedGraphics (self)-> int :
      '''Returns Adesk::kTrue if the object is derived from AcDbEntity and has had either an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called), or its recordGraphicsModified() function called with an Adesk::kTrue argument value.Otherwise it returns Adesk::kFalse.'''
    ...
    def isModifiedXData (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called) and has then had its setXData() method called. Otherwise it returns Adesk::kFalse.'''
    ...
    def isNewObject (self)-> int :
      '''Returns Adesk::kTrue if the object has not yet been closed since it was first created. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifyEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForNotify. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifying (self)-> int :
      '''Returns Adesk::kTrue if the object is in the process of sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isPersistent (self)-> int :
      '''                             '''
    ...
    def isReadEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForRead. Otherwise returns Adesk::kFalse.'''
    ...
    def isReallyClosing (self)-> int :
      '''Returns true if calling close() at this time would really close the object completely. For example, if the object is not in a transaction, and is open for read with only one reader, then Adesk::kTrue would be returned. If, on the other hand, the object is in a transaction, then Adesk::kFalse would be returned.'''
    ...
    def isTransactionResident (self)-> int :
      '''Returns Adesk::kTrue if the object is currently part of a transaction. Otherwise returns Adesk::kFalse.'''
    ...
    def isUndoRecordingDisabled (self)-> bool :
      '''Returns true if undo recording is disabled.'''
    ...
    def isUndoing (self)-> int :
      '''Returns Adesk::kTrue if the object is involved in an Undo operation at this time. Otherwise returns Adesk::kFalse.'''
    ...
    def isWriteEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForWrite and is not currently sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def nameAt (self, val : int)-> str :
      '''                             '''
    ...
    def nextPointNumber (self)-> int :
      '''                             '''
    ...
    def objectId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the object. If the object is not yet database-resident, then the returned objectId will be set to AcDbObjectId::kNull.'''
    ...

    @staticmethod
    def openManager (db: PyDb.Database,mode: PyDb.OpenMode)-> PyBrxCv.CvDbPointGroupManager :
      '''                             '''
    ...
    def ownerId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the owner of the object. If the object does not yet have an owner, or the ownerId data member has not yet been set using AcDbObject::setOwnerId, then the returned objectId will be set to AcDbObjectId::kNull.Appending the object to a BlockTable record, a symbol table, or a dictionary automatically calls AcDbObject::setOwnerId.'''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def releaseExtensionDictionary (self)-> None :
      '''Removes the object's extension dictionary (that is, removes the object as the owner of the dictionary object) if it exists and is empty. Once removed, this function calls the dictionary's erase() method. Any reactors attached to the extension dictionary receive normal notification appropriate to an open for write, erase, close sequence.Returns Acad::eOk if successful.If the dictionary is not empty, then this function fails and returns Acad::eContainerNotEmpty.'''
    ...
    def remove1 (self)-> bool :
      '''                             '''
    ...
    def remove2 (self, id : str|PyDb.ObjectId)-> bool :
      '''                             '''
    ...
    def removeContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def removeField (self, id: str|PyDb.ObjectId)-> None :
      '''Removes the specified field.Returns Acad::eOk if successful. Otherwise, returns an AutoCAD error status.'''
    ...
    def removePersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Removes the persistent reactor specified by objId from the reactor list of the object. The object must be open AcDb::kForWrite to be able to execute this function.Returns Acad::eOk if successful. If the object is currently sending notification and is not open AcDb::kForWrite, then Acad::eWasNotifying is returned.'''
    ...
    def removeReactor (self, reactor: PyDb.DbObjectReactor)-> None :
      '''Removes reactor pointed to by pNewObj from the object's reactor list. The object may be open AcDb::kForRead or AcDb::kForWrite when this function is called.'''
    ...
    def rolloverHit (self, nSubentId: int, nMouseFlags: int, bReset: bool)-> int :
      '''                             '''
    ...
    def setAcDbObjectIdsInFlux (self)-> None :
      '''This function must be called on any newly created objects in AcDbObject::deepClone or AcDbObject::wblockClone. It indicates that reference object IDs are not yet pointing to the correct objects. The references can be translated only when the entire deep clone operation is complete. The flag is cleared at that time.'''
    ...
    def setAnnotative (self, state : PyDb.AnnotativeStates)-> None :
      '''                             '''
    ...
    def setAttributes (self, traits: PyGi.DrawableTraits)-> int :
      '''                             '''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...

    @overload
    def setField (self, field: PyDb.Field)-> PyDb.ObjectId : ...
    @overload
    def setField (self, propName: str, field: PyDb.Field)-> PyDb.ObjectId : ...
    def setField (self, *args, **kwargs)-> PyDb.ObjectId :
      '''Overloads:
    - field: PyDb.Field
    - propName: str, field: PyDb.Field
    '''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setNextPointNumber (self, val : int)-> bool :
      '''                             '''
    ...
    def setOwnerId (self, owner: PyDb.ObjectId)-> None :
      '''Sets the ownerId data member of the object to be objId, thus establishing a "backpointer." This backpointer is used by WBLOCK to be sure all necessary objects are written out.Returns Acad::eOk if successful.'''
    ...
    def setXData (self, xdata: list)-> None :
      '''Each regapp sublist (delimited by a resbuf with restype == 1001 and resval.rstring == a valid regappName string) within the resbuf chain pointed to by xdata, is placed in the xdata area of the object. If any of the regappNames in xdata are already present in the xdata area of the object, then that regappName's existing data on the object is overwritten by that regappName's new data in xdata.All resbufs with restype == 1001 must have valid regappNames for the database the object resides in (that is, the regappNames must be in the APPID table of the database).Only valid xdata group codes (1000--1071) are accepted in the restype fields of the resbufs in xdata.No "-3" group code is necessary, and in fact, is not accepted. So, the first element in the resbuf chain must be a 1001 group code with a resval.rstring set to a regappName that's already registered in the regapp table. To register a regappName, use the acdbRegApp() function.To remove an appName (and its xdata) from an object, just use a resbuf with restype == 1001, resval == and no data resbufs following it (that is, either its rbnext == NULL or the next resbuf is another 1001)This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If this function is overridden, then it should supermessage its parent in order to invoke the built-in mechanism to add the xdata to the object.Returns Acad::eOk if the xdata is successfully added to the object. If there is insufficient space in the xdata area of the object, then Acad::eXdataSizeExceeded is returned. If any of the regappNames in xdata are not in the APPID table, then Acad::eRegappIdNotFound is returned.'''
    ...
    def snoop (self,  filer : PyDb.SnoopDwgFiler)-> None :
      '''                             '''
    ...
    def swapIdWith (self, otherId: PyDb.DbObject, swapXdata: bool, swapExtDict: bool)-> None :
      '''This function swaps objectIds and handles between the object specified by otherId and the object invoking this function. Both objects must currently be database-resident and must reside in the same database. If swapXdata == Adesk::kTrue, then the objects swap extended entity data as well. If swapExtDict == Adesk::kTrue, then the objects swap extension dictionaries also.If the object specified by otherId or the object invoking this function are not database-resident, then Acad::eNoDatabase is returned. If both objects involved are not in the same database, then Acad::eWrongDatabase is returned.'''
    ...
    def updatePointGroups (self)-> int :
      '''                             '''
    ...
    def upgradeFromNotify (self, wasWritable: bool)-> None :
      '''Upgrades the object from being at least open AcDb::kForNotify to being open both AcDb::kForNotify and AcDb::kForWrite. The wasWritable argument is set to Adesk::kTrue if the object was already open for write, otherwise it's set to Adesk::kFalse. The wasWritable value should be saved to be passed into the downgradeToNotify() call later.This function must be followed at some point by a call to downgradeToNotify() with no open() (in any of its forms) or close() calls in between.This method should only be called from within other methods of the same object it is being called from. In other words, this method is intended to be used by an object to change it's own open status so that it can safely modify itself.upgradeFromNotify() and downgradeToNotify() call pairs are not nestable.Returns Acad::eOk if successful. If the object is not currently open AcDb::kForNotify, then Acad::eNotApplicable is returned. If the object is currently in the process of actually sending notification (that is, isNotifying() returns Adesk::kTrue), then Acad::eWasNotifying is returned.'''
    ...
    def upgradeOpen (self)-> None :
      '''If the object is currently open AcDb::kForRead with only one reader, then this function upgrades the object to open AcDb::kForWrite. In the process of changing to open for write, the object is closed, thus triggering any pertinent notification.Returns Acad::eOk if successful. If the object has more than one reader, then the open status is not changed and Adesk::eHadMultipleReaders is returned. If the object is already open AcDb::kForWrite, then Acad::eWasOpenForWrite is returned. If the object is currently sending notification, then the open status is not changed and Acad::eWasNotifying is returned.'''
    ...
    def viewportDraw (self, vpdraw: PyGi.ViewportDraw)-> None :
      '''                             '''
    ...
    def viewportDrawLogicalFlags (self, vpdraw: PyGi.ViewportDraw)-> int :
      '''                             '''
    ...
    def wblockClone (self, owner: PyRx.RxObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function is almost identical to AcDbObject::deepClone, except that an AcDbWblockCloneFiler is used and ownership is not carried across database boundaries. Subcloning is based on hard owner and hard pointer connections.'''
    ...
    def worldDraw (self, wdraw: PyGi.WorldDraw)-> int :
      '''                             '''
    ...
    def xData (self, appname: str = None)-> list :
      '''Returns a linked list of resbuf structures containing a copy of the xdata for the object. If regappName == NULL is passed in, all xdata is returned, otherwise only the xdata for the specified name is returned. If not all xdata is required, but the xdata for more than one regappName is desired, then multiple calls to this member function must be made--one for each regappName.The caller of this function is responsible for releasing the memory used by the resbuf list that is returned. The most commonly used way to deallocate such a list is via the acutRelRb() function.This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If a failure accessing the xdata occurs, NULL is returned.'''
    ...
    def xDataTransformBy (self, xform: PyGe.Matrix3d)-> None :
      '''This method applies the xform transformation matrix to any XData data types 1011, 1021, 1031, 1012, 1022, 1032, 1013, 1023, 1033, 1041, and 1042 in the object's XData. See the documentation on XData for more information on the way the transformation matrix is applied to the different data types.This method should be called from within the transformBy() method on custom entities so that such entities will transform XData in the same way that the built-in AcDb entities do.Returns Acad::eOk if successful.'''
    ...
    def xmitPropagateModify (self)-> None :
      '''Within an object's close() method is a call to the object's xmitPropagateModify().The AcDbObject::xmitPropagateModify() default implementation is to inform the containing database that the object has been modified, appended to the database, or erased. The database then sends out the appropriate notification to any AcDbDatabaseReactors attached to it.Within AutoCAD, this function is used by complex entities such as polylines to allow the subentities to notify the header that they have been changed. The header can then "propagate" the notification by sending its own notification that the "complex entity" has been modified.The way this works is:The subobject class has it's xmitPropagateModify() class overridden such that it calls it's parent class's xmitPropagateModify() and also calls the owning object's recvPropagateModify().The "root" or "header" class has it's recvPropagateModify() overridden to provide an implementation that triggers "modified" notification to be sent for the "root" or "header" (which effectively represents the whole complex object).The subobject's close() triggers "modified" notification for the subobject and calls the subobject's xmitPropagateModify() function. So, when the subobject's close() is called, its xmitPropagateModify() is called. This then calls the owning object's recvPropagateModify(), which then triggers the owner to send "modified" notification.So, the result is a "modified" notification from both the subentity and the "root" or "header" entity.When overridden, this function should:Call its parent class's xmitPropagateModify() (which ultimately results in the execution of AcDbObject::xmitPropagateModify() to trigger database notification).Call its owner's recvPropagateModify() (passing in its "this" pointer) to "propagate" the notification information to the "root" owner to be sent out.'''
    ...

class CvDbPointReferencedEntity(CvDbSubObject):
    def __init__ (self)-> None :
      '''                             '''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbPointReferencedEntity :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def id (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...
    def setId (self, id : PyDb.ObjectId)-> bool :
      '''                             '''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def type (self)-> PyRx.RxClass :
      '''                             '''
    ...

class CvDbStyleManager(CvDbObjectManager):
    def __getitem__ (self, val : int|str)-> PyDb.ObjectId :
      '''                             '''
    ...
    def __init__ (self, id: PyDb.ObjectId, mode: PyDb.OpenMode=PyDb.OpenMode.kForRead, erased: bool=False)-> None :
      '''                             '''
    ...
    def addContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def addPersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Adds the database-resident object specified by objId to the reactor list of the AcDbObject object.'''
    ...
    def addReactor (self, reactor: PyDb.DbObjectReactor)-> None :
      '''Adds the transient reactor pointed to by pNewObj to the AcDbObject object's reactor list.'''
    ...
    def assertNotifyEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should be used inside of member functions that are only called when the object is open kForNotify. When used, it should be the first function called inside the member function.'''
    ...
    def assertReadEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that access the object's data in a read-only fashion (for example, dxfOutFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is open AcDb::kForRead.If this function is called while the object is not open, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def assertWriteEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that modify the object's data (for example, dxfInFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is indeed open for write (if it is not, then AutoCAD terminates); to trigger an immediate sending of "openedForModify" notification; to set up the notification mechanism so that "modified" and "modifiedGraphics" (if the object is derived from AcDbEntity) are sent at the appropriate times; and to ensure that graphics get updated if the object is derived from AcDbEntity.If this function is called on a database resident object, "openedForModify" will be sent if the object is not newly created, and "modified", and "modifiedGraphics" (if appropriate) notifications will be sent when the object is next closed.If recordModified is false, then the autoUndo argument is ignored, and the undo filer is not initialized, no undo recording will take place, but notifications will be sent.If autoUndo and recordModified are both true, then automatic undo recording will be performed and notifications will be sent.If autoUndo is false and recordModified is true, then there will not be any automatic undo recording, but the undo filer is initialized and the object must manually write out partial Undo records and must implement its applyPartialUndo() method. Notifications will be sent.If this function is called while the object is not open AcDb::kForWrite, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def bounds (self, ext: PyDb.Extents)-> bool :
      '''                             '''
    ...
    def cancel (self)-> None :
      '''Terminates the current open operation. All changes made to the object since it was opened are undone, the object is marked as closed, and "cancel" notification is sent.Returns Acad::eOk if successful.'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbStyleManager :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...

    @staticmethod
    def cloneFrom (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbStyleManager :
      '''                             '''
    ...
    def close (self)-> None :
      '''Closes the object. All changes made to the object since it was opened are committed to the database, the object is marked as pageable, and a "closed" notification (as well as any other appropriate notification such as "modified", "erased", and so on) is sent.Returns Acad::eOk if successful.If the object is not in an AcDbDatabase yet, then Acad::eNoDatabase is returned.If the object is sending notification, then Acad::eCloseWasNotifying is returned.If the subClose() call made within the close() method returns anything other than Acad::eOk, then that ErrorStatus is returned.'''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...
    def createExtensionDictionary (self)-> None :
      '''Creates an AcDbDictionary object and sets it up as the extension dictionary for the AcDbObject.Returns Acad::eOk if successful. If an extension dictionary already exists, Acad::eAlreadyInDb is returned.'''
    ...
    def database (self)-> PyDb.Database :
      '''Returns a pointer to the AcDbDatabase object that contains the AcDbObject.'''
    ...
    def deepClone (self, owner: PyDb.DbObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function gives control of deep clone operations to the object. In the default implementation, the object is cloned and appended to the owner object (pOwnerObject). The cloning is performed by an AcDbDeepCloneFiler. A record is also added to the idMap. Then, using the filer, any owned objects are deep cloned, with isPrimary set to Adesk::kFalse.'''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def disableUndoRecording (self, disable: bool)-> None :
      '''Turns off or on the Undo recording for the object. If disable == Adesk::kTrue, then Undo recording is turned off until this function is called with disable == Adesk::kFalse, at which time Undo recording is turned back on.'''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def downgradeOpen (self)-> None :
      '''Downgrades the object from being open AcDb::kForWrite, to being AcDb::kForRead. In the process, all changes made to the object while it was open for write are committed to the database and appropriate notification is sent.'''
    ...
    def downgradeToNotify (self, wasWritable: bool)-> None :
      '''Restores an object from being open both AcDb::kForNotify and AcDb::kForWrite, to being open just AcDb::kForNotify. The wasWritable value that was returned from the matching AcDbObject::upgradeFromNotify() call should be passed into this function to restore the proper open status.This function must have been preceded by a call to upgradeFromNotify().Returns Acad::eOk if successful.'''
    ...
    def drawableType (self)-> PyGi.GiDrawableType :
      '''                             '''
    ...
    def elementCount (self)-> int :
      '''                             '''
    ...
    def erase (self, erasing : bool=True)-> None :
      '''Sets the erase bit of the object. If erasing == Adesk::kTrue, then the erase bit is set on. If erasing == Adesk::kFalse, then the erase bit is set off.'''
    ...
    def extensionDictionary (self)-> PyDb.ObjectId :
      '''Returns the objectId of the extension dictionary owned by the object. If the object does not own an extension dictionary, then the returned objectId is set to AcDbObjectId::kNull.'''
    ...
    def getField (self, prop: str='TEXT')-> PyDb.ObjectId :
      '''Gets the field ID. A field can be stored in an object using the property name as the key.Returns Acad::eOk if the object has a field for the specified property. Otherwise, returns an AutoCAD error status.'''
    ...
    def getFieldDictionary (self)-> PyDb.ObjectId :
      '''Returns the field dictionary ID. The field dictionary stores all the fields set in the object as property name-field object pairs. The ID will be null if there is no field in the object.'''
    ...
    def getHandle (self)-> PyDb.Handle :
      '''Fills in handle with the handle value for the object. If the object is not yet database-resident, then it will not have a handle. Use AcDbHandle::isNull to test for this condition.'''
    ...

    @staticmethod
    def getManager (db: PyDb.Database,styleType: PyBrxCv.StyleManagerType)-> PyDb.ObjectId :
      '''                             '''
    ...
    def handOverTo (self, newObject: PyDb.DbObject, keepXData: bool, keepExtDict: bool)-> None :
      '''This function provides the ability to exchange a non-database-resident object (NDBRO) in place of an existing database-resident object (DBRO) while retaining the objectId, handle, and reactor list of the DBRO. An example of this situation is when the BREAK command is used to break a circle into one or two arc segments. AcDbArc is a completely different class from AcDbCircle, so a new AcDbArc object must be substituted in place of the AcDbCircle object that is there now, yet the arc must get the handle and objectId that the circle has.To use the handOverTo() function, the object to be replaced (the AcDbCircle in the example) must be open AcDb::kForWrite. The object's handOverTo() function is called with newObject pointing to a non-database-resident object that replaces it (the AcDbArc in the example).keepXData is set to Adesk::kTrue if the xdata is to be retained or Adesk::kFalse if the xdata is to be thrown out.keepExtDict is set to Adesk::kTrue if the extension dictionary and its contents are to be retained, or set to Adesk::kFalse if the extension dictionary and its contents are to be thrown out.Once returned from this function, the replacement object (the AcDbArc in the example) is open for AcDb::kForWrite and must have its close() member called to commit the change and close out Undo recording. Then it's up to the ObjectARX application to delete the old object (the AcDbCircle in the example) from memory since it's no longer database-resident.Returns Acad::eObjectToBeDeleted if the operation is successful. If newObject is pointing to an object that is already in the database, or the object invoking handOverTo() is not database-resident, then Acad::eIllegalReplacement is returned.'''
    ...
    def has1 (self, *args, **kwargs)-> bool :
      '''has1( (CvDbObjectManager)arg1, (ObjectId)arg2) -> bool :

    C++ signature :
        bool has1(class PyBrxCvDbObjectManager {lvalue},class PyDbObjectId)'''
    ...
    def has2 (self, id : str|PyDb.ObjectId)-> bool :
      '''                             '''
    ...
    def hasFields (self)-> bool :
      '''Returns true if the object has one or more PyDb.Field Objects. Otherwise returns false.'''
    ...
    def hasPersistentReactor (self, id: PyDb.ObjectId)-> bool :
      '''This method returns true if objId is the object ID of a reactor attached to this object. Otherwise, it returns false.'''
    ...
    def hasXData (self, appname: str)-> bool :
      '''                             '''
    ...
    def id (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def idAt (self, val : int|str)-> PyDb.ObjectId :
      '''                             '''
    ...
    def ids (self)-> list :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isAProxy (self)-> int :
      '''Returns Adesk::kTrue if the object is a proxy object or entity. Otherwise returns Adesk::kFalse.'''
    ...
    def isAcDbObjectIdsInFlux (self)-> int :
      '''This function refers to a condition that occurs during deep clone operations. It returns Adesk::kTrue when the cloned objects' IDs have not yet been translated and thus cannot be used in any operations on the objects. This condition normally occurs only during AcEditorReactor::beginDeepCloneXlation, AcDbObject::deepClone, or AcDbObject::wblockClone. Any operations that involve AcDbObjectId references, such as symbol table records, should be postponed until after endDeepClone. AcDbObject::subClose is never called on any objects whose IDs are in flux.'''
    ...
    def isAnnotative (self)-> PyDb.AnnotativeStates :
      '''                             '''
    ...
    def isCancelling (self)-> int :
      '''Returns Adesk::kTrue if the object is currently in the middle of a cancel() call (that is, an open is being canceled and all changes made are being rolled back). Otherwise returns Adesk::kFalse.'''
    ...
    def isEraseStatusToggled (self)-> int :
      '''Returns Adesk::kTrue if the object's erase bit has been toggled since it was opened. Otherwise returns Adesk::kFalse.'''
    ...
    def isErased (self)-> int :
      '''Returns Adesk::kTrue if the object is currently erased. Otherwise returns Adesk::kFalse.'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isModified (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called). Otherwise returns Adesk::kFalse.'''
    ...
    def isModifiedGraphics (self)-> int :
      '''Returns Adesk::kTrue if the object is derived from AcDbEntity and has had either an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called), or its recordGraphicsModified() function called with an Adesk::kTrue argument value.Otherwise it returns Adesk::kFalse.'''
    ...
    def isModifiedXData (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called) and has then had its setXData() method called. Otherwise it returns Adesk::kFalse.'''
    ...
    def isNewObject (self)-> int :
      '''Returns Adesk::kTrue if the object has not yet been closed since it was first created. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifyEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForNotify. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifying (self)-> int :
      '''Returns Adesk::kTrue if the object is in the process of sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isPersistent (self)-> int :
      '''                             '''
    ...
    def isReadEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForRead. Otherwise returns Adesk::kFalse.'''
    ...
    def isReallyClosing (self)-> int :
      '''Returns true if calling close() at this time would really close the object completely. For example, if the object is not in a transaction, and is open for read with only one reader, then Adesk::kTrue would be returned. If, on the other hand, the object is in a transaction, then Adesk::kFalse would be returned.'''
    ...
    def isTransactionResident (self)-> int :
      '''Returns Adesk::kTrue if the object is currently part of a transaction. Otherwise returns Adesk::kFalse.'''
    ...
    def isUndoRecordingDisabled (self)-> bool :
      '''Returns true if undo recording is disabled.'''
    ...
    def isUndoing (self)-> int :
      '''Returns Adesk::kTrue if the object is involved in an Undo operation at this time. Otherwise returns Adesk::kFalse.'''
    ...
    def isWriteEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForWrite and is not currently sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def nameAt (self, val : int)-> str :
      '''                             '''
    ...
    def objectId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the object. If the object is not yet database-resident, then the returned objectId will be set to AcDbObjectId::kNull.'''
    ...

    @staticmethod
    def openManager (db: PyDb.Database,mode: PyDb.OpenMode,styleType: PyBrxCv.StyleManagerType)-> PyBrxCv.CvDbObjectManager :
      '''                             '''
    ...
    def ownerId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the owner of the object. If the object does not yet have an owner, or the ownerId data member has not yet been set using AcDbObject::setOwnerId, then the returned objectId will be set to AcDbObjectId::kNull.Appending the object to a BlockTable record, a symbol table, or a dictionary automatically calls AcDbObject::setOwnerId.'''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def releaseExtensionDictionary (self)-> None :
      '''Removes the object's extension dictionary (that is, removes the object as the owner of the dictionary object) if it exists and is empty. Once removed, this function calls the dictionary's erase() method. Any reactors attached to the extension dictionary receive normal notification appropriate to an open for write, erase, close sequence.Returns Acad::eOk if successful.If the dictionary is not empty, then this function fails and returns Acad::eContainerNotEmpty.'''
    ...
    def remove1 (self)-> bool :
      '''                             '''
    ...
    def remove2 (self, id : str|PyDb.ObjectId)-> bool :
      '''                             '''
    ...
    def removeContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def removeField (self, id: str|PyDb.ObjectId)-> None :
      '''Removes the specified field.Returns Acad::eOk if successful. Otherwise, returns an AutoCAD error status.'''
    ...
    def removePersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Removes the persistent reactor specified by objId from the reactor list of the object. The object must be open AcDb::kForWrite to be able to execute this function.Returns Acad::eOk if successful. If the object is currently sending notification and is not open AcDb::kForWrite, then Acad::eWasNotifying is returned.'''
    ...
    def removeReactor (self, reactor: PyDb.DbObjectReactor)-> None :
      '''Removes reactor pointed to by pNewObj from the object's reactor list. The object may be open AcDb::kForRead or AcDb::kForWrite when this function is called.'''
    ...
    def rolloverHit (self, nSubentId: int, nMouseFlags: int, bReset: bool)-> int :
      '''                             '''
    ...
    def setAcDbObjectIdsInFlux (self)-> None :
      '''This function must be called on any newly created objects in AcDbObject::deepClone or AcDbObject::wblockClone. It indicates that reference object IDs are not yet pointing to the correct objects. The references can be translated only when the entire deep clone operation is complete. The flag is cleared at that time.'''
    ...
    def setAnnotative (self, state : PyDb.AnnotativeStates)-> None :
      '''                             '''
    ...
    def setAttributes (self, traits: PyGi.DrawableTraits)-> int :
      '''                             '''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...

    @overload
    def setField (self, field: PyDb.Field)-> PyDb.ObjectId : ...
    @overload
    def setField (self, propName: str, field: PyDb.Field)-> PyDb.ObjectId : ...
    def setField (self, *args, **kwargs)-> PyDb.ObjectId :
      '''Overloads:
    - field: PyDb.Field
    - propName: str, field: PyDb.Field
    '''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setOwnerId (self, owner: PyDb.ObjectId)-> None :
      '''Sets the ownerId data member of the object to be objId, thus establishing a "backpointer." This backpointer is used by WBLOCK to be sure all necessary objects are written out.Returns Acad::eOk if successful.'''
    ...
    def setXData (self, xdata: list)-> None :
      '''Each regapp sublist (delimited by a resbuf with restype == 1001 and resval.rstring == a valid regappName string) within the resbuf chain pointed to by xdata, is placed in the xdata area of the object. If any of the regappNames in xdata are already present in the xdata area of the object, then that regappName's existing data on the object is overwritten by that regappName's new data in xdata.All resbufs with restype == 1001 must have valid regappNames for the database the object resides in (that is, the regappNames must be in the APPID table of the database).Only valid xdata group codes (1000--1071) are accepted in the restype fields of the resbufs in xdata.No "-3" group code is necessary, and in fact, is not accepted. So, the first element in the resbuf chain must be a 1001 group code with a resval.rstring set to a regappName that's already registered in the regapp table. To register a regappName, use the acdbRegApp() function.To remove an appName (and its xdata) from an object, just use a resbuf with restype == 1001, resval == and no data resbufs following it (that is, either its rbnext == NULL or the next resbuf is another 1001)This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If this function is overridden, then it should supermessage its parent in order to invoke the built-in mechanism to add the xdata to the object.Returns Acad::eOk if the xdata is successfully added to the object. If there is insufficient space in the xdata area of the object, then Acad::eXdataSizeExceeded is returned. If any of the regappNames in xdata are not in the APPID table, then Acad::eRegappIdNotFound is returned.'''
    ...
    def snoop (self,  filer : PyDb.SnoopDwgFiler)-> None :
      '''                             '''
    ...
    def swapIdWith (self, otherId: PyDb.DbObject, swapXdata: bool, swapExtDict: bool)-> None :
      '''This function swaps objectIds and handles between the object specified by otherId and the object invoking this function. Both objects must currently be database-resident and must reside in the same database. If swapXdata == Adesk::kTrue, then the objects swap extended entity data as well. If swapExtDict == Adesk::kTrue, then the objects swap extension dictionaries also.If the object specified by otherId or the object invoking this function are not database-resident, then Acad::eNoDatabase is returned. If both objects involved are not in the same database, then Acad::eWrongDatabase is returned.'''
    ...
    def upgradeFromNotify (self, wasWritable: bool)-> None :
      '''Upgrades the object from being at least open AcDb::kForNotify to being open both AcDb::kForNotify and AcDb::kForWrite. The wasWritable argument is set to Adesk::kTrue if the object was already open for write, otherwise it's set to Adesk::kFalse. The wasWritable value should be saved to be passed into the downgradeToNotify() call later.This function must be followed at some point by a call to downgradeToNotify() with no open() (in any of its forms) or close() calls in between.This method should only be called from within other methods of the same object it is being called from. In other words, this method is intended to be used by an object to change it's own open status so that it can safely modify itself.upgradeFromNotify() and downgradeToNotify() call pairs are not nestable.Returns Acad::eOk if successful. If the object is not currently open AcDb::kForNotify, then Acad::eNotApplicable is returned. If the object is currently in the process of actually sending notification (that is, isNotifying() returns Adesk::kTrue), then Acad::eWasNotifying is returned.'''
    ...
    def upgradeOpen (self)-> None :
      '''If the object is currently open AcDb::kForRead with only one reader, then this function upgrades the object to open AcDb::kForWrite. In the process of changing to open for write, the object is closed, thus triggering any pertinent notification.Returns Acad::eOk if successful. If the object has more than one reader, then the open status is not changed and Adesk::eHadMultipleReaders is returned. If the object is already open AcDb::kForWrite, then Acad::eWasOpenForWrite is returned. If the object is currently sending notification, then the open status is not changed and Acad::eWasNotifying is returned.'''
    ...
    def viewportDraw (self, vpdraw: PyGi.ViewportDraw)-> None :
      '''                             '''
    ...
    def viewportDrawLogicalFlags (self, vpdraw: PyGi.ViewportDraw)-> int :
      '''                             '''
    ...
    def wblockClone (self, owner: PyRx.RxObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function is almost identical to AcDbObject::deepClone, except that an AcDbWblockCloneFiler is used and ownership is not carried across database boundaries. Subcloning is based on hard owner and hard pointer connections.'''
    ...
    def worldDraw (self, wdraw: PyGi.WorldDraw)-> int :
      '''                             '''
    ...
    def xData (self, appname: str = None)-> list :
      '''Returns a linked list of resbuf structures containing a copy of the xdata for the object. If regappName == NULL is passed in, all xdata is returned, otherwise only the xdata for the specified name is returned. If not all xdata is required, but the xdata for more than one regappName is desired, then multiple calls to this member function must be made--one for each regappName.The caller of this function is responsible for releasing the memory used by the resbuf list that is returned. The most commonly used way to deallocate such a list is via the acutRelRb() function.This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If a failure accessing the xdata occurs, NULL is returned.'''
    ...
    def xDataTransformBy (self, xform: PyGe.Matrix3d)-> None :
      '''This method applies the xform transformation matrix to any XData data types 1011, 1021, 1031, 1012, 1022, 1032, 1013, 1023, 1033, 1041, and 1042 in the object's XData. See the documentation on XData for more information on the way the transformation matrix is applied to the different data types.This method should be called from within the transformBy() method on custom entities so that such entities will transform XData in the same way that the built-in AcDb entities do.Returns Acad::eOk if successful.'''
    ...
    def xmitPropagateModify (self)-> None :
      '''Within an object's close() method is a call to the object's xmitPropagateModify().The AcDbObject::xmitPropagateModify() default implementation is to inform the containing database that the object has been modified, appended to the database, or erased. The database then sends out the appropriate notification to any AcDbDatabaseReactors attached to it.Within AutoCAD, this function is used by complex entities such as polylines to allow the subentities to notify the header that they have been changed. The header can then "propagate" the notification by sending its own notification that the "complex entity" has been modified.The way this works is:The subobject class has it's xmitPropagateModify() class overridden such that it calls it's parent class's xmitPropagateModify() and also calls the owning object's recvPropagateModify().The "root" or "header" class has it's recvPropagateModify() overridden to provide an implementation that triggers "modified" notification to be sent for the "root" or "header" (which effectively represents the whole complex object).The subobject's close() triggers "modified" notification for the subobject and calls the subobject's xmitPropagateModify() function. So, when the subobject's close() is called, its xmitPropagateModify() is called. This then calls the owning object's recvPropagateModify(), which then triggers the owner to send "modified" notification.So, the result is a "modified" notification from both the subentity and the "root" or "header" entity.When overridden, this function should:Call its parent class's xmitPropagateModify() (which ultimately results in the execution of AcDbObject::xmitPropagateModify() to trigger database notification).Call its owner's recvPropagateModify() (passing in its "this" pointer) to "propagate" the notification information to the "root" owner to be sent out.'''
    ...

class CvDbSubObject(PyRx.RxObject):
    def __init__ (self, *args, **kwargs)-> None :
      '''Raises an exception
This class cannot be instantiated from Python'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbSubObject :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...

class CvDbTinSurface(CvDbEntity):
    def __init__ (self, id: PyDb.ObjectId, mode: PyDb.OpenMode=PyDb.OpenMode.kForRead, erased: bool=False)-> None :
      '''                             '''
    ...
    def addConstraint (self, constraint : PyBrxCv.CvDbTinSurfaceConstraint, addReactor : bool)-> bool :
      '''                             '''
    ...
    def addConstraints (self, constraints : list[PyBrxCv.CvDbTinSurfaceConstraint], addReactor : bool)-> bool :
      '''                             '''
    ...
    def addContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def addDefinition (self, ref : PyBrxCv.CvDbTinSurfaceDefinition)-> int :
      '''                             '''
    ...
    def addPersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Adds the database-resident object specified by objId to the reactor list of the AcDbObject object.'''
    ...
    def addPoint (self, pt : PyGe.Point3d)-> bool :
      '''                             '''
    ...
    def addPoints (self, pts : list[PyGe.Point3d])-> bool :
      '''                             '''
    ...
    def addReactor (self, reactor: PyDb.EntityReactor)-> None :
      '''                             '''
    ...
    def addSubentPaths (self, paths: list[PyDb.FullSubentPath])-> None :
      '''Adds one or more subentities to an entity.The prototype of this method is provided for completeness of the subentity manipulation APIs. AutoCAD will never call this method on a custom object.Returns Acad::eOk if successful. The default implementation returns Acad::eNotAvailable.'''
    ...
    def area2d (self, visibleOnly : bool=False)-> float :
      '''                             '''
    ...
    def area3d (self, visibleOnly : bool=False)-> float :
      '''                             '''
    ...
    def assertNotifyEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should be used inside of member functions that are only called when the object is open kForNotify. When used, it should be the first function called inside the member function.'''
    ...
    def assertReadEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that access the object's data in a read-only fashion (for example, dxfOutFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is open AcDb::kForRead.If this function is called while the object is not open, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def assertWriteEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that modify the object's data (for example, dxfInFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is indeed open for write (if it is not, then AutoCAD terminates); to trigger an immediate sending of "openedForModify" notification; to set up the notification mechanism so that "modified" and "modifiedGraphics" (if the object is derived from AcDbEntity) are sent at the appropriate times; and to ensure that graphics get updated if the object is derived from AcDbEntity.If this function is called on a database resident object, "openedForModify" will be sent if the object is not newly created, and "modified", and "modifiedGraphics" (if appropriate) notifications will be sent when the object is next closed.If recordModified is false, then the autoUndo argument is ignored, and the undo filer is not initialized, no undo recording will take place, but notifications will be sent.If autoUndo and recordModified are both true, then automatic undo recording will be performed and notifications will be sent.If autoUndo is false and recordModified is true, then there will not be any automatic undo recording, but the undo filer is initialized and the object must manually write out partial Undo records and must implement its applyPartialUndo() method. Notifications will be sent.If this function is called while the object is not open AcDb::kForWrite, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def blockId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the entity's owner, which must be an AcDbBlockTableRecord.If the entity does not have an owner yet, then AcDbObjectId::kNull will be returned.'''
    ...
    def boundingBox (self)-> tuple[Any,...] :
      '''                             '''
    ...
    def bounds (self, ext: PyDb.Extents)-> bool :
      '''                             '''
    ...
    def cancel (self)-> None :
      '''Terminates the current open operation. All changes made to the object since it was opened are undone, the object is marked as closed, and "cancel" notification is sent.Returns Acad::eOk if successful.'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbTinSurface :
      '''                             '''
    ...
    def castShadows (self)-> bool :
      '''Returns a boolean value that indicates whether the entity can cast shadows. '''
    ...
    def changePointsElevations (self, pts : list[PyGe.Point3d], newZValues : list[float])-> bool :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...

    @staticmethod
    def cloneFrom (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbTinSurface :
      '''                             '''
    ...
    def close (self)-> None :
      '''Closes the object. All changes made to the object since it was opened are committed to the database, the object is marked as pageable, and a "closed" notification (as well as any other appropriate notification such as "modified", "erased", and so on) is sent.Returns Acad::eOk if successful.If the object is not in an AcDbDatabase yet, then Acad::eNoDatabase is returned.If the object is sending notification, then Acad::eCloseWasNotifying is returned.If the subClose() call made within the close() method returns anything other than Acad::eOk, then that ErrorStatus is returned.'''
    ...
    def closestPointTo (self, pt : PyGe.Point3d)-> PyGe.Point3d :
      '''                             '''
    ...
    def collisionType (self)-> PyDb.CollisionType :
      '''This function returns the collision detection treatment for this entity. Subclasses may override this method to customize how the class interacts in collision-aware features.'''
    ...
    def color (self)-> PyDb.Color :
      '''This function returns the full true color information for the entity within an instance of AcCmColor.The index value will be in the range 0 to 256. 0 and 256 are special values.0 indicates the entity uses the color of the BlockReference that's displaying it. If the entity is not displayed through a BlockReference (for example, it's directly owned by the model space BlockTableRecord) and its color is 0, then it will display as though its color were 7.256 indicates the entity uses the color specified in the LayerTableRecord it references.'''
    ...
    def colorIndex (self)-> int :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def contains (self, pt : PyGe.Point3d)-> bool :
      '''                             '''
    ...
    def contoursAtElevation (self, elevation : float)-> list :
      '''                             '''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...
    def createExtensionDictionary (self)-> None :
      '''Creates an AcDbDictionary object and sets it up as the extension dictionary for the AcDbObject.Returns Acad::eOk if successful. If an extension dictionary already exists, Acad::eAlreadyInDb is returned.'''
    ...
    def createSnapshot (self)-> int :
      '''                             '''
    ...
    def database (self)-> PyDb.Database :
      '''Returns a pointer to the AcDbDatabase object that contains the AcDbObject.'''
    ...
    def deepClone (self, owner: PyDb.DbObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function gives control of deep clone operations to the object. In the default implementation, the object is cloned and appended to the owner object (pOwnerObject). The cloning is performed by an AcDbDeepCloneFiler. A record is also added to the idMap. Then, using the filer, any owned objects are deep cloned, with isPrimary set to Adesk::kFalse.'''
    ...
    def definitionAt (self, index : int)-> PyBrxCv.CvDbTinSurfaceDefinition :
      '''                             '''
    ...
    def definitionCount (self)-> int :
      '''                             '''
    ...
    def definitionIndex (self, ref : PyBrxCv.CvDbTinSurfaceDefinition)-> tuple[Any,...] :
      '''                             '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def disableUndoRecording (self, disable: bool)-> None :
      '''Turns off or on the Undo recording for the object. If disable == Adesk::kTrue, then Undo recording is turned off until this function is called with disable == Adesk::kFalse, at which time Undo recording is turned back on.'''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def downgradeOpen (self)-> None :
      '''Downgrades the object from being open AcDb::kForWrite, to being AcDb::kForRead. In the process, all changes made to the object while it was open for write are committed to the database and appropriate notification is sent.'''
    ...
    def downgradeToNotify (self, wasWritable: bool)-> None :
      '''Restores an object from being open both AcDb::kForNotify and AcDb::kForWrite, to being open just AcDb::kForNotify. The wasWritable value that was returned from the matching AcDbObject::upgradeFromNotify() call should be passed into this function to restore the proper open status.This function must have been preceded by a call to upgradeFromNotify().Returns Acad::eOk if successful.'''
    ...
    def drapeId (self, id : PyDb.ObjectId)-> list :
      '''                             '''
    ...
    def drapePoints (self, pts : list[PyGe.Point3d])-> list :
      '''                             '''
    ...
    def draw (self)-> None :
      '''This function queues up the entity's graphics and flushes the graphics queue, forcing the entity and anything else in the queue to be drawn or re-drawn on-screen.Returns Acad::eOk if successful.If the entity is not in a database, then Acad::eNotInDatabase will be returned.If the entity is in a database other than the one currently loaded into the AutoCAD editor, then Acad::eNotCurrentDatabase will be returned.'''
    ...
    def drawableType (self)-> PyGi.GiDrawableType :
      '''                             '''
    ...
    def elevationAtPoint (self, pt : PyGe.Point3d)-> tuple[Any,...] :
      '''                             '''
    ...
    def entityColor (self)-> PyDb.EntityColor :
      '''This function returns the color settings of the entity in an AcCmEntityColor form. Most clients should use the color() function, which returns the heavyweight AcCmColor object. However, if color name information is not required, this function provides faster access to the lightweight AcCmEntityColor data.'''
    ...
    def erase (self, erasing : bool=True)-> None :
      '''Sets the erase bit of the object. If erasing == Adesk::kTrue, then the erase bit is set on. If erasing == Adesk::kFalse, then the erase bit is set off.'''
    ...
    def eraseConstraint (self, id : PyDb.ObjectId | int, removeReactor : bool)-> bool :
      '''                             '''
    ...
    def eraseConstraints (self, int64ids : list[int], removeReactor : bool)-> bool :
      '''                             '''
    ...
    def eraseConstraintsIds (self, ids : list[PyDb.ObjectId], removeReactor : bool)-> bool :
      '''                             '''
    ...
    def explode (self)-> list :
      '''Function UsageThis function is primarily intended for AutoCAD to call as part of an explode operation that includes this entity. However, this function can be used by ObjectARX applications to obtain an array of pointers to non-database-resident entity objects that are what the entity considers to be its exploded parts.When calling this function, the entitySet array does not need to be empty. This function will append to it, and pointers to entities that it creates to be used in its place as the "exploded" result.If this function is successful, it will return Acad::eOk. Other return values may vary depending on how it has been implemented.Function Implementation in Derived ClassesThis function should dynamically create (using the new operator) whatever entity objects are appropriate to be used to replace the entity after an explode operation has taken place. Pointers to these entities are then appended to the entitySet array. Once the pointers have been appended, the function should return with a status of Acad::eOk.'''
    ...
    def extensionDictionary (self)-> PyDb.ObjectId :
      '''Returns the objectId of the extension dictionary owned by the object. If the object does not own an extension dictionary, then the returned objectId is set to AcDbObjectId::kNull.'''
    ...
    def findDefinition (self, id : int)-> PyBrxCv.CvDbTinSurfaceDefinition :
      '''                             '''
    ...
    def findTinPointAt (self, pt : PyGe.Point3d)-> tuple[Any,...] :
      '''                             '''
    ...
    def findTinTrianglesAt (self, pt : PyGe.Point3d)-> list :
      '''                             '''
    ...
    def getBorders (self)-> list :
      '''                             '''
    ...
    def getCompoundObjectTransform (self)-> PyGe.Matrix3d :
      '''This function is intended to be overridden by derived classes that are compound objects (in other words, objects that behave like blocks in the display list).A compound object has little or no geometry of its own; instead it relies on nested entities, perhaps the contents of a BlockTableRecord, to represent itself. A compound object must use the same transformation matrix for all of its contained entities. Otherwise selection and osnap will not function correctly. This is the method that the system uses to obtain that matrix from the compound object.This method should only be overridden if you return the kDrawableIsCompoundObject flag from setAttributes. The matrix you should return here is the one that you pass to pushModelTransform before you render your nested objects. You must override this method if you return the compound object flag in setAttributes, even if you don't push a transform for your nested objects. In that case you would return Acad::eOk and the identity transform in xMat.Default implementation: Returns Acad::eNotApplicable and the identity matrix in xMat.'''
    ...
    def getConstraint (self, id : PyDb.ObjectId|int)-> PyBrxCv.CvDbTinSurfaceConstraint :
      '''                             '''
    ...
    def getConstraints (self)-> list :
      '''                             '''
    ...
    def getEcs (self)-> PyGe.Matrix3d :
      '''This function is intended to be overridden by derived classes that need to be able to provide access to an object coordinate system for objects of the class. The intent is that this function provide a transformation matrix that can be used to transform vectors or points from the object's object coordinate system (OCS) to the World Coordinate System (WCS).Default implementation: Return the identity matrix (ones along the diagonal, zeros elsewhere) in retVal.We recommend that all data stored in custom classes be stored in WCS coordinates. If this is done, then the object's OCS will be the WCS and the transformation matrix will be the identity matrix. Then this function will not need to be overridden since the identity matrix is this function's default return.'''
    ...
    def getField (self, prop: str='TEXT')-> PyDb.ObjectId :
      '''Gets the field ID. A field can be stored in an object using the property name as the key.Returns Acad::eOk if the object has a field for the specified property. Otherwise, returns an AutoCAD error status.'''
    ...
    def getFieldDictionary (self)-> PyDb.ObjectId :
      '''Returns the field dictionary ID. The field dictionary stores all the fields set in the object as property name-field object pairs. The ID will be null if there is no field in the object.'''
    ...
    def getGeomExtents (self)-> PyDb.Extents :
      '''Unimplemented at the AcDbEntity level, this method is intended to be overridden in derived classes.Derived classes should calculate and return the corner points (in WCS coordinates) of a box (with edges parallel to the WCS X, Y, and Z axes) that encloses the 3D extents of the entity, and return those points as an instance of class AcDbExtents in the "extents" parameter.Default implementation: Immediately returns Acad::eInvalidExtents.'''
    ...
    def getGeomExtents2d (self)-> PyDb.Extents2d :
      '''                             '''
    ...

    @overload
    def getGripPoints (self, /)-> tuple[Any,...] : ...
    @overload
    def getGripPoints (self, curViewUnitSize: float, gripSize: int, curViewDir: PyGe.Vector3d, bitflags: int)-> tuple[Any,...] : ...
    def getGripPoints (self, *args, **kwargs)-> tuple[Any,...] :
      '''Overloads:
    - None: Any
    - curViewUnitSize: float, gripSize: int, curViewDir: PyGe.Vector3d, bitflags: int
    
	-Function usageThis function supports "old style" grips, in applications that existed before the enhancement of grip functionality by the addition of the AcDbGripData class.This function is not intended to be called by ObjectARX applications. However, it is possible to do so (for example, as a pass-through from the getStretchPoints() method).Function implementation in derived classesThis function should append to the gripPoints array any points that are to treated as grip points for the entity.The gripPoints array is passed to all entities involved in the grip operation, so the array may already contain grip points for other entities. Therefore, it is very important to append the new points rather than assigning them to any existing elements in the array.When finished appending all desired grip points, return Acad::eOk. If anything other than Acad::eOk is returned, then grips are not activated for this entity.The osnapModes and geomIds arguments are not currently used.Default implementationImmediately returns Adesk::eNotImplemented.-'''
    ...
    def getHandle (self)-> PyDb.Handle :
      '''Fills in handle with the handle value for the object. If the object is not yet database-resident, then it will not have a handle. Use AcDbHandle::isNull to test for this condition.'''
    ...
    def getPlane (self)-> PyGe.Plane :
      '''If the entity is planar, then the plane containing the entity is returned in plane and flag is set to AcDb::kPlanar.If the entity is nonplanar, but is linear, then plane is set to an arbitrary plane that contains the entity and flag is set to AcDb::kLinear.If the entity is nonplanar and nonlinear, then plane is left unset and flag is set to AcDb::kNonPlanar.Returns Acad::eOk if successful. Other ErrorStatus return values are implementation-dependent.The default implementation is to return Acad::eNotApplicable.'''
    ...
    def getPlotStyleNameId (self)-> PyDb.ObjectId :
      '''Returns with id set to the object ID of the AcDbPlaceHolder object referenced by the entity. The AcDbPlaceHolder object resides in the plot style name dictionary, and its key in the dictionary is the plot style name.Use the AcDbDictionary::nameAt() function on the plot style name dictionary to get the plot style name string that corresponds to the ID obtained by this function.'''
    ...
    def getPoints (self, visibleOnly : bool=False)-> list :
      '''                             '''
    ...
    def getPointsInsidePolygon (self, pts : list[PyGe.Point3d], includeOnEdge : bool)-> list :
      '''                             '''
    ...
    def getStretchPoints (self)-> list :
      '''Function usageThis function is not intended to be called by ObjectARX applications. However, it is possible to do so (for example, as a pass-through from the getGripPoints() method).Function implementation in derived classesThis function should append to the stretchPoints array any points that are to treated as stretch points for the entity.Stretch points are used by the stretch command within AutoCAD. Any stretch points that are within the crossing selection window during the stretch command, will be moved by whatever amount the user decides to "stretch" the selected entities. Any stretch points not in the crossing selection window will be left alone. This combination of some stretch points moving while others do not is what "stretches" the entity. If all stretch points are in the crossing window, then the entity is moved instead of stretched.The stretchPoints array is passed to all entities involved in the stretch operation, so the array may already contain stretch points for other entities. Therefore it is very important to append the new points rather than assigning them to any existing elements in the array.When finished appending all desired stretch points, return Acad::eOk. If anything other than Acad::eOk is returned, then this entity's stretch points will be ignored by the stretch operation.Default implementationCalls the AcDbEntity::getGripPoints() method. So, unless the entity needs to have stretch points that are different from the grip points, there is no need to override this method.'''
    ...
    def getSubentPathsAtGsMarker (self, type: PyDb.SubentType, gsMark: int, pickPoint: PyGe.Point3d, viewXform: PyGe.Matrix3d)-> list[PyDb.FullSubentPath] :
      '''Entities use various graphic primitives defined in AcGi to draw themselves. Part of this mechanism is the ability to associate an integer identifier called a graphics system marker (or, GS marker) with each primitive or with groups of primitives. Through the use of certain selection mechanisms, the GS marker for the actual subentity selected on screen can be obtained and, along with some other information passed into this function, can be used to create one or more AcDbFullSubentPath objects, each one representing a subentity and providing a more complete description of the subentity and its environment. These AcDbFullSubentPath objects can be used by several other functions for various purposes such as highlighting or unhighlighting the subentities on screen.Function usageIf the entity (of which the subentity is a part) is directly owned by the model or paper space BlockTableRecords, then leave out numInserts and entAndInsertStack so that their default value will be used.Typically the GS marker is obtained via the use of ads_ssget() followed by ads_ssnamex() (see the ObjectARX Developer's Guide for more information on this).The pickPoint can be obtained from ads_ssnamex() as well (it's the first group 5009 in the returned list).The viewXform can be calculated using the ads_trans() function on the vectors (1,0,0), (0,1,0), and (0,0,1) to translate them from DCS to WCS. The translations of these three vectors (with an extra 0 appended on to the end of each) would be used as the first three rows of the matrix. The last row is not used so it can be left as is. This argument is not used by any of the AutoCAD built-in entities.If the entity is nested inside one or more block definitions, then the numInserts and entAndInsertStack arguments must also be filled in with non-zero or non-null values. If they are not filled in, then this function will fail and return an error status. One way to get the necessary object IDs is to use ads_nentselp() to obtain the list of ads_names of the container objects. This list must then be converted to object IDs and reversed.Upon return, the subentPaths argument will point to a dynamically allocated array of one or more AcDbFullSubentPath objects. The numPaths argument will contain the number of AcDbFullSubentPath objects being returned.The calling application is responsible for deallocating the memory used by the subentPaths array. The C++ delete [ ] should be used.Return values for this function may vary depending on how the function has been implemented (see below).Function implementation in derived classesEntity classes which do not set GS markers probably should not implement this function since the GS marker is the primary (and often the only) means of subentity distinction.When implemented, this function must use the material provided in type, gsMark, pickPoint, viewXform, numInserts, and entAndInsertStack to determine which subentity or subentities meet the criteria in these arguments. Next it must create a dynamically allocated array of AcDbFullSubentPaths (using the C++ new operator) with one element for each subentity determined in the first step. Finally it must fill in each AcDbFullSubentPath object in the array with the information appropriate to the subentity it will represent.If numInserts == 0 and entAndInsertStack == NULL, it's important to check to be sure that the entity's owner is indeed the model or paper space BlockTableRecord. This can be done by using the entity's ownerId() method to obtain the objectId of its owner, and then opening up that object and using its name() method to obtain its name string. If the owner is not the model or paper space BlockTableRecord, and numInserts == 0 or entAndInsertStack == NULL, or both, then the input data is invalid and this function should set numPaths to 0, set subentPaths to NULL and then return the error status Acad::eInvalidInput.Each AcDbFullSubentPath object has two parts, an array of objectIds containing all the container objects, and an embedded AcDbSubentId object which in turn has two elements: an index value and a SubentityType.If the "main" entity (the entity on which this function is being called) is not nested within BlockReferences (that is, numInserts == 0 and entAndInsertStack == NULL), then the objectId array should contain only the objectId of the "main" entity. If the "main" entity is nested in one or more BlockReferences, then the AcDbObjectIdArray is the same as entAndInsertStack, so copying the entAndInsertStack elements into the AcDbObjectIdArray is all that's required.The SubentType data item within the embedded AcDbSubentId should be set the same as type.The index data item within the embedded AcDbSubentId can be any value you wish (it is often simply the GS marker), but if implemented, the following functions must be able to interpret them to determine the corresponding GS marker(s) or subentity (or subentities):getGsMarkersAtSubentPath()subentPtr()The pickPoint and viewXform arguments are provided as extra aids (if necessary) in determining which subentity is involved. For example, some entity types might display differently depending on the display viewpoint. The viewXform transformation matrix can be used in such cases.The viewXform argument provides a transformation matrix to transform from WCS (World Coordinate System) to DCS (display coordinate system).The display coordinate system is oriented such that the positive Z axis is coming out of the display screen towards the user, the positive X axis is horizontally from left to right on screen, and the positive Y axis is vertically upwards on screen.So, if the current viewpoint is at (1,0,0) (the viewer is always looking towards (0,0,0)) then the viewXform matrix would be:0 1 0 00 0 1 01 0 0 00 0 0 1In this matrix the last row and the last column are not used. Notice also that the third row is the DCS Z axis in WCS coordinates (which is the WCS version of the AutoCAD VIEWPOINT system variable).When this function returns, the return code to use is completely up to the implementer, but to be consistent with other existing entity class implementations of this function the following should be used:If the function succeeds, it should return Acad::eOk.If an invalid or unsupported SubentType is passed in, then numPaths should be set to 0, subentPaths should be set to NULL, and Acad::eWrongSubentityType should be returned.If an invalid GS marker (or any other data item that turns out to be needed) is passed in, then numPaths should be set to 0, subentPaths should be set to NULL, and Acad::eInvalidInput should be returned.Default implementationImmediately returns Adesk::eNotApplicable.'''
    ...
    def getTinPoints (self)-> list :
      '''                             '''
    ...
    def getTransformedCopy (self, matrix3d: PyGe.Matrix3d)-> PyDb.Entity :
      '''Function usageThis function creates a clone of the entity, applies the xform transformation matrix to the clone, and then returns with pEnt pointing to the transformed clone.Returns Acad::eOk if successful.If xform is a non-uniform scaling matrix or non-orthogonal then Acad::eCannotScaleNonUniformly or Acad::eNotImplemented is returned.WarningFor AutoCAD built-in complex entities such as polylines, this function produces a shallow clone of the header entity only, which also owns the original set of "owned" entities (such as vertices for a polyline) which are then transformed by the xform matrix. This results in a corrupt drawing (two header entities owning the same set of "owned" entities) as well as transforming the original set of "owned" entities instead of a copied set.Function implementation in derived classesThe default AcDbEntity implementation of this function should be adequate for most derived entity types. However, derived entity classes that wish to support non-uniform scaling or non-orthogonal transformations will need to override this method with their own implementation.This function must create a copy of the entity (using memory that has been dynamically allocated via the C++ new operator), apply the transformation matrix xform to the copy and then return with pEnt pointing to the transformed copy.Determining what constitutes a valid transformation matrix and whether to do a shallow clone (that is, the entity's clone() method), a deepclone (if the entity owns other objects), or no clone at all (that is, make this function a no-op), is up to the implementer.Return values for this function are also up to the implementer, but to be consistent with other existing classes the following is recommended:If the function succeeds, it should return Acad::eOk.If the function is to be a no-op, it should return Acad::eNotImplementedIf non-uniform scaling is not to be supported and a non-uniform scaling matrix is passed in, then either Acad::eCannotScaleNonUniformly or Acad::eNotImplemented should be returned.Default implementationIf the entity is uniformly scaled and orthogonal, AcDbEntity::getTransformedCopy will call the entity's clone() method to create a clone of the entity, then call AcDbEntity::transformBy() on the clone, and then return with pEnt set to point to the transformed clone. If xform is a non-uniformly scaled or a non-orthogonal matrix, then this function will return Acad::eNotImplemented.'''
    ...
    def handOverTo (self, newObject: PyDb.DbObject, keepXData: bool, keepExtDict: bool)-> None :
      '''This function provides the ability to exchange a non-database-resident object (NDBRO) in place of an existing database-resident object (DBRO) while retaining the objectId, handle, and reactor list of the DBRO. An example of this situation is when the BREAK command is used to break a circle into one or two arc segments. AcDbArc is a completely different class from AcDbCircle, so a new AcDbArc object must be substituted in place of the AcDbCircle object that is there now, yet the arc must get the handle and objectId that the circle has.To use the handOverTo() function, the object to be replaced (the AcDbCircle in the example) must be open AcDb::kForWrite. The object's handOverTo() function is called with newObject pointing to a non-database-resident object that replaces it (the AcDbArc in the example).keepXData is set to Adesk::kTrue if the xdata is to be retained or Adesk::kFalse if the xdata is to be thrown out.keepExtDict is set to Adesk::kTrue if the extension dictionary and its contents are to be retained, or set to Adesk::kFalse if the extension dictionary and its contents are to be thrown out.Once returned from this function, the replacement object (the AcDbArc in the example) is open for AcDb::kForWrite and must have its close() member called to commit the change and close out Undo recording. Then it's up to the ObjectARX application to delete the old object (the AcDbCircle in the example) from memory since it's no longer database-resident.Returns Acad::eObjectToBeDeleted if the operation is successful. If newObject is pointing to an object that is already in the database, or the object invoking handOverTo() is not database-resident, then Acad::eIllegalReplacement is returned.'''
    ...
    def hasFields (self)-> bool :
      '''Returns true if the object has one or more PyDb.Field Objects. Otherwise returns false.'''
    ...
    def hasPersistentReactor (self, id: PyDb.ObjectId)-> bool :
      '''This method returns true if objId is the object ID of a reactor attached to this object. Otherwise, it returns false.'''
    ...
    def hasSnapshot (self)-> bool :
      '''                             '''
    ...
    def hasXData (self, appname: str)-> bool :
      '''                             '''
    ...
    def highlight (self, path: PyDb.FullSubentPath = None, highlightAll : bool = False)-> None :
      '''Function usageThis function uses the AcDbFullSubentPathid to determine which subentity in the entity is desired. It then highlights that subentity on screen. If no AcDbFullSubentPath argument is provided, then the entire entity will be highlighted.Typically, the AcDbFullSubentPath object passed in via subId is obtained from the entity's AcDbEntity::getSubentPathsAtGsMarker() method. This guarantees that it is fully and properly filled in.This function uses the entity's getGsMarkersAtSubentPath() method to get the GS markers associated with subId. If that function does not return Acad::eOk, then this function will fail and return whatever ErrorStatus was returned by getGsMarkersAtSubentPath().If this function succeeds, then it returns Acad::eOk.It is not necessary to balance each highlight() function call with a corresponding call to unhighlight(). Calling the unhighlight() function will unhighlight the entity designated by subId regardless of how many times the highlight function has been called on it.WarningIf the entity on which this method is called has its graphics queued for regeneration (that is, changes have been made to the entity but have not yet been reflected on screen), then this method will not cause a highlight to occur. Also, calling this method on an entity that's open for write and whose graphics are queued for regeneration may terminate AutoCAD.To avoid this limitation, before calling highlight(), you should flush the entity's graphics by either calling the entity's draw() method, or calling the AcTransactionManager::flushGraphics() function.Function implementation in derived classesThe AcDbEntity::highlight() implementation does all the work necessary to highlight any subentities that correspond to the subIdFullSubentPath. So, there is no need to override this method unless you wish to do some pre-or post-processing, or you wish to disable the ability to highlight subentities.If this method is overridden and it is supposed to highlight subentities, then the AcDbEntity::highlight() method will need to be invoked at some point within this function in order to do the actual highlighting.Within the AcDbEntity::highlight() method, the getGsMarkersAtSubentPath() method of this entity is called to translate the FullSubentPath into the corresponding GS markers. So, if this function is to succeed, the getGsMarkersAtSubentPath() method needs to be implemented as well.For more information on the subIdAcDbFullSubentPath argument, see the documentation on the getGsMarkersAtSubentPath() or getSubentPathsAtGsMarker() methods.'''
    ...
    def id (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def initialize (self, min : PyGe.Point3d, max : PyGe.Point3d, numOfPoints : int)-> None :
      '''                             '''
    ...
    def insertDefinitionAt (self, index : int, ref : PyBrxCv.CvDbTinSurfaceDefinition)-> int :
      '''                             '''
    ...

    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, thisGsMarker : int, otherGsMarker : int)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane, thisGsMarker : int, otherGsMarker : int)-> list : ...
    def intersectWith (self, *args, **kwargs)-> list :
      '''Overloads:
    - entity: PyDb.Entity, intType : PyDb.Intersect
    - entity: PyDb.Entity, intType : PyDb.Intersect, thisGsMarker : int, otherGsMarker : int
    - entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane
    - entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane, thisGsMarker : int, otherGsMarker : int
    
	-Function usageIt finds the intersections of the entity pointed to by pEnt and all the edges of the bounding box of this entity.The intType is used to determine how to deal with extending the two entities in order to calculate intersections. The possible AcDb::Intersect values are:AcDb::kOnBothOperandsDo not extend either entity. This results in only calculating intersections where the two entitys' geometry actually intersectAcDb::kExtendThisExtend this entity (if necessary) when calculating intersections, but do not extend the pEnt entity.AcDb::kExtendArgExtend the pEnt entity (if necessary) when calculating intersections, but do not extend this entity.AcDb::kExtendBothExtend both the pEnt entity and this entity (if necessary) when calculating intersectionsAny intersection points found are appended to the points array. All points are in WCS coordinates.The thisGsMarker and otherGsMarker arguments are intended to provide this function with information to allow it to localize the search for intersections to be between specific subentities. However, this function is not required to make use of either of these arguments (most, if not all, of the AutoCAD built-in entity classes do not). When calling this function, either or both of these arguments may be 0 in order to indicate that they should be ignored.If this function is successful it returns Acad::eOk. Return values for error conditions are dependent on the implementation of this function in the classes involved.Function implementation in derived classesThis function should do all it can to find all intersection points between the entity it's being called on and the entity pointed to by pEnt. All intersection points found should be appended to the points array. All such points must be in WCS coordinates.When implementing the intersection calculation portion of this function you should take a good look at the AcGe classes to see if they can provide any useful functionality to help in finding intersections with the geometric primitives that make up the entity this function is being called on and the pEnt entity. For example, the AcGeCurve3d class has an isOn() method that will indicate if a supplied point is on the curve and the AcGeCircArc3d class has several intersectWith() methods to find intersections with other AcGe types.If the pEnt entity is a type not recognized by this function, it is quite reasonable to call the pEnt entity's intersectWith() method passing in a pointer to this entity as the "pEnt", and all the other arguments passed into this function (remembering to convert the intType argument If necessary) to see if that entity can determine any intersection points. This is what the AutoCAD built-in classes do.Also, don't forget to take into account the intType value. The intType tells you which, if any, of the two entities should be extended to find "apparent" intersections. It is not required that apparent intersection be supported, but if it is not, then an appropriate ErrorStatus value should be returned to indicate that the call failed.The thisGsMarker and otherGsMarker arguments are provided to allow this function to determine exactly which subentities are involved in the intersection operation (for example, if this function is being called by AutoCAD as part of an intersection Osnap operation these arguments would indicate which subentities are within the osnap pickbox). For these arguments, a value less than or equal to zero indicates that that argument should not be used.If this function completes successfully (even if no intersection points are found), it should return Acad::eOk. Determining what is considered an error and what ErrorStatus return code to use for any such errors are up to the implementer -- there are no conventions in this regard.Default implementationImmediately returns Acad::eNotImplemented.-'''
    ...
    def intersectionsWithLine (self, start : PyGe.Point3d, end : PyGe.Point3d, type : PyBrxCv.TinSurfaceIntersectType, visibleOnly : bool)-> tuple[Any,...] :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isAProxy (self)-> int :
      '''Returns Adesk::kTrue if the object is a proxy object or entity. Otherwise returns Adesk::kFalse.'''
    ...
    def isAcDbObjectIdsInFlux (self)-> int :
      '''This function refers to a condition that occurs during deep clone operations. It returns Adesk::kTrue when the cloned objects' IDs have not yet been translated and thus cannot be used in any operations on the objects. This condition normally occurs only during AcEditorReactor::beginDeepCloneXlation, AcDbObject::deepClone, or AcDbObject::wblockClone. Any operations that involve AcDbObjectId references, such as symbol table records, should be postponed until after endDeepClone. AcDbObject::subClose is never called on any objects whose IDs are in flux.'''
    ...
    def isAnnotative (self)-> PyDb.AnnotativeStates :
      '''                             '''
    ...
    def isAssociative (self)-> bool :
      '''                             '''
    ...
    def isAutoUpdate (self)-> bool :
      '''                             '''
    ...
    def isCancelling (self)-> int :
      '''Returns Adesk::kTrue if the object is currently in the middle of a cancel() call (that is, an open is being canceled and all changes made are being rolled back). Otherwise returns Adesk::kFalse.'''
    ...
    def isEraseStatusToggled (self)-> int :
      '''Returns Adesk::kTrue if the object's erase bit has been toggled since it was opened. Otherwise returns Adesk::kFalse.'''
    ...
    def isErased (self)-> int :
      '''Returns Adesk::kTrue if the object is currently erased. Otherwise returns Adesk::kFalse.'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isModified (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called). Otherwise returns Adesk::kFalse.'''
    ...
    def isModifiedGraphics (self)-> int :
      '''Returns Adesk::kTrue if the object is derived from AcDbEntity and has had either an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called), or its recordGraphicsModified() function called with an Adesk::kTrue argument value.Otherwise it returns Adesk::kFalse.'''
    ...
    def isModifiedXData (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called) and has then had its setXData() method called. Otherwise it returns Adesk::kFalse.'''
    ...
    def isNewObject (self)-> int :
      '''Returns Adesk::kTrue if the object has not yet been closed since it was first created. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifyEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForNotify. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifying (self)-> int :
      '''Returns Adesk::kTrue if the object is in the process of sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isPersistent (self)-> int :
      '''                             '''
    ...
    def isPlanar (self)-> int :
      '''This function returns Adesk::kTrue if and only if there is a plane that contains the entity. Otherwise Adesk::kFalse is returned.'''
    ...
    def isReadEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForRead. Otherwise returns Adesk::kFalse.'''
    ...
    def isReallyClosing (self)-> int :
      '''Returns true if calling close() at this time would really close the object completely. For example, if the object is not in a transaction, and is open for read with only one reader, then Adesk::kTrue would be returned. If, on the other hand, the object is in a transaction, then Adesk::kFalse would be returned.'''
    ...
    def isRebuildPossible (self)-> bool :
      '''                             '''
    ...
    def isSnapshotUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isTransactionResident (self)-> int :
      '''Returns Adesk::kTrue if the object is currently part of a transaction. Otherwise returns Adesk::kFalse.'''
    ...
    def isUndoRecordingDisabled (self)-> bool :
      '''Returns true if undo recording is disabled.'''
    ...
    def isUndoing (self)-> int :
      '''Returns Adesk::kTrue if the object is involved in an Undo operation at this time. Otherwise returns Adesk::kFalse.'''
    ...
    def isUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isWriteEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForWrite and is not currently sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def layer (self)-> str :
      '''This function returns a copy of the name string in the AcDbLayerTableRecord object referenced by the entity.The calling application is responsible for deallocating the memory used by the returned string. The acutDelString() function is recommended.WarningCalling this function before the entity has had its referenced layer object ID set (that is, it's still set to AcDbObjectId::kNull) will terminate AutoCAD. If the referenced layer objectId is AcDbObjectId::kNull when the entity is added to a database, it will be set to the object ID of the database's current default layer.'''
    ...
    def layerId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the AcDbLayerTableRecord referenced by the entity. If the layerId has not been set yet, then AcDbObjectId::kNull is returned.'''
    ...
    def lineWeight (self)-> PyDb.LineWeight :
      '''This function returns the AcDb::LineWeight of the entity.'''
    ...
    def linetype (self)-> str :
      '''This function returns a copy of the name string in the AcDbLinetypeTableRecord object referenced by the entity.The calling application is responsible for deallocating the memory used by the returned string. Either the C++ delete [ ] or the C free() function may be used.Warning Calling this function before the entity has had its referenced linetype object ID set (that is, it's still set to AcDbObjectId::kNull) will terminate AutoCAD. If the referenced linetype objectId is AcDbObjectId::kNull when the entity is added to a database it will be set to the object ID of the database's current default linetype.'''
    ...
    def linetypeId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the AcDbLinetypeTableRecord referenced by the entity. If the linetypeId has not been set yet, then AcDbObjectId::kNull will be returned.'''
    ...
    def linetypeScale (self)-> float :
      '''This function returns the linetype scale factor for the entity.'''
    ...
    def list (self)-> None :
      '''Function usageThis function is intended to be called from AutoCAD whenever the entity is selected during the LIST command. However, it can be called from ObjectARX applications if desired.This function will print entity specific information to the AutoCAD command line.Function implementation in derived classesWhen implementing this function in a derived class, the first thing that should be done in the function is to make a call to assertReadEnabled(). The next thing to do is to call the parent class's list() method to allow the parent class to list it's information (the parent class should in turn call its parent class first and so on up the inheritance chain until AcDbObject is reached. This way all the entity's information will be properly printed out in order). Once the parent class's list function has been called then a series of ads_printf() calls can be used to list whatever information is desired.Default implementationLists out the entity's DXF name, the layer, the space the entity resides in (model or paper), and the entity's handle.'''
    ...
    def majorContours (self)-> list :
      '''                             '''
    ...
    def majorContoursColor (self)-> tuple[Any,...] :
      '''                             '''
    ...
    def majorContoursInterval (self)-> tuple[Any,...] :
      '''                             '''
    ...
    def material (self)-> str :
      '''Returns the material name.'''
    ...
    def materialId (self)-> PyDb.ObjectId :
      '''Returns the ID of the associated AcDbMaterial object.'''
    ...
    def maxElevation (self, visibleOnly : bool=False)-> float :
      '''                             '''
    ...
    def merge (self, other : PyBrxCv.CvDbTinSurface)-> bool :
      '''                             '''
    ...

    @staticmethod
    def mergeSurfaces (theOne: PyBrxCv.CvDbTinSurface,theOther: PyBrxCv.CvDbTinSurface)-> PyBrxCv.CvDbTinSurface :
      '''                             '''
    ...
    def minElevation (self, visibleOnly : bool=False)-> float :
      '''                             '''
    ...
    def minorContours (self)-> list :
      '''                             '''
    ...
    def minorContoursColor (self)-> tuple[Any,...] :
      '''                             '''
    ...
    def minorContoursInterval (self)-> tuple[Any,...] :
      '''                             '''
    ...
    def moveDefinition (self, _from : int, _to : int)-> int :
      '''                             '''
    ...
    def movePoint (self, _from : PyGe.Point3d, _to : PyGe.Point3d)-> bool :
      '''                             '''
    ...
    def movePoints (self, _from : list[PyGe.Point3d], _to : list[PyGe.Point3d])-> bool :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def objectId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the object. If the object is not yet database-resident, then the returned objectId will be set to AcDbObjectId::kNull.'''
    ...
    def ownerId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the owner of the object. If the object does not yet have an owner, or the ownerId data member has not yet been set using AcDbObject::setOwnerId, then the returned objectId will be set to AcDbObjectId::kNull.Appending the object to a BlockTable record, a symbol table, or a dictionary automatically calls AcDbObject::setOwnerId.'''
    ...
    def plotStyleName (self)-> str :
      '''This function returns a copy of the plotStyleName string of the entity. The caller is responsible for deallocating the returned string.The plotStyleName value is used for DXF group code 390.'''
    ...
    def pointsCount (self, visibleOnly : bool=False)-> int :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def raiseSurface (self, offset : float)-> bool :
      '''                             '''
    ...
    def rebuild (self, val : bool)-> bool :
      '''                             '''
    ...
    def rebuildSnapshot (self)-> bool :
      '''                             '''
    ...
    def receiveShadows (self)-> bool :
      '''Returns a boolean value indicating whether this entity can receive shadows.'''
    ...
    def recordGraphicsModified (self)-> None :
      '''This method sets the entity's state to indicate whether or not the entity should be updated on screen when it is closed. If the entity is set not to update, then any changes made will appear the next time the entity is regenerated.If setModified is false and the entity is currently set to update its graphics on close (which is its default state), then this function sets the entity so that it will not update on screen when it is closed and objectModified notification is sent to all entity type reactors attached to the entity. If setModified is false and the entity is already set not to update its graphics on close, then this function simply returns.If setModified is true, then the entity is set to update on screen when it is closed.'''
    ...
    def releaseExtensionDictionary (self)-> None :
      '''Removes the object's extension dictionary (that is, removes the object as the owner of the dictionary object) if it exists and is empty. Once removed, this function calls the dictionary's erase() method. Any reactors attached to the extension dictionary receive normal notification appropriate to an open for write, erase, close sequence.Returns Acad::eOk if successful.If the dictionary is not empty, then this function fails and returns Acad::eContainerNotEmpty.'''
    ...
    def removeAllDefinitions (self)-> int :
      '''                             '''
    ...
    def removeContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def removeDefinitionAt (self, index: int)-> bool :
      '''                             '''
    ...
    def removeField (self, id: str|PyDb.ObjectId)-> None :
      '''Removes the specified field.Returns Acad::eOk if successful. Otherwise, returns an AutoCAD error status.'''
    ...
    def removePersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Removes the persistent reactor specified by objId from the reactor list of the object. The object must be open AcDb::kForWrite to be able to execute this function.Returns Acad::eOk if successful. If the object is currently sending notification and is not open AcDb::kForWrite, then Acad::eWasNotifying is returned.'''
    ...
    def removePoint (self, pt : PyGe.Point3d)-> bool :
      '''                             '''
    ...
    def removePoints (self, pts : list[PyGe.Point3d])-> bool :
      '''                             '''
    ...
    def removeReactor (self, reactor: PyDb.EntityReactor)-> None :
      '''                             '''
    ...
    def removeSnapshot (self)-> bool :
      '''                             '''
    ...
    def rolloverHit (self, nSubentId: int, nMouseFlags: int, bReset: bool)-> int :
      '''                             '''
    ...
    def setAcDbObjectIdsInFlux (self)-> None :
      '''This function must be called on any newly created objects in AcDbObject::deepClone or AcDbObject::wblockClone. It indicates that reference object IDs are not yet pointing to the correct objects. The references can be translated only when the entire deep clone operation is complete. The flag is cleared at that time.'''
    ...
    def setAnnotative (self, state : PyDb.AnnotativeStates)-> None :
      '''                             '''
    ...
    def setAssociative (self, isAssociative : bool)-> bool :
      '''                             '''
    ...
    def setAttributes (self, traits: PyGi.DrawableTraits)-> int :
      '''                             '''
    ...
    def setCastShadows (self, val: bool)-> None :
      '''Sets the property to indicate whether the entity can cast shadows.'''
    ...
    def setColor (self, clr: PyDb.AcCmColor, dosubents : bool=True, db : PyDb.Database='current')-> None :
      '''Function usageThis method sets the entity's color to the color specified by color. If the entity owns subentities and doSubents == Adesk::kTrue, the color change is applied to the subentities as well. Custom classes may override this method.'''
    ...
    def setColorIndex (self, clr: int, dosubents : bool=True)-> None :
      '''Function usageThis method sets the entity's color to the AutoCAD color index color. If the entity owns subentities and doSubents == Adesk::kTrue, then the color index change will be applied to the subentities as well.'''
    ...
    def setDatabaseDefaults (self, db: PyDb.Database = 'current')-> None :
      '''This function sets the entity's:ColorLayerLinetypeLinetype scaleVisibilityPlot style nameLine weightto the default values of the database indicated by pDb: If pDb == NULL, then the current database in the AutoCAD editor is used.'''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...

    @overload
    def setField (self, field: PyDb.Field)-> PyDb.ObjectId : ...
    @overload
    def setField (self, propName: str, field: PyDb.Field)-> PyDb.ObjectId : ...
    def setField (self, *args, **kwargs)-> PyDb.ObjectId :
      '''Overloads:
    - field: PyDb.Field
    - propName: str, field: PyDb.Field
    '''
    ...
    def setIsAutoUpdate (self, autoUpdateOn : bool)-> bool :
      '''                             '''
    ...
    def setLayer (self, val: str|PyDb.ObjectId, dosubents : bool=True, allowHiddenLayer : bool=False)-> None :
      '''This method sets entity to reference the AcDbLayerTableRecord identified by the name specified in newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the layer change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.'''
    ...
    def setLineWeight (self, val: PyDb.LineWeight, dosubents : bool=True)-> None :
      '''This method sets the entity to use lineweight. If the entity owns subentities and doSubents == Adesk::kTrue, then the line weight change will be applied to the subentities as well.Returns Acad::eOk if successful.Function implementation in derived classesIf this function is overridden and wishes to set the line weight of the entity, then it must call AcDbEntity::setLineWeight() passing on the lineweight and doSubents arguments.It is also possible for this function's implementation to deal directly with any subentities and pass a doSubents value of Adesk::kFalse to AcDbEntity:: setLineWeight().If the line weight setting operation is successful, then this function should return Acad::eOk. If lineweight is not an acceptable value, then this function should return Acad::eInvalidInput. Any other error return values are up to the implementer.'''
    ...
    def setLinetype (self, val: str|PyDb.ObjectId, dosubents : bool=True)-> None :
      '''Function usageThis method sets the entity to reference the AcDbLinetypeTableRecord with the name specified in newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the linetype change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.'''
    ...
    def setLinetypeScale (self, val: float, dosubents : bool=True)-> None :
      '''This method sets the entity to use newval as its linetype scale factor. newVal must be nonnegative. If the entity owns subentities and doSubents == Adesk::kTrue, then the linetype scale change will be applied to the subentities as well.'''
    ...
    def setMajorContoursColor (self, colorIndex : int)-> bool :
      '''                             '''
    ...
    def setMajorContoursInterval (self, interval : float)-> bool :
      '''                             '''
    ...
    def setMaterial (self, val: str|PyDb.ObjectId, dosubents : bool=True)-> None :
      '''This method sets the material reference to the specified material. The specified name must correspond to an existing AcDbMaterial object.Returns Acad::eOk when successful'''
    ...
    def setMinorContoursColor (self, colorIndex : int)-> bool :
      '''                             '''
    ...
    def setMinorContoursInterval (self, interval : float)-> bool :
      '''                             '''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setOwnerId (self, owner: PyDb.ObjectId)-> None :
      '''Sets the ownerId data member of the object to be objId, thus establishing a "backpointer." This backpointer is used by WBLOCK to be sure all necessary objects are written out.Returns Acad::eOk if successful.'''
    ...

    @overload
    def setPlotStyleName (self, /)-> None : ...
    @overload
    def setPlotStyleName (self, nameType: PyDb.PlotStyleNameType, doSubents: bool)-> None : ...
    @overload
    def setPlotStyleName (self, nameType: PyDb.PlotStyleNameType, newId: PyDb.ObjectId, doSubents: bool)-> None : ...
    def setPlotStyleName (self, *args, **kwargs)-> None :
      '''Overloads:
    - None: Any
    - nameType: PyDb.PlotStyleNameType, doSubents: bool
    - nameType: PyDb.PlotStyleNameType, newId: PyDb.ObjectId, doSubents: bool
    
	-This function searches the PlotStyleName dictionary for an entry with the name that matches newName and if found, sets the entity to use that plotStyleName entry. Because a lookup in the PlotStyleName dictionary is required, the entity must be database-resident for this method to succeed. The names ByLayer and ByBlock are allowed as well as user-defined names.If the entity owns subentities and doSubents == Adesk::kTrue, then the change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.Returns Acad::eOk if successful. If the entity is not database-resident, then Acad::eNoDatabase will be returned. If there is no entry in the PlotStyleName dictionary for newName, then Acad::eKeyNotFound will be returned.The plotStyleName value is used for DXF group code 390.-'''
    ...
    def setPropertiesFrom (self, entity: PyDb.Entity, dosubents : bool=True)-> None :
      '''This method copies theColorLayerLinetypeLinetype scaleVisibilityvalues from the entity pointed to by pEntity into this entity. If the entity owns subentities and doSubents == Adesk::kTrue, then the property changes will be applied to the subentities as well.Returns Acad::eOk if successful.'''
    ...
    def setReceiveShadows (self, val: bool)-> None :
      '''Sets the property indicating whether this entity can receive shadows.'''
    ...
    def setStyle (self, style : PyBrxCv.TinSurfaceStyle)-> bool :
      '''                             '''
    ...
    def setSurfaceElevation (self, elevation : float)-> bool :
      '''                             '''
    ...
    def setVisibility (self, val: PyDb.Visibility, dosubents : bool=True)-> None :
      '''This method sets the visibility of an entity to the value specified by newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the visibility change will be applied to the subentities as well.'''
    ...
    def setXData (self, xdata: list)-> None :
      '''Each regapp sublist (delimited by a resbuf with restype == 1001 and resval.rstring == a valid regappName string) within the resbuf chain pointed to by xdata, is placed in the xdata area of the object. If any of the regappNames in xdata are already present in the xdata area of the object, then that regappName's existing data on the object is overwritten by that regappName's new data in xdata.All resbufs with restype == 1001 must have valid regappNames for the database the object resides in (that is, the regappNames must be in the APPID table of the database).Only valid xdata group codes (1000--1071) are accepted in the restype fields of the resbufs in xdata.No "-3" group code is necessary, and in fact, is not accepted. So, the first element in the resbuf chain must be a 1001 group code with a resval.rstring set to a regappName that's already registered in the regapp table. To register a regappName, use the acdbRegApp() function.To remove an appName (and its xdata) from an object, just use a resbuf with restype == 1001, resval == and no data resbufs following it (that is, either its rbnext == NULL or the next resbuf is another 1001)This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If this function is overridden, then it should supermessage its parent in order to invoke the built-in mechanism to add the xdata to the object.Returns Acad::eOk if the xdata is successfully added to the object. If there is insufficient space in the xdata area of the object, then Acad::eXdataSizeExceeded is returned. If any of the regappNames in xdata are not in the APPID table, then Acad::eRegappIdNotFound is returned.'''
    ...
    def snoop (self,  filer : PyDb.SnoopDwgFiler)-> None :
      '''                             '''
    ...

    @overload
    def solid3d (self, surface: PyBrxCv.CvDbTinSurface)-> PyDb.Solid3d : ...
    @overload
    def solid3d (self, surfaceType: PyBrxCv.TinSurfaceMeshType, thickness: float)-> PyDb.Solid3d : ...
    def solid3d (self, *args, **kwargs)-> PyDb.Solid3d :
      '''Overloads:
    - surface: PyBrxCv.CvDbTinSurface
    - surfaceType: PyBrxCv.TinSurfaceMeshType, thickness: float 
    '''
    ...
    def style (self)-> PyBrxCv.TinSurfaceStyle :
      '''                             '''
    ...

    @overload
    def subDMesh (self, /)-> PyDb.SubDMesh : ...
    @overload
    def subDMesh (self, surface: PyBrxCv.CvDbTinSurface)-> PyDb.SubDMesh : ...
    @overload
    def subDMesh (self, surfaceType: PyBrxCv.TinSurfaceMeshType, depthOrElevation: float)-> PyDb.SubDMesh : ...
    def subDMesh (self, *args, **kwargs)-> PyDb.SubDMesh :
      '''Overloads:
    - None: Any
    - surface: PyBrxCv.CvDbTinSurface
    - surfaceType: PyBrxCv.TinSurfaceMeshType, depthOrElevation: float 
    '''
    ...
    def swapEdge (self, pt : PyGe.Point3d)-> bool :
      '''                             '''
    ...
    def swapIdWith (self, otherId: PyDb.DbObject, swapXdata: bool, swapExtDict: bool)-> None :
      '''This function swaps objectIds and handles between the object specified by otherId and the object invoking this function. Both objects must currently be database-resident and must reside in the same database. If swapXdata == Adesk::kTrue, then the objects swap extended entity data as well. If swapExtDict == Adesk::kTrue, then the objects swap extension dictionaries also.If the object specified by otherId or the object invoking this function are not database-resident, then Acad::eNoDatabase is returned. If both objects involved are not in the same database, then Acad::eWrongDatabase is returned.'''
    ...
    def tinTriangles (self)-> list :
      '''                             '''
    ...
    def transformBy (self, matrix3d: PyGe.Matrix3d)-> None :
      '''Function usageThis function provides a means by which AutoCAD and ObjectARX applications can ask the entity to apply a transformation matrix (xform) to itself.Each entity class must implement this function, so restrictions on what types of transformations are supported are up to the implementer of the entity class. The AutoCAD built-in entity classes for entity types that existed before R13 (that is, all the classes listed in the header file dbents.h such as AcDbCircle, AcDbLine, AcDbArc, AcDb2dPolyline, etc.) require that the transformation matrix represent a uniformly scaling orthogonal transformation (if it is not, then Acad::eCannotScaleNonUniformly will be returned). Other AutoCAD built-in classes have no restrictions.Returns Acad::eOk if successful. Return values for errors are implementation-dependent.Function implementation in derived classesThis function must apply the transformation matrix xform to the entity and change the entity's state to reflect the transformation. It is completely up to the implementer as to how to apply the transformation. It is also up to the implementer to decide what, if any, restrictions will be placed on the type of transformations supported. If any restrictions are desired, then it's up to the implementation of this function to enforce them.If your derived class implements transformBy() without calling the base class, you must call AcDbObject:: xDataTransformBy() or your Xdata will not be transformed.If this function successfully transforms the entity, then it should return Acad::eOk.Return values for error conditions are completely up to the implementer of this function. However, if the error is caused by a non-uniformly scaling or non-orthogonal matrix, then to be consistent with other entities that have this restriction, it is recommended that Acad::eCannotScaleNonUniformly be returned.'''
    ...
    def triangles (self, visibleOnly : bool=False)-> list :
      '''                             '''
    ...
    def trianglesCount (self, visibleOnly : bool=False)-> int :
      '''                             '''
    ...
    def updateConstraint (self, val : PyBrxCv.CvDbTinSurfaceConstraint)-> bool :
      '''                             '''
    ...
    def updateObjectData (self)-> None :
      '''                             '''
    ...
    def upgradeFromNotify (self, wasWritable: bool)-> None :
      '''Upgrades the object from being at least open AcDb::kForNotify to being open both AcDb::kForNotify and AcDb::kForWrite. The wasWritable argument is set to Adesk::kTrue if the object was already open for write, otherwise it's set to Adesk::kFalse. The wasWritable value should be saved to be passed into the downgradeToNotify() call later.This function must be followed at some point by a call to downgradeToNotify() with no open() (in any of its forms) or close() calls in between.This method should only be called from within other methods of the same object it is being called from. In other words, this method is intended to be used by an object to change it's own open status so that it can safely modify itself.upgradeFromNotify() and downgradeToNotify() call pairs are not nestable.Returns Acad::eOk if successful. If the object is not currently open AcDb::kForNotify, then Acad::eNotApplicable is returned. If the object is currently in the process of actually sending notification (that is, isNotifying() returns Adesk::kTrue), then Acad::eWasNotifying is returned.'''
    ...
    def upgradeOpen (self)-> None :
      '''If the object is currently open AcDb::kForRead with only one reader, then this function upgrades the object to open AcDb::kForWrite. In the process of changing to open for write, the object is closed, thus triggering any pertinent notification.Returns Acad::eOk if successful. If the object has more than one reader, then the open status is not changed and Adesk::eHadMultipleReaders is returned. If the object is already open AcDb::kForWrite, then Acad::eWasOpenForWrite is returned. If the object is currently sending notification, then the open status is not changed and Acad::eWasNotifying is returned.'''
    ...
    def viewportDraw (self, vpdraw: PyGi.ViewportDraw)-> None :
      '''                             '''
    ...
    def viewportDrawLogicalFlags (self, vpdraw: PyGi.ViewportDraw)-> int :
      '''                             '''
    ...
    def visibility (self)-> PyDb.Visibility :
      '''This method returns the entity's current visibility state, either AcDb::kVisible or AcDb::kInvisible.'''
    ...
    def wblockClone (self, owner: PyRx.RxObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function is almost identical to AcDbObject::deepClone, except that an AcDbWblockCloneFiler is used and ownership is not carried across database boundaries. Subcloning is based on hard owner and hard pointer connections.'''
    ...
    def worldDraw (self, wdraw: PyGi.WorldDraw)-> int :
      '''                             '''
    ...
    def xData (self, appname: str = None)-> list :
      '''Returns a linked list of resbuf structures containing a copy of the xdata for the object. If regappName == NULL is passed in, all xdata is returned, otherwise only the xdata for the specified name is returned. If not all xdata is required, but the xdata for more than one regappName is desired, then multiple calls to this member function must be made--one for each regappName.The caller of this function is responsible for releasing the memory used by the resbuf list that is returned. The most commonly used way to deallocate such a list is via the acutRelRb() function.This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If a failure accessing the xdata occurs, NULL is returned.'''
    ...
    def xDataTransformBy (self, xform: PyGe.Matrix3d)-> None :
      '''This method applies the xform transformation matrix to any XData data types 1011, 1021, 1031, 1012, 1022, 1032, 1013, 1023, 1033, 1041, and 1042 in the object's XData. See the documentation on XData for more information on the way the transformation matrix is applied to the different data types.This method should be called from within the transformBy() method on custom entities so that such entities will transform XData in the same way that the built-in AcDb entities do.Returns Acad::eOk if successful.'''
    ...
    def xmitPropagateModify (self)-> None :
      '''Within an object's close() method is a call to the object's xmitPropagateModify().The AcDbObject::xmitPropagateModify() default implementation is to inform the containing database that the object has been modified, appended to the database, or erased. The database then sends out the appropriate notification to any AcDbDatabaseReactors attached to it.Within AutoCAD, this function is used by complex entities such as polylines to allow the subentities to notify the header that they have been changed. The header can then "propagate" the notification by sending its own notification that the "complex entity" has been modified.The way this works is:The subobject class has it's xmitPropagateModify() class overridden such that it calls it's parent class's xmitPropagateModify() and also calls the owning object's recvPropagateModify().The "root" or "header" class has it's recvPropagateModify() overridden to provide an implementation that triggers "modified" notification to be sent for the "root" or "header" (which effectively represents the whole complex object).The subobject's close() triggers "modified" notification for the subobject and calls the subobject's xmitPropagateModify() function. So, when the subobject's close() is called, its xmitPropagateModify() is called. This then calls the owning object's recvPropagateModify(), which then triggers the owner to send "modified" notification.So, the result is a "modified" notification from both the subentity and the "root" or "header" entity.When overridden, this function should:Call its parent class's xmitPropagateModify() (which ultimately results in the execution of AcDbObject::xmitPropagateModify() to trigger database notification).Call its owner's recvPropagateModify() (passing in its "this" pointer) to "propagate" the notification information to the "root" owner to be sent out.'''
    ...

class CvDbTinSurfaceBoundary(CvDbTinSurfaceConstraint):
    def __init__ (self, type: PyBrxCv.TinBoundaryType)-> None :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def constraintType (self)-> PyBrxCv.TinConstraintType :
      '''                             '''
    ...
    def data (self)-> list :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def isDbResident (self)-> bool :
      '''                             '''
    ...
    def midOrdinateDistance (self)-> float :
      '''                             '''
    ...
    def setData (self, intId : int, pts : list[PyGe.Point3d])-> None :
      '''                             '''
    ...
    def setDataId (self, id : PyDb.ObjectId, midOrdinateDist : float)-> None :
      '''                             '''
    ...
    def setIsDbResident (self, val : bool)-> None :
      '''                             '''
    ...
    def setMidOrdinateDistance (self, val : float)-> None :
      '''                             '''
    ...
    def wallType (self)-> PyBrxCv.TinBoundaryType :
      '''                             '''
    ...

class CvDbTinSurfaceBreakline(CvDbTinSurfaceConstraint):
    def __init__ (self, type: PyBrxCv.TinBreaklineType)-> None :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def constraintType (self)-> PyBrxCv.TinConstraintType :
      '''                             '''
    ...
    def data (self)-> list :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def intersectionElevation (self)-> PyBrxCv.BreaklineIntersectionElevation :
      '''                             '''
    ...
    def isDbResident (self)-> bool :
      '''                             '''
    ...
    def midOrdinateDistance (self)-> float :
      '''                             '''
    ...
    def setData (self, intId : int, pts : list[PyGe.Point3d])-> None :
      '''                             '''
    ...
    def setDataId (self, id : PyDb.ObjectId, midOrdinateDist : float)-> None :
      '''                             '''
    ...
    def setIntersectionElevation (self, val : PyBrxCv.TinBreaklineType)-> None :
      '''                             '''
    ...
    def setIsDbResident (self, val : bool)-> None :
      '''                             '''
    ...
    def setMidOrdinateDistance (self, val : float)-> None :
      '''                             '''
    ...

class CvDbTinSurfaceConstraint(object):
    def __init__ (self, type: PyBrxCv.TinConstraintType)-> None :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def constraintType (self)-> PyBrxCv.TinConstraintType :
      '''                             '''
    ...
    def data (self)-> list :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def isDbResident (self)-> bool :
      '''                             '''
    ...
    def midOrdinateDistance (self)-> float :
      '''                             '''
    ...
    def setData (self, intId : int, pts : list[PyGe.Point3d])-> None :
      '''                             '''
    ...
    def setDataId (self, id : PyDb.ObjectId, midOrdinateDist : float)-> None :
      '''                             '''
    ...
    def setIsDbResident (self, val : bool)-> None :
      '''                             '''
    ...
    def setMidOrdinateDistance (self, val : float)-> None :
      '''                             '''
    ...

class CvDbTinSurfaceDefinition(CvDbSubObject):
    def __init__ (self, *args, **kwargs)-> None :
      '''Raises an exception
This class cannot be instantiated from Python'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbTinSurfaceDefinition :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isEnabled (self)-> bool :
      '''                             '''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isReadOnly (self)-> bool :
      '''                             '''
    ...
    def isSubDefinition (self)-> bool :
      '''                             '''
    ...
    def isUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isValid (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, desc : str)-> bool :
      '''                             '''
    ...
    def setEnabled (self, val : bool)-> bool :
      '''                             '''
    ...
    def setName (self, name : str)-> bool :
      '''                             '''
    ...
    def setReadOnly (self, val : bool)-> bool :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.TinSurfaceDefinitionType :
      '''                             '''
    ...

class CvDbTinSurfaceDefinitionAddDrawingObjects(CvDbTinSurfaceDefinition):
    def __init__ (self, *args, **kwargs)-> None :
      '''__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1, (list)arg2, (float)arg3, (bool)arg4, (TinIntersectionElevation)arg5) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64,class boost::python::list,double,bool,enum BrxCvDbTinSurfaceDefinitionAddDrawingObjects::ETinIntersectionElevation)'''
    ...
    def addEntity (self, entity: PyDb.Entity)-> bool :
      '''                             '''
    ...
    def addEntityId (self, id : PyDb.ObjectId)-> bool :
      '''                             '''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbTinSurfaceDefinitionAddDrawingObjects :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...
    def crossingsElevation (self)-> PyBrxCv.TinIntersectionElevation :
      '''                             '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def drawingObjectAt (self, idx : int)-> tuple[Any,...] :
      '''                             '''
    ...
    def drawingObjectsCount (self)-> int :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isApplyEdges (self)-> bool :
      '''                             '''
    ...
    def isEnabled (self)-> bool :
      '''                             '''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isReadOnly (self)-> bool :
      '''                             '''
    ...
    def isSubDefinition (self)-> bool :
      '''                             '''
    ...
    def isUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isValid (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def removeAllDrawingObjects (self)-> bool :
      '''                             '''
    ...
    def removeDrawingObjectAt (self, idx : int)-> bool :
      '''                             '''
    ...
    def setCrossingsElevation (self, val : PyBrxCv.TinIntersectionElevation)-> bool :
      '''                             '''
    ...
    def setDescription (self, desc : str)-> bool :
      '''                             '''
    ...
    def setEnabled (self, val : bool)-> bool :
      '''                             '''
    ...
    def setIsApplyEdges (self, val : bool)-> bool :
      '''                             '''
    ...
    def setName (self, name : str)-> bool :
      '''                             '''
    ...
    def setReadOnly (self, val : bool)-> bool :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.TinSurfaceDefinitionType :
      '''                             '''
    ...

class CvDbTinSurfaceDefinitionAddFromFiles(CvDbTinSurfaceDefinition):
    def __init__ (self, *args, **kwargs)-> None :
      '''__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1, (list)arg2, (ObjectId)arg3) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64,class boost::python::list,class PyDbObjectId)'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbTinSurfaceDefinitionAddFromFiles :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def fileFormatId (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def filesPaths (self)-> list :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isEnabled (self)-> bool :
      '''                             '''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isReadOnly (self)-> bool :
      '''                             '''
    ...
    def isSubDefinition (self)-> bool :
      '''                             '''
    ...
    def isUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isValid (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, desc : str)-> bool :
      '''                             '''
    ...
    def setEnabled (self, val : bool)-> bool :
      '''                             '''
    ...
    def setFileFormatId (self, id : PyDb.ObjectId)-> bool :
      '''                             '''
    ...
    def setFilesPaths (self, val : list[str])-> bool :
      '''                             '''
    ...
    def setName (self, name : str)-> bool :
      '''                             '''
    ...
    def setReadOnly (self, val : bool)-> bool :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.TinSurfaceDefinitionType :
      '''                             '''
    ...

class CvDbTinSurfaceDefinitionAddFromPointClouds(CvDbTinSurfaceDefinition):
    def __init__ (self, *args, **kwargs)-> None :
      '''__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1, (list)arg2) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64,class boost::python::list)'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbTinSurfaceDefinitionAddFromPointClouds :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isEnabled (self)-> bool :
      '''                             '''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isReadOnly (self)-> bool :
      '''                             '''
    ...
    def isSubDefinition (self)-> bool :
      '''                             '''
    ...
    def isUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isValid (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def pcObjectIds (self)-> list :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, desc : str)-> bool :
      '''                             '''
    ...
    def setEnabled (self, val : bool)-> bool :
      '''                             '''
    ...
    def setName (self, name : str)-> bool :
      '''                             '''
    ...
    def setPcObjectIds (self, val : list[PyDb.ObjectId])-> bool :
      '''                             '''
    ...
    def setReadOnly (self, val : bool)-> bool :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.TinSurfaceDefinitionType :
      '''                             '''
    ...

class CvDbTinSurfaceDefinitionAddLine(CvDbTinSurfaceDefinition):
    def __init__ (self, *args, **kwargs)-> None :
      '''__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1, (object)arg2) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64,class AcGeLineSeg2d)'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbTinSurfaceDefinitionAddLine :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isEnabled (self)-> bool :
      '''                             '''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isReadOnly (self)-> bool :
      '''                             '''
    ...
    def isSubDefinition (self)-> bool :
      '''                             '''
    ...
    def isUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isValid (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def line (self)-> PyGe.LineSeg2d :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, desc : str)-> bool :
      '''                             '''
    ...
    def setEnabled (self, val : bool)-> bool :
      '''                             '''
    ...
    def setLine (self, line : PyGe.LineSeg2d)-> bool :
      '''                             '''
    ...
    def setName (self, name : str)-> bool :
      '''                             '''
    ...
    def setReadOnly (self, val : bool)-> bool :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.TinSurfaceDefinitionType :
      '''                             '''
    ...

class CvDbTinSurfaceDefinitionAddLines(CvDbTinSurfaceDefinition):
    def __init__ (self, *args, **kwargs)-> None :
      '''__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1, (list)arg2) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64,class boost::python::list)'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbTinSurfaceDefinitionAddLines :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isEnabled (self)-> bool :
      '''                             '''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isReadOnly (self)-> bool :
      '''                             '''
    ...
    def isSubDefinition (self)-> bool :
      '''                             '''
    ...
    def isUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isValid (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def lines (self)-> list :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, desc : str)-> bool :
      '''                             '''
    ...
    def setEnabled (self, val : bool)-> bool :
      '''                             '''
    ...
    def setLines (self, lines : list[PyGe.LineSeg2d])-> bool :
      '''                             '''
    ...
    def setName (self, name : str)-> bool :
      '''                             '''
    ...
    def setReadOnly (self, val : bool)-> bool :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.TinSurfaceDefinitionType :
      '''                             '''
    ...

class CvDbTinSurfaceDefinitionAddPoint(CvDbTinSurfaceDefinition):
    def __init__ (self, *args, **kwargs)-> None :
      '''__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1, (Point3d)arg2) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64,class AcGePoint3d)'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbTinSurfaceDefinitionAddPoint :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isEnabled (self)-> bool :
      '''                             '''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isReadOnly (self)-> bool :
      '''                             '''
    ...
    def isSubDefinition (self)-> bool :
      '''                             '''
    ...
    def isUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isValid (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def position (self)-> PyGe.Point3d :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, desc : str)-> bool :
      '''                             '''
    ...
    def setEnabled (self, val : bool)-> bool :
      '''                             '''
    ...
    def setName (self, name : str)-> bool :
      '''                             '''
    ...
    def setPosition (self, pt : PyGe.Point3d)-> bool :
      '''                             '''
    ...
    def setReadOnly (self, val : bool)-> bool :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.TinSurfaceDefinitionType :
      '''                             '''
    ...

class CvDbTinSurfaceDefinitionAddPointGroups(CvDbTinSurfaceDefinition):
    def __init__ (self, *args, **kwargs)-> None :
      '''__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1, (list)arg2) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64,class boost::python::list)'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbTinSurfaceDefinitionAddPointGroups :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isEnabled (self)-> bool :
      '''                             '''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isReadOnly (self)-> bool :
      '''                             '''
    ...
    def isSubDefinition (self)-> bool :
      '''                             '''
    ...
    def isUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isValid (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def pointGroupsIds (self)-> list :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, desc : str)-> bool :
      '''                             '''
    ...
    def setEnabled (self, val : bool)-> bool :
      '''                             '''
    ...
    def setName (self, name : str)-> bool :
      '''                             '''
    ...
    def setPointGroupsIds (self, val : list[PyDb.ObjectId])-> bool :
      '''                             '''
    ...
    def setReadOnly (self, val : bool)-> bool :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.TinSurfaceDefinitionType :
      '''                             '''
    ...

class CvDbTinSurfaceDefinitionAddPoints(CvDbTinSurfaceDefinition):
    def __init__ (self, *args, **kwargs)-> None :
      '''__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1, (list)arg2) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64,class boost::python::list)'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbTinSurfaceDefinitionAddPoints :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isEnabled (self)-> bool :
      '''                             '''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isReadOnly (self)-> bool :
      '''                             '''
    ...
    def isSubDefinition (self)-> bool :
      '''                             '''
    ...
    def isUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isValid (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def positions (self)-> list :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, desc : str)-> bool :
      '''                             '''
    ...
    def setEnabled (self, val : bool)-> bool :
      '''                             '''
    ...
    def setName (self, name : str)-> bool :
      '''                             '''
    ...
    def setPositions (self, pt : list[PyGe.Point3d])-> bool :
      '''                             '''
    ...
    def setReadOnly (self, val : bool)-> bool :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.TinSurfaceDefinitionType :
      '''                             '''
    ...

class CvDbTinSurfaceDefinitionCreateFromC3D(CvDbTinSurfaceDefinition):
    def __init__ (self, *args, **kwargs)-> None :
      '''__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1, (str)arg2, (str)arg3) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64,class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >,class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >)'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbTinSurfaceDefinitionCreateFromC3D :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def filePath (self)-> str :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isEnabled (self)-> bool :
      '''                             '''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isReadOnly (self)-> bool :
      '''                             '''
    ...
    def isSubDefinition (self)-> bool :
      '''                             '''
    ...
    def isUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isValid (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, desc : str)-> bool :
      '''                             '''
    ...
    def setEnabled (self, val : bool)-> bool :
      '''                             '''
    ...
    def setFilePath (self, val : str)-> bool :
      '''                             '''
    ...
    def setName (self, name : str)-> bool :
      '''                             '''
    ...
    def setReadOnly (self, val : bool)-> bool :
      '''                             '''
    ...
    def setSurfaceName (self, val : str)-> bool :
      '''                             '''
    ...
    def surfaceName (self)-> str :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.TinSurfaceDefinitionType :
      '''                             '''
    ...

class CvDbTinSurfaceDefinitionCreateFromFaces(CvDbTinSurfaceDefinition):
    def __init__ (self, *args, **kwargs)-> None :
      '''__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1, (list)arg2, (bool)arg3) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64,class boost::python::list,bool)'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbTinSurfaceDefinitionCreateFromFaces :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def faceAt (self, *args, **kwargs)-> tuple[Any,...] :
      '''faceAt( (CvDbTinSurfaceDefinitionCreateFromFaces)arg1, (SubentType)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple faceAt(class PyBrxCvDbTinSurfaceDefinitionCreateFromFaces {lvalue},unsigned long)'''
    ...
    def facesCount (self, *args, **kwargs)-> int :
      '''facesCount( (CvDbTinSurfaceDefinitionCreateFromFaces)arg1) -> int :

    C++ signature :
        unsigned long facesCount(class PyBrxCvDbTinSurfaceDefinitionCreateFromFaces {lvalue})'''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isApplyEdgesVisibility (self, *args, **kwargs)-> bool :
      '''isApplyEdgesVisibility( (CvDbTinSurfaceDefinitionCreateFromFaces)arg1) -> bool :

    C++ signature :
        bool isApplyEdgesVisibility(class PyBrxCvDbTinSurfaceDefinitionCreateFromFaces {lvalue})'''
    ...
    def isEnabled (self)-> bool :
      '''                             '''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isReadOnly (self)-> bool :
      '''                             '''
    ...
    def isSubDefinition (self)-> bool :
      '''                             '''
    ...
    def isUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isValid (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def points (self, *args, **kwargs)-> list :
      '''points( (CvDbTinSurfaceDefinitionCreateFromFaces)arg1) -> list :

    C++ signature :
        class boost::python::list points(class PyBrxCvDbTinSurfaceDefinitionCreateFromFaces {lvalue})'''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, desc : str)-> bool :
      '''                             '''
    ...
    def setEnabled (self, val : bool)-> bool :
      '''                             '''
    ...
    def setIsApplyEdgesVisibility (self, *args, **kwargs)-> bool :
      '''setIsApplyEdgesVisibility( (CvDbTinSurfaceDefinitionCreateFromFaces)arg1, (bool)arg2) -> bool :

    C++ signature :
        bool setIsApplyEdgesVisibility(class PyBrxCvDbTinSurfaceDefinitionCreateFromFaces {lvalue},bool)'''
    ...
    def setName (self, name : str)-> bool :
      '''                             '''
    ...
    def setReadOnly (self, val : bool)-> bool :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.TinSurfaceDefinitionType :
      '''                             '''
    ...

class CvDbTinSurfaceDefinitionCreateFromLandXML(CvDbTinSurfaceDefinition):
    def __init__ (self, *args, **kwargs)-> None :
      '''__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1, (str)arg2, (str)arg3, (UnitsValue)arg4, (bool)arg5) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64,class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >,class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >,enum AcDb::UnitsValue,bool)'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbTinSurfaceDefinitionCreateFromLandXML :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def dwgUnits (self)-> PyDb.UnitsValue :
      '''                             '''
    ...
    def filePath (self)-> str :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isEnabled (self)-> bool :
      '''                             '''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isReadOnly (self)-> bool :
      '''                             '''
    ...
    def isSubDefinition (self)-> bool :
      '''                             '''
    ...
    def isUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isValid (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def scaleToDwgUnits (self)-> bool :
      '''                             '''
    ...
    def setDescription (self, desc : str)-> bool :
      '''                             '''
    ...
    def setEnabled (self, val : bool)-> bool :
      '''                             '''
    ...
    def setFilePath (self, val : str)-> bool :
      '''                             '''
    ...
    def setName (self, name : str)-> bool :
      '''                             '''
    ...
    def setReadOnly (self, val : bool)-> bool :
      '''                             '''
    ...
    def setScaleToDwgUnits (self, val : bool)-> bool :
      '''                             '''
    ...
    def setSurfaceName (self, val : str)-> bool :
      '''                             '''
    ...
    def surfaceName (self)-> str :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.TinSurfaceDefinitionType :
      '''                             '''
    ...

class CvDbTinSurfaceDefinitionDeleteEdge(CvDbTinSurfaceDefinition):
    def __init__ (self, *args, **kwargs)-> None :
      '''__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1, (Point2d)arg2) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64,class AcGePoint2d)'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbTinSurfaceDefinitionDeleteEdge :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isEnabled (self)-> bool :
      '''                             '''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isReadOnly (self)-> bool :
      '''                             '''
    ...
    def isSubDefinition (self)-> bool :
      '''                             '''
    ...
    def isUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isValid (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def position (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, desc : str)-> bool :
      '''                             '''
    ...
    def setEnabled (self, val : bool)-> bool :
      '''                             '''
    ...
    def setName (self, name : str)-> bool :
      '''                             '''
    ...
    def setPosition (self, pt : PyGe.Point2d)-> bool :
      '''                             '''
    ...
    def setReadOnly (self, val : bool)-> bool :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.TinSurfaceDefinitionType :
      '''                             '''
    ...

class CvDbTinSurfaceDefinitionDeleteEdges(CvDbTinSurfaceDefinition):
    def __init__ (self, *args, **kwargs)-> None :
      '''__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)'''
    ...
    def addPolygon (self, edgePolygon : list[PyGe.Point2d], includeIntersected : bool)-> bool :
      '''                             '''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbTinSurfaceDefinitionDeleteEdges :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isEnabled (self)-> bool :
      '''                             '''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isReadOnly (self)-> bool :
      '''                             '''
    ...
    def isSubDefinition (self)-> bool :
      '''                             '''
    ...
    def isUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isValid (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def polygonAt (self, index : int)-> tuple[Any,...] :
      '''                             '''
    ...
    def polygonsCount (self)-> int :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def removeAllPolygons (self)-> bool :
      '''                             '''
    ...
    def removePolygonAt (self, index : int)-> bool :
      '''                             '''
    ...
    def setDescription (self, desc : str)-> bool :
      '''                             '''
    ...
    def setEnabled (self, val : bool)-> bool :
      '''                             '''
    ...
    def setName (self, name : str)-> bool :
      '''                             '''
    ...
    def setReadOnly (self, val : bool)-> bool :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.TinSurfaceDefinitionType :
      '''                             '''
    ...

class CvDbTinSurfaceDefinitionDeletePoint(CvDbTinSurfaceDefinition):
    def __init__ (self, *args, **kwargs)-> None :
      '''__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1, (Point2d)arg2) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64,class AcGePoint2d)'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbTinSurfaceDefinitionDeletePoint :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isEnabled (self)-> bool :
      '''                             '''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isReadOnly (self)-> bool :
      '''                             '''
    ...
    def isSubDefinition (self)-> bool :
      '''                             '''
    ...
    def isUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isValid (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def position (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, desc : str)-> bool :
      '''                             '''
    ...
    def setEnabled (self, val : bool)-> bool :
      '''                             '''
    ...
    def setName (self, name : str)-> bool :
      '''                             '''
    ...
    def setPosition (self, pt : PyGe.Point2d)-> bool :
      '''                             '''
    ...
    def setReadOnly (self, val : bool)-> bool :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.TinSurfaceDefinitionType :
      '''                             '''
    ...

class CvDbTinSurfaceDefinitionGroupDefs(CvDbTinSurfaceDefinition):
    def __init__ (self, *args, **kwargs)-> None :
      '''__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)'''
    ...
    def addSubDefinition (self, val : PyBrxCv.CvDbTinSurfaceDefinition)-> int :
      '''                             '''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbTinSurfaceDefinitionGroupDefs :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def findSubDefinition (self, defid : int)-> int :
      '''                             '''
    ...
    def getSubDefinitionAt (self, index : int)-> PyBrxCv.CvDbTinSurfaceDefinition :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isEnabled (self)-> bool :
      '''                             '''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isReadOnly (self)-> bool :
      '''                             '''
    ...
    def isSubDefinition (self)-> bool :
      '''                             '''
    ...
    def isUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isValid (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def numSubDefinitions (self)-> int :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def removeSubDefinitionAt (self, index : int)-> bool :
      '''                             '''
    ...
    def setDescription (self, desc : str)-> bool :
      '''                             '''
    ...
    def setEnabled (self, val : bool)-> bool :
      '''                             '''
    ...
    def setName (self, name : str)-> bool :
      '''                             '''
    ...
    def setReadOnly (self, val : bool)-> bool :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.TinSurfaceDefinitionType :
      '''                             '''
    ...

class CvDbTinSurfaceDefinitionModifyPointElevation(CvDbTinSurfaceDefinition):
    def __init__ (self, *args, **kwargs)-> None :
      '''__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1, (Point2d)arg2, (float)arg3, (bool)arg4) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64,class AcGePoint2d,double,bool)'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbTinSurfaceDefinitionModifyPointElevation :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def elevation (self)-> float :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isDeltaElevation (self)-> bool :
      '''                             '''
    ...
    def isEnabled (self)-> bool :
      '''                             '''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isReadOnly (self)-> bool :
      '''                             '''
    ...
    def isSubDefinition (self)-> bool :
      '''                             '''
    ...
    def isUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isValid (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def position (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, desc : str)-> bool :
      '''                             '''
    ...
    def setElevation (self, val : float)-> bool :
      '''                             '''
    ...
    def setEnabled (self, val : bool)-> bool :
      '''                             '''
    ...
    def setIsDeltaElevation (self, val : float)-> bool :
      '''                             '''
    ...
    def setName (self, name : str)-> bool :
      '''                             '''
    ...
    def setPosition (self, pt : PyGe.Point2d)-> bool :
      '''                             '''
    ...
    def setReadOnly (self, val : bool)-> bool :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.TinSurfaceDefinitionType :
      '''                             '''
    ...

class CvDbTinSurfaceDefinitionModifyPointsElevation(CvDbTinSurfaceDefinition):
    def __init__ (self, *args, **kwargs)-> None :
      '''__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1, (list)arg2, (float)arg3, (bool)arg4) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64,class boost::python::list,double,bool)'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbTinSurfaceDefinitionModifyPointsElevation :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def elevation (self)-> float :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isDeltaElevation (self)-> bool :
      '''                             '''
    ...
    def isEnabled (self)-> bool :
      '''                             '''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isReadOnly (self)-> bool :
      '''                             '''
    ...
    def isSubDefinition (self)-> bool :
      '''                             '''
    ...
    def isUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isValid (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def positions (self)-> list :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, desc : str)-> bool :
      '''                             '''
    ...
    def setElevation (self, val : float)-> bool :
      '''                             '''
    ...
    def setEnabled (self, val : bool)-> bool :
      '''                             '''
    ...
    def setName (self, name : str)-> bool :
      '''                             '''
    ...
    def setPositions (self, pt : list[PyGe.Point2d])-> bool :
      '''                             '''
    ...
    def setReadOnly (self, val : bool)-> bool :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.TinSurfaceDefinitionType :
      '''                             '''
    ...

class CvDbTinSurfaceDefinitionModifyPointsElevations(CvDbTinSurfaceDefinition):
    def __init__ (self, *args, **kwargs)-> None :
      '''__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)'''
    ...
    def addPointElevation (self, *args, **kwargs)-> bool :
      '''addPointElevation( (CvDbTinSurfaceDefinitionModifyPointsElevations)arg1, (Point2d)arg2, (float)arg3) -> bool :

    C++ signature :
        bool addPointElevation(class PyBrxCvDbTinSurfaceDefinitionModifyPointsElevations {lvalue},class AcGePoint2d,double)'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbTinSurfaceDefinitionModifyPointsElevations :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isEnabled (self)-> bool :
      '''                             '''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isReadOnly (self)-> bool :
      '''                             '''
    ...
    def isSubDefinition (self)-> bool :
      '''                             '''
    ...
    def isUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isValid (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def pointElevationAt (self, *args, **kwargs)-> tuple[Any,...] :
      '''pointElevationAt( (CvDbTinSurfaceDefinitionModifyPointsElevations)arg1, (SubentType)arg2) -> tuple :

    C++ signature :
        class boost::python::tuple pointElevationAt(class PyBrxCvDbTinSurfaceDefinitionModifyPointsElevations {lvalue},unsigned long)'''
    ...
    def pointElevationsCount (self, *args, **kwargs)-> int :
      '''pointElevationsCount( (CvDbTinSurfaceDefinitionModifyPointsElevations)arg1) -> int :

    C++ signature :
        unsigned long pointElevationsCount(class PyBrxCvDbTinSurfaceDefinitionModifyPointsElevations {lvalue})'''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def removeAllPointElevations (self, *args, **kwargs)-> bool :
      '''removeAllPointElevations( (CvDbTinSurfaceDefinitionModifyPointsElevations)arg1) -> bool :

    C++ signature :
        bool removeAllPointElevations(class PyBrxCvDbTinSurfaceDefinitionModifyPointsElevations {lvalue})'''
    ...
    def removePointElevationAt (self, *args, **kwargs)-> bool :
      '''removePointElevationAt( (CvDbTinSurfaceDefinitionModifyPointsElevations)arg1, (SubentType)arg2) -> bool :

    C++ signature :
        bool removePointElevationAt(class PyBrxCvDbTinSurfaceDefinitionModifyPointsElevations {lvalue},unsigned long)'''
    ...
    def setDescription (self, desc : str)-> bool :
      '''                             '''
    ...
    def setEnabled (self, val : bool)-> bool :
      '''                             '''
    ...
    def setName (self, name : str)-> bool :
      '''                             '''
    ...
    def setReadOnly (self, val : bool)-> bool :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.TinSurfaceDefinitionType :
      '''                             '''
    ...

class CvDbTinSurfaceDefinitionMovePoint(CvDbTinSurfaceDefinition):
    def __init__ (self, *args, **kwargs)-> None :
      '''__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1, (Point2d)arg2, (Point2d)arg3) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64,class AcGePoint2d,class AcGePoint2d)'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbTinSurfaceDefinitionMovePoint :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def fromPosition (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isEnabled (self)-> bool :
      '''                             '''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isReadOnly (self)-> bool :
      '''                             '''
    ...
    def isSubDefinition (self)-> bool :
      '''                             '''
    ...
    def isUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isValid (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, desc : str)-> bool :
      '''                             '''
    ...
    def setEnabled (self, val : bool)-> bool :
      '''                             '''
    ...
    def setFromPosition (self, pt : PyGe.Point2d)-> bool :
      '''                             '''
    ...
    def setName (self, name : str)-> bool :
      '''                             '''
    ...
    def setReadOnly (self, val : bool)-> bool :
      '''                             '''
    ...
    def setToPosition (self, pt : PyGe.Point2d)-> bool :
      '''                             '''
    ...
    def toPosition (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.TinSurfaceDefinitionType :
      '''                             '''
    ...

class CvDbTinSurfaceDefinitionMovePoints(CvDbTinSurfaceDefinition):
    def __init__ (self, *args, **kwargs)-> None :
      '''__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1, (list)arg2, (Vector2d)arg3) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64,class boost::python::list,class AcGeVector2d)'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbTinSurfaceDefinitionMovePoints :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def displacement (self)-> PyGe.Vector2d :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def fromPoints (self)-> list :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isEnabled (self)-> bool :
      '''                             '''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isReadOnly (self)-> bool :
      '''                             '''
    ...
    def isSubDefinition (self)-> bool :
      '''                             '''
    ...
    def isUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isValid (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, desc : str)-> bool :
      '''                             '''
    ...
    def setDisplacement (self, vec : PyGe.Vector3d)-> bool :
      '''                             '''
    ...
    def setEnabled (self, val : bool)-> bool :
      '''                             '''
    ...
    def setFromPoints (self, pt : list[PyGe.Point2d])-> bool :
      '''                             '''
    ...
    def setName (self, name : str)-> bool :
      '''                             '''
    ...
    def setReadOnly (self, val : bool)-> bool :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.TinSurfaceDefinitionType :
      '''                             '''
    ...

class CvDbTinSurfaceDefinitionRemoveElevations(CvDbTinSurfaceDefinition):
    def __init__ (self, *args, **kwargs)-> None :
      '''__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1, (bool)arg2, (float)arg3, (bool)arg4, (float)arg5) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64,bool,double,bool,double)'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbTinSurfaceDefinitionRemoveElevations :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isEnabled (self)-> bool :
      '''                             '''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isReadOnly (self)-> bool :
      '''                             '''
    ...
    def isSubDefinition (self)-> bool :
      '''                             '''
    ...
    def isUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isValid (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def removeAbove (self)-> bool :
      '''                             '''
    ...
    def removeAboveElevation (self)-> float :
      '''                             '''
    ...
    def removeBelow (self)-> bool :
      '''                             '''
    ...
    def removeBelowElevation (self)-> float :
      '''                             '''
    ...
    def removedPointsCount (self)-> int :
      '''                             '''
    ...
    def setDescription (self, desc : str)-> bool :
      '''                             '''
    ...
    def setEnabled (self, val : bool)-> bool :
      '''                             '''
    ...
    def setName (self, name : str)-> bool :
      '''                             '''
    ...
    def setReadOnly (self, val : bool)-> bool :
      '''                             '''
    ...
    def setRemoveAbove (self, val : bool)-> bool :
      '''                             '''
    ...
    def setRemoveAboveElevation (self, val : float)-> bool :
      '''                             '''
    ...
    def setRemoveBelow (self, val : bool)-> bool :
      '''                             '''
    ...
    def setRemoveBelowElevation (self, val : float)-> bool :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.TinSurfaceDefinitionType :
      '''                             '''
    ...

class CvDbTinSurfaceDefinitionRemoveOuterEdges(CvDbTinSurfaceDefinition):
    def __init__ (self, *args, **kwargs)-> None :
      '''__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1, (bool)arg2, (float)arg3, (bool)arg4, (float)arg5, (bool)arg6, (float)arg7) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64,bool,double,bool,double,bool,double)'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbTinSurfaceDefinitionRemoveOuterEdges :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isEnabled (self)-> bool :
      '''                             '''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isReadOnly (self)-> bool :
      '''                             '''
    ...
    def isSubDefinition (self)-> bool :
      '''                             '''
    ...
    def isUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isValid (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def maxAdjAngle (self)-> float :
      '''                             '''
    ...
    def maxEdgeLength (self)-> float :
      '''                             '''
    ...
    def minEdgeLength (self)-> float :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, desc : str)-> bool :
      '''                             '''
    ...
    def setEnabled (self, val : bool)-> bool :
      '''                             '''
    ...
    def setMaxAdjAngle (self, val : float)-> bool :
      '''                             '''
    ...
    def setMaxEdgeLength (self, val : float)-> bool :
      '''                             '''
    ...
    def setMinEdgeLength (self, val : float)-> bool :
      '''                             '''
    ...
    def setName (self, name : str)-> bool :
      '''                             '''
    ...
    def setReadOnly (self, val : bool)-> bool :
      '''                             '''
    ...
    def setUseMaxAdjAngle (self, val : bool)-> bool :
      '''                             '''
    ...
    def setUseMaxEdgeLength (self, val : bool)-> bool :
      '''                             '''
    ...
    def setUseMinEdgeLength (self, val : bool)-> bool :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.TinSurfaceDefinitionType :
      '''                             '''
    ...
    def useMaxAdjAngle (self)-> bool :
      '''                             '''
    ...
    def useMaxEdgeLength (self)-> bool :
      '''                             '''
    ...
    def useMinEdgeLength (self)-> bool :
      '''                             '''
    ...

class CvDbTinSurfaceDefinitionRiseLower(CvDbTinSurfaceDefinition):
    def __init__ (self, *args, **kwargs)-> None :
      '''__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1, (float)arg2) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64,double)'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbTinSurfaceDefinitionRiseLower :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isEnabled (self)-> bool :
      '''                             '''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isReadOnly (self)-> bool :
      '''                             '''
    ...
    def isSubDefinition (self)-> bool :
      '''                             '''
    ...
    def isUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isValid (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def offset (self)-> float :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, desc : str)-> bool :
      '''                             '''
    ...
    def setEnabled (self, val : bool)-> bool :
      '''                             '''
    ...
    def setName (self, name : str)-> bool :
      '''                             '''
    ...
    def setOffset (self, val : float)-> bool :
      '''                             '''
    ...
    def setReadOnly (self, val : bool)-> bool :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.TinSurfaceDefinitionType :
      '''                             '''
    ...

class CvDbTinSurfaceDefinitionSwapEdge(CvDbTinSurfaceDefinition):
    def __init__ (self, *args, **kwargs)-> None :
      '''__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1, (Point2d)arg2) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64,class AcGePoint2d)'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbTinSurfaceDefinitionSwapEdge :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isEnabled (self)-> bool :
      '''                             '''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isReadOnly (self)-> bool :
      '''                             '''
    ...
    def isSubDefinition (self)-> bool :
      '''                             '''
    ...
    def isUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isValid (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def position (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, desc : str)-> bool :
      '''                             '''
    ...
    def setEnabled (self, val : bool)-> bool :
      '''                             '''
    ...
    def setName (self, name : str)-> bool :
      '''                             '''
    ...
    def setPosition (self, pt : PyGe.Point2d)-> bool :
      '''                             '''
    ...
    def setReadOnly (self, val : bool)-> bool :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.TinSurfaceDefinitionType :
      '''                             '''
    ...

class CvDbTinSurfaceDefinitionTransform(CvDbTinSurfaceDefinition):
    def __init__ (self, *args, **kwargs)-> None :
      '''__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1, (Matrix3d)arg2) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64,class AcGeMatrix3d)'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbTinSurfaceDefinitionTransform :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isEnabled (self)-> bool :
      '''                             '''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isReadOnly (self)-> bool :
      '''                             '''
    ...
    def isSubDefinition (self)-> bool :
      '''                             '''
    ...
    def isUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isValid (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, desc : str)-> bool :
      '''                             '''
    ...
    def setEnabled (self, val : bool)-> bool :
      '''                             '''
    ...
    def setName (self, name : str)-> bool :
      '''                             '''
    ...
    def setReadOnly (self, val : bool)-> bool :
      '''                             '''
    ...
    def setTransformationMatrix (self, xform : PyGe.Matrix3d)-> bool :
      '''                             '''
    ...
    def transformationMatrix (self)-> PyGe.Matrix3d :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.TinSurfaceDefinitionType :
      '''                             '''
    ...

class CvDbTinSurfaceDefinitionTrianglesVisibility(CvDbTinSurfaceDefinition):
    def __init__ (self, *args, **kwargs)-> None :
      '''__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1, (list)arg2, (bool)arg3) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64,class boost::python::list,bool)'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbTinSurfaceDefinitionTrianglesVisibility :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isEnabled (self)-> bool :
      '''                             '''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isReadOnly (self)-> bool :
      '''                             '''
    ...
    def isSubDefinition (self)-> bool :
      '''                             '''
    ...
    def isUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isValid (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def positions (self)-> list :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, desc : str)-> bool :
      '''                             '''
    ...
    def setEnabled (self, val : bool)-> bool :
      '''                             '''
    ...
    def setName (self, name : str)-> bool :
      '''                             '''
    ...
    def setPositions (self, val : list[PyGe.Point2d])-> bool :
      '''                             '''
    ...
    def setReadOnly (self, val : bool)-> bool :
      '''                             '''
    ...
    def setVisible (self, val : bool)-> bool :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.TinSurfaceDefinitionType :
      '''                             '''
    ...
    def visible (self)-> bool :
      '''                             '''
    ...

class CvDbTinSurfaceWall(CvDbTinSurfaceConstraint):
    def __init__ (self, type: PyBrxCv.TinWallType)-> None :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def constraintType (self)-> PyBrxCv.TinConstraintType :
      '''                             '''
    ...
    def data (self)-> list :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def isDbResident (self)-> bool :
      '''                             '''
    ...
    def midOrdinateDistance (self)-> float :
      '''                             '''
    ...
    def setData (self, intId : int, pts : list[PyGe.Point3d])-> None :
      '''                             '''
    ...
    def setDataId (self, id : PyDb.ObjectId, midOrdinateDist : float)-> None :
      '''                             '''
    ...
    def setHeight (self, val : float)-> None :
      '''                             '''
    ...
    def setIsDbResident (self, val : bool)-> None :
      '''                             '''
    ...
    def setMidOrdinateDistance (self, val : float)-> None :
      '''                             '''
    ...
    def setWallSide (self, val : PyBrxCv.TinWallSide)-> None :
      '''                             '''
    ...
    def wallSide (self)-> PyBrxCv.TinWallSide :
      '''                             '''
    ...
    def wallType (self)-> PyBrxCv.TinWallType :
      '''                             '''
    ...

class CvDbVAlignment(CvDbCurve):
    def __init__ (self, id: ObjectId, mode: PyDb.OpenMode=PyDb.OpenMode.kForRead, erased: bool=False)-> None :
      '''                             '''
    ...
    def addArcAuto (self, prevId: int, nextId: int)-> int :
      '''                             '''
    ...
    def addArcBetween (self, prevId: int, nextId: int, radius: float)-> int :
      '''                             '''
    ...
    def addContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def addParabolaAuto (self, prevId: int, nextId: int)-> int :
      '''                             '''
    ...
    def addParabolaBetween (self, prevId: int, nextId: int, radius: float)-> int :
      '''                             '''
    ...
    def addPersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Adds the database-resident object specified by objId to the reactor list of the AcDbObject object.'''
    ...
    def addReactor (self, reactor: PyDb.EntityReactor)-> None :
      '''                             '''
    ...
    def addSubentPaths (self, paths: list[PyDb.FullSubentPath])-> None :
      '''Adds one or more subentities to an entity.The prototype of this method is provided for completeness of the subentity manipulation APIs. AutoCAD will never call this method on a custom object.Returns Acad::eOk if successful. The default implementation returns Acad::eNotAvailable.'''
    ...
    def addTangentFixed (self, startPoint: PyGe.Point2d, endPoint: PyGe.Point2d)-> int :
      '''                             '''
    ...
    def assertNotifyEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should be used inside of member functions that are only called when the object is open kForNotify. When used, it should be the first function called inside the member function.'''
    ...
    def assertReadEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that access the object's data in a read-only fashion (for example, dxfOutFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is open AcDb::kForRead.If this function is called while the object is not open, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def assertWriteEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that modify the object's data (for example, dxfInFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is indeed open for write (if it is not, then AutoCAD terminates); to trigger an immediate sending of "openedForModify" notification; to set up the notification mechanism so that "modified" and "modifiedGraphics" (if the object is derived from AcDbEntity) are sent at the appropriate times; and to ensure that graphics get updated if the object is derived from AcDbEntity.If this function is called on a database resident object, "openedForModify" will be sent if the object is not newly created, and "modified", and "modifiedGraphics" (if appropriate) notifications will be sent when the object is next closed.If recordModified is false, then the autoUndo argument is ignored, and the undo filer is not initialized, no undo recording will take place, but notifications will be sent.If autoUndo and recordModified are both true, then automatic undo recording will be performed and notifications will be sent.If autoUndo is false and recordModified is true, then there will not be any automatic undo recording, but the undo filer is initialized and the object must manually write out partial Undo records and must implement its applyPartialUndo() method. Notifications will be sent.If this function is called while the object is not open AcDb::kForWrite, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def baseHAlignment (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def baseSurface (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def blockId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the entity's owner, which must be an AcDbBlockTableRecord.If the entity does not have an owner yet, then AcDbObjectId::kNull will be returned.'''
    ...
    def bounds (self, ext: PyDb.Extents)-> bool :
      '''                             '''
    ...
    def cancel (self)-> None :
      '''Terminates the current open operation. All changes made to the object since it was opened are undone, the object is marked as closed, and "cancel" notification is sent.Returns Acad::eOk if successful.'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbVAlignment :
      '''                             '''
    ...
    def castShadows (self)-> bool :
      '''Returns a boolean value that indicates whether the entity can cast shadows. '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...

    @staticmethod
    def cloneFrom (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbVAlignment :
      '''                             '''
    ...
    def close (self)-> None :
      '''Closes the object. All changes made to the object since it was opened are committed to the database, the object is marked as pageable, and a "closed" notification (as well as any other appropriate notification such as "modified", "erased", and so on) is sent.Returns Acad::eOk if successful.If the object is not in an AcDbDatabase yet, then Acad::eNoDatabase is returned.If the object is sending notification, then Acad::eCloseWasNotifying is returned.If the subClose() call made within the close() method returns anything other than Acad::eOk, then that ErrorStatus is returned.'''
    ...
    def collisionType (self)-> PyDb.CollisionType :
      '''This function returns the collision detection treatment for this entity. Subclasses may override this method to customize how the class interacts in collision-aware features.'''
    ...
    def color (self)-> PyDb.Color :
      '''This function returns the full true color information for the entity within an instance of AcCmColor.The index value will be in the range 0 to 256. 0 and 256 are special values.0 indicates the entity uses the color of the BlockReference that's displaying it. If the entity is not displayed through a BlockReference (for example, it's directly owned by the model space BlockTableRecord) and its color is 0, then it will display as though its color were 7.256 indicates the entity uses the color specified in the LayerTableRecord it references.'''
    ...
    def colorIndex (self)-> int :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...
    def createExtensionDictionary (self)-> None :
      '''Creates an AcDbDictionary object and sets it up as the extension dictionary for the AcDbObject.Returns Acad::eOk if successful. If an extension dictionary already exists, Acad::eAlreadyInDb is returned.'''
    ...

    @staticmethod
    def createFromAcGeCurve (curve: PyGe.Curve3d,normal: PyGe.Vector3d = PyGe.Vector3d.kZAxis,tol: PyGe.Tol = 'default')-> PyDb.Curve :
      '''This is createFromAcGeCurve, a member of class AcDbCurve.'''
    ...
    def curveAtPVI (self, pvi: PyBrxCv.CvDbVAlignmentPVI)-> int :
      '''                             '''
    ...
    def curveElementColor (self)-> int :
      '''                             '''
    ...
    def database (self)-> PyDb.Database :
      '''Returns a pointer to the AcDbDatabase object that contains the AcDbObject.'''
    ...
    def deepClone (self, owner: PyDb.DbObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function gives control of deep clone operations to the object. In the default implementation, the object is cloned and appended to the owner object (pOwnerObject). The cloning is performed by an AcDbDeepCloneFiler. A record is also added to the idMap. Then, using the filer, any owned objects are deep cloned, with isPrimary set to Adesk::kFalse.'''
    ...
    def deleteElement (self, id: int)-> bool :
      '''                             '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def disableUndoRecording (self, disable: bool)-> None :
      '''Turns off or on the Undo recording for the object. If disable == Adesk::kTrue, then Undo recording is turned off until this function is called with disable == Adesk::kFalse, at which time Undo recording is turned back on.'''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def downgradeOpen (self)-> None :
      '''Downgrades the object from being open AcDb::kForWrite, to being AcDb::kForRead. In the process, all changes made to the object while it was open for write are committed to the database and appropriate notification is sent.'''
    ...
    def downgradeToNotify (self, wasWritable: bool)-> None :
      '''Restores an object from being open both AcDb::kForNotify and AcDb::kForWrite, to being open just AcDb::kForNotify. The wasWritable value that was returned from the matching AcDbObject::upgradeFromNotify() call should be passed into this function to restore the proper open status.This function must have been preceded by a call to upgradeFromNotify().Returns Acad::eOk if successful.'''
    ...
    def draw (self)-> None :
      '''This function queues up the entity's graphics and flushes the graphics queue, forcing the entity and anything else in the queue to be drawn or re-drawn on-screen.Returns Acad::eOk if successful.If the entity is not in a database, then Acad::eNotInDatabase will be returned.If the entity is in a database other than the one currently loaded into the AutoCAD editor, then Acad::eNotCurrentDatabase will be returned.'''
    ...
    def drawableType (self)-> PyGi.GiDrawableType :
      '''                             '''
    ...
    def elementAtId (self, id: int)-> PyBrxCv.CvDbVAlignmentElement :
      '''                             '''
    ...
    def elementCount (self)-> int :
      '''                             '''
    ...
    def elevationMax (self)-> float :
      '''                             '''
    ...
    def elevationMin (self)-> float :
      '''                             '''
    ...
    def entityColor (self)-> PyDb.EntityColor :
      '''This function returns the color settings of the entity in an AcCmEntityColor form. Most clients should use the color() function, which returns the heavyweight AcCmColor object. However, if color name information is not required, this function provides faster access to the lightweight AcCmEntityColor data.'''
    ...
    def erase (self, erasing : bool=True)-> None :
      '''Sets the erase bit of the object. If erasing == Adesk::kTrue, then the erase bit is set on. If erasing == Adesk::kFalse, then the erase bit is set off.'''
    ...
    def explode (self)-> list :
      '''Function UsageThis function is primarily intended for AutoCAD to call as part of an explode operation that includes this entity. However, this function can be used by ObjectARX applications to obtain an array of pointers to non-database-resident entity objects that are what the entity considers to be its exploded parts.When calling this function, the entitySet array does not need to be empty. This function will append to it, and pointers to entities that it creates to be used in its place as the "exploded" result.If this function is successful, it will return Acad::eOk. Other return values may vary depending on how it has been implemented.Function Implementation in Derived ClassesThis function should dynamically create (using the new operator) whatever entity objects are appropriate to be used to replace the entity after an explode operation has taken place. Pointers to these entities are then appended to the entitySet array. Once the pointers have been appended, the function should return with a status of Acad::eOk.'''
    ...

    @overload
    def extend (self, newParam: float)-> None : ...
    @overload
    def extend (self, extendStart: bool, toPoint: PyGe.Point3d)-> None : ...
    def extend (self, *args, **kwargs)-> None :
      '''Overloads:
    - newParam: float
    - extendStart: bool, toPoint: PyGe.Point3d
    
	-This function extends the beginning or end of the curve to the new point determined by the newParam value.If newParam is less than the curve's start parameter, then the curve is reset to start at newParam. If newParam is greater than the curve's end parameter, then the curve is reset to end at newParam.Returns Acad::eOk if successful. If newParam's first period value is between the curve's start and end, then Acad::eInvalidInput will be returned.The function implementation in derived classes must be able to interpret the newParam value, decide if it is beyond the existing curve end or before the curve beginning, and then extend the curve in the appropriate direction to the newParam value.Return ErrorStatus values are up to the implementer, but to be consistent with built-in classes, the following return values are recommended:Acad::eOkFunction completed successfully.Acad::eInvalidInputThe parameter was not acceptable for some reason (for example, if its first period lies within the existing curve so that it would be a trim rather than an extension).The default implementation returns Acad::eNotImplemented.-'''
    ...
    def extensionDictionary (self)-> PyDb.ObjectId :
      '''Returns the objectId of the extension dictionary owned by the object. If the object does not own an extension dictionary, then the returned objectId is set to AcDbObjectId::kNull.'''
    ...
    def firstElementId (self)-> int :
      '''                             '''
    ...
    def firstTangentElementId (self)-> int :
      '''                             '''
    ...
    def getAcGeCurve (self, tol: PyGe.Tol = 'default')-> PyGe.Curve3d :
      '''This is getAcGeCurve, a member of class AcDbCurve.'''
    ...
    def getArea (self)-> float :
      '''This function returns with area set to the area inside the curve. For the AutoCAD built-in classes, the curve must lie on a plane. If the curve is not closed, its start and end points are considered as connected by a line segment that closes it.Returns Acad::eOk if successful. For the AutoCAD built-in classes, Acad::eInvalidInput is returned if the curve is not planar. Other return values are possible for custom entity classes depending on how they were implemented.This function must be able to calculate a bounded area value for the curve.While the AutoCAD built-in classes require the curve to be planar, no such restriction need be made for custom entity classes unless desired by the implementer.ErrorStatus return values are up to the implementer, but the following are recommended to be consistent with existing classes:Acad::eOkFunction completed successfully.Acad::eInvalidInputThe area was not calculable (for example, the curve was not planar).The default implementation's return value is Acad::eNotImplemented.'''
    ...
    def getClosestPointTo (self, point3d: PyGe.Point3d, direction: PyGe.Vector3d=None, extend: bool=False)-> PyGe.Point3d :
      '''This function projects the curve onto the plane defined by givenPnt and normal, finds the point on the projected curve that is nearest to givenPnt, then projects this nearest point back onto the original curve and sets pointOnCurve to the result.If extend == Adesk::kTrue, then the curve is extended along its path to find the closest point.Returns Acad::eOk if successful. Return values for errors are dependent on the implementation.In derived classes; this function needs to be able to project the curve onto a plane determined by a point (givenPnt) and a normal vector (normal), extend the curve's projection if necessary (if extend==Adesk::kTrue), find the point on the projected curve that is nearest to givenPnt, then project the point found back onto the original curve (or its path if it was extended) and set pointOnCurve to the end result.Use of AcGe classes may be helpful in doing some of the projection and nearest point calculation work.If the operation is successful, this function returns Acad::eOk. Return values for errors are dependent upon the error and the implementer. See header file acdh.h for a list of possible ErrorStatus values.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getCompoundObjectTransform (self)-> PyGe.Matrix3d :
      '''This function is intended to be overridden by derived classes that are compound objects (in other words, objects that behave like blocks in the display list).A compound object has little or no geometry of its own; instead it relies on nested entities, perhaps the contents of a BlockTableRecord, to represent itself. A compound object must use the same transformation matrix for all of its contained entities. Otherwise selection and osnap will not function correctly. This is the method that the system uses to obtain that matrix from the compound object.This method should only be overridden if you return the kDrawableIsCompoundObject flag from setAttributes. The matrix you should return here is the one that you pass to pushModelTransform before you render your nested objects. You must override this method if you return the compound object flag in setAttributes, even if you don't push a transform for your nested objects. In that case you would return Acad::eOk and the identity transform in xMat.Default implementation: Returns Acad::eNotApplicable and the identity matrix in xMat.'''
    ...
    def getDistAtParam (self, param: float)-> float :
      '''Calculates the length of the curve's segment from the curve's start point to the point specified by param.Returns Acad::eOk if successful, or Acad::eInvalidInput if param is out of range. For other errors, the implementer must decide what return value to use. See the acdb.h header file for possible ErrorStatus values.In the default implementation, the function returns Acad::eNotImplemented.'''
    ...
    def getDistAtPoint (self, point3d: PyGe.Point3d)-> float :
      '''Calculates the length of the curve's segment between the curve's start point and point and returns the length in distance.Returns Acad::eOk if successful, or Acad::eInvalidInput if the point is not on the curve. For other errors, the implementer must decide what return value to use. See the acdb.h header file for possible ErrorStatus values.Returns Acad::eNotImplemented in the default implementation.'''
    ...
    def getEcs (self)-> PyGe.Matrix3d :
      '''This function is intended to be overridden by derived classes that need to be able to provide access to an object coordinate system for objects of the class. The intent is that this function provide a transformation matrix that can be used to transform vectors or points from the object's object coordinate system (OCS) to the World Coordinate System (WCS).Default implementation: Return the identity matrix (ones along the diagonal, zeros elsewhere) in retVal.We recommend that all data stored in custom classes be stored in WCS coordinates. If this is done, then the object's OCS will be the WCS and the transformation matrix will be the identity matrix. Then this function will not need to be overridden since the identity matrix is this function's default return.'''
    ...
    def getElementId (self, gsMarker: int)-> int :
      '''                             '''
    ...
    def getElevationAt (self, station: float)-> tuple[Any,...] :
      '''                             '''
    ...
    def getElevations (self)-> list :
      '''                             '''
    ...
    def getEndParam (self)-> float :
      '''The implementation of this function in derived classes should return with endParam set to the parameter of the endpoint of the curve.Returns Acad::eOk if successful.By default, the function returns Acad::eNotImplemented.'''
    ...
    def getEndPoint (self)-> PyGe.Point3d :
      '''In this class and in derived classes, this function returns with endPoint set to the end point (in WCS coordinates) of the curve.Returns Acad::eOk if successful.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getField (self, prop: str='TEXT')-> PyDb.ObjectId :
      '''Gets the field ID. A field can be stored in an object using the property name as the key.Returns Acad::eOk if the object has a field for the specified property. Otherwise, returns an AutoCAD error status.'''
    ...
    def getFieldDictionary (self)-> PyDb.ObjectId :
      '''Returns the field dictionary ID. The field dictionary stores all the fields set in the object as property name-field object pairs. The ID will be null if there is no field in the object.'''
    ...
    def getFirstDeriv (self, param: float|PyGe.Point3d)-> PyGe.Vector3d :
      '''Here and in derived classes, this function is implemented to evaluate the first derivative at the location on the curve specified by param, and sets firstDeriv to the result (in WCS coordinates).Returns Acad::eOk if successful. If param is not valid for the curve, then Acad::eInvalidInput is returned. Other ErrorStatus return values are up to the implementer.For implementation, the AcGe classes may provide some of the necessary functionality to make the job easier.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getGeomExtents (self)-> PyDb.Extents :
      '''Unimplemented at the AcDbEntity level, this method is intended to be overridden in derived classes.Derived classes should calculate and return the corner points (in WCS coordinates) of a box (with edges parallel to the WCS X, Y, and Z axes) that encloses the 3D extents of the entity, and return those points as an instance of class AcDbExtents in the "extents" parameter.Default implementation: Immediately returns Acad::eInvalidExtents.'''
    ...
    def getGeomExtents2d (self)-> PyDb.Extents2d :
      '''                             '''
    ...

    @overload
    def getGripPoints (self, /)-> tuple[Any,...] : ...
    @overload
    def getGripPoints (self, curViewUnitSize: float, gripSize: int, curViewDir: PyGe.Vector3d, bitflags: int)-> tuple[Any,...] : ...
    def getGripPoints (self, *args, **kwargs)-> tuple[Any,...] :
      '''Overloads:
    - None: Any
    - curViewUnitSize: float, gripSize: int, curViewDir: PyGe.Vector3d, bitflags: int
    
	-Function usageThis function supports "old style" grips, in applications that existed before the enhancement of grip functionality by the addition of the AcDbGripData class.This function is not intended to be called by ObjectARX applications. However, it is possible to do so (for example, as a pass-through from the getStretchPoints() method).Function implementation in derived classesThis function should append to the gripPoints array any points that are to treated as grip points for the entity.The gripPoints array is passed to all entities involved in the grip operation, so the array may already contain grip points for other entities. Therefore, it is very important to append the new points rather than assigning them to any existing elements in the array.When finished appending all desired grip points, return Acad::eOk. If anything other than Acad::eOk is returned, then grips are not activated for this entity.The osnapModes and geomIds arguments are not currently used.Default implementationImmediately returns Adesk::eNotImplemented.-'''
    ...
    def getHandle (self)-> PyDb.Handle :
      '''Fills in handle with the handle value for the object. If the object is not yet database-resident, then it will not have a handle. Use AcDbHandle::isNull to test for this condition.'''
    ...
    def getOffsetCurves (self, dist: float)-> list :
      '''This function creates one or more entities that together make up the result of offsetting the curve by the distance offsetDist. For many curves, the result is a single new curve. (This single new curve may not be of the same class as the original curve. For example, offsetting an AcDbEllipse results in an AcDbSpline, since the result of offsetting an ellipse does NOT fit the equation of an ellipse.)In some cases, it might be necessary for the offset result to be several curves. (The result may even be several curves that would form a single curve if they were joined end-to-end.) To allow for this possibility, a dynamic array of void pointers is used to hold pointers to the resulting entity or entities.To use this array of pointers, the calling application needs to cast the pointer(s) to the appropriate object type(s). If only a specific entity type or set of types are to be handled, then use the cast method of the class(es) desired to see if each pointer can be safely cast to that object type. If the actual object type (class name) is desired, then each object's isA() method may be used to get a pointer to the object's AcRxClass object, which has a name() method.If the offsetDist value is negative, it is usually interpreted as being an offset to make a smaller curve (that is, for an arc it would offset to a radius that is offsetDist less than the starting curve's radius). If the negative value has no meaning in terms of making the curve smaller, a negative offsetDist may be interpreted as an offset in the direction of smaller X,Y,Z WCS coordinates. This is not enforced, so custom entities can interpret the sign of the offsetDist value however they want.The entities returned in the offsetCurves array are dynamically allocated, but have not been added to an AcDbDatabase yet. So, the application that calls this function is responsible for their memory. If they are subsequently appended to a database, then the database takes over responsibility for their memory. Otherwise, the application is responsible for deleting them when they are no longer needed.Returns Acad::eOk if offsetting is successfully completed. If the offset distance is invalid (for example, if you are offsetting an arc such that the offset result would be a negative radius), then Acad::eInvalidInput is returned. For the AutoCAD built-in classes that use ShapeManager (AcDbBody, AcDbRegion, and AcDb3dSolid), Acad::eGeneralModelingFailure will be returned if an error occurs in the ShapeManager modeler. Other ErrorStatus return values are implementation-dependent.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getOffsetCurvesGivenPlaneNormal (self, normal: PyGe.Vector3d, dist: float)-> list :
      '''This function creates one or more entities that, together, make up the result of offsetting the curve by the distance offsetDist in the plane with normal vector normal. For many curves, the result will be a single new curve, which may not be of the same class as the original curve. For example, offsetting an AcDbEllipse results in an AcDbSpline, since the result of offsetting an ellipse does not fit the equation of an ellipse. However, in some cases it might be necessary for the offset result to be several curves. To allow for this possibility, a dynamic array of void pointers is used to hold pointers to the resulting entity or entities.To use this array of pointers, the calling application must cast the pointer(s) to the appropriate object type(s). If only a specific entity type or set of types are to be handled, then using the cast method of the class(es) desired to see if each pointer can be safely cast to that object type will work. If the actual object type is desired, then each object's isA() method may be used to get a pointer to the object's AcRxClass object, which has a name() method to get the classname of the object.If the offsetDist value is negative this is usually interpreted as being an offset to make a smaller curve (that is, for an arc it would offset to a radius that is offsetDist less than the starting curve's radius). Or, if smaller has no meaning, then a negative offsetDist may be interpreted as an offset in the direction of smaller X,Y,Z WCS coordinates. However, this is not enforced, so custom entities can interpret the sign of the offsetDist value however they wish.The entities returned in the offsetCurves arrays are dynamically allocated, but have not been added to an AcDbDatabase yet. So, the application that calls this function is responsible for their memory. If they are subsequently appended to a database, then the database takes over responsibility for their memory. Otherwise, the application is responsible for deleting them when they are no longer needed.Returns Acad::eOk if offsetting is successfully completed. If the offset distance is invalid, or if normal is a zero length vector or the entity is linear and normal is not perpendicular with the entity, then Acad::eInvalidInput is returned. Other ErrorStatus return values are implementation dependent.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getOrthoProjectedCurve (self, plane: PyGe.Plane)-> PyDb.Curve :
      '''This function creates a new curve entity that is the result of projecting the curve along the projPlane's normal onto the projPlane and sets projCurve to point to the newly created curve. projCurve is declared as type AcDbCurve to allow the returned curve to be any class derived from AcDbCurve (for example, when an AcDbArc is projected onto a plane, the result is an AcDbEllipse).The returned curve is dynamically allocated, but has not been added to an AcDbDatabase yet. So, the application that calls this function is responsible for its memory. If the curve is subsequently appended to a database, then the database takes over responsibility for its memory. Otherwise, the application is responsible for deleting it when it is no longer needed.Returns Acad::eOk if successful. Other ErrorStatus values are implementation-dependent.Returns Acad::eNotImplemented in the default implementation.'''
    ...
    def getPVIsArrays (self)-> list :
      '''                             '''
    ...
    def getParamAtDist (self, dist: float)-> float :
      '''This function determines the parameter of the curve at the location that is a distance of dist along the curve from the curve start, and returns the parameter in param.Returns Acad::eOk if successful. If dist is not valid for the curve, then Acad::eInvalidInput is returned. Other ErrorStatus return values are implementation-dependent.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getParamAtPoint (self, point3d: PyGe.Point3d)-> float :
      '''This function determines the parameter of the curve at point and returns the parameter in param.Returns Acad::eOk if successful. If point is not on the curve, then Acad::eInvalidInput is returned. Other ErrorStatus return values are implementation-dependent.Acad::eNotImplemented is returned by the default implementation.'''
    ...
    def getPlane (self)-> PyGe.Plane :
      '''If the entity is planar, then the plane containing the entity is returned in plane and flag is set to AcDb::kPlanar.If the entity is nonplanar, but is linear, then plane is set to an arbitrary plane that contains the entity and flag is set to AcDb::kLinear.If the entity is nonplanar and nonlinear, then plane is left unset and flag is set to AcDb::kNonPlanar.Returns Acad::eOk if successful. Other ErrorStatus return values are implementation-dependent.The default implementation is to return Acad::eNotApplicable.'''
    ...
    def getPlotStyleNameId (self)-> PyDb.ObjectId :
      '''Returns with id set to the object ID of the AcDbPlaceHolder object referenced by the entity. The AcDbPlaceHolder object resides in the plot style name dictionary, and its key in the dictionary is the plot style name.Use the AcDbDictionary::nameAt() function on the plot style name dictionary to get the plot style name string that corresponds to the ID obtained by this function.'''
    ...
    def getPointAtDist (self, dist: float)-> PyGe.Point3d :
      '''This function determines the point on the curve that is a distance of dist along the curve from the curve start, and returns the point in point. point is in WCS coordinates.Returns Acad::eOk if successful. If dist is not valid for the curve, then Acad::eInvalidInput is returned. Other ErrorStatus return values are implementation-dependent.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getPointAtParam (self, param: float)-> PyGe.Point3d :
      '''This function determines the point on the curve that corresponds to the param parameter, and returns the point in point. point is in WCS coordinates.Returns Acad::eOk if successful. If the parameter is not within the curve's range, then Acad::eInvalidInput is returned. Other ErrorStatus return values are implementation-dependent.Returns Acad::eNotImplemented in the default implementation.'''
    ...
    def getProjectedCurve (self, plane: PyGe.Plane, projDir: PyGe.Vector3d)-> PyDb.Curve :
      '''This function creates a new curve entity that is the result of projecting the curve parallel to projDir onto the projPlane and sets projCurve to point to the newly created curve. projCurve is declared as type AcDbCurve in order to allow the returned curve to be any class derived from AcDbCurve. For example, when an AcDbArc is projected onto a plane, the result is an AcDbEllipse.The returned curve is dynamically allocated, but has not been added to an AcDbDatabase yet. The application that calls this function is therefore responsible for its memory. If the curve is subsequently appended to a database, then the database takes over responsibility for its memory. Otherwise, the application is responsible for deleting it when it is no longer needed.Returns Acad::eOk if successful. If projDir is perpendicular to the projPlane's normal then Acad::eInvalidInput is returned. For the AutoCAD built-in classes that use ShapeManager (AcDbEllipse, AcDbSpline, AcDbBody, AcDbRegion, and AcDb3dSolid), Acad::eGeneralModelingFailure is returned if an error occurs in the ShapeManager modeler. Other ErrorStatus values are implementation-dependent.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getRadius (self, param: float)-> float :
      '''                             '''
    ...
    def getSecondDeriv (self, param: float|PyGe.Point3d)-> PyGe.Vector3d :
      '''Evaluates the second derivative at the location on the curve specified by param and sets secDeriv to the result (in WCS coordinates).Returns Acad::eOk if successful. If param is not valid for the curve, then Acad::eInvalidInput is returned. Other ErrorStatus return values are up to the implementer.For implementation, the AcGe classes provide some of the necessary functionality to make the job easier.Returns Acad::eNotImplemented in the default implementation.'''
    ...
    def getSpline (self)-> PyDb.Spline :
      '''This function creates a new AcDbSpline entity, sets it to be as close an approximation as possible to the curve, and then returns with spline pointing to the newly created spline entity.The returned spline is dynamically allocated, but has not been added to an AcDbDatabase yet. So, the application that calls this function is responsible for its memory. If the spline is subsequently appended to a database, then the database takes over responsibility for its memory. Otherwise, the application is responsible for deleting it when it is no longer needed.Returns Acad::eOk if successful. If there is an error in the ShapeManager modeler (which AcDbSpline uses), then Acad::eGeneralModelingFailure will be returned. Other ErrorStatus values are implementation-dependent.Returns Acad::eNotImplemented in the default implementation.'''
    ...
    def getSplitCurves (self, paramsOrPoints: list)-> list :
      '''This function creates one or more entities that are all subcurves of the original. The points array must contain the points on the curve that are used as the start or end points of the newly created subcurves. The first subcurve starts at the original curve's start point and ends at the first point in the points array. The second subcurve starts at the first point in the points array and ends at the second point in the points array. The third subcurve starts at the second point and ends at the third, and so on. The last subcurve starts at the last point in the points array and ends at the original curve's endpoint.If successive points are coincident (including the original curve's start to the first array point and the last array point to the original curve's end), then no subcurve is created for that pair.Pointers to all new curves are appended to the curveSegments array.The entities that are returned in the curveSegments array are dynamically allocated, but are not yet added to an AcDbDatabase. So, the application that calls this function is responsible for their memory. If they are subsequently appended to a database, then the database takes over responsibility for their memory. Otherwise, the application is responsible for deleting them when they are no longer needed.Depending on how this function is implemented, it is possible that the function might return an ErrorStatus other than Acad::eOk and still have appended some pointers to subcurves to the curveSegments array (AcDbArc does this). Typically, this would be the result of an invalid point somewhere in the middle of the points array. So, it is very important to check the size of the curveSegments array upon return to be sure that any subcurves that are created are properly dealt with.To use the pointer(s) in the curveSegments array, the calling application will need to cast the pointer(s) to the appropriate object type(s). For this function, the objects pointed to by the pointers in the curveSegments array are usually going to be of the same class as the original curve. However, this is not a requirement. To be safe, the pointers should be cast using the appropriate class's cast method.Returns Acad::eOk if successful.If points is empty or any of the points in points are not on the curve, then Acad::eInvalidInput is returned. As mentioned above, it is possible for this ErrorStatus to be returned and still have some subcurve pointers appended to the curveSegments array.For the AutoCAD built-in classes that use ShapeManager (AcDbEllipse, AcDbSpline, AcDbBody, AcDbRegion, and AcDb3dSolid), Acad::eGeneralModelingFailure is returned if an error occurs in the ShapeManager modeler.Other ErrorStatus return values are implementation-dependent.The default implementation returns Acad::eNotImplemented.'''
    ...
    def getSplitCurvesAtParam (self, param: float)-> list :
      '''                             '''
    ...
    def getSplitCurvesAtParams (self, params: list)-> list :
      '''                             '''
    ...
    def getSplitCurvesAtPoint (self, point: PyGe.Point3d)-> list :
      '''                             '''
    ...
    def getSplitCurvesAtPoints (self, points: list)-> list :
      '''                             '''
    ...
    def getStartParam (self)-> float :
      '''This function returns with startParam set to the start parameter on the curve.Returns Acad::eOk if successful.Returns Acad::eNotImplemented in the default implementation.'''
    ...
    def getStartPoint (self)-> PyGe.Point3d :
      '''This function returns with startPoint set to the start point (in WCS coordinates) of the curve.Returns Acad::eOk if successful, and Acad::eNotImplemented in the default implementation.'''
    ...
    def getStretchPoints (self)-> list :
      '''Function usageThis function is not intended to be called by ObjectARX applications. However, it is possible to do so (for example, as a pass-through from the getGripPoints() method).Function implementation in derived classesThis function should append to the stretchPoints array any points that are to treated as stretch points for the entity.Stretch points are used by the stretch command within AutoCAD. Any stretch points that are within the crossing selection window during the stretch command, will be moved by whatever amount the user decides to "stretch" the selected entities. Any stretch points not in the crossing selection window will be left alone. This combination of some stretch points moving while others do not is what "stretches" the entity. If all stretch points are in the crossing window, then the entity is moved instead of stretched.The stretchPoints array is passed to all entities involved in the stretch operation, so the array may already contain stretch points for other entities. Therefore it is very important to append the new points rather than assigning them to any existing elements in the array.When finished appending all desired stretch points, return Acad::eOk. If anything other than Acad::eOk is returned, then this entity's stretch points will be ignored by the stretch operation.Default implementationCalls the AcDbEntity::getGripPoints() method. So, unless the entity needs to have stretch points that are different from the grip points, there is no need to override this method.'''
    ...
    def getSubentPathsAtGsMarker (self, type: PyDb.SubentType, gsMark: int, pickPoint: PyGe.Point3d, viewXform: PyGe.Matrix3d)-> list[PyDb.FullSubentPath] :
      '''Entities use various graphic primitives defined in AcGi to draw themselves. Part of this mechanism is the ability to associate an integer identifier called a graphics system marker (or, GS marker) with each primitive or with groups of primitives. Through the use of certain selection mechanisms, the GS marker for the actual subentity selected on screen can be obtained and, along with some other information passed into this function, can be used to create one or more AcDbFullSubentPath objects, each one representing a subentity and providing a more complete description of the subentity and its environment. These AcDbFullSubentPath objects can be used by several other functions for various purposes such as highlighting or unhighlighting the subentities on screen.Function usageIf the entity (of which the subentity is a part) is directly owned by the model or paper space BlockTableRecords, then leave out numInserts and entAndInsertStack so that their default value will be used.Typically the GS marker is obtained via the use of ads_ssget() followed by ads_ssnamex() (see the ObjectARX Developer's Guide for more information on this).The pickPoint can be obtained from ads_ssnamex() as well (it's the first group 5009 in the returned list).The viewXform can be calculated using the ads_trans() function on the vectors (1,0,0), (0,1,0), and (0,0,1) to translate them from DCS to WCS. The translations of these three vectors (with an extra 0 appended on to the end of each) would be used as the first three rows of the matrix. The last row is not used so it can be left as is. This argument is not used by any of the AutoCAD built-in entities.If the entity is nested inside one or more block definitions, then the numInserts and entAndInsertStack arguments must also be filled in with non-zero or non-null values. If they are not filled in, then this function will fail and return an error status. One way to get the necessary object IDs is to use ads_nentselp() to obtain the list of ads_names of the container objects. This list must then be converted to object IDs and reversed.Upon return, the subentPaths argument will point to a dynamically allocated array of one or more AcDbFullSubentPath objects. The numPaths argument will contain the number of AcDbFullSubentPath objects being returned.The calling application is responsible for deallocating the memory used by the subentPaths array. The C++ delete [ ] should be used.Return values for this function may vary depending on how the function has been implemented (see below).Function implementation in derived classesEntity classes which do not set GS markers probably should not implement this function since the GS marker is the primary (and often the only) means of subentity distinction.When implemented, this function must use the material provided in type, gsMark, pickPoint, viewXform, numInserts, and entAndInsertStack to determine which subentity or subentities meet the criteria in these arguments. Next it must create a dynamically allocated array of AcDbFullSubentPaths (using the C++ new operator) with one element for each subentity determined in the first step. Finally it must fill in each AcDbFullSubentPath object in the array with the information appropriate to the subentity it will represent.If numInserts == 0 and entAndInsertStack == NULL, it's important to check to be sure that the entity's owner is indeed the model or paper space BlockTableRecord. This can be done by using the entity's ownerId() method to obtain the objectId of its owner, and then opening up that object and using its name() method to obtain its name string. If the owner is not the model or paper space BlockTableRecord, and numInserts == 0 or entAndInsertStack == NULL, or both, then the input data is invalid and this function should set numPaths to 0, set subentPaths to NULL and then return the error status Acad::eInvalidInput.Each AcDbFullSubentPath object has two parts, an array of objectIds containing all the container objects, and an embedded AcDbSubentId object which in turn has two elements: an index value and a SubentityType.If the "main" entity (the entity on which this function is being called) is not nested within BlockReferences (that is, numInserts == 0 and entAndInsertStack == NULL), then the objectId array should contain only the objectId of the "main" entity. If the "main" entity is nested in one or more BlockReferences, then the AcDbObjectIdArray is the same as entAndInsertStack, so copying the entAndInsertStack elements into the AcDbObjectIdArray is all that's required.The SubentType data item within the embedded AcDbSubentId should be set the same as type.The index data item within the embedded AcDbSubentId can be any value you wish (it is often simply the GS marker), but if implemented, the following functions must be able to interpret them to determine the corresponding GS marker(s) or subentity (or subentities):getGsMarkersAtSubentPath()subentPtr()The pickPoint and viewXform arguments are provided as extra aids (if necessary) in determining which subentity is involved. For example, some entity types might display differently depending on the display viewpoint. The viewXform transformation matrix can be used in such cases.The viewXform argument provides a transformation matrix to transform from WCS (World Coordinate System) to DCS (display coordinate system).The display coordinate system is oriented such that the positive Z axis is coming out of the display screen towards the user, the positive X axis is horizontally from left to right on screen, and the positive Y axis is vertically upwards on screen.So, if the current viewpoint is at (1,0,0) (the viewer is always looking towards (0,0,0)) then the viewXform matrix would be:0 1 0 00 0 1 01 0 0 00 0 0 1In this matrix the last row and the last column are not used. Notice also that the third row is the DCS Z axis in WCS coordinates (which is the WCS version of the AutoCAD VIEWPOINT system variable).When this function returns, the return code to use is completely up to the implementer, but to be consistent with other existing entity class implementations of this function the following should be used:If the function succeeds, it should return Acad::eOk.If an invalid or unsupported SubentType is passed in, then numPaths should be set to 0, subentPaths should be set to NULL, and Acad::eWrongSubentityType should be returned.If an invalid GS marker (or any other data item that turns out to be needed) is passed in, then numPaths should be set to 0, subentPaths should be set to NULL, and Acad::eInvalidInput should be returned.Default implementationImmediately returns Adesk::eNotApplicable.'''
    ...
    def getTransformedCopy (self, matrix3d: PyGe.Matrix3d)-> PyDb.Entity :
      '''Function usageThis function creates a clone of the entity, applies the xform transformation matrix to the clone, and then returns with pEnt pointing to the transformed clone.Returns Acad::eOk if successful.If xform is a non-uniform scaling matrix or non-orthogonal then Acad::eCannotScaleNonUniformly or Acad::eNotImplemented is returned.WarningFor AutoCAD built-in complex entities such as polylines, this function produces a shallow clone of the header entity only, which also owns the original set of "owned" entities (such as vertices for a polyline) which are then transformed by the xform matrix. This results in a corrupt drawing (two header entities owning the same set of "owned" entities) as well as transforming the original set of "owned" entities instead of a copied set.Function implementation in derived classesThe default AcDbEntity implementation of this function should be adequate for most derived entity types. However, derived entity classes that wish to support non-uniform scaling or non-orthogonal transformations will need to override this method with their own implementation.This function must create a copy of the entity (using memory that has been dynamically allocated via the C++ new operator), apply the transformation matrix xform to the copy and then return with pEnt pointing to the transformed copy.Determining what constitutes a valid transformation matrix and whether to do a shallow clone (that is, the entity's clone() method), a deepclone (if the entity owns other objects), or no clone at all (that is, make this function a no-op), is up to the implementer.Return values for this function are also up to the implementer, but to be consistent with other existing classes the following is recommended:If the function succeeds, it should return Acad::eOk.If the function is to be a no-op, it should return Acad::eNotImplementedIf non-uniform scaling is not to be supported and a non-uniform scaling matrix is passed in, then either Acad::eCannotScaleNonUniformly or Acad::eNotImplemented should be returned.Default implementationIf the entity is uniformly scaled and orthogonal, AcDbEntity::getTransformedCopy will call the entity's clone() method to create a clone of the entity, then call AcDbEntity::transformBy() on the clone, and then return with pEnt set to point to the transformed clone. If xform is a non-uniformly scaled or a non-orthogonal matrix, then this function will return Acad::eNotImplemented.'''
    ...
    def getUnorderedElementIds (self)-> list :
      '''                             '''
    ...
    def handOverTo (self, newObject: PyDb.DbObject, keepXData: bool, keepExtDict: bool)-> None :
      '''This function provides the ability to exchange a non-database-resident object (NDBRO) in place of an existing database-resident object (DBRO) while retaining the objectId, handle, and reactor list of the DBRO. An example of this situation is when the BREAK command is used to break a circle into one or two arc segments. AcDbArc is a completely different class from AcDbCircle, so a new AcDbArc object must be substituted in place of the AcDbCircle object that is there now, yet the arc must get the handle and objectId that the circle has.To use the handOverTo() function, the object to be replaced (the AcDbCircle in the example) must be open AcDb::kForWrite. The object's handOverTo() function is called with newObject pointing to a non-database-resident object that replaces it (the AcDbArc in the example).keepXData is set to Adesk::kTrue if the xdata is to be retained or Adesk::kFalse if the xdata is to be thrown out.keepExtDict is set to Adesk::kTrue if the extension dictionary and its contents are to be retained, or set to Adesk::kFalse if the extension dictionary and its contents are to be thrown out.Once returned from this function, the replacement object (the AcDbArc in the example) is open for AcDb::kForWrite and must have its close() member called to commit the change and close out Undo recording. Then it's up to the ObjectARX application to delete the old object (the AcDbCircle in the example) from memory since it's no longer database-resident.Returns Acad::eObjectToBeDeleted if the operation is successful. If newObject is pointing to an object that is already in the database, or the object invoking handOverTo() is not database-resident, then Acad::eIllegalReplacement is returned.'''
    ...
    def hasFields (self)-> bool :
      '''Returns true if the object has one or more PyDb.Field Objects. Otherwise returns false.'''
    ...
    def hasPersistentReactor (self, id: PyDb.ObjectId)-> bool :
      '''This method returns true if objId is the object ID of a reactor attached to this object. Otherwise, it returns false.'''
    ...
    def hasXData (self, appname: str)-> bool :
      '''                             '''
    ...
    def highlight (self, path: PyDb.FullSubentPath = None, highlightAll : bool = False)-> None :
      '''Function usageThis function uses the AcDbFullSubentPathid to determine which subentity in the entity is desired. It then highlights that subentity on screen. If no AcDbFullSubentPath argument is provided, then the entire entity will be highlighted.Typically, the AcDbFullSubentPath object passed in via subId is obtained from the entity's AcDbEntity::getSubentPathsAtGsMarker() method. This guarantees that it is fully and properly filled in.This function uses the entity's getGsMarkersAtSubentPath() method to get the GS markers associated with subId. If that function does not return Acad::eOk, then this function will fail and return whatever ErrorStatus was returned by getGsMarkersAtSubentPath().If this function succeeds, then it returns Acad::eOk.It is not necessary to balance each highlight() function call with a corresponding call to unhighlight(). Calling the unhighlight() function will unhighlight the entity designated by subId regardless of how many times the highlight function has been called on it.WarningIf the entity on which this method is called has its graphics queued for regeneration (that is, changes have been made to the entity but have not yet been reflected on screen), then this method will not cause a highlight to occur. Also, calling this method on an entity that's open for write and whose graphics are queued for regeneration may terminate AutoCAD.To avoid this limitation, before calling highlight(), you should flush the entity's graphics by either calling the entity's draw() method, or calling the AcTransactionManager::flushGraphics() function.Function implementation in derived classesThe AcDbEntity::highlight() implementation does all the work necessary to highlight any subentities that correspond to the subIdFullSubentPath. So, there is no need to override this method unless you wish to do some pre-or post-processing, or you wish to disable the ability to highlight subentities.If this method is overridden and it is supposed to highlight subentities, then the AcDbEntity::highlight() method will need to be invoked at some point within this function in order to do the actual highlighting.Within the AcDbEntity::highlight() method, the getGsMarkersAtSubentPath() method of this entity is called to translate the FullSubentPath into the corresponding GS markers. So, if this function is to succeed, the getGsMarkersAtSubentPath() method needs to be implemented as well.For more information on the subIdAcDbFullSubentPath argument, see the documentation on the getGsMarkersAtSubentPath() or getSubentPathsAtGsMarker() methods.'''
    ...
    def id (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def insertTangentFixed (self, startPoint: PyGe.Point2d, endPoint: PyGe.Point2d, val: int)-> int :
      '''                             '''
    ...

    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, thisGsMarker : int, otherGsMarker : int)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane, thisGsMarker : int, otherGsMarker : int)-> list : ...
    def intersectWith (self, *args, **kwargs)-> list :
      '''Overloads:
    - entity: PyDb.Entity, intType : PyDb.Intersect
    - entity: PyDb.Entity, intType : PyDb.Intersect, thisGsMarker : int, otherGsMarker : int
    - entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane
    - entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane, thisGsMarker : int, otherGsMarker : int
    
	-Function usageIt finds the intersections of the entity pointed to by pEnt and all the edges of the bounding box of this entity.The intType is used to determine how to deal with extending the two entities in order to calculate intersections. The possible AcDb::Intersect values are:AcDb::kOnBothOperandsDo not extend either entity. This results in only calculating intersections where the two entitys' geometry actually intersectAcDb::kExtendThisExtend this entity (if necessary) when calculating intersections, but do not extend the pEnt entity.AcDb::kExtendArgExtend the pEnt entity (if necessary) when calculating intersections, but do not extend this entity.AcDb::kExtendBothExtend both the pEnt entity and this entity (if necessary) when calculating intersectionsAny intersection points found are appended to the points array. All points are in WCS coordinates.The thisGsMarker and otherGsMarker arguments are intended to provide this function with information to allow it to localize the search for intersections to be between specific subentities. However, this function is not required to make use of either of these arguments (most, if not all, of the AutoCAD built-in entity classes do not). When calling this function, either or both of these arguments may be 0 in order to indicate that they should be ignored.If this function is successful it returns Acad::eOk. Return values for error conditions are dependent on the implementation of this function in the classes involved.Function implementation in derived classesThis function should do all it can to find all intersection points between the entity it's being called on and the entity pointed to by pEnt. All intersection points found should be appended to the points array. All such points must be in WCS coordinates.When implementing the intersection calculation portion of this function you should take a good look at the AcGe classes to see if they can provide any useful functionality to help in finding intersections with the geometric primitives that make up the entity this function is being called on and the pEnt entity. For example, the AcGeCurve3d class has an isOn() method that will indicate if a supplied point is on the curve and the AcGeCircArc3d class has several intersectWith() methods to find intersections with other AcGe types.If the pEnt entity is a type not recognized by this function, it is quite reasonable to call the pEnt entity's intersectWith() method passing in a pointer to this entity as the "pEnt", and all the other arguments passed into this function (remembering to convert the intType argument If necessary) to see if that entity can determine any intersection points. This is what the AutoCAD built-in classes do.Also, don't forget to take into account the intType value. The intType tells you which, if any, of the two entities should be extended to find "apparent" intersections. It is not required that apparent intersection be supported, but if it is not, then an appropriate ErrorStatus value should be returned to indicate that the call failed.The thisGsMarker and otherGsMarker arguments are provided to allow this function to determine exactly which subentities are involved in the intersection operation (for example, if this function is being called by AutoCAD as part of an intersection Osnap operation these arguments would indicate which subentities are within the osnap pickbox). For these arguments, a value less than or equal to zero indicates that that argument should not be used.If this function completes successfully (even if no intersection points are found), it should return Acad::eOk. Determining what is considered an error and what ErrorStatus return code to use for any such errors are up to the implementer -- there are no conventions in this regard.Default implementationImmediately returns Acad::eNotImplemented.-'''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isAProxy (self)-> int :
      '''Returns Adesk::kTrue if the object is a proxy object or entity. Otherwise returns Adesk::kFalse.'''
    ...
    def isAcDbObjectIdsInFlux (self)-> int :
      '''This function refers to a condition that occurs during deep clone operations. It returns Adesk::kTrue when the cloned objects' IDs have not yet been translated and thus cannot be used in any operations on the objects. This condition normally occurs only during AcEditorReactor::beginDeepCloneXlation, AcDbObject::deepClone, or AcDbObject::wblockClone. Any operations that involve AcDbObjectId references, such as symbol table records, should be postponed until after endDeepClone. AcDbObject::subClose is never called on any objects whose IDs are in flux.'''
    ...
    def isAnnotative (self)-> PyDb.AnnotativeStates :
      '''                             '''
    ...
    def isCancelling (self)-> int :
      '''Returns Adesk::kTrue if the object is currently in the middle of a cancel() call (that is, an open is being canceled and all changes made are being rolled back). Otherwise returns Adesk::kFalse.'''
    ...
    def isClosed (self)-> int :
      '''This function returns Adesk::kTrue if, and only if, the curve is closed; that is, its start point is identical to its end point. Otherwise, it returns Adesk::kFalse.Returns Acad::kFalse in the default implementation.'''
    ...
    def isEraseStatusToggled (self)-> int :
      '''Returns Adesk::kTrue if the object's erase bit has been toggled since it was opened. Otherwise returns Adesk::kFalse.'''
    ...
    def isErased (self)-> int :
      '''Returns Adesk::kTrue if the object is currently erased. Otherwise returns Adesk::kFalse.'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isModified (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called). Otherwise returns Adesk::kFalse.'''
    ...
    def isModifiedGraphics (self)-> int :
      '''Returns Adesk::kTrue if the object is derived from AcDbEntity and has had either an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called), or its recordGraphicsModified() function called with an Adesk::kTrue argument value.Otherwise it returns Adesk::kFalse.'''
    ...
    def isModifiedXData (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called) and has then had its setXData() method called. Otherwise it returns Adesk::kFalse.'''
    ...
    def isNewObject (self)-> int :
      '''Returns Adesk::kTrue if the object has not yet been closed since it was first created. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifyEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForNotify. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifying (self)-> int :
      '''Returns Adesk::kTrue if the object is in the process of sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isPeriodic (self)-> int :
      '''This function returns Adesk::kTrue if, and only if, the curve has an infinite range in both directions and there is a period value T such that there is a point on curve at (u + T) = point on curve (u), for any parameter u. If the curve is not periodic, then Adesk::kFalse is returned.The default implementation returns Adesk::kFalse.'''
    ...
    def isPersistent (self)-> int :
      '''                             '''
    ...
    def isPlanar (self)-> int :
      '''This function returns Adesk::kTrue if and only if there is a plane that contains the entity. Otherwise Adesk::kFalse is returned.'''
    ...
    def isReadEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForRead. Otherwise returns Adesk::kFalse.'''
    ...
    def isReallyClosing (self)-> int :
      '''Returns true if calling close() at this time would really close the object completely. For example, if the object is not in a transaction, and is open for read with only one reader, then Adesk::kTrue would be returned. If, on the other hand, the object is in a transaction, then Adesk::kFalse would be returned.'''
    ...
    def isTransactionResident (self)-> int :
      '''Returns Adesk::kTrue if the object is currently part of a transaction. Otherwise returns Adesk::kFalse.'''
    ...
    def isUndoRecordingDisabled (self)-> bool :
      '''Returns true if undo recording is disabled.'''
    ...
    def isUndoing (self)-> int :
      '''Returns Adesk::kTrue if the object is involved in an Undo operation at this time. Otherwise returns Adesk::kFalse.'''
    ...
    def isWriteEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForWrite and is not currently sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def lastElementId (self)-> int :
      '''                             '''
    ...
    def layer (self)-> str :
      '''This function returns a copy of the name string in the AcDbLayerTableRecord object referenced by the entity.The calling application is responsible for deallocating the memory used by the returned string. The acutDelString() function is recommended.WarningCalling this function before the entity has had its referenced layer object ID set (that is, it's still set to AcDbObjectId::kNull) will terminate AutoCAD. If the referenced layer objectId is AcDbObjectId::kNull when the entity is added to a database, it will be set to the object ID of the database's current default layer.'''
    ...
    def layerId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the AcDbLayerTableRecord referenced by the entity. If the layerId has not been set yet, then AcDbObjectId::kNull is returned.'''
    ...
    def length (self)-> float :
      '''                             '''
    ...
    def lineElementColor (self)-> int :
      '''                             '''
    ...
    def lineWeight (self)-> PyDb.LineWeight :
      '''This function returns the AcDb::LineWeight of the entity.'''
    ...
    def linetype (self)-> str :
      '''This function returns a copy of the name string in the AcDbLinetypeTableRecord object referenced by the entity.The calling application is responsible for deallocating the memory used by the returned string. Either the C++ delete [ ] or the C free() function may be used.Warning Calling this function before the entity has had its referenced linetype object ID set (that is, it's still set to AcDbObjectId::kNull) will terminate AutoCAD. If the referenced linetype objectId is AcDbObjectId::kNull when the entity is added to a database it will be set to the object ID of the database's current default linetype.'''
    ...
    def linetypeId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the AcDbLinetypeTableRecord referenced by the entity. If the linetypeId has not been set yet, then AcDbObjectId::kNull will be returned.'''
    ...
    def linetypeScale (self)-> float :
      '''This function returns the linetype scale factor for the entity.'''
    ...
    def list (self)-> None :
      '''Function usageThis function is intended to be called from AutoCAD whenever the entity is selected during the LIST command. However, it can be called from ObjectARX applications if desired.This function will print entity specific information to the AutoCAD command line.Function implementation in derived classesWhen implementing this function in a derived class, the first thing that should be done in the function is to make a call to assertReadEnabled(). The next thing to do is to call the parent class's list() method to allow the parent class to list it's information (the parent class should in turn call its parent class first and so on up the inheritance chain until AcDbObject is reached. This way all the entity's information will be properly printed out in order). Once the parent class's list function has been called then a series of ads_printf() calls can be used to list whatever information is desired.Default implementationLists out the entity's DXF name, the layer, the space the entity resides in (model or paper), and the entity's handle.'''
    ...
    def material (self)-> str :
      '''Returns the material name.'''
    ...
    def materialId (self)-> PyDb.ObjectId :
      '''Returns the ID of the associated AcDbMaterial object.'''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def nextTangentElementId (self, id: int)-> int :
      '''                             '''
    ...
    def objectId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the object. If the object is not yet database-resident, then the returned objectId will be set to AcDbObjectId::kNull.'''
    ...
    def ownerId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the owner of the object. If the object does not yet have an owner, or the ownerId data member has not yet been set using AcDbObject::setOwnerId, then the returned objectId will be set to AcDbObjectId::kNull.Appending the object to a BlockTable record, a symbol table, or a dictionary automatically calls AcDbObject::setOwnerId.'''
    ...
    def plotStyleName (self)-> str :
      '''This function returns a copy of the plotStyleName string of the entity. The caller is responsible for deallocating the returned string.The plotStyleName value is used for DXF group code 390.'''
    ...
    def previousTangentElementId (self, id: int)-> int :
      '''                             '''
    ...
    def pviAtCurve (self, curve: PyBrxCv.CvDbVAlignmentCurve)-> PyBrxCv.CvDbVAlignmentPVI :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def receiveShadows (self)-> bool :
      '''Returns a boolean value indicating whether this entity can receive shadows.'''
    ...
    def recordGraphicsModified (self)-> None :
      '''This method sets the entity's state to indicate whether or not the entity should be updated on screen when it is closed. If the entity is set not to update, then any changes made will appear the next time the entity is regenerated.If setModified is false and the entity is currently set to update its graphics on close (which is its default state), then this function sets the entity so that it will not update on screen when it is closed and objectModified notification is sent to all entity type reactors attached to the entity. If setModified is false and the entity is already set not to update its graphics on close, then this function simply returns.If setModified is true, then the entity is set to update on screen when it is closed.'''
    ...
    def releaseExtensionDictionary (self)-> None :
      '''Removes the object's extension dictionary (that is, removes the object as the owner of the dictionary object) if it exists and is empty. Once removed, this function calls the dictionary's erase() method. Any reactors attached to the extension dictionary receive normal notification appropriate to an open for write, erase, close sequence.Returns Acad::eOk if successful.If the dictionary is not empty, then this function fails and returns Acad::eContainerNotEmpty.'''
    ...
    def removeContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def removeField (self, id: str|PyDb.ObjectId)-> None :
      '''Removes the specified field.Returns Acad::eOk if successful. Otherwise, returns an AutoCAD error status.'''
    ...
    def removePersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Removes the persistent reactor specified by objId from the reactor list of the object. The object must be open AcDb::kForWrite to be able to execute this function.Returns Acad::eOk if successful. If the object is currently sending notification and is not open AcDb::kForWrite, then Acad::eWasNotifying is returned.'''
    ...
    def removeReactor (self, reactor: PyDb.EntityReactor)-> None :
      '''                             '''
    ...
    def reverseCurve (self)-> None :
      '''Reverses the parameterization of the curve. The start becomes the end and visa versa.'''
    ...
    def rolloverHit (self, nSubentId: int, nMouseFlags: int, bReset: bool)-> int :
      '''                             '''
    ...
    def setAcDbObjectIdsInFlux (self)-> None :
      '''This function must be called on any newly created objects in AcDbObject::deepClone or AcDbObject::wblockClone. It indicates that reference object IDs are not yet pointing to the correct objects. The references can be translated only when the entire deep clone operation is complete. The flag is cleared at that time.'''
    ...
    def setAnnotative (self, state : PyDb.AnnotativeStates)-> None :
      '''                             '''
    ...
    def setAttributes (self, traits: PyGi.DrawableTraits)-> int :
      '''                             '''
    ...
    def setBaseHAlignment (self, id: PyDb.ObjectId)-> bool :
      '''                             '''
    ...
    def setBaseSurface (self, id: PyDb.ObjectId)-> bool :
      '''                             '''
    ...
    def setCastShadows (self, val: bool)-> None :
      '''Sets the property to indicate whether the entity can cast shadows.'''
    ...
    def setColor (self, clr: PyDb.AcCmColor, dosubents : bool=True, db : PyDb.Database='current')-> None :
      '''Function usageThis method sets the entity's color to the color specified by color. If the entity owns subentities and doSubents == Adesk::kTrue, the color change is applied to the subentities as well. Custom classes may override this method.'''
    ...
    def setColorIndex (self, clr: int, dosubents : bool=True)-> None :
      '''Function usageThis method sets the entity's color to the AutoCAD color index color. If the entity owns subentities and doSubents == Adesk::kTrue, then the color index change will be applied to the subentities as well.'''
    ...
    def setCurveElementColor (self, val: int)-> bool :
      '''                             '''
    ...
    def setDatabaseDefaults (self, db: PyDb.Database = 'current')-> None :
      '''This function sets the entity's:ColorLayerLinetypeLinetype scaleVisibilityPlot style nameLine weightto the default values of the database indicated by pDb: If pDb == NULL, then the current database in the AutoCAD editor is used.'''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...

    @overload
    def setField (self, field: PyDb.Field)-> PyDb.ObjectId : ...
    @overload
    def setField (self, propName: str, field: PyDb.Field)-> PyDb.ObjectId : ...
    def setField (self, *args, **kwargs)-> PyDb.ObjectId :
      '''Overloads:
    - field: PyDb.Field
    - propName: str, field: PyDb.Field
    '''
    ...
    def setFromAcGeCurve (self, curve: PyGe.Curve3d, normal: PyGe.Vector3d = PyGe.Vector3d.kZAxis, tol: PyGe.Tol = 'default')-> None :
      '''This is setFromAcGeCurve, a member of class AcDbCurve.'''
    ...
    def setLayer (self, val: str|PyDb.ObjectId, dosubents : bool=True, allowHiddenLayer : bool=False)-> None :
      '''This method sets entity to reference the AcDbLayerTableRecord identified by the name specified in newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the layer change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.'''
    ...
    def setLineElementColor (self, val: int)-> bool :
      '''                             '''
    ...
    def setLineWeight (self, val: PyDb.LineWeight, dosubents : bool=True)-> None :
      '''This method sets the entity to use lineweight. If the entity owns subentities and doSubents == Adesk::kTrue, then the line weight change will be applied to the subentities as well.Returns Acad::eOk if successful.Function implementation in derived classesIf this function is overridden and wishes to set the line weight of the entity, then it must call AcDbEntity::setLineWeight() passing on the lineweight and doSubents arguments.It is also possible for this function's implementation to deal directly with any subentities and pass a doSubents value of Adesk::kFalse to AcDbEntity:: setLineWeight().If the line weight setting operation is successful, then this function should return Acad::eOk. If lineweight is not an acceptable value, then this function should return Acad::eInvalidInput. Any other error return values are up to the implementer.'''
    ...
    def setLinetype (self, val: str|PyDb.ObjectId, dosubents : bool=True)-> None :
      '''Function usageThis method sets the entity to reference the AcDbLinetypeTableRecord with the name specified in newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the linetype change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.'''
    ...
    def setLinetypeScale (self, val: float, dosubents : bool=True)-> None :
      '''This method sets the entity to use newval as its linetype scale factor. newVal must be nonnegative. If the entity owns subentities and doSubents == Adesk::kTrue, then the linetype scale change will be applied to the subentities as well.'''
    ...
    def setMaterial (self, val: str|PyDb.ObjectId, dosubents : bool=True)-> None :
      '''This method sets the material reference to the specified material. The specified name must correspond to an existing AcDbMaterial object.Returns Acad::eOk when successful'''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setOwnerId (self, owner: PyDb.ObjectId)-> None :
      '''Sets the ownerId data member of the object to be objId, thus establishing a "backpointer." This backpointer is used by WBLOCK to be sure all necessary objects are written out.Returns Acad::eOk if successful.'''
    ...

    @overload
    def setPlotStyleName (self, /)-> None : ...
    @overload
    def setPlotStyleName (self, nameType: PyDb.PlotStyleNameType, doSubents: bool)-> None : ...
    @overload
    def setPlotStyleName (self, nameType: PyDb.PlotStyleNameType, newId: PyDb.ObjectId, doSubents: bool)-> None : ...
    def setPlotStyleName (self, *args, **kwargs)-> None :
      '''Overloads:
    - None: Any
    - nameType: PyDb.PlotStyleNameType, doSubents: bool
    - nameType: PyDb.PlotStyleNameType, newId: PyDb.ObjectId, doSubents: bool
    
	-This function searches the PlotStyleName dictionary for an entry with the name that matches newName and if found, sets the entity to use that plotStyleName entry. Because a lookup in the PlotStyleName dictionary is required, the entity must be database-resident for this method to succeed. The names ByLayer and ByBlock are allowed as well as user-defined names.If the entity owns subentities and doSubents == Adesk::kTrue, then the change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.Returns Acad::eOk if successful. If the entity is not database-resident, then Acad::eNoDatabase will be returned. If there is no entry in the PlotStyleName dictionary for newName, then Acad::eKeyNotFound will be returned.The plotStyleName value is used for DXF group code 390.-'''
    ...
    def setPropertiesFrom (self, entity: PyDb.Entity, dosubents : bool=True)-> None :
      '''This method copies theColorLayerLinetypeLinetype scaleVisibilityvalues from the entity pointed to by pEntity into this entity. If the entity owns subentities and doSubents == Adesk::kTrue, then the property changes will be applied to the subentities as well.Returns Acad::eOk if successful.'''
    ...
    def setReceiveShadows (self, val: bool)-> None :
      '''Sets the property indicating whether this entity can receive shadows.'''
    ...
    def setStyle (self, val: int)-> bool :
      '''                             '''
    ...
    def setTangentPolygonColor (self, val: int)-> bool :
      '''                             '''
    ...
    def setType (self, val: VAlignmentType)-> bool :
      '''                             '''
    ...
    def setVisibility (self, val: PyDb.Visibility, dosubents : bool=True)-> None :
      '''This method sets the visibility of an entity to the value specified by newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the visibility change will be applied to the subentities as well.'''
    ...
    def setXData (self, xdata: list)-> None :
      '''Each regapp sublist (delimited by a resbuf with restype == 1001 and resval.rstring == a valid regappName string) within the resbuf chain pointed to by xdata, is placed in the xdata area of the object. If any of the regappNames in xdata are already present in the xdata area of the object, then that regappName's existing data on the object is overwritten by that regappName's new data in xdata.All resbufs with restype == 1001 must have valid regappNames for the database the object resides in (that is, the regappNames must be in the APPID table of the database).Only valid xdata group codes (1000--1071) are accepted in the restype fields of the resbufs in xdata.No "-3" group code is necessary, and in fact, is not accepted. So, the first element in the resbuf chain must be a 1001 group code with a resval.rstring set to a regappName that's already registered in the regapp table. To register a regappName, use the acdbRegApp() function.To remove an appName (and its xdata) from an object, just use a resbuf with restype == 1001, resval == and no data resbufs following it (that is, either its rbnext == NULL or the next resbuf is another 1001)This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If this function is overridden, then it should supermessage its parent in order to invoke the built-in mechanism to add the xdata to the object.Returns Acad::eOk if the xdata is successfully added to the object. If there is insufficient space in the xdata area of the object, then Acad::eXdataSizeExceeded is returned. If any of the regappNames in xdata are not in the APPID table, then Acad::eRegappIdNotFound is returned.'''
    ...
    def snoop (self,  filer : PyDb.SnoopDwgFiler)-> None :
      '''                             '''
    ...
    def style (self)-> int :
      '''                             '''
    ...
    def swapIdWith (self, otherId: PyDb.DbObject, swapXdata: bool, swapExtDict: bool)-> None :
      '''This function swaps objectIds and handles between the object specified by otherId and the object invoking this function. Both objects must currently be database-resident and must reside in the same database. If swapXdata == Adesk::kTrue, then the objects swap extended entity data as well. If swapExtDict == Adesk::kTrue, then the objects swap extension dictionaries also.If the object specified by otherId or the object invoking this function are not database-resident, then Acad::eNoDatabase is returned. If both objects involved are not in the same database, then Acad::eWrongDatabase is returned.'''
    ...
    def tangentPolygonColor (self)-> int :
      '''                             '''
    ...
    def transformBy (self, matrix3d: PyGe.Matrix3d)-> None :
      '''Function usageThis function provides a means by which AutoCAD and ObjectARX applications can ask the entity to apply a transformation matrix (xform) to itself.Each entity class must implement this function, so restrictions on what types of transformations are supported are up to the implementer of the entity class. The AutoCAD built-in entity classes for entity types that existed before R13 (that is, all the classes listed in the header file dbents.h such as AcDbCircle, AcDbLine, AcDbArc, AcDb2dPolyline, etc.) require that the transformation matrix represent a uniformly scaling orthogonal transformation (if it is not, then Acad::eCannotScaleNonUniformly will be returned). Other AutoCAD built-in classes have no restrictions.Returns Acad::eOk if successful. Return values for errors are implementation-dependent.Function implementation in derived classesThis function must apply the transformation matrix xform to the entity and change the entity's state to reflect the transformation. It is completely up to the implementer as to how to apply the transformation. It is also up to the implementer to decide what, if any, restrictions will be placed on the type of transformations supported. If any restrictions are desired, then it's up to the implementation of this function to enforce them.If your derived class implements transformBy() without calling the base class, you must call AcDbObject:: xDataTransformBy() or your Xdata will not be transformed.If this function successfully transforms the entity, then it should return Acad::eOk.Return values for error conditions are completely up to the implementer of this function. However, if the error is caused by a non-uniformly scaling or non-orthogonal matrix, then to be consistent with other entities that have this restriction, it is recommended that Acad::eCannotScaleNonUniformly be returned.'''
    ...
    def type (self)-> PyBrxCv.VAlignmentType :
      '''                             '''
    ...
    def update (self, updateDependencies: bool)-> bool :
      '''                             '''
    ...
    def upgradeFromNotify (self, wasWritable: bool)-> None :
      '''Upgrades the object from being at least open AcDb::kForNotify to being open both AcDb::kForNotify and AcDb::kForWrite. The wasWritable argument is set to Adesk::kTrue if the object was already open for write, otherwise it's set to Adesk::kFalse. The wasWritable value should be saved to be passed into the downgradeToNotify() call later.This function must be followed at some point by a call to downgradeToNotify() with no open() (in any of its forms) or close() calls in between.This method should only be called from within other methods of the same object it is being called from. In other words, this method is intended to be used by an object to change it's own open status so that it can safely modify itself.upgradeFromNotify() and downgradeToNotify() call pairs are not nestable.Returns Acad::eOk if successful. If the object is not currently open AcDb::kForNotify, then Acad::eNotApplicable is returned. If the object is currently in the process of actually sending notification (that is, isNotifying() returns Adesk::kTrue), then Acad::eWasNotifying is returned.'''
    ...
    def upgradeOpen (self)-> None :
      '''If the object is currently open AcDb::kForRead with only one reader, then this function upgrades the object to open AcDb::kForWrite. In the process of changing to open for write, the object is closed, thus triggering any pertinent notification.Returns Acad::eOk if successful. If the object has more than one reader, then the open status is not changed and Adesk::eHadMultipleReaders is returned. If the object is already open AcDb::kForWrite, then Acad::eWasOpenForWrite is returned. If the object is currently sending notification, then the open status is not changed and Acad::eWasNotifying is returned.'''
    ...
    def viewportDraw (self, vpdraw: PyGi.ViewportDraw)-> None :
      '''                             '''
    ...
    def viewportDrawLogicalFlags (self, vpdraw: PyGi.ViewportDraw)-> int :
      '''                             '''
    ...
    def visibility (self)-> PyDb.Visibility :
      '''This method returns the entity's current visibility state, either AcDb::kVisible or AcDb::kInvisible.'''
    ...
    def wblockClone (self, owner: PyRx.RxObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function is almost identical to AcDbObject::deepClone, except that an AcDbWblockCloneFiler is used and ownership is not carried across database boundaries. Subcloning is based on hard owner and hard pointer connections.'''
    ...
    def worldDraw (self, wdraw: PyGi.WorldDraw)-> int :
      '''                             '''
    ...
    def xData (self, appname: str = None)-> list :
      '''Returns a linked list of resbuf structures containing a copy of the xdata for the object. If regappName == NULL is passed in, all xdata is returned, otherwise only the xdata for the specified name is returned. If not all xdata is required, but the xdata for more than one regappName is desired, then multiple calls to this member function must be made--one for each regappName.The caller of this function is responsible for releasing the memory used by the resbuf list that is returned. The most commonly used way to deallocate such a list is via the acutRelRb() function.This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If a failure accessing the xdata occurs, NULL is returned.'''
    ...
    def xDataTransformBy (self, xform: PyGe.Matrix3d)-> None :
      '''This method applies the xform transformation matrix to any XData data types 1011, 1021, 1031, 1012, 1022, 1032, 1013, 1023, 1033, 1041, and 1042 in the object's XData. See the documentation on XData for more information on the way the transformation matrix is applied to the different data types.This method should be called from within the transformBy() method on custom entities so that such entities will transform XData in the same way that the built-in AcDb entities do.Returns Acad::eOk if successful.'''
    ...
    def xmitPropagateModify (self)-> None :
      '''Within an object's close() method is a call to the object's xmitPropagateModify().The AcDbObject::xmitPropagateModify() default implementation is to inform the containing database that the object has been modified, appended to the database, or erased. The database then sends out the appropriate notification to any AcDbDatabaseReactors attached to it.Within AutoCAD, this function is used by complex entities such as polylines to allow the subentities to notify the header that they have been changed. The header can then "propagate" the notification by sending its own notification that the "complex entity" has been modified.The way this works is:The subobject class has it's xmitPropagateModify() class overridden such that it calls it's parent class's xmitPropagateModify() and also calls the owning object's recvPropagateModify().The "root" or "header" class has it's recvPropagateModify() overridden to provide an implementation that triggers "modified" notification to be sent for the "root" or "header" (which effectively represents the whole complex object).The subobject's close() triggers "modified" notification for the subobject and calls the subobject's xmitPropagateModify() function. So, when the subobject's close() is called, its xmitPropagateModify() is called. This then calls the owning object's recvPropagateModify(), which then triggers the owner to send "modified" notification.So, the result is a "modified" notification from both the subentity and the "root" or "header" entity.When overridden, this function should:Call its parent class's xmitPropagateModify() (which ultimately results in the execution of AcDbObject::xmitPropagateModify() to trigger database notification).Call its owner's recvPropagateModify() (passing in its "this" pointer) to "propagate" the notification information to the "root" owner to be sent out.'''
    ...

class CvDbVAlignmentArc(CvDbVAlignmentCurve):
    def __init__ (self)-> None :
      '''                             '''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbVAlignmentArc :
      '''                             '''
    ...
    def center (self)-> PyGe.Point2d :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def endPoint (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def gradeIn (self)-> float :
      '''                             '''
    ...
    def gradeOut (self)-> float :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isClockwise (self)-> bool :
      '''                             '''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def length (self)-> float :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def nextId (self)-> int :
      '''                             '''
    ...
    def parameterConstraint (self)-> PyBrxCv.VAlignmentParameterConstraint :
      '''                             '''
    ...
    def previousId (self)-> int :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def radius (self)-> float :
      '''                             '''
    ...
    def setCenter (self, pt : PyGe.Point2d)-> bool :
      '''                             '''
    ...
    def setClockwise (self, val : bool)-> bool :
      '''                             '''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setNextId (self, val : int)-> bool :
      '''                             '''
    ...
    def setParameterConstraint (self, val : PyBrxCv.VAlignmentParameterConstraint)-> bool :
      '''                             '''
    ...
    def setPreviousId (self, val : int)-> bool :
      '''                             '''
    ...
    def setRadius (self, val : float)-> bool :
      '''                             '''
    ...
    def setTangencyConstraint (self, val : PyBrxCv.VAlignmentTangencyConstraint)-> bool :
      '''                             '''
    ...
    def startPoint (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def tangencyConstraint (self)-> PyBrxCv.VAlignmentTangencyConstraint :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.VAlignmentElementType :
      '''                             '''
    ...

class CvDbVAlignmentCurve(CvDbVAlignmentElement):
    def __init__ (self, *args, **kwargs)-> None :
      '''Raises an exception
This class cannot be instantiated from Python'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbVAlignmentCurve :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def endPoint (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def length (self)-> float :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def nextId (self)-> int :
      '''                             '''
    ...
    def parameterConstraint (self)-> PyBrxCv.VAlignmentParameterConstraint :
      '''                             '''
    ...
    def previousId (self)-> int :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setNextId (self, val : int)-> bool :
      '''                             '''
    ...
    def setParameterConstraint (self, val : PyBrxCv.VAlignmentParameterConstraint)-> bool :
      '''                             '''
    ...
    def setPreviousId (self, val : int)-> bool :
      '''                             '''
    ...
    def setTangencyConstraint (self, val : PyBrxCv.VAlignmentTangencyConstraint)-> bool :
      '''                             '''
    ...
    def startPoint (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def tangencyConstraint (self)-> PyBrxCv.VAlignmentTangencyConstraint :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.VAlignmentElementType :
      '''                             '''
    ...

class CvDbVAlignmentElement(CvDbSubObject):
    def __init__ (self, *args, **kwargs)-> None :
      '''Raises an exception
This class cannot be instantiated from Python'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbVAlignmentElement :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def nextId (self)-> int :
      '''                             '''
    ...
    def parameterConstraint (self)-> PyBrxCv.VAlignmentParameterConstraint :
      '''                             '''
    ...
    def previousId (self)-> int :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setNextId (self, val : int)-> bool :
      '''                             '''
    ...
    def setParameterConstraint (self, val : PyBrxCv.VAlignmentParameterConstraint)-> bool :
      '''                             '''
    ...
    def setPreviousId (self, val : int)-> bool :
      '''                             '''
    ...
    def setTangencyConstraint (self, val : PyBrxCv.VAlignmentTangencyConstraint)-> bool :
      '''                             '''
    ...
    def tangencyConstraint (self)-> PyBrxCv.VAlignmentTangencyConstraint :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.VAlignmentElementType :
      '''                             '''
    ...

class CvDbVAlignmentPVI(CvDbVAlignmentElement):
    def __init__ (self)-> None :
      '''                             '''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbVAlignmentPVI :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def location (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def nextId (self)-> int :
      '''                             '''
    ...
    def parameterConstraint (self)-> PyBrxCv.VAlignmentParameterConstraint :
      '''                             '''
    ...
    def previousId (self)-> int :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setNextId (self, val : int)-> bool :
      '''                             '''
    ...
    def setParameterConstraint (self, val : PyBrxCv.VAlignmentParameterConstraint)-> bool :
      '''                             '''
    ...
    def setPreviousId (self, val : int)-> bool :
      '''                             '''
    ...
    def setTangencyConstraint (self, val : PyBrxCv.VAlignmentTangencyConstraint)-> bool :
      '''                             '''
    ...
    def tangencyConstraint (self)-> PyBrxCv.VAlignmentTangencyConstraint :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.VAlignmentElementType :
      '''                             '''
    ...

class CvDbVAlignmentParabola(CvDbVAlignmentCurve):
    def __init__ (self)-> None :
      '''                             '''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbVAlignmentParabola :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def endPoint (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def gradeIn (self)-> float :
      '''                             '''
    ...
    def gradeOut (self)-> float :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def length (self)-> float :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def nextId (self)-> int :
      '''                             '''
    ...
    def parameterConstraint (self)-> PyBrxCv.VAlignmentParameterConstraint :
      '''                             '''
    ...
    def previousId (self)-> int :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def radius (self)-> float :
      '''                             '''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setNextId (self, val : int)-> bool :
      '''                             '''
    ...
    def setParameterConstraint (self, val : PyBrxCv.VAlignmentParameterConstraint)-> bool :
      '''                             '''
    ...
    def setPreviousId (self, val : int)-> bool :
      '''                             '''
    ...
    def setRadius (self, val : float)-> bool :
      '''                             '''
    ...
    def setTangencyConstraint (self, val : PyBrxCv.VAlignmentTangencyConstraint)-> bool :
      '''                             '''
    ...
    def startPoint (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def tangencyConstraint (self)-> PyBrxCv.VAlignmentTangencyConstraint :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.VAlignmentElementType :
      '''                             '''
    ...

class CvDbVAlignmentTangent(CvDbVAlignmentCurve):
    def __init__ (self)-> None :
      '''                             '''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbVAlignmentTangent :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def endPoint (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def id (self)-> int :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def length (self)-> float :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def nextId (self)-> int :
      '''                             '''
    ...
    def parameterConstraint (self)-> PyBrxCv.VAlignmentParameterConstraint :
      '''                             '''
    ...
    def passThroughPoint1 (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def passThroughPoint2 (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def previousId (self)-> int :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setNextId (self, val : int)-> bool :
      '''                             '''
    ...
    def setParameterConstraint (self, val : PyBrxCv.VAlignmentParameterConstraint)-> bool :
      '''                             '''
    ...
    def setPassThroughPoint1 (self, pt : PyGe.Point2d)-> bool :
      '''                             '''
    ...
    def setPassThroughPoint2 (self, pt : PyGe.Point2d)-> bool :
      '''                             '''
    ...
    def setPreviousId (self, val : int)-> bool :
      '''                             '''
    ...
    def setTangencyConstraint (self, val : PyBrxCv.VAlignmentTangencyConstraint)-> bool :
      '''                             '''
    ...
    def startPoint (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def tangencyConstraint (self)-> PyBrxCv.VAlignmentTangencyConstraint :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.VAlignmentElementType :
      '''                             '''
    ...

class CvDbVAlignmentView(CvDbView):
    def __init__ (self, id: ObjectId, mode: PyDb.OpenMode=PyDb.OpenMode.kForRead, erased: bool=False)-> None :
      '''                             '''
    ...
    def addContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def addGraph (self, id : PyDb.ObjectId)-> bool :
      '''                             '''
    ...
    def addPersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Adds the database-resident object specified by objId to the reactor list of the AcDbObject object.'''
    ...
    def addReactor (self, reactor: PyDb.EntityReactor)-> None :
      '''                             '''
    ...
    def addSubentPaths (self, paths: list[PyDb.FullSubentPath])-> None :
      '''Adds one or more subentities to an entity.The prototype of this method is provided for completeness of the subentity manipulation APIs. AutoCAD will never call this method on a custom object.Returns Acad::eOk if successful. The default implementation returns Acad::eNotAvailable.'''
    ...
    def assertNotifyEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should be used inside of member functions that are only called when the object is open kForNotify. When used, it should be the first function called inside the member function.'''
    ...
    def assertReadEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that access the object's data in a read-only fashion (for example, dxfOutFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is open AcDb::kForRead.If this function is called while the object is not open, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def assertWriteEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that modify the object's data (for example, dxfInFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is indeed open for write (if it is not, then AutoCAD terminates); to trigger an immediate sending of "openedForModify" notification; to set up the notification mechanism so that "modified" and "modifiedGraphics" (if the object is derived from AcDbEntity) are sent at the appropriate times; and to ensure that graphics get updated if the object is derived from AcDbEntity.If this function is called on a database resident object, "openedForModify" will be sent if the object is not newly created, and "modified", and "modifiedGraphics" (if appropriate) notifications will be sent when the object is next closed.If recordModified is false, then the autoUndo argument is ignored, and the undo filer is not initialized, no undo recording will take place, but notifications will be sent.If autoUndo and recordModified are both true, then automatic undo recording will be performed and notifications will be sent.If autoUndo is false and recordModified is true, then there will not be any automatic undo recording, but the undo filer is initialized and the object must manually write out partial Undo records and must implement its applyPartialUndo() method. Notifications will be sent.If this function is called while the object is not open AcDb::kForWrite, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def baseElevation (self)-> float :
      '''                             '''
    ...
    def baseHAlignment (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def blockId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the entity's owner, which must be an AcDbBlockTableRecord.If the entity does not have an owner yet, then AcDbObjectId::kNull will be returned.'''
    ...
    def bounds (self, ext: PyDb.Extents)-> bool :
      '''                             '''
    ...
    def cancel (self)-> None :
      '''Terminates the current open operation. All changes made to the object since it was opened are undone, the object is marked as closed, and "cancel" notification is sent.Returns Acad::eOk if successful.'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbVAlignmentView :
      '''                             '''
    ...
    def castShadows (self)-> bool :
      '''Returns a boolean value that indicates whether the entity can cast shadows. '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...

    @staticmethod
    def cloneFrom (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbVAlignmentView :
      '''                             '''
    ...
    def close (self)-> None :
      '''Closes the object. All changes made to the object since it was opened are committed to the database, the object is marked as pageable, and a "closed" notification (as well as any other appropriate notification such as "modified", "erased", and so on) is sent.Returns Acad::eOk if successful.If the object is not in an AcDbDatabase yet, then Acad::eNoDatabase is returned.If the object is sending notification, then Acad::eCloseWasNotifying is returned.If the subClose() call made within the close() method returns anything other than Acad::eOk, then that ErrorStatus is returned.'''
    ...
    def collisionType (self)-> PyDb.CollisionType :
      '''This function returns the collision detection treatment for this entity. Subclasses may override this method to customize how the class interacts in collision-aware features.'''
    ...
    def color (self)-> PyDb.Color :
      '''This function returns the full true color information for the entity within an instance of AcCmColor.The index value will be in the range 0 to 256. 0 and 256 are special values.0 indicates the entity uses the color of the BlockReference that's displaying it. If the entity is not displayed through a BlockReference (for example, it's directly owned by the model space BlockTableRecord) and its color is 0, then it will display as though its color were 7.256 indicates the entity uses the color specified in the LayerTableRecord it references.'''
    ...
    def colorIndex (self)-> int :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...
    def createExtensionDictionary (self)-> None :
      '''Creates an AcDbDictionary object and sets it up as the extension dictionary for the AcDbObject.Returns Acad::eOk if successful. If an extension dictionary already exists, Acad::eAlreadyInDb is returned.'''
    ...
    def database (self)-> PyDb.Database :
      '''Returns a pointer to the AcDbDatabase object that contains the AcDbObject.'''
    ...
    def deepClone (self, owner: PyDb.DbObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function gives control of deep clone operations to the object. In the default implementation, the object is cloned and appended to the owner object (pOwnerObject). The cloning is performed by an AcDbDeepCloneFiler. A record is also added to the idMap. Then, using the filer, any owned objects are deep cloned, with isPrimary set to Adesk::kFalse.'''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def disableUndoRecording (self, disable: bool)-> None :
      '''Turns off or on the Undo recording for the object. If disable == Adesk::kTrue, then Undo recording is turned off until this function is called with disable == Adesk::kFalse, at which time Undo recording is turned back on.'''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def downgradeOpen (self)-> None :
      '''Downgrades the object from being open AcDb::kForWrite, to being AcDb::kForRead. In the process, all changes made to the object while it was open for write are committed to the database and appropriate notification is sent.'''
    ...
    def downgradeToNotify (self, wasWritable: bool)-> None :
      '''Restores an object from being open both AcDb::kForNotify and AcDb::kForWrite, to being open just AcDb::kForNotify. The wasWritable value that was returned from the matching AcDbObject::upgradeFromNotify() call should be passed into this function to restore the proper open status.This function must have been preceded by a call to upgradeFromNotify().Returns Acad::eOk if successful.'''
    ...
    def draw (self)-> None :
      '''This function queues up the entity's graphics and flushes the graphics queue, forcing the entity and anything else in the queue to be drawn or re-drawn on-screen.Returns Acad::eOk if successful.If the entity is not in a database, then Acad::eNotInDatabase will be returned.If the entity is in a database other than the one currently loaded into the AutoCAD editor, then Acad::eNotCurrentDatabase will be returned.'''
    ...
    def drawableType (self)-> PyGi.GiDrawableType :
      '''                             '''
    ...
    def entityColor (self)-> PyDb.EntityColor :
      '''This function returns the color settings of the entity in an AcCmEntityColor form. Most clients should use the color() function, which returns the heavyweight AcCmColor object. However, if color name information is not required, this function provides faster access to the lightweight AcCmEntityColor data.'''
    ...
    def erase (self, erasing : bool=True)-> None :
      '''Sets the erase bit of the object. If erasing == Adesk::kTrue, then the erase bit is set on. If erasing == Adesk::kFalse, then the erase bit is set off.'''
    ...
    def explode (self)-> list :
      '''Function UsageThis function is primarily intended for AutoCAD to call as part of an explode operation that includes this entity. However, this function can be used by ObjectARX applications to obtain an array of pointers to non-database-resident entity objects that are what the entity considers to be its exploded parts.When calling this function, the entitySet array does not need to be empty. This function will append to it, and pointers to entities that it creates to be used in its place as the "exploded" result.If this function is successful, it will return Acad::eOk. Other return values may vary depending on how it has been implemented.Function Implementation in Derived ClassesThis function should dynamically create (using the new operator) whatever entity objects are appropriate to be used to replace the entity after an explode operation has taken place. Pointers to these entities are then appended to the entitySet array. Once the pointers have been appended, the function should return with a status of Acad::eOk.'''
    ...
    def extensionDictionary (self)-> PyDb.ObjectId :
      '''Returns the objectId of the extension dictionary owned by the object. If the object does not own an extension dictionary, then the returned objectId is set to AcDbObjectId::kNull.'''
    ...
    def fromWCSPoint2d (self, pt : PyGe.Point2d)-> PyGe.Point2d :
      '''                             '''
    ...
    def fromWCSX (self, val : float)-> float :
      '''                             '''
    ...
    def fromWCSY (self, val : float)-> float :
      '''                             '''
    ...
    def getCompoundObjectTransform (self)-> PyGe.Matrix3d :
      '''This function is intended to be overridden by derived classes that are compound objects (in other words, objects that behave like blocks in the display list).A compound object has little or no geometry of its own; instead it relies on nested entities, perhaps the contents of a BlockTableRecord, to represent itself. A compound object must use the same transformation matrix for all of its contained entities. Otherwise selection and osnap will not function correctly. This is the method that the system uses to obtain that matrix from the compound object.This method should only be overridden if you return the kDrawableIsCompoundObject flag from setAttributes. The matrix you should return here is the one that you pass to pushModelTransform before you render your nested objects. You must override this method if you return the compound object flag in setAttributes, even if you don't push a transform for your nested objects. In that case you would return Acad::eOk and the identity transform in xMat.Default implementation: Returns Acad::eNotApplicable and the identity matrix in xMat.'''
    ...
    def getEcs (self)-> PyGe.Matrix3d :
      '''This function is intended to be overridden by derived classes that need to be able to provide access to an object coordinate system for objects of the class. The intent is that this function provide a transformation matrix that can be used to transform vectors or points from the object's object coordinate system (OCS) to the World Coordinate System (WCS).Default implementation: Return the identity matrix (ones along the diagonal, zeros elsewhere) in retVal.We recommend that all data stored in custom classes be stored in WCS coordinates. If this is done, then the object's OCS will be the WCS and the transformation matrix will be the identity matrix. Then this function will not need to be overridden since the identity matrix is this function's default return.'''
    ...
    def getField (self, prop: str='TEXT')-> PyDb.ObjectId :
      '''Gets the field ID. A field can be stored in an object using the property name as the key.Returns Acad::eOk if the object has a field for the specified property. Otherwise, returns an AutoCAD error status.'''
    ...
    def getFieldDictionary (self)-> PyDb.ObjectId :
      '''Returns the field dictionary ID. The field dictionary stores all the fields set in the object as property name-field object pairs. The ID will be null if there is no field in the object.'''
    ...
    def getGeomExtents (self)-> PyDb.Extents :
      '''Unimplemented at the AcDbEntity level, this method is intended to be overridden in derived classes.Derived classes should calculate and return the corner points (in WCS coordinates) of a box (with edges parallel to the WCS X, Y, and Z axes) that encloses the 3D extents of the entity, and return those points as an instance of class AcDbExtents in the "extents" parameter.Default implementation: Immediately returns Acad::eInvalidExtents.'''
    ...
    def getGeomExtents2d (self)-> PyDb.Extents2d :
      '''                             '''
    ...

    @overload
    def getGripPoints (self, /)-> tuple[Any,...] : ...
    @overload
    def getGripPoints (self, curViewUnitSize: float, gripSize: int, curViewDir: PyGe.Vector3d, bitflags: int)-> tuple[Any,...] : ...
    def getGripPoints (self, *args, **kwargs)-> tuple[Any,...] :
      '''Overloads:
    - None: Any
    - curViewUnitSize: float, gripSize: int, curViewDir: PyGe.Vector3d, bitflags: int
    
	-Function usageThis function supports "old style" grips, in applications that existed before the enhancement of grip functionality by the addition of the AcDbGripData class.This function is not intended to be called by ObjectARX applications. However, it is possible to do so (for example, as a pass-through from the getStretchPoints() method).Function implementation in derived classesThis function should append to the gripPoints array any points that are to treated as grip points for the entity.The gripPoints array is passed to all entities involved in the grip operation, so the array may already contain grip points for other entities. Therefore, it is very important to append the new points rather than assigning them to any existing elements in the array.When finished appending all desired grip points, return Acad::eOk. If anything other than Acad::eOk is returned, then grips are not activated for this entity.The osnapModes and geomIds arguments are not currently used.Default implementationImmediately returns Adesk::eNotImplemented.-'''
    ...
    def getHandle (self)-> PyDb.Handle :
      '''Fills in handle with the handle value for the object. If the object is not yet database-resident, then it will not have a handle. Use AcDbHandle::isNull to test for this condition.'''
    ...
    def getPlane (self)-> PyGe.Plane :
      '''If the entity is planar, then the plane containing the entity is returned in plane and flag is set to AcDb::kPlanar.If the entity is nonplanar, but is linear, then plane is set to an arbitrary plane that contains the entity and flag is set to AcDb::kLinear.If the entity is nonplanar and nonlinear, then plane is left unset and flag is set to AcDb::kNonPlanar.Returns Acad::eOk if successful. Other ErrorStatus return values are implementation-dependent.The default implementation is to return Acad::eNotApplicable.'''
    ...
    def getPlotStyleNameId (self)-> PyDb.ObjectId :
      '''Returns with id set to the object ID of the AcDbPlaceHolder object referenced by the entity. The AcDbPlaceHolder object resides in the plot style name dictionary, and its key in the dictionary is the plot style name.Use the AcDbDictionary::nameAt() function on the plot style name dictionary to get the plot style name string that corresponds to the ID obtained by this function.'''
    ...
    def getStretchPoints (self)-> list :
      '''Function usageThis function is not intended to be called by ObjectARX applications. However, it is possible to do so (for example, as a pass-through from the getGripPoints() method).Function implementation in derived classesThis function should append to the stretchPoints array any points that are to treated as stretch points for the entity.Stretch points are used by the stretch command within AutoCAD. Any stretch points that are within the crossing selection window during the stretch command, will be moved by whatever amount the user decides to "stretch" the selected entities. Any stretch points not in the crossing selection window will be left alone. This combination of some stretch points moving while others do not is what "stretches" the entity. If all stretch points are in the crossing window, then the entity is moved instead of stretched.The stretchPoints array is passed to all entities involved in the stretch operation, so the array may already contain stretch points for other entities. Therefore it is very important to append the new points rather than assigning them to any existing elements in the array.When finished appending all desired stretch points, return Acad::eOk. If anything other than Acad::eOk is returned, then this entity's stretch points will be ignored by the stretch operation.Default implementationCalls the AcDbEntity::getGripPoints() method. So, unless the entity needs to have stretch points that are different from the grip points, there is no need to override this method.'''
    ...
    def getSubentPathsAtGsMarker (self, type: PyDb.SubentType, gsMark: int, pickPoint: PyGe.Point3d, viewXform: PyGe.Matrix3d)-> list[PyDb.FullSubentPath] :
      '''Entities use various graphic primitives defined in AcGi to draw themselves. Part of this mechanism is the ability to associate an integer identifier called a graphics system marker (or, GS marker) with each primitive or with groups of primitives. Through the use of certain selection mechanisms, the GS marker for the actual subentity selected on screen can be obtained and, along with some other information passed into this function, can be used to create one or more AcDbFullSubentPath objects, each one representing a subentity and providing a more complete description of the subentity and its environment. These AcDbFullSubentPath objects can be used by several other functions for various purposes such as highlighting or unhighlighting the subentities on screen.Function usageIf the entity (of which the subentity is a part) is directly owned by the model or paper space BlockTableRecords, then leave out numInserts and entAndInsertStack so that their default value will be used.Typically the GS marker is obtained via the use of ads_ssget() followed by ads_ssnamex() (see the ObjectARX Developer's Guide for more information on this).The pickPoint can be obtained from ads_ssnamex() as well (it's the first group 5009 in the returned list).The viewXform can be calculated using the ads_trans() function on the vectors (1,0,0), (0,1,0), and (0,0,1) to translate them from DCS to WCS. The translations of these three vectors (with an extra 0 appended on to the end of each) would be used as the first three rows of the matrix. The last row is not used so it can be left as is. This argument is not used by any of the AutoCAD built-in entities.If the entity is nested inside one or more block definitions, then the numInserts and entAndInsertStack arguments must also be filled in with non-zero or non-null values. If they are not filled in, then this function will fail and return an error status. One way to get the necessary object IDs is to use ads_nentselp() to obtain the list of ads_names of the container objects. This list must then be converted to object IDs and reversed.Upon return, the subentPaths argument will point to a dynamically allocated array of one or more AcDbFullSubentPath objects. The numPaths argument will contain the number of AcDbFullSubentPath objects being returned.The calling application is responsible for deallocating the memory used by the subentPaths array. The C++ delete [ ] should be used.Return values for this function may vary depending on how the function has been implemented (see below).Function implementation in derived classesEntity classes which do not set GS markers probably should not implement this function since the GS marker is the primary (and often the only) means of subentity distinction.When implemented, this function must use the material provided in type, gsMark, pickPoint, viewXform, numInserts, and entAndInsertStack to determine which subentity or subentities meet the criteria in these arguments. Next it must create a dynamically allocated array of AcDbFullSubentPaths (using the C++ new operator) with one element for each subentity determined in the first step. Finally it must fill in each AcDbFullSubentPath object in the array with the information appropriate to the subentity it will represent.If numInserts == 0 and entAndInsertStack == NULL, it's important to check to be sure that the entity's owner is indeed the model or paper space BlockTableRecord. This can be done by using the entity's ownerId() method to obtain the objectId of its owner, and then opening up that object and using its name() method to obtain its name string. If the owner is not the model or paper space BlockTableRecord, and numInserts == 0 or entAndInsertStack == NULL, or both, then the input data is invalid and this function should set numPaths to 0, set subentPaths to NULL and then return the error status Acad::eInvalidInput.Each AcDbFullSubentPath object has two parts, an array of objectIds containing all the container objects, and an embedded AcDbSubentId object which in turn has two elements: an index value and a SubentityType.If the "main" entity (the entity on which this function is being called) is not nested within BlockReferences (that is, numInserts == 0 and entAndInsertStack == NULL), then the objectId array should contain only the objectId of the "main" entity. If the "main" entity is nested in one or more BlockReferences, then the AcDbObjectIdArray is the same as entAndInsertStack, so copying the entAndInsertStack elements into the AcDbObjectIdArray is all that's required.The SubentType data item within the embedded AcDbSubentId should be set the same as type.The index data item within the embedded AcDbSubentId can be any value you wish (it is often simply the GS marker), but if implemented, the following functions must be able to interpret them to determine the corresponding GS marker(s) or subentity (or subentities):getGsMarkersAtSubentPath()subentPtr()The pickPoint and viewXform arguments are provided as extra aids (if necessary) in determining which subentity is involved. For example, some entity types might display differently depending on the display viewpoint. The viewXform transformation matrix can be used in such cases.The viewXform argument provides a transformation matrix to transform from WCS (World Coordinate System) to DCS (display coordinate system).The display coordinate system is oriented such that the positive Z axis is coming out of the display screen towards the user, the positive X axis is horizontally from left to right on screen, and the positive Y axis is vertically upwards on screen.So, if the current viewpoint is at (1,0,0) (the viewer is always looking towards (0,0,0)) then the viewXform matrix would be:0 1 0 00 0 1 01 0 0 00 0 0 1In this matrix the last row and the last column are not used. Notice also that the third row is the DCS Z axis in WCS coordinates (which is the WCS version of the AutoCAD VIEWPOINT system variable).When this function returns, the return code to use is completely up to the implementer, but to be consistent with other existing entity class implementations of this function the following should be used:If the function succeeds, it should return Acad::eOk.If an invalid or unsupported SubentType is passed in, then numPaths should be set to 0, subentPaths should be set to NULL, and Acad::eWrongSubentityType should be returned.If an invalid GS marker (or any other data item that turns out to be needed) is passed in, then numPaths should be set to 0, subentPaths should be set to NULL, and Acad::eInvalidInput should be returned.Default implementationImmediately returns Adesk::eNotApplicable.'''
    ...
    def getTransformedCopy (self, matrix3d: PyGe.Matrix3d)-> PyDb.Entity :
      '''Function usageThis function creates a clone of the entity, applies the xform transformation matrix to the clone, and then returns with pEnt pointing to the transformed clone.Returns Acad::eOk if successful.If xform is a non-uniform scaling matrix or non-orthogonal then Acad::eCannotScaleNonUniformly or Acad::eNotImplemented is returned.WarningFor AutoCAD built-in complex entities such as polylines, this function produces a shallow clone of the header entity only, which also owns the original set of "owned" entities (such as vertices for a polyline) which are then transformed by the xform matrix. This results in a corrupt drawing (two header entities owning the same set of "owned" entities) as well as transforming the original set of "owned" entities instead of a copied set.Function implementation in derived classesThe default AcDbEntity implementation of this function should be adequate for most derived entity types. However, derived entity classes that wish to support non-uniform scaling or non-orthogonal transformations will need to override this method with their own implementation.This function must create a copy of the entity (using memory that has been dynamically allocated via the C++ new operator), apply the transformation matrix xform to the copy and then return with pEnt pointing to the transformed copy.Determining what constitutes a valid transformation matrix and whether to do a shallow clone (that is, the entity's clone() method), a deepclone (if the entity owns other objects), or no clone at all (that is, make this function a no-op), is up to the implementer.Return values for this function are also up to the implementer, but to be consistent with other existing classes the following is recommended:If the function succeeds, it should return Acad::eOk.If the function is to be a no-op, it should return Acad::eNotImplementedIf non-uniform scaling is not to be supported and a non-uniform scaling matrix is passed in, then either Acad::eCannotScaleNonUniformly or Acad::eNotImplemented should be returned.Default implementationIf the entity is uniformly scaled and orthogonal, AcDbEntity::getTransformedCopy will call the entity's clone() method to create a clone of the entity, then call AcDbEntity::transformBy() on the clone, and then return with pEnt set to point to the transformed clone. If xform is a non-uniformly scaled or a non-orthogonal matrix, then this function will return Acad::eNotImplemented.'''
    ...
    def graphAt (self, val : int)-> PyDb.ObjectId :
      '''                             '''
    ...
    def graphCount (self)-> int :
      '''                             '''
    ...
    def handOverTo (self, newObject: PyDb.DbObject, keepXData: bool, keepExtDict: bool)-> None :
      '''This function provides the ability to exchange a non-database-resident object (NDBRO) in place of an existing database-resident object (DBRO) while retaining the objectId, handle, and reactor list of the DBRO. An example of this situation is when the BREAK command is used to break a circle into one or two arc segments. AcDbArc is a completely different class from AcDbCircle, so a new AcDbArc object must be substituted in place of the AcDbCircle object that is there now, yet the arc must get the handle and objectId that the circle has.To use the handOverTo() function, the object to be replaced (the AcDbCircle in the example) must be open AcDb::kForWrite. The object's handOverTo() function is called with newObject pointing to a non-database-resident object that replaces it (the AcDbArc in the example).keepXData is set to Adesk::kTrue if the xdata is to be retained or Adesk::kFalse if the xdata is to be thrown out.keepExtDict is set to Adesk::kTrue if the extension dictionary and its contents are to be retained, or set to Adesk::kFalse if the extension dictionary and its contents are to be thrown out.Once returned from this function, the replacement object (the AcDbArc in the example) is open for AcDb::kForWrite and must have its close() member called to commit the change and close out Undo recording. Then it's up to the ObjectARX application to delete the old object (the AcDbCircle in the example) from memory since it's no longer database-resident.Returns Acad::eObjectToBeDeleted if the operation is successful. If newObject is pointing to an object that is already in the database, or the object invoking handOverTo() is not database-resident, then Acad::eIllegalReplacement is returned.'''
    ...
    def hasFields (self)-> bool :
      '''Returns true if the object has one or more PyDb.Field Objects. Otherwise returns false.'''
    ...
    def hasPersistentReactor (self, id: PyDb.ObjectId)-> bool :
      '''This method returns true if objId is the object ID of a reactor attached to this object. Otherwise, it returns false.'''
    ...
    def hasXData (self, appname: str)-> bool :
      '''                             '''
    ...
    def height (self)-> float :
      '''                             '''
    ...
    def highlight (self, path: PyDb.FullSubentPath = None, highlightAll : bool = False)-> None :
      '''Function usageThis function uses the AcDbFullSubentPathid to determine which subentity in the entity is desired. It then highlights that subentity on screen. If no AcDbFullSubentPath argument is provided, then the entire entity will be highlighted.Typically, the AcDbFullSubentPath object passed in via subId is obtained from the entity's AcDbEntity::getSubentPathsAtGsMarker() method. This guarantees that it is fully and properly filled in.This function uses the entity's getGsMarkersAtSubentPath() method to get the GS markers associated with subId. If that function does not return Acad::eOk, then this function will fail and return whatever ErrorStatus was returned by getGsMarkersAtSubentPath().If this function succeeds, then it returns Acad::eOk.It is not necessary to balance each highlight() function call with a corresponding call to unhighlight(). Calling the unhighlight() function will unhighlight the entity designated by subId regardless of how many times the highlight function has been called on it.WarningIf the entity on which this method is called has its graphics queued for regeneration (that is, changes have been made to the entity but have not yet been reflected on screen), then this method will not cause a highlight to occur. Also, calling this method on an entity that's open for write and whose graphics are queued for regeneration may terminate AutoCAD.To avoid this limitation, before calling highlight(), you should flush the entity's graphics by either calling the entity's draw() method, or calling the AcTransactionManager::flushGraphics() function.Function implementation in derived classesThe AcDbEntity::highlight() implementation does all the work necessary to highlight any subentities that correspond to the subIdFullSubentPath. So, there is no need to override this method unless you wish to do some pre-or post-processing, or you wish to disable the ability to highlight subentities.If this method is overridden and it is supposed to highlight subentities, then the AcDbEntity::highlight() method will need to be invoked at some point within this function in order to do the actual highlighting.Within the AcDbEntity::highlight() method, the getGsMarkersAtSubentPath() method of this entity is called to translate the FullSubentPath into the corresponding GS markers. So, if this function is to succeed, the getGsMarkersAtSubentPath() method needs to be implemented as well.For more information on the subIdAcDbFullSubentPath argument, see the documentation on the getGsMarkersAtSubentPath() or getSubentPathsAtGsMarker() methods.'''
    ...
    def horizontalScale (self)-> float :
      '''                             '''
    ...
    def id (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...

    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, thisGsMarker : int, otherGsMarker : int)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane, thisGsMarker : int, otherGsMarker : int)-> list : ...
    def intersectWith (self, *args, **kwargs)-> list :
      '''Overloads:
    - entity: PyDb.Entity, intType : PyDb.Intersect
    - entity: PyDb.Entity, intType : PyDb.Intersect, thisGsMarker : int, otherGsMarker : int
    - entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane
    - entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane, thisGsMarker : int, otherGsMarker : int
    
	-Function usageIt finds the intersections of the entity pointed to by pEnt and all the edges of the bounding box of this entity.The intType is used to determine how to deal with extending the two entities in order to calculate intersections. The possible AcDb::Intersect values are:AcDb::kOnBothOperandsDo not extend either entity. This results in only calculating intersections where the two entitys' geometry actually intersectAcDb::kExtendThisExtend this entity (if necessary) when calculating intersections, but do not extend the pEnt entity.AcDb::kExtendArgExtend the pEnt entity (if necessary) when calculating intersections, but do not extend this entity.AcDb::kExtendBothExtend both the pEnt entity and this entity (if necessary) when calculating intersectionsAny intersection points found are appended to the points array. All points are in WCS coordinates.The thisGsMarker and otherGsMarker arguments are intended to provide this function with information to allow it to localize the search for intersections to be between specific subentities. However, this function is not required to make use of either of these arguments (most, if not all, of the AutoCAD built-in entity classes do not). When calling this function, either or both of these arguments may be 0 in order to indicate that they should be ignored.If this function is successful it returns Acad::eOk. Return values for error conditions are dependent on the implementation of this function in the classes involved.Function implementation in derived classesThis function should do all it can to find all intersection points between the entity it's being called on and the entity pointed to by pEnt. All intersection points found should be appended to the points array. All such points must be in WCS coordinates.When implementing the intersection calculation portion of this function you should take a good look at the AcGe classes to see if they can provide any useful functionality to help in finding intersections with the geometric primitives that make up the entity this function is being called on and the pEnt entity. For example, the AcGeCurve3d class has an isOn() method that will indicate if a supplied point is on the curve and the AcGeCircArc3d class has several intersectWith() methods to find intersections with other AcGe types.If the pEnt entity is a type not recognized by this function, it is quite reasonable to call the pEnt entity's intersectWith() method passing in a pointer to this entity as the "pEnt", and all the other arguments passed into this function (remembering to convert the intType argument If necessary) to see if that entity can determine any intersection points. This is what the AutoCAD built-in classes do.Also, don't forget to take into account the intType value. The intType tells you which, if any, of the two entities should be extended to find "apparent" intersections. It is not required that apparent intersection be supported, but if it is not, then an appropriate ErrorStatus value should be returned to indicate that the call failed.The thisGsMarker and otherGsMarker arguments are provided to allow this function to determine exactly which subentities are involved in the intersection operation (for example, if this function is being called by AutoCAD as part of an intersection Osnap operation these arguments would indicate which subentities are within the osnap pickbox). For these arguments, a value less than or equal to zero indicates that that argument should not be used.If this function completes successfully (even if no intersection points are found), it should return Acad::eOk. Determining what is considered an error and what ErrorStatus return code to use for any such errors are up to the implementer -- there are no conventions in this regard.Default implementationImmediately returns Acad::eNotImplemented.-'''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isAProxy (self)-> int :
      '''Returns Adesk::kTrue if the object is a proxy object or entity. Otherwise returns Adesk::kFalse.'''
    ...
    def isAcDbObjectIdsInFlux (self)-> int :
      '''This function refers to a condition that occurs during deep clone operations. It returns Adesk::kTrue when the cloned objects' IDs have not yet been translated and thus cannot be used in any operations on the objects. This condition normally occurs only during AcEditorReactor::beginDeepCloneXlation, AcDbObject::deepClone, or AcDbObject::wblockClone. Any operations that involve AcDbObjectId references, such as symbol table records, should be postponed until after endDeepClone. AcDbObject::subClose is never called on any objects whose IDs are in flux.'''
    ...
    def isAnnotative (self)-> PyDb.AnnotativeStates :
      '''                             '''
    ...
    def isCancelling (self)-> int :
      '''Returns Adesk::kTrue if the object is currently in the middle of a cancel() call (that is, an open is being canceled and all changes made are being rolled back). Otherwise returns Adesk::kFalse.'''
    ...
    def isEraseStatusToggled (self)-> int :
      '''Returns Adesk::kTrue if the object's erase bit has been toggled since it was opened. Otherwise returns Adesk::kFalse.'''
    ...
    def isErased (self)-> int :
      '''Returns Adesk::kTrue if the object is currently erased. Otherwise returns Adesk::kFalse.'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isModified (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called). Otherwise returns Adesk::kFalse.'''
    ...
    def isModifiedGraphics (self)-> int :
      '''Returns Adesk::kTrue if the object is derived from AcDbEntity and has had either an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called), or its recordGraphicsModified() function called with an Adesk::kTrue argument value.Otherwise it returns Adesk::kFalse.'''
    ...
    def isModifiedXData (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called) and has then had its setXData() method called. Otherwise it returns Adesk::kFalse.'''
    ...
    def isNewObject (self)-> int :
      '''Returns Adesk::kTrue if the object has not yet been closed since it was first created. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifyEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForNotify. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifying (self)-> int :
      '''Returns Adesk::kTrue if the object is in the process of sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isPersistent (self)-> int :
      '''                             '''
    ...
    def isPlanar (self)-> int :
      '''This function returns Adesk::kTrue if and only if there is a plane that contains the entity. Otherwise Adesk::kFalse is returned.'''
    ...
    def isReadEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForRead. Otherwise returns Adesk::kFalse.'''
    ...
    def isReallyClosing (self)-> int :
      '''Returns true if calling close() at this time would really close the object completely. For example, if the object is not in a transaction, and is open for read with only one reader, then Adesk::kTrue would be returned. If, on the other hand, the object is in a transaction, then Adesk::kFalse would be returned.'''
    ...
    def isTransactionResident (self)-> int :
      '''Returns Adesk::kTrue if the object is currently part of a transaction. Otherwise returns Adesk::kFalse.'''
    ...
    def isUndoRecordingDisabled (self)-> bool :
      '''Returns true if undo recording is disabled.'''
    ...
    def isUndoing (self)-> int :
      '''Returns Adesk::kTrue if the object is involved in an Undo operation at this time. Otherwise returns Adesk::kFalse.'''
    ...
    def isWriteEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForWrite and is not currently sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def layer (self)-> str :
      '''This function returns a copy of the name string in the AcDbLayerTableRecord object referenced by the entity.The calling application is responsible for deallocating the memory used by the returned string. The acutDelString() function is recommended.WarningCalling this function before the entity has had its referenced layer object ID set (that is, it's still set to AcDbObjectId::kNull) will terminate AutoCAD. If the referenced layer objectId is AcDbObjectId::kNull when the entity is added to a database, it will be set to the object ID of the database's current default layer.'''
    ...
    def layerId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the AcDbLayerTableRecord referenced by the entity. If the layerId has not been set yet, then AcDbObjectId::kNull is returned.'''
    ...
    def length (self)-> float :
      '''                             '''
    ...
    def lineWeight (self)-> PyDb.LineWeight :
      '''This function returns the AcDb::LineWeight of the entity.'''
    ...
    def linetype (self)-> str :
      '''This function returns a copy of the name string in the AcDbLinetypeTableRecord object referenced by the entity.The calling application is responsible for deallocating the memory used by the returned string. Either the C++ delete [ ] or the C free() function may be used.Warning Calling this function before the entity has had its referenced linetype object ID set (that is, it's still set to AcDbObjectId::kNull) will terminate AutoCAD. If the referenced linetype objectId is AcDbObjectId::kNull when the entity is added to a database it will be set to the object ID of the database's current default linetype.'''
    ...
    def linetypeId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the AcDbLinetypeTableRecord referenced by the entity. If the linetypeId has not been set yet, then AcDbObjectId::kNull will be returned.'''
    ...
    def linetypeScale (self)-> float :
      '''This function returns the linetype scale factor for the entity.'''
    ...
    def list (self)-> None :
      '''Function usageThis function is intended to be called from AutoCAD whenever the entity is selected during the LIST command. However, it can be called from ObjectARX applications if desired.This function will print entity specific information to the AutoCAD command line.Function implementation in derived classesWhen implementing this function in a derived class, the first thing that should be done in the function is to make a call to assertReadEnabled(). The next thing to do is to call the parent class's list() method to allow the parent class to list it's information (the parent class should in turn call its parent class first and so on up the inheritance chain until AcDbObject is reached. This way all the entity's information will be properly printed out in order). Once the parent class's list function has been called then a series of ads_printf() calls can be used to list whatever information is desired.Default implementationLists out the entity's DXF name, the layer, the space the entity resides in (model or paper), and the entity's handle.'''
    ...
    def material (self)-> str :
      '''Returns the material name.'''
    ...
    def materialId (self)-> PyDb.ObjectId :
      '''Returns the ID of the associated AcDbMaterial object.'''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def objectId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the object. If the object is not yet database-resident, then the returned objectId will be set to AcDbObjectId::kNull.'''
    ...
    def origin (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def ownerId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the owner of the object. If the object does not yet have an owner, or the ownerId data member has not yet been set using AcDbObject::setOwnerId, then the returned objectId will be set to AcDbObjectId::kNull.Appending the object to a BlockTable record, a symbol table, or a dictionary automatically calls AcDbObject::setOwnerId.'''
    ...
    def plotStyleName (self)-> str :
      '''This function returns a copy of the plotStyleName string of the entity. The caller is responsible for deallocating the returned string.The plotStyleName value is used for DXF group code 390.'''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def receiveShadows (self)-> bool :
      '''Returns a boolean value indicating whether this entity can receive shadows.'''
    ...
    def recordGraphicsModified (self)-> None :
      '''This method sets the entity's state to indicate whether or not the entity should be updated on screen when it is closed. If the entity is set not to update, then any changes made will appear the next time the entity is regenerated.If setModified is false and the entity is currently set to update its graphics on close (which is its default state), then this function sets the entity so that it will not update on screen when it is closed and objectModified notification is sent to all entity type reactors attached to the entity. If setModified is false and the entity is already set not to update its graphics on close, then this function simply returns.If setModified is true, then the entity is set to update on screen when it is closed.'''
    ...
    def releaseExtensionDictionary (self)-> None :
      '''Removes the object's extension dictionary (that is, removes the object as the owner of the dictionary object) if it exists and is empty. Once removed, this function calls the dictionary's erase() method. Any reactors attached to the extension dictionary receive normal notification appropriate to an open for write, erase, close sequence.Returns Acad::eOk if successful.If the dictionary is not empty, then this function fails and returns Acad::eContainerNotEmpty.'''
    ...
    def removeContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def removeField (self, id: str|PyDb.ObjectId)-> None :
      '''Removes the specified field.Returns Acad::eOk if successful. Otherwise, returns an AutoCAD error status.'''
    ...
    def removeGraph (self, id: PyDb.ObjectId)-> bool :
      '''                             '''
    ...
    def removePersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Removes the persistent reactor specified by objId from the reactor list of the object. The object must be open AcDb::kForWrite to be able to execute this function.Returns Acad::eOk if successful. If the object is currently sending notification and is not open AcDb::kForWrite, then Acad::eWasNotifying is returned.'''
    ...
    def removeReactor (self, reactor: PyDb.EntityReactor)-> None :
      '''                             '''
    ...
    def rolloverHit (self, nSubentId: int, nMouseFlags: int, bReset: bool)-> int :
      '''                             '''
    ...
    def setAcDbObjectIdsInFlux (self)-> None :
      '''This function must be called on any newly created objects in AcDbObject::deepClone or AcDbObject::wblockClone. It indicates that reference object IDs are not yet pointing to the correct objects. The references can be translated only when the entire deep clone operation is complete. The flag is cleared at that time.'''
    ...
    def setAnnotative (self, state : PyDb.AnnotativeStates)-> None :
      '''                             '''
    ...
    def setAttributes (self, traits: PyGi.DrawableTraits)-> int :
      '''                             '''
    ...
    def setBaseElevation (self, val : float)-> bool :
      '''                             '''
    ...
    def setBaseHAlignment (self, id : PyDb.ObjectId)-> bool :
      '''                             '''
    ...
    def setCastShadows (self, val: bool)-> None :
      '''Sets the property to indicate whether the entity can cast shadows.'''
    ...
    def setColor (self, clr: PyDb.AcCmColor, dosubents : bool=True, db : PyDb.Database='current')-> None :
      '''Function usageThis method sets the entity's color to the color specified by color. If the entity owns subentities and doSubents == Adesk::kTrue, the color change is applied to the subentities as well. Custom classes may override this method.'''
    ...
    def setColorIndex (self, clr: int, dosubents : bool=True)-> None :
      '''Function usageThis method sets the entity's color to the AutoCAD color index color. If the entity owns subentities and doSubents == Adesk::kTrue, then the color index change will be applied to the subentities as well.'''
    ...
    def setDatabaseDefaults (self, db: PyDb.Database = 'current')-> None :
      '''This function sets the entity's:ColorLayerLinetypeLinetype scaleVisibilityPlot style nameLine weightto the default values of the database indicated by pDb: If pDb == NULL, then the current database in the AutoCAD editor is used.'''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...

    @overload
    def setField (self, field: PyDb.Field)-> PyDb.ObjectId : ...
    @overload
    def setField (self, propName: str, field: PyDb.Field)-> PyDb.ObjectId : ...
    def setField (self, *args, **kwargs)-> PyDb.ObjectId :
      '''Overloads:
    - field: PyDb.Field
    - propName: str, field: PyDb.Field
    '''
    ...
    def setHeight (self, val : float)-> bool :
      '''                             '''
    ...
    def setHorizontalScale (self, val : float)-> bool :
      '''                             '''
    ...
    def setLayer (self, val: str|PyDb.ObjectId, dosubents : bool=True, allowHiddenLayer : bool=False)-> None :
      '''This method sets entity to reference the AcDbLayerTableRecord identified by the name specified in newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the layer change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.'''
    ...
    def setLength (self, val : float)-> bool :
      '''                             '''
    ...
    def setLineWeight (self, val: PyDb.LineWeight, dosubents : bool=True)-> None :
      '''This method sets the entity to use lineweight. If the entity owns subentities and doSubents == Adesk::kTrue, then the line weight change will be applied to the subentities as well.Returns Acad::eOk if successful.Function implementation in derived classesIf this function is overridden and wishes to set the line weight of the entity, then it must call AcDbEntity::setLineWeight() passing on the lineweight and doSubents arguments.It is also possible for this function's implementation to deal directly with any subentities and pass a doSubents value of Adesk::kFalse to AcDbEntity:: setLineWeight().If the line weight setting operation is successful, then this function should return Acad::eOk. If lineweight is not an acceptable value, then this function should return Acad::eInvalidInput. Any other error return values are up to the implementer.'''
    ...
    def setLinetype (self, val: str|PyDb.ObjectId, dosubents : bool=True)-> None :
      '''Function usageThis method sets the entity to reference the AcDbLinetypeTableRecord with the name specified in newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the linetype change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.'''
    ...
    def setLinetypeScale (self, val: float, dosubents : bool=True)-> None :
      '''This method sets the entity to use newval as its linetype scale factor. newVal must be nonnegative. If the entity owns subentities and doSubents == Adesk::kTrue, then the linetype scale change will be applied to the subentities as well.'''
    ...
    def setMaterial (self, val: str|PyDb.ObjectId, dosubents : bool=True)-> None :
      '''This method sets the material reference to the specified material. The specified name must correspond to an existing AcDbMaterial object.Returns Acad::eOk when successful'''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setOrigin (self, pt : PyGe.Point2d)-> bool :
      '''                             '''
    ...
    def setOwnerId (self, owner: PyDb.ObjectId)-> None :
      '''Sets the ownerId data member of the object to be objId, thus establishing a "backpointer." This backpointer is used by WBLOCK to be sure all necessary objects are written out.Returns Acad::eOk if successful.'''
    ...

    @overload
    def setPlotStyleName (self, /)-> None : ...
    @overload
    def setPlotStyleName (self, nameType: PyDb.PlotStyleNameType, doSubents: bool)-> None : ...
    @overload
    def setPlotStyleName (self, nameType: PyDb.PlotStyleNameType, newId: PyDb.ObjectId, doSubents: bool)-> None : ...
    def setPlotStyleName (self, *args, **kwargs)-> None :
      '''Overloads:
    - None: Any
    - nameType: PyDb.PlotStyleNameType, doSubents: bool
    - nameType: PyDb.PlotStyleNameType, newId: PyDb.ObjectId, doSubents: bool
    
	-This function searches the PlotStyleName dictionary for an entry with the name that matches newName and if found, sets the entity to use that plotStyleName entry. Because a lookup in the PlotStyleName dictionary is required, the entity must be database-resident for this method to succeed. The names ByLayer and ByBlock are allowed as well as user-defined names.If the entity owns subentities and doSubents == Adesk::kTrue, then the change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.Returns Acad::eOk if successful. If the entity is not database-resident, then Acad::eNoDatabase will be returned. If there is no entry in the PlotStyleName dictionary for newName, then Acad::eKeyNotFound will be returned.The plotStyleName value is used for DXF group code 390.-'''
    ...
    def setPropertiesFrom (self, entity: PyDb.Entity, dosubents : bool=True)-> None :
      '''This method copies theColorLayerLinetypeLinetype scaleVisibilityvalues from the entity pointed to by pEntity into this entity. If the entity owns subentities and doSubents == Adesk::kTrue, then the property changes will be applied to the subentities as well.Returns Acad::eOk if successful.'''
    ...
    def setReceiveShadows (self, val: bool)-> None :
      '''Sets the property indicating whether this entity can receive shadows.'''
    ...
    def setVerticalScale (self, val : float)-> bool :
      '''                             '''
    ...
    def setVisibility (self, val: PyDb.Visibility, dosubents : bool=True)-> None :
      '''This method sets the visibility of an entity to the value specified by newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the visibility change will be applied to the subentities as well.'''
    ...
    def setXData (self, xdata: list)-> None :
      '''Each regapp sublist (delimited by a resbuf with restype == 1001 and resval.rstring == a valid regappName string) within the resbuf chain pointed to by xdata, is placed in the xdata area of the object. If any of the regappNames in xdata are already present in the xdata area of the object, then that regappName's existing data on the object is overwritten by that regappName's new data in xdata.All resbufs with restype == 1001 must have valid regappNames for the database the object resides in (that is, the regappNames must be in the APPID table of the database).Only valid xdata group codes (1000--1071) are accepted in the restype fields of the resbufs in xdata.No "-3" group code is necessary, and in fact, is not accepted. So, the first element in the resbuf chain must be a 1001 group code with a resval.rstring set to a regappName that's already registered in the regapp table. To register a regappName, use the acdbRegApp() function.To remove an appName (and its xdata) from an object, just use a resbuf with restype == 1001, resval == and no data resbufs following it (that is, either its rbnext == NULL or the next resbuf is another 1001)This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If this function is overridden, then it should supermessage its parent in order to invoke the built-in mechanism to add the xdata to the object.Returns Acad::eOk if the xdata is successfully added to the object. If there is insufficient space in the xdata area of the object, then Acad::eXdataSizeExceeded is returned. If any of the regappNames in xdata are not in the APPID table, then Acad::eRegappIdNotFound is returned.'''
    ...
    def snoop (self,  filer : PyDb.SnoopDwgFiler)-> None :
      '''                             '''
    ...
    def swapIdWith (self, otherId: PyDb.DbObject, swapXdata: bool, swapExtDict: bool)-> None :
      '''This function swaps objectIds and handles between the object specified by otherId and the object invoking this function. Both objects must currently be database-resident and must reside in the same database. If swapXdata == Adesk::kTrue, then the objects swap extended entity data as well. If swapExtDict == Adesk::kTrue, then the objects swap extension dictionaries also.If the object specified by otherId or the object invoking this function are not database-resident, then Acad::eNoDatabase is returned. If both objects involved are not in the same database, then Acad::eWrongDatabase is returned.'''
    ...
    def toWCSPoint2d (self, pt : PyGe.Point2d)-> PyGe.Point2d :
      '''                             '''
    ...
    def toWCSX (self, val : float)-> float :
      '''                             '''
    ...
    def toWCSY (self, val : float)-> float :
      '''                             '''
    ...
    def transformBy (self, matrix3d: PyGe.Matrix3d)-> None :
      '''Function usageThis function provides a means by which AutoCAD and ObjectARX applications can ask the entity to apply a transformation matrix (xform) to itself.Each entity class must implement this function, so restrictions on what types of transformations are supported are up to the implementer of the entity class. The AutoCAD built-in entity classes for entity types that existed before R13 (that is, all the classes listed in the header file dbents.h such as AcDbCircle, AcDbLine, AcDbArc, AcDb2dPolyline, etc.) require that the transformation matrix represent a uniformly scaling orthogonal transformation (if it is not, then Acad::eCannotScaleNonUniformly will be returned). Other AutoCAD built-in classes have no restrictions.Returns Acad::eOk if successful. Return values for errors are implementation-dependent.Function implementation in derived classesThis function must apply the transformation matrix xform to the entity and change the entity's state to reflect the transformation. It is completely up to the implementer as to how to apply the transformation. It is also up to the implementer to decide what, if any, restrictions will be placed on the type of transformations supported. If any restrictions are desired, then it's up to the implementation of this function to enforce them.If your derived class implements transformBy() without calling the base class, you must call AcDbObject:: xDataTransformBy() or your Xdata will not be transformed.If this function successfully transforms the entity, then it should return Acad::eOk.Return values for error conditions are completely up to the implementer of this function. However, if the error is caused by a non-uniformly scaling or non-orthogonal matrix, then to be consistent with other entities that have this restriction, it is recommended that Acad::eCannotScaleNonUniformly be returned.'''
    ...
    def update (self, bUpdateDependencies : bool=True, updateOrigin : bool=True)-> bool :
      '''                             '''
    ...
    def upgradeFromNotify (self, wasWritable: bool)-> None :
      '''Upgrades the object from being at least open AcDb::kForNotify to being open both AcDb::kForNotify and AcDb::kForWrite. The wasWritable argument is set to Adesk::kTrue if the object was already open for write, otherwise it's set to Adesk::kFalse. The wasWritable value should be saved to be passed into the downgradeToNotify() call later.This function must be followed at some point by a call to downgradeToNotify() with no open() (in any of its forms) or close() calls in between.This method should only be called from within other methods of the same object it is being called from. In other words, this method is intended to be used by an object to change it's own open status so that it can safely modify itself.upgradeFromNotify() and downgradeToNotify() call pairs are not nestable.Returns Acad::eOk if successful. If the object is not currently open AcDb::kForNotify, then Acad::eNotApplicable is returned. If the object is currently in the process of actually sending notification (that is, isNotifying() returns Adesk::kTrue), then Acad::eWasNotifying is returned.'''
    ...
    def upgradeOpen (self)-> None :
      '''If the object is currently open AcDb::kForRead with only one reader, then this function upgrades the object to open AcDb::kForWrite. In the process of changing to open for write, the object is closed, thus triggering any pertinent notification.Returns Acad::eOk if successful. If the object has more than one reader, then the open status is not changed and Adesk::eHadMultipleReaders is returned. If the object is already open AcDb::kForWrite, then Acad::eWasOpenForWrite is returned. If the object is currently sending notification, then the open status is not changed and Acad::eWasNotifying is returned.'''
    ...
    def verticalScale (self)-> float :
      '''                             '''
    ...
    def viewportDraw (self, vpdraw: PyGi.ViewportDraw)-> None :
      '''                             '''
    ...
    def viewportDrawLogicalFlags (self, vpdraw: PyGi.ViewportDraw)-> int :
      '''                             '''
    ...
    def visibility (self)-> PyDb.Visibility :
      '''This method returns the entity's current visibility state, either AcDb::kVisible or AcDb::kInvisible.'''
    ...
    def wblockClone (self, owner: PyRx.RxObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function is almost identical to AcDbObject::deepClone, except that an AcDbWblockCloneFiler is used and ownership is not carried across database boundaries. Subcloning is based on hard owner and hard pointer connections.'''
    ...
    def worldDraw (self, wdraw: PyGi.WorldDraw)-> int :
      '''                             '''
    ...
    def xData (self, appname: str = None)-> list :
      '''Returns a linked list of resbuf structures containing a copy of the xdata for the object. If regappName == NULL is passed in, all xdata is returned, otherwise only the xdata for the specified name is returned. If not all xdata is required, but the xdata for more than one regappName is desired, then multiple calls to this member function must be made--one for each regappName.The caller of this function is responsible for releasing the memory used by the resbuf list that is returned. The most commonly used way to deallocate such a list is via the acutRelRb() function.This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If a failure accessing the xdata occurs, NULL is returned.'''
    ...
    def xDataTransformBy (self, xform: PyGe.Matrix3d)-> None :
      '''This method applies the xform transformation matrix to any XData data types 1011, 1021, 1031, 1012, 1022, 1032, 1013, 1023, 1033, 1041, and 1042 in the object's XData. See the documentation on XData for more information on the way the transformation matrix is applied to the different data types.This method should be called from within the transformBy() method on custom entities so that such entities will transform XData in the same way that the built-in AcDb entities do.Returns Acad::eOk if successful.'''
    ...
    def xmitPropagateModify (self)-> None :
      '''Within an object's close() method is a call to the object's xmitPropagateModify().The AcDbObject::xmitPropagateModify() default implementation is to inform the containing database that the object has been modified, appended to the database, or erased. The database then sends out the appropriate notification to any AcDbDatabaseReactors attached to it.Within AutoCAD, this function is used by complex entities such as polylines to allow the subentities to notify the header that they have been changed. The header can then "propagate" the notification by sending its own notification that the "complex entity" has been modified.The way this works is:The subobject class has it's xmitPropagateModify() class overridden such that it calls it's parent class's xmitPropagateModify() and also calls the owning object's recvPropagateModify().The "root" or "header" class has it's recvPropagateModify() overridden to provide an implementation that triggers "modified" notification to be sent for the "root" or "header" (which effectively represents the whole complex object).The subobject's close() triggers "modified" notification for the subobject and calls the subobject's xmitPropagateModify() function. So, when the subobject's close() is called, its xmitPropagateModify() is called. This then calls the owning object's recvPropagateModify(), which then triggers the owner to send "modified" notification.So, the result is a "modified" notification from both the subentity and the "root" or "header" entity.When overridden, this function should:Call its parent class's xmitPropagateModify() (which ultimately results in the execution of AcDbObject::xmitPropagateModify() to trigger database notification).Call its owner's recvPropagateModify() (passing in its "this" pointer) to "propagate" the notification information to the "root" owner to be sent out.'''
    ...

class CvDbView(CvDbEntity):
    def __init__ (self, id: ObjectId, mode: PyDb.OpenMode=PyDb.OpenMode.kForRead, erased: bool=False)-> None :
      '''                             '''
    ...
    def addContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def addGraph (self, id : PyDb.ObjectId)-> bool :
      '''                             '''
    ...
    def addPersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Adds the database-resident object specified by objId to the reactor list of the AcDbObject object.'''
    ...
    def addReactor (self, reactor: PyDb.EntityReactor)-> None :
      '''                             '''
    ...
    def addSubentPaths (self, paths: list[PyDb.FullSubentPath])-> None :
      '''Adds one or more subentities to an entity.The prototype of this method is provided for completeness of the subentity manipulation APIs. AutoCAD will never call this method on a custom object.Returns Acad::eOk if successful. The default implementation returns Acad::eNotAvailable.'''
    ...
    def assertNotifyEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should be used inside of member functions that are only called when the object is open kForNotify. When used, it should be the first function called inside the member function.'''
    ...
    def assertReadEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that access the object's data in a read-only fashion (for example, dxfOutFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is open AcDb::kForRead.If this function is called while the object is not open, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def assertWriteEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that modify the object's data (for example, dxfInFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is indeed open for write (if it is not, then AutoCAD terminates); to trigger an immediate sending of "openedForModify" notification; to set up the notification mechanism so that "modified" and "modifiedGraphics" (if the object is derived from AcDbEntity) are sent at the appropriate times; and to ensure that graphics get updated if the object is derived from AcDbEntity.If this function is called on a database resident object, "openedForModify" will be sent if the object is not newly created, and "modified", and "modifiedGraphics" (if appropriate) notifications will be sent when the object is next closed.If recordModified is false, then the autoUndo argument is ignored, and the undo filer is not initialized, no undo recording will take place, but notifications will be sent.If autoUndo and recordModified are both true, then automatic undo recording will be performed and notifications will be sent.If autoUndo is false and recordModified is true, then there will not be any automatic undo recording, but the undo filer is initialized and the object must manually write out partial Undo records and must implement its applyPartialUndo() method. Notifications will be sent.If this function is called while the object is not open AcDb::kForWrite, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def baseElevation (self)-> float :
      '''                             '''
    ...
    def baseHAlignment (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def blockId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the entity's owner, which must be an AcDbBlockTableRecord.If the entity does not have an owner yet, then AcDbObjectId::kNull will be returned.'''
    ...
    def bounds (self, ext: PyDb.Extents)-> bool :
      '''                             '''
    ...
    def cancel (self)-> None :
      '''Terminates the current open operation. All changes made to the object since it was opened are undone, the object is marked as closed, and "cancel" notification is sent.Returns Acad::eOk if successful.'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbView :
      '''                             '''
    ...
    def castShadows (self)-> bool :
      '''Returns a boolean value that indicates whether the entity can cast shadows. '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...

    @staticmethod
    def cloneFrom (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbView :
      '''                             '''
    ...
    def close (self)-> None :
      '''Closes the object. All changes made to the object since it was opened are committed to the database, the object is marked as pageable, and a "closed" notification (as well as any other appropriate notification such as "modified", "erased", and so on) is sent.Returns Acad::eOk if successful.If the object is not in an AcDbDatabase yet, then Acad::eNoDatabase is returned.If the object is sending notification, then Acad::eCloseWasNotifying is returned.If the subClose() call made within the close() method returns anything other than Acad::eOk, then that ErrorStatus is returned.'''
    ...
    def collisionType (self)-> PyDb.CollisionType :
      '''This function returns the collision detection treatment for this entity. Subclasses may override this method to customize how the class interacts in collision-aware features.'''
    ...
    def color (self)-> PyDb.Color :
      '''This function returns the full true color information for the entity within an instance of AcCmColor.The index value will be in the range 0 to 256. 0 and 256 are special values.0 indicates the entity uses the color of the BlockReference that's displaying it. If the entity is not displayed through a BlockReference (for example, it's directly owned by the model space BlockTableRecord) and its color is 0, then it will display as though its color were 7.256 indicates the entity uses the color specified in the LayerTableRecord it references.'''
    ...
    def colorIndex (self)-> int :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...
    def createExtensionDictionary (self)-> None :
      '''Creates an AcDbDictionary object and sets it up as the extension dictionary for the AcDbObject.Returns Acad::eOk if successful. If an extension dictionary already exists, Acad::eAlreadyInDb is returned.'''
    ...
    def database (self)-> PyDb.Database :
      '''Returns a pointer to the AcDbDatabase object that contains the AcDbObject.'''
    ...
    def deepClone (self, owner: PyDb.DbObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function gives control of deep clone operations to the object. In the default implementation, the object is cloned and appended to the owner object (pOwnerObject). The cloning is performed by an AcDbDeepCloneFiler. A record is also added to the idMap. Then, using the filer, any owned objects are deep cloned, with isPrimary set to Adesk::kFalse.'''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def disableUndoRecording (self, disable: bool)-> None :
      '''Turns off or on the Undo recording for the object. If disable == Adesk::kTrue, then Undo recording is turned off until this function is called with disable == Adesk::kFalse, at which time Undo recording is turned back on.'''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def downgradeOpen (self)-> None :
      '''Downgrades the object from being open AcDb::kForWrite, to being AcDb::kForRead. In the process, all changes made to the object while it was open for write are committed to the database and appropriate notification is sent.'''
    ...
    def downgradeToNotify (self, wasWritable: bool)-> None :
      '''Restores an object from being open both AcDb::kForNotify and AcDb::kForWrite, to being open just AcDb::kForNotify. The wasWritable value that was returned from the matching AcDbObject::upgradeFromNotify() call should be passed into this function to restore the proper open status.This function must have been preceded by a call to upgradeFromNotify().Returns Acad::eOk if successful.'''
    ...
    def draw (self)-> None :
      '''This function queues up the entity's graphics and flushes the graphics queue, forcing the entity and anything else in the queue to be drawn or re-drawn on-screen.Returns Acad::eOk if successful.If the entity is not in a database, then Acad::eNotInDatabase will be returned.If the entity is in a database other than the one currently loaded into the AutoCAD editor, then Acad::eNotCurrentDatabase will be returned.'''
    ...
    def drawableType (self)-> PyGi.GiDrawableType :
      '''                             '''
    ...
    def entityColor (self)-> PyDb.EntityColor :
      '''This function returns the color settings of the entity in an AcCmEntityColor form. Most clients should use the color() function, which returns the heavyweight AcCmColor object. However, if color name information is not required, this function provides faster access to the lightweight AcCmEntityColor data.'''
    ...
    def erase (self, erasing : bool=True)-> None :
      '''Sets the erase bit of the object. If erasing == Adesk::kTrue, then the erase bit is set on. If erasing == Adesk::kFalse, then the erase bit is set off.'''
    ...
    def explode (self)-> list :
      '''Function UsageThis function is primarily intended for AutoCAD to call as part of an explode operation that includes this entity. However, this function can be used by ObjectARX applications to obtain an array of pointers to non-database-resident entity objects that are what the entity considers to be its exploded parts.When calling this function, the entitySet array does not need to be empty. This function will append to it, and pointers to entities that it creates to be used in its place as the "exploded" result.If this function is successful, it will return Acad::eOk. Other return values may vary depending on how it has been implemented.Function Implementation in Derived ClassesThis function should dynamically create (using the new operator) whatever entity objects are appropriate to be used to replace the entity after an explode operation has taken place. Pointers to these entities are then appended to the entitySet array. Once the pointers have been appended, the function should return with a status of Acad::eOk.'''
    ...
    def extensionDictionary (self)-> PyDb.ObjectId :
      '''Returns the objectId of the extension dictionary owned by the object. If the object does not own an extension dictionary, then the returned objectId is set to AcDbObjectId::kNull.'''
    ...
    def fromWCSPoint2d (self, pt : PyGe.Point2d)-> PyGe.Point2d :
      '''                             '''
    ...
    def fromWCSX (self, val : float)-> float :
      '''                             '''
    ...
    def fromWCSY (self, val : float)-> float :
      '''                             '''
    ...
    def getCompoundObjectTransform (self)-> PyGe.Matrix3d :
      '''This function is intended to be overridden by derived classes that are compound objects (in other words, objects that behave like blocks in the display list).A compound object has little or no geometry of its own; instead it relies on nested entities, perhaps the contents of a BlockTableRecord, to represent itself. A compound object must use the same transformation matrix for all of its contained entities. Otherwise selection and osnap will not function correctly. This is the method that the system uses to obtain that matrix from the compound object.This method should only be overridden if you return the kDrawableIsCompoundObject flag from setAttributes. The matrix you should return here is the one that you pass to pushModelTransform before you render your nested objects. You must override this method if you return the compound object flag in setAttributes, even if you don't push a transform for your nested objects. In that case you would return Acad::eOk and the identity transform in xMat.Default implementation: Returns Acad::eNotApplicable and the identity matrix in xMat.'''
    ...
    def getEcs (self)-> PyGe.Matrix3d :
      '''This function is intended to be overridden by derived classes that need to be able to provide access to an object coordinate system for objects of the class. The intent is that this function provide a transformation matrix that can be used to transform vectors or points from the object's object coordinate system (OCS) to the World Coordinate System (WCS).Default implementation: Return the identity matrix (ones along the diagonal, zeros elsewhere) in retVal.We recommend that all data stored in custom classes be stored in WCS coordinates. If this is done, then the object's OCS will be the WCS and the transformation matrix will be the identity matrix. Then this function will not need to be overridden since the identity matrix is this function's default return.'''
    ...
    def getField (self, prop: str='TEXT')-> PyDb.ObjectId :
      '''Gets the field ID. A field can be stored in an object using the property name as the key.Returns Acad::eOk if the object has a field for the specified property. Otherwise, returns an AutoCAD error status.'''
    ...
    def getFieldDictionary (self)-> PyDb.ObjectId :
      '''Returns the field dictionary ID. The field dictionary stores all the fields set in the object as property name-field object pairs. The ID will be null if there is no field in the object.'''
    ...
    def getGeomExtents (self)-> PyDb.Extents :
      '''Unimplemented at the AcDbEntity level, this method is intended to be overridden in derived classes.Derived classes should calculate and return the corner points (in WCS coordinates) of a box (with edges parallel to the WCS X, Y, and Z axes) that encloses the 3D extents of the entity, and return those points as an instance of class AcDbExtents in the "extents" parameter.Default implementation: Immediately returns Acad::eInvalidExtents.'''
    ...
    def getGeomExtents2d (self)-> PyDb.Extents2d :
      '''                             '''
    ...

    @overload
    def getGripPoints (self, /)-> tuple[Any,...] : ...
    @overload
    def getGripPoints (self, curViewUnitSize: float, gripSize: int, curViewDir: PyGe.Vector3d, bitflags: int)-> tuple[Any,...] : ...
    def getGripPoints (self, *args, **kwargs)-> tuple[Any,...] :
      '''Overloads:
    - None: Any
    - curViewUnitSize: float, gripSize: int, curViewDir: PyGe.Vector3d, bitflags: int
    
	-Function usageThis function supports "old style" grips, in applications that existed before the enhancement of grip functionality by the addition of the AcDbGripData class.This function is not intended to be called by ObjectARX applications. However, it is possible to do so (for example, as a pass-through from the getStretchPoints() method).Function implementation in derived classesThis function should append to the gripPoints array any points that are to treated as grip points for the entity.The gripPoints array is passed to all entities involved in the grip operation, so the array may already contain grip points for other entities. Therefore, it is very important to append the new points rather than assigning them to any existing elements in the array.When finished appending all desired grip points, return Acad::eOk. If anything other than Acad::eOk is returned, then grips are not activated for this entity.The osnapModes and geomIds arguments are not currently used.Default implementationImmediately returns Adesk::eNotImplemented.-'''
    ...
    def getHandle (self)-> PyDb.Handle :
      '''Fills in handle with the handle value for the object. If the object is not yet database-resident, then it will not have a handle. Use AcDbHandle::isNull to test for this condition.'''
    ...
    def getPlane (self)-> PyGe.Plane :
      '''If the entity is planar, then the plane containing the entity is returned in plane and flag is set to AcDb::kPlanar.If the entity is nonplanar, but is linear, then plane is set to an arbitrary plane that contains the entity and flag is set to AcDb::kLinear.If the entity is nonplanar and nonlinear, then plane is left unset and flag is set to AcDb::kNonPlanar.Returns Acad::eOk if successful. Other ErrorStatus return values are implementation-dependent.The default implementation is to return Acad::eNotApplicable.'''
    ...
    def getPlotStyleNameId (self)-> PyDb.ObjectId :
      '''Returns with id set to the object ID of the AcDbPlaceHolder object referenced by the entity. The AcDbPlaceHolder object resides in the plot style name dictionary, and its key in the dictionary is the plot style name.Use the AcDbDictionary::nameAt() function on the plot style name dictionary to get the plot style name string that corresponds to the ID obtained by this function.'''
    ...
    def getStretchPoints (self)-> list :
      '''Function usageThis function is not intended to be called by ObjectARX applications. However, it is possible to do so (for example, as a pass-through from the getGripPoints() method).Function implementation in derived classesThis function should append to the stretchPoints array any points that are to treated as stretch points for the entity.Stretch points are used by the stretch command within AutoCAD. Any stretch points that are within the crossing selection window during the stretch command, will be moved by whatever amount the user decides to "stretch" the selected entities. Any stretch points not in the crossing selection window will be left alone. This combination of some stretch points moving while others do not is what "stretches" the entity. If all stretch points are in the crossing window, then the entity is moved instead of stretched.The stretchPoints array is passed to all entities involved in the stretch operation, so the array may already contain stretch points for other entities. Therefore it is very important to append the new points rather than assigning them to any existing elements in the array.When finished appending all desired stretch points, return Acad::eOk. If anything other than Acad::eOk is returned, then this entity's stretch points will be ignored by the stretch operation.Default implementationCalls the AcDbEntity::getGripPoints() method. So, unless the entity needs to have stretch points that are different from the grip points, there is no need to override this method.'''
    ...
    def getSubentPathsAtGsMarker (self, type: PyDb.SubentType, gsMark: int, pickPoint: PyGe.Point3d, viewXform: PyGe.Matrix3d)-> list[PyDb.FullSubentPath] :
      '''Entities use various graphic primitives defined in AcGi to draw themselves. Part of this mechanism is the ability to associate an integer identifier called a graphics system marker (or, GS marker) with each primitive or with groups of primitives. Through the use of certain selection mechanisms, the GS marker for the actual subentity selected on screen can be obtained and, along with some other information passed into this function, can be used to create one or more AcDbFullSubentPath objects, each one representing a subentity and providing a more complete description of the subentity and its environment. These AcDbFullSubentPath objects can be used by several other functions for various purposes such as highlighting or unhighlighting the subentities on screen.Function usageIf the entity (of which the subentity is a part) is directly owned by the model or paper space BlockTableRecords, then leave out numInserts and entAndInsertStack so that their default value will be used.Typically the GS marker is obtained via the use of ads_ssget() followed by ads_ssnamex() (see the ObjectARX Developer's Guide for more information on this).The pickPoint can be obtained from ads_ssnamex() as well (it's the first group 5009 in the returned list).The viewXform can be calculated using the ads_trans() function on the vectors (1,0,0), (0,1,0), and (0,0,1) to translate them from DCS to WCS. The translations of these three vectors (with an extra 0 appended on to the end of each) would be used as the first three rows of the matrix. The last row is not used so it can be left as is. This argument is not used by any of the AutoCAD built-in entities.If the entity is nested inside one or more block definitions, then the numInserts and entAndInsertStack arguments must also be filled in with non-zero or non-null values. If they are not filled in, then this function will fail and return an error status. One way to get the necessary object IDs is to use ads_nentselp() to obtain the list of ads_names of the container objects. This list must then be converted to object IDs and reversed.Upon return, the subentPaths argument will point to a dynamically allocated array of one or more AcDbFullSubentPath objects. The numPaths argument will contain the number of AcDbFullSubentPath objects being returned.The calling application is responsible for deallocating the memory used by the subentPaths array. The C++ delete [ ] should be used.Return values for this function may vary depending on how the function has been implemented (see below).Function implementation in derived classesEntity classes which do not set GS markers probably should not implement this function since the GS marker is the primary (and often the only) means of subentity distinction.When implemented, this function must use the material provided in type, gsMark, pickPoint, viewXform, numInserts, and entAndInsertStack to determine which subentity or subentities meet the criteria in these arguments. Next it must create a dynamically allocated array of AcDbFullSubentPaths (using the C++ new operator) with one element for each subentity determined in the first step. Finally it must fill in each AcDbFullSubentPath object in the array with the information appropriate to the subentity it will represent.If numInserts == 0 and entAndInsertStack == NULL, it's important to check to be sure that the entity's owner is indeed the model or paper space BlockTableRecord. This can be done by using the entity's ownerId() method to obtain the objectId of its owner, and then opening up that object and using its name() method to obtain its name string. If the owner is not the model or paper space BlockTableRecord, and numInserts == 0 or entAndInsertStack == NULL, or both, then the input data is invalid and this function should set numPaths to 0, set subentPaths to NULL and then return the error status Acad::eInvalidInput.Each AcDbFullSubentPath object has two parts, an array of objectIds containing all the container objects, and an embedded AcDbSubentId object which in turn has two elements: an index value and a SubentityType.If the "main" entity (the entity on which this function is being called) is not nested within BlockReferences (that is, numInserts == 0 and entAndInsertStack == NULL), then the objectId array should contain only the objectId of the "main" entity. If the "main" entity is nested in one or more BlockReferences, then the AcDbObjectIdArray is the same as entAndInsertStack, so copying the entAndInsertStack elements into the AcDbObjectIdArray is all that's required.The SubentType data item within the embedded AcDbSubentId should be set the same as type.The index data item within the embedded AcDbSubentId can be any value you wish (it is often simply the GS marker), but if implemented, the following functions must be able to interpret them to determine the corresponding GS marker(s) or subentity (or subentities):getGsMarkersAtSubentPath()subentPtr()The pickPoint and viewXform arguments are provided as extra aids (if necessary) in determining which subentity is involved. For example, some entity types might display differently depending on the display viewpoint. The viewXform transformation matrix can be used in such cases.The viewXform argument provides a transformation matrix to transform from WCS (World Coordinate System) to DCS (display coordinate system).The display coordinate system is oriented such that the positive Z axis is coming out of the display screen towards the user, the positive X axis is horizontally from left to right on screen, and the positive Y axis is vertically upwards on screen.So, if the current viewpoint is at (1,0,0) (the viewer is always looking towards (0,0,0)) then the viewXform matrix would be:0 1 0 00 0 1 01 0 0 00 0 0 1In this matrix the last row and the last column are not used. Notice also that the third row is the DCS Z axis in WCS coordinates (which is the WCS version of the AutoCAD VIEWPOINT system variable).When this function returns, the return code to use is completely up to the implementer, but to be consistent with other existing entity class implementations of this function the following should be used:If the function succeeds, it should return Acad::eOk.If an invalid or unsupported SubentType is passed in, then numPaths should be set to 0, subentPaths should be set to NULL, and Acad::eWrongSubentityType should be returned.If an invalid GS marker (or any other data item that turns out to be needed) is passed in, then numPaths should be set to 0, subentPaths should be set to NULL, and Acad::eInvalidInput should be returned.Default implementationImmediately returns Adesk::eNotApplicable.'''
    ...
    def getTransformedCopy (self, matrix3d: PyGe.Matrix3d)-> PyDb.Entity :
      '''Function usageThis function creates a clone of the entity, applies the xform transformation matrix to the clone, and then returns with pEnt pointing to the transformed clone.Returns Acad::eOk if successful.If xform is a non-uniform scaling matrix or non-orthogonal then Acad::eCannotScaleNonUniformly or Acad::eNotImplemented is returned.WarningFor AutoCAD built-in complex entities such as polylines, this function produces a shallow clone of the header entity only, which also owns the original set of "owned" entities (such as vertices for a polyline) which are then transformed by the xform matrix. This results in a corrupt drawing (two header entities owning the same set of "owned" entities) as well as transforming the original set of "owned" entities instead of a copied set.Function implementation in derived classesThe default AcDbEntity implementation of this function should be adequate for most derived entity types. However, derived entity classes that wish to support non-uniform scaling or non-orthogonal transformations will need to override this method with their own implementation.This function must create a copy of the entity (using memory that has been dynamically allocated via the C++ new operator), apply the transformation matrix xform to the copy and then return with pEnt pointing to the transformed copy.Determining what constitutes a valid transformation matrix and whether to do a shallow clone (that is, the entity's clone() method), a deepclone (if the entity owns other objects), or no clone at all (that is, make this function a no-op), is up to the implementer.Return values for this function are also up to the implementer, but to be consistent with other existing classes the following is recommended:If the function succeeds, it should return Acad::eOk.If the function is to be a no-op, it should return Acad::eNotImplementedIf non-uniform scaling is not to be supported and a non-uniform scaling matrix is passed in, then either Acad::eCannotScaleNonUniformly or Acad::eNotImplemented should be returned.Default implementationIf the entity is uniformly scaled and orthogonal, AcDbEntity::getTransformedCopy will call the entity's clone() method to create a clone of the entity, then call AcDbEntity::transformBy() on the clone, and then return with pEnt set to point to the transformed clone. If xform is a non-uniformly scaled or a non-orthogonal matrix, then this function will return Acad::eNotImplemented.'''
    ...
    def graphAt (self, val : int)-> PyDb.ObjectId :
      '''                             '''
    ...
    def graphCount (self)-> int :
      '''                             '''
    ...
    def handOverTo (self, newObject: PyDb.DbObject, keepXData: bool, keepExtDict: bool)-> None :
      '''This function provides the ability to exchange a non-database-resident object (NDBRO) in place of an existing database-resident object (DBRO) while retaining the objectId, handle, and reactor list of the DBRO. An example of this situation is when the BREAK command is used to break a circle into one or two arc segments. AcDbArc is a completely different class from AcDbCircle, so a new AcDbArc object must be substituted in place of the AcDbCircle object that is there now, yet the arc must get the handle and objectId that the circle has.To use the handOverTo() function, the object to be replaced (the AcDbCircle in the example) must be open AcDb::kForWrite. The object's handOverTo() function is called with newObject pointing to a non-database-resident object that replaces it (the AcDbArc in the example).keepXData is set to Adesk::kTrue if the xdata is to be retained or Adesk::kFalse if the xdata is to be thrown out.keepExtDict is set to Adesk::kTrue if the extension dictionary and its contents are to be retained, or set to Adesk::kFalse if the extension dictionary and its contents are to be thrown out.Once returned from this function, the replacement object (the AcDbArc in the example) is open for AcDb::kForWrite and must have its close() member called to commit the change and close out Undo recording. Then it's up to the ObjectARX application to delete the old object (the AcDbCircle in the example) from memory since it's no longer database-resident.Returns Acad::eObjectToBeDeleted if the operation is successful. If newObject is pointing to an object that is already in the database, or the object invoking handOverTo() is not database-resident, then Acad::eIllegalReplacement is returned.'''
    ...
    def hasFields (self)-> bool :
      '''Returns true if the object has one or more PyDb.Field Objects. Otherwise returns false.'''
    ...
    def hasPersistentReactor (self, id: PyDb.ObjectId)-> bool :
      '''This method returns true if objId is the object ID of a reactor attached to this object. Otherwise, it returns false.'''
    ...
    def hasXData (self, appname: str)-> bool :
      '''                             '''
    ...
    def height (self)-> float :
      '''                             '''
    ...
    def highlight (self, path: PyDb.FullSubentPath = None, highlightAll : bool = False)-> None :
      '''Function usageThis function uses the AcDbFullSubentPathid to determine which subentity in the entity is desired. It then highlights that subentity on screen. If no AcDbFullSubentPath argument is provided, then the entire entity will be highlighted.Typically, the AcDbFullSubentPath object passed in via subId is obtained from the entity's AcDbEntity::getSubentPathsAtGsMarker() method. This guarantees that it is fully and properly filled in.This function uses the entity's getGsMarkersAtSubentPath() method to get the GS markers associated with subId. If that function does not return Acad::eOk, then this function will fail and return whatever ErrorStatus was returned by getGsMarkersAtSubentPath().If this function succeeds, then it returns Acad::eOk.It is not necessary to balance each highlight() function call with a corresponding call to unhighlight(). Calling the unhighlight() function will unhighlight the entity designated by subId regardless of how many times the highlight function has been called on it.WarningIf the entity on which this method is called has its graphics queued for regeneration (that is, changes have been made to the entity but have not yet been reflected on screen), then this method will not cause a highlight to occur. Also, calling this method on an entity that's open for write and whose graphics are queued for regeneration may terminate AutoCAD.To avoid this limitation, before calling highlight(), you should flush the entity's graphics by either calling the entity's draw() method, or calling the AcTransactionManager::flushGraphics() function.Function implementation in derived classesThe AcDbEntity::highlight() implementation does all the work necessary to highlight any subentities that correspond to the subIdFullSubentPath. So, there is no need to override this method unless you wish to do some pre-or post-processing, or you wish to disable the ability to highlight subentities.If this method is overridden and it is supposed to highlight subentities, then the AcDbEntity::highlight() method will need to be invoked at some point within this function in order to do the actual highlighting.Within the AcDbEntity::highlight() method, the getGsMarkersAtSubentPath() method of this entity is called to translate the FullSubentPath into the corresponding GS markers. So, if this function is to succeed, the getGsMarkersAtSubentPath() method needs to be implemented as well.For more information on the subIdAcDbFullSubentPath argument, see the documentation on the getGsMarkersAtSubentPath() or getSubentPathsAtGsMarker() methods.'''
    ...
    def horizontalScale (self)-> float :
      '''                             '''
    ...
    def id (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...

    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, thisGsMarker : int, otherGsMarker : int)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane, thisGsMarker : int, otherGsMarker : int)-> list : ...
    def intersectWith (self, *args, **kwargs)-> list :
      '''Overloads:
    - entity: PyDb.Entity, intType : PyDb.Intersect
    - entity: PyDb.Entity, intType : PyDb.Intersect, thisGsMarker : int, otherGsMarker : int
    - entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane
    - entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane, thisGsMarker : int, otherGsMarker : int
    
	-Function usageIt finds the intersections of the entity pointed to by pEnt and all the edges of the bounding box of this entity.The intType is used to determine how to deal with extending the two entities in order to calculate intersections. The possible AcDb::Intersect values are:AcDb::kOnBothOperandsDo not extend either entity. This results in only calculating intersections where the two entitys' geometry actually intersectAcDb::kExtendThisExtend this entity (if necessary) when calculating intersections, but do not extend the pEnt entity.AcDb::kExtendArgExtend the pEnt entity (if necessary) when calculating intersections, but do not extend this entity.AcDb::kExtendBothExtend both the pEnt entity and this entity (if necessary) when calculating intersectionsAny intersection points found are appended to the points array. All points are in WCS coordinates.The thisGsMarker and otherGsMarker arguments are intended to provide this function with information to allow it to localize the search for intersections to be between specific subentities. However, this function is not required to make use of either of these arguments (most, if not all, of the AutoCAD built-in entity classes do not). When calling this function, either or both of these arguments may be 0 in order to indicate that they should be ignored.If this function is successful it returns Acad::eOk. Return values for error conditions are dependent on the implementation of this function in the classes involved.Function implementation in derived classesThis function should do all it can to find all intersection points between the entity it's being called on and the entity pointed to by pEnt. All intersection points found should be appended to the points array. All such points must be in WCS coordinates.When implementing the intersection calculation portion of this function you should take a good look at the AcGe classes to see if they can provide any useful functionality to help in finding intersections with the geometric primitives that make up the entity this function is being called on and the pEnt entity. For example, the AcGeCurve3d class has an isOn() method that will indicate if a supplied point is on the curve and the AcGeCircArc3d class has several intersectWith() methods to find intersections with other AcGe types.If the pEnt entity is a type not recognized by this function, it is quite reasonable to call the pEnt entity's intersectWith() method passing in a pointer to this entity as the "pEnt", and all the other arguments passed into this function (remembering to convert the intType argument If necessary) to see if that entity can determine any intersection points. This is what the AutoCAD built-in classes do.Also, don't forget to take into account the intType value. The intType tells you which, if any, of the two entities should be extended to find "apparent" intersections. It is not required that apparent intersection be supported, but if it is not, then an appropriate ErrorStatus value should be returned to indicate that the call failed.The thisGsMarker and otherGsMarker arguments are provided to allow this function to determine exactly which subentities are involved in the intersection operation (for example, if this function is being called by AutoCAD as part of an intersection Osnap operation these arguments would indicate which subentities are within the osnap pickbox). For these arguments, a value less than or equal to zero indicates that that argument should not be used.If this function completes successfully (even if no intersection points are found), it should return Acad::eOk. Determining what is considered an error and what ErrorStatus return code to use for any such errors are up to the implementer -- there are no conventions in this regard.Default implementationImmediately returns Acad::eNotImplemented.-'''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isAProxy (self)-> int :
      '''Returns Adesk::kTrue if the object is a proxy object or entity. Otherwise returns Adesk::kFalse.'''
    ...
    def isAcDbObjectIdsInFlux (self)-> int :
      '''This function refers to a condition that occurs during deep clone operations. It returns Adesk::kTrue when the cloned objects' IDs have not yet been translated and thus cannot be used in any operations on the objects. This condition normally occurs only during AcEditorReactor::beginDeepCloneXlation, AcDbObject::deepClone, or AcDbObject::wblockClone. Any operations that involve AcDbObjectId references, such as symbol table records, should be postponed until after endDeepClone. AcDbObject::subClose is never called on any objects whose IDs are in flux.'''
    ...
    def isAnnotative (self)-> PyDb.AnnotativeStates :
      '''                             '''
    ...
    def isCancelling (self)-> int :
      '''Returns Adesk::kTrue if the object is currently in the middle of a cancel() call (that is, an open is being canceled and all changes made are being rolled back). Otherwise returns Adesk::kFalse.'''
    ...
    def isEraseStatusToggled (self)-> int :
      '''Returns Adesk::kTrue if the object's erase bit has been toggled since it was opened. Otherwise returns Adesk::kFalse.'''
    ...
    def isErased (self)-> int :
      '''Returns Adesk::kTrue if the object is currently erased. Otherwise returns Adesk::kFalse.'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isModified (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called). Otherwise returns Adesk::kFalse.'''
    ...
    def isModifiedGraphics (self)-> int :
      '''Returns Adesk::kTrue if the object is derived from AcDbEntity and has had either an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called), or its recordGraphicsModified() function called with an Adesk::kTrue argument value.Otherwise it returns Adesk::kFalse.'''
    ...
    def isModifiedXData (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called) and has then had its setXData() method called. Otherwise it returns Adesk::kFalse.'''
    ...
    def isNewObject (self)-> int :
      '''Returns Adesk::kTrue if the object has not yet been closed since it was first created. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifyEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForNotify. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifying (self)-> int :
      '''Returns Adesk::kTrue if the object is in the process of sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isPersistent (self)-> int :
      '''                             '''
    ...
    def isPlanar (self)-> int :
      '''This function returns Adesk::kTrue if and only if there is a plane that contains the entity. Otherwise Adesk::kFalse is returned.'''
    ...
    def isReadEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForRead. Otherwise returns Adesk::kFalse.'''
    ...
    def isReallyClosing (self)-> int :
      '''Returns true if calling close() at this time would really close the object completely. For example, if the object is not in a transaction, and is open for read with only one reader, then Adesk::kTrue would be returned. If, on the other hand, the object is in a transaction, then Adesk::kFalse would be returned.'''
    ...
    def isTransactionResident (self)-> int :
      '''Returns Adesk::kTrue if the object is currently part of a transaction. Otherwise returns Adesk::kFalse.'''
    ...
    def isUndoRecordingDisabled (self)-> bool :
      '''Returns true if undo recording is disabled.'''
    ...
    def isUndoing (self)-> int :
      '''Returns Adesk::kTrue if the object is involved in an Undo operation at this time. Otherwise returns Adesk::kFalse.'''
    ...
    def isWriteEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForWrite and is not currently sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def layer (self)-> str :
      '''This function returns a copy of the name string in the AcDbLayerTableRecord object referenced by the entity.The calling application is responsible for deallocating the memory used by the returned string. The acutDelString() function is recommended.WarningCalling this function before the entity has had its referenced layer object ID set (that is, it's still set to AcDbObjectId::kNull) will terminate AutoCAD. If the referenced layer objectId is AcDbObjectId::kNull when the entity is added to a database, it will be set to the object ID of the database's current default layer.'''
    ...
    def layerId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the AcDbLayerTableRecord referenced by the entity. If the layerId has not been set yet, then AcDbObjectId::kNull is returned.'''
    ...
    def length (self)-> float :
      '''                             '''
    ...
    def lineWeight (self)-> PyDb.LineWeight :
      '''This function returns the AcDb::LineWeight of the entity.'''
    ...
    def linetype (self)-> str :
      '''This function returns a copy of the name string in the AcDbLinetypeTableRecord object referenced by the entity.The calling application is responsible for deallocating the memory used by the returned string. Either the C++ delete [ ] or the C free() function may be used.Warning Calling this function before the entity has had its referenced linetype object ID set (that is, it's still set to AcDbObjectId::kNull) will terminate AutoCAD. If the referenced linetype objectId is AcDbObjectId::kNull when the entity is added to a database it will be set to the object ID of the database's current default linetype.'''
    ...
    def linetypeId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the AcDbLinetypeTableRecord referenced by the entity. If the linetypeId has not been set yet, then AcDbObjectId::kNull will be returned.'''
    ...
    def linetypeScale (self)-> float :
      '''This function returns the linetype scale factor for the entity.'''
    ...
    def list (self)-> None :
      '''Function usageThis function is intended to be called from AutoCAD whenever the entity is selected during the LIST command. However, it can be called from ObjectARX applications if desired.This function will print entity specific information to the AutoCAD command line.Function implementation in derived classesWhen implementing this function in a derived class, the first thing that should be done in the function is to make a call to assertReadEnabled(). The next thing to do is to call the parent class's list() method to allow the parent class to list it's information (the parent class should in turn call its parent class first and so on up the inheritance chain until AcDbObject is reached. This way all the entity's information will be properly printed out in order). Once the parent class's list function has been called then a series of ads_printf() calls can be used to list whatever information is desired.Default implementationLists out the entity's DXF name, the layer, the space the entity resides in (model or paper), and the entity's handle.'''
    ...
    def material (self)-> str :
      '''Returns the material name.'''
    ...
    def materialId (self)-> PyDb.ObjectId :
      '''Returns the ID of the associated AcDbMaterial object.'''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def objectId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the object. If the object is not yet database-resident, then the returned objectId will be set to AcDbObjectId::kNull.'''
    ...
    def origin (self)-> PyGe.Point2d :
      '''                             '''
    ...
    def ownerId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the owner of the object. If the object does not yet have an owner, or the ownerId data member has not yet been set using AcDbObject::setOwnerId, then the returned objectId will be set to AcDbObjectId::kNull.Appending the object to a BlockTable record, a symbol table, or a dictionary automatically calls AcDbObject::setOwnerId.'''
    ...
    def plotStyleName (self)-> str :
      '''This function returns a copy of the plotStyleName string of the entity. The caller is responsible for deallocating the returned string.The plotStyleName value is used for DXF group code 390.'''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def receiveShadows (self)-> bool :
      '''Returns a boolean value indicating whether this entity can receive shadows.'''
    ...
    def recordGraphicsModified (self)-> None :
      '''This method sets the entity's state to indicate whether or not the entity should be updated on screen when it is closed. If the entity is set not to update, then any changes made will appear the next time the entity is regenerated.If setModified is false and the entity is currently set to update its graphics on close (which is its default state), then this function sets the entity so that it will not update on screen when it is closed and objectModified notification is sent to all entity type reactors attached to the entity. If setModified is false and the entity is already set not to update its graphics on close, then this function simply returns.If setModified is true, then the entity is set to update on screen when it is closed.'''
    ...
    def releaseExtensionDictionary (self)-> None :
      '''Removes the object's extension dictionary (that is, removes the object as the owner of the dictionary object) if it exists and is empty. Once removed, this function calls the dictionary's erase() method. Any reactors attached to the extension dictionary receive normal notification appropriate to an open for write, erase, close sequence.Returns Acad::eOk if successful.If the dictionary is not empty, then this function fails and returns Acad::eContainerNotEmpty.'''
    ...
    def removeContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def removeField (self, id: str|PyDb.ObjectId)-> None :
      '''Removes the specified field.Returns Acad::eOk if successful. Otherwise, returns an AutoCAD error status.'''
    ...
    def removeGraph (self, id: PyDb.ObjectId)-> bool :
      '''                             '''
    ...
    def removePersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Removes the persistent reactor specified by objId from the reactor list of the object. The object must be open AcDb::kForWrite to be able to execute this function.Returns Acad::eOk if successful. If the object is currently sending notification and is not open AcDb::kForWrite, then Acad::eWasNotifying is returned.'''
    ...
    def removeReactor (self, reactor: PyDb.EntityReactor)-> None :
      '''                             '''
    ...
    def rolloverHit (self, nSubentId: int, nMouseFlags: int, bReset: bool)-> int :
      '''                             '''
    ...
    def setAcDbObjectIdsInFlux (self)-> None :
      '''This function must be called on any newly created objects in AcDbObject::deepClone or AcDbObject::wblockClone. It indicates that reference object IDs are not yet pointing to the correct objects. The references can be translated only when the entire deep clone operation is complete. The flag is cleared at that time.'''
    ...
    def setAnnotative (self, state : PyDb.AnnotativeStates)-> None :
      '''                             '''
    ...
    def setAttributes (self, traits: PyGi.DrawableTraits)-> int :
      '''                             '''
    ...
    def setBaseElevation (self, val : float)-> bool :
      '''                             '''
    ...
    def setBaseHAlignment (self, id : PyDb.ObjectId)-> bool :
      '''                             '''
    ...
    def setCastShadows (self, val: bool)-> None :
      '''Sets the property to indicate whether the entity can cast shadows.'''
    ...
    def setColor (self, clr: PyDb.AcCmColor, dosubents : bool=True, db : PyDb.Database='current')-> None :
      '''Function usageThis method sets the entity's color to the color specified by color. If the entity owns subentities and doSubents == Adesk::kTrue, the color change is applied to the subentities as well. Custom classes may override this method.'''
    ...
    def setColorIndex (self, clr: int, dosubents : bool=True)-> None :
      '''Function usageThis method sets the entity's color to the AutoCAD color index color. If the entity owns subentities and doSubents == Adesk::kTrue, then the color index change will be applied to the subentities as well.'''
    ...
    def setDatabaseDefaults (self, db: PyDb.Database = 'current')-> None :
      '''This function sets the entity's:ColorLayerLinetypeLinetype scaleVisibilityPlot style nameLine weightto the default values of the database indicated by pDb: If pDb == NULL, then the current database in the AutoCAD editor is used.'''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...

    @overload
    def setField (self, field: PyDb.Field)-> PyDb.ObjectId : ...
    @overload
    def setField (self, propName: str, field: PyDb.Field)-> PyDb.ObjectId : ...
    def setField (self, *args, **kwargs)-> PyDb.ObjectId :
      '''Overloads:
    - field: PyDb.Field
    - propName: str, field: PyDb.Field
    '''
    ...
    def setHeight (self, val : float)-> bool :
      '''                             '''
    ...
    def setHorizontalScale (self, val : float)-> bool :
      '''                             '''
    ...
    def setLayer (self, val: str|PyDb.ObjectId, dosubents : bool=True, allowHiddenLayer : bool=False)-> None :
      '''This method sets entity to reference the AcDbLayerTableRecord identified by the name specified in newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the layer change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.'''
    ...
    def setLength (self, val : float)-> bool :
      '''                             '''
    ...
    def setLineWeight (self, val: PyDb.LineWeight, dosubents : bool=True)-> None :
      '''This method sets the entity to use lineweight. If the entity owns subentities and doSubents == Adesk::kTrue, then the line weight change will be applied to the subentities as well.Returns Acad::eOk if successful.Function implementation in derived classesIf this function is overridden and wishes to set the line weight of the entity, then it must call AcDbEntity::setLineWeight() passing on the lineweight and doSubents arguments.It is also possible for this function's implementation to deal directly with any subentities and pass a doSubents value of Adesk::kFalse to AcDbEntity:: setLineWeight().If the line weight setting operation is successful, then this function should return Acad::eOk. If lineweight is not an acceptable value, then this function should return Acad::eInvalidInput. Any other error return values are up to the implementer.'''
    ...
    def setLinetype (self, val: str|PyDb.ObjectId, dosubents : bool=True)-> None :
      '''Function usageThis method sets the entity to reference the AcDbLinetypeTableRecord with the name specified in newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the linetype change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.'''
    ...
    def setLinetypeScale (self, val: float, dosubents : bool=True)-> None :
      '''This method sets the entity to use newval as its linetype scale factor. newVal must be nonnegative. If the entity owns subentities and doSubents == Adesk::kTrue, then the linetype scale change will be applied to the subentities as well.'''
    ...
    def setMaterial (self, val: str|PyDb.ObjectId, dosubents : bool=True)-> None :
      '''This method sets the material reference to the specified material. The specified name must correspond to an existing AcDbMaterial object.Returns Acad::eOk when successful'''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setOrigin (self, pt : PyGe.Point2d)-> bool :
      '''                             '''
    ...
    def setOwnerId (self, owner: PyDb.ObjectId)-> None :
      '''Sets the ownerId data member of the object to be objId, thus establishing a "backpointer." This backpointer is used by WBLOCK to be sure all necessary objects are written out.Returns Acad::eOk if successful.'''
    ...

    @overload
    def setPlotStyleName (self, /)-> None : ...
    @overload
    def setPlotStyleName (self, nameType: PyDb.PlotStyleNameType, doSubents: bool)-> None : ...
    @overload
    def setPlotStyleName (self, nameType: PyDb.PlotStyleNameType, newId: PyDb.ObjectId, doSubents: bool)-> None : ...
    def setPlotStyleName (self, *args, **kwargs)-> None :
      '''Overloads:
    - None: Any
    - nameType: PyDb.PlotStyleNameType, doSubents: bool
    - nameType: PyDb.PlotStyleNameType, newId: PyDb.ObjectId, doSubents: bool
    
	-This function searches the PlotStyleName dictionary for an entry with the name that matches newName and if found, sets the entity to use that plotStyleName entry. Because a lookup in the PlotStyleName dictionary is required, the entity must be database-resident for this method to succeed. The names ByLayer and ByBlock are allowed as well as user-defined names.If the entity owns subentities and doSubents == Adesk::kTrue, then the change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.Returns Acad::eOk if successful. If the entity is not database-resident, then Acad::eNoDatabase will be returned. If there is no entry in the PlotStyleName dictionary for newName, then Acad::eKeyNotFound will be returned.The plotStyleName value is used for DXF group code 390.-'''
    ...
    def setPropertiesFrom (self, entity: PyDb.Entity, dosubents : bool=True)-> None :
      '''This method copies theColorLayerLinetypeLinetype scaleVisibilityvalues from the entity pointed to by pEntity into this entity. If the entity owns subentities and doSubents == Adesk::kTrue, then the property changes will be applied to the subentities as well.Returns Acad::eOk if successful.'''
    ...
    def setReceiveShadows (self, val: bool)-> None :
      '''Sets the property indicating whether this entity can receive shadows.'''
    ...
    def setVerticalScale (self, val : float)-> bool :
      '''                             '''
    ...
    def setVisibility (self, val: PyDb.Visibility, dosubents : bool=True)-> None :
      '''This method sets the visibility of an entity to the value specified by newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the visibility change will be applied to the subentities as well.'''
    ...
    def setXData (self, xdata: list)-> None :
      '''Each regapp sublist (delimited by a resbuf with restype == 1001 and resval.rstring == a valid regappName string) within the resbuf chain pointed to by xdata, is placed in the xdata area of the object. If any of the regappNames in xdata are already present in the xdata area of the object, then that regappName's existing data on the object is overwritten by that regappName's new data in xdata.All resbufs with restype == 1001 must have valid regappNames for the database the object resides in (that is, the regappNames must be in the APPID table of the database).Only valid xdata group codes (1000--1071) are accepted in the restype fields of the resbufs in xdata.No "-3" group code is necessary, and in fact, is not accepted. So, the first element in the resbuf chain must be a 1001 group code with a resval.rstring set to a regappName that's already registered in the regapp table. To register a regappName, use the acdbRegApp() function.To remove an appName (and its xdata) from an object, just use a resbuf with restype == 1001, resval == and no data resbufs following it (that is, either its rbnext == NULL or the next resbuf is another 1001)This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If this function is overridden, then it should supermessage its parent in order to invoke the built-in mechanism to add the xdata to the object.Returns Acad::eOk if the xdata is successfully added to the object. If there is insufficient space in the xdata area of the object, then Acad::eXdataSizeExceeded is returned. If any of the regappNames in xdata are not in the APPID table, then Acad::eRegappIdNotFound is returned.'''
    ...
    def snoop (self,  filer : PyDb.SnoopDwgFiler)-> None :
      '''                             '''
    ...
    def swapIdWith (self, otherId: PyDb.DbObject, swapXdata: bool, swapExtDict: bool)-> None :
      '''This function swaps objectIds and handles between the object specified by otherId and the object invoking this function. Both objects must currently be database-resident and must reside in the same database. If swapXdata == Adesk::kTrue, then the objects swap extended entity data as well. If swapExtDict == Adesk::kTrue, then the objects swap extension dictionaries also.If the object specified by otherId or the object invoking this function are not database-resident, then Acad::eNoDatabase is returned. If both objects involved are not in the same database, then Acad::eWrongDatabase is returned.'''
    ...
    def toWCSPoint2d (self, pt : PyGe.Point2d)-> PyGe.Point2d :
      '''                             '''
    ...
    def toWCSX (self, val : float)-> float :
      '''                             '''
    ...
    def toWCSY (self, val : float)-> float :
      '''                             '''
    ...
    def transformBy (self, matrix3d: PyGe.Matrix3d)-> None :
      '''Function usageThis function provides a means by which AutoCAD and ObjectARX applications can ask the entity to apply a transformation matrix (xform) to itself.Each entity class must implement this function, so restrictions on what types of transformations are supported are up to the implementer of the entity class. The AutoCAD built-in entity classes for entity types that existed before R13 (that is, all the classes listed in the header file dbents.h such as AcDbCircle, AcDbLine, AcDbArc, AcDb2dPolyline, etc.) require that the transformation matrix represent a uniformly scaling orthogonal transformation (if it is not, then Acad::eCannotScaleNonUniformly will be returned). Other AutoCAD built-in classes have no restrictions.Returns Acad::eOk if successful. Return values for errors are implementation-dependent.Function implementation in derived classesThis function must apply the transformation matrix xform to the entity and change the entity's state to reflect the transformation. It is completely up to the implementer as to how to apply the transformation. It is also up to the implementer to decide what, if any, restrictions will be placed on the type of transformations supported. If any restrictions are desired, then it's up to the implementation of this function to enforce them.If your derived class implements transformBy() without calling the base class, you must call AcDbObject:: xDataTransformBy() or your Xdata will not be transformed.If this function successfully transforms the entity, then it should return Acad::eOk.Return values for error conditions are completely up to the implementer of this function. However, if the error is caused by a non-uniformly scaling or non-orthogonal matrix, then to be consistent with other entities that have this restriction, it is recommended that Acad::eCannotScaleNonUniformly be returned.'''
    ...
    def upgradeFromNotify (self, wasWritable: bool)-> None :
      '''Upgrades the object from being at least open AcDb::kForNotify to being open both AcDb::kForNotify and AcDb::kForWrite. The wasWritable argument is set to Adesk::kTrue if the object was already open for write, otherwise it's set to Adesk::kFalse. The wasWritable value should be saved to be passed into the downgradeToNotify() call later.This function must be followed at some point by a call to downgradeToNotify() with no open() (in any of its forms) or close() calls in between.This method should only be called from within other methods of the same object it is being called from. In other words, this method is intended to be used by an object to change it's own open status so that it can safely modify itself.upgradeFromNotify() and downgradeToNotify() call pairs are not nestable.Returns Acad::eOk if successful. If the object is not currently open AcDb::kForNotify, then Acad::eNotApplicable is returned. If the object is currently in the process of actually sending notification (that is, isNotifying() returns Adesk::kTrue), then Acad::eWasNotifying is returned.'''
    ...
    def upgradeOpen (self)-> None :
      '''If the object is currently open AcDb::kForRead with only one reader, then this function upgrades the object to open AcDb::kForWrite. In the process of changing to open for write, the object is closed, thus triggering any pertinent notification.Returns Acad::eOk if successful. If the object has more than one reader, then the open status is not changed and Adesk::eHadMultipleReaders is returned. If the object is already open AcDb::kForWrite, then Acad::eWasOpenForWrite is returned. If the object is currently sending notification, then the open status is not changed and Acad::eWasNotifying is returned.'''
    ...
    def verticalScale (self)-> float :
      '''                             '''
    ...
    def viewportDraw (self, vpdraw: PyGi.ViewportDraw)-> None :
      '''                             '''
    ...
    def viewportDrawLogicalFlags (self, vpdraw: PyGi.ViewportDraw)-> int :
      '''                             '''
    ...
    def visibility (self)-> PyDb.Visibility :
      '''This method returns the entity's current visibility state, either AcDb::kVisible or AcDb::kInvisible.'''
    ...
    def wblockClone (self, owner: PyRx.RxObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function is almost identical to AcDbObject::deepClone, except that an AcDbWblockCloneFiler is used and ownership is not carried across database boundaries. Subcloning is based on hard owner and hard pointer connections.'''
    ...
    def worldDraw (self, wdraw: PyGi.WorldDraw)-> int :
      '''                             '''
    ...
    def xData (self, appname: str = None)-> list :
      '''Returns a linked list of resbuf structures containing a copy of the xdata for the object. If regappName == NULL is passed in, all xdata is returned, otherwise only the xdata for the specified name is returned. If not all xdata is required, but the xdata for more than one regappName is desired, then multiple calls to this member function must be made--one for each regappName.The caller of this function is responsible for releasing the memory used by the resbuf list that is returned. The most commonly used way to deallocate such a list is via the acutRelRb() function.This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If a failure accessing the xdata occurs, NULL is returned.'''
    ...
    def xDataTransformBy (self, xform: PyGe.Matrix3d)-> None :
      '''This method applies the xform transformation matrix to any XData data types 1011, 1021, 1031, 1012, 1022, 1032, 1013, 1023, 1033, 1041, and 1042 in the object's XData. See the documentation on XData for more information on the way the transformation matrix is applied to the different data types.This method should be called from within the transformBy() method on custom entities so that such entities will transform XData in the same way that the built-in AcDb entities do.Returns Acad::eOk if successful.'''
    ...
    def xmitPropagateModify (self)-> None :
      '''Within an object's close() method is a call to the object's xmitPropagateModify().The AcDbObject::xmitPropagateModify() default implementation is to inform the containing database that the object has been modified, appended to the database, or erased. The database then sends out the appropriate notification to any AcDbDatabaseReactors attached to it.Within AutoCAD, this function is used by complex entities such as polylines to allow the subentities to notify the header that they have been changed. The header can then "propagate" the notification by sending its own notification that the "complex entity" has been modified.The way this works is:The subobject class has it's xmitPropagateModify() class overridden such that it calls it's parent class's xmitPropagateModify() and also calls the owning object's recvPropagateModify().The "root" or "header" class has it's recvPropagateModify() overridden to provide an implementation that triggers "modified" notification to be sent for the "root" or "header" (which effectively represents the whole complex object).The subobject's close() triggers "modified" notification for the subobject and calls the subobject's xmitPropagateModify() function. So, when the subobject's close() is called, its xmitPropagateModify() is called. This then calls the owning object's recvPropagateModify(), which then triggers the owner to send "modified" notification.So, the result is a "modified" notification from both the subentity and the "root" or "header" entity.When overridden, this function should:Call its parent class's xmitPropagateModify() (which ultimately results in the execution of AcDbObject::xmitPropagateModify() to trigger database notification).Call its owner's recvPropagateModify() (passing in its "this" pointer) to "propagate" the notification information to the "root" owner to be sent out.'''
    ...

class CvDbVolumeSurface(CvDbTinSurface):
    def __init__ (self, id: ObjectId, mode: PyDb.OpenMode=PyDb.OpenMode.kForRead, erased: bool=False)-> None :
      '''                             '''
    ...
    def addConstraint (self, constraint : PyBrxCv.CvDbTinSurfaceConstraint, addReactor : bool)-> bool :
      '''                             '''
    ...
    def addConstraints (self, constraints : list[PyBrxCv.CvDbTinSurfaceConstraint], addReactor : bool)-> bool :
      '''                             '''
    ...
    def addContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def addDefinition (self, ref : PyBrxCv.CvDbTinSurfaceDefinition)-> int :
      '''                             '''
    ...
    def addPersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Adds the database-resident object specified by objId to the reactor list of the AcDbObject object.'''
    ...
    def addPoint (self, pt : PyGe.Point3d)-> bool :
      '''                             '''
    ...
    def addPoints (self, pts : list[PyGe.Point3d])-> bool :
      '''                             '''
    ...
    def addReactor (self, reactor: PyDb.EntityReactor)-> None :
      '''                             '''
    ...
    def addSubentPaths (self, paths: list[PyDb.FullSubentPath])-> None :
      '''Adds one or more subentities to an entity.The prototype of this method is provided for completeness of the subentity manipulation APIs. AutoCAD will never call this method on a custom object.Returns Acad::eOk if successful. The default implementation returns Acad::eNotAvailable.'''
    ...
    def area2d (self, visibleOnly : bool=False)-> float :
      '''                             '''
    ...
    def area3d (self, visibleOnly : bool=False)-> float :
      '''                             '''
    ...
    def assertNotifyEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should be used inside of member functions that are only called when the object is open kForNotify. When used, it should be the first function called inside the member function.'''
    ...
    def assertReadEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that access the object's data in a read-only fashion (for example, dxfOutFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is open AcDb::kForRead.If this function is called while the object is not open, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def assertWriteEnabled (self)-> None :
      '''This function is used only inside of member functions of classes derived from AcDbObject. It should only be used inside of member functions that modify the object's data (for example, dxfInFields()). When used, it should be the first function called inside the member function. Its purpose is to make sure that the object is indeed open for write (if it is not, then AutoCAD terminates); to trigger an immediate sending of "openedForModify" notification; to set up the notification mechanism so that "modified" and "modifiedGraphics" (if the object is derived from AcDbEntity) are sent at the appropriate times; and to ensure that graphics get updated if the object is derived from AcDbEntity.If this function is called on a database resident object, "openedForModify" will be sent if the object is not newly created, and "modified", and "modifiedGraphics" (if appropriate) notifications will be sent when the object is next closed.If recordModified is false, then the autoUndo argument is ignored, and the undo filer is not initialized, no undo recording will take place, but notifications will be sent.If autoUndo and recordModified are both true, then automatic undo recording will be performed and notifications will be sent.If autoUndo is false and recordModified is true, then there will not be any automatic undo recording, but the undo filer is initialized and the object must manually write out partial Undo records and must implement its applyPartialUndo() method. Notifications will be sent.If this function is called while the object is not open AcDb::kForWrite, AutoCAD terminates (allowing the user to save changes).'''
    ...
    def baseSurfaceObjectId (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def blockId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the entity's owner, which must be an AcDbBlockTableRecord.If the entity does not have an owner yet, then AcDbObjectId::kNull will be returned.'''
    ...
    def boundingBox (self)-> tuple[Any,...] :
      '''                             '''
    ...
    def boundingPolygon (self)-> list :
      '''                             '''
    ...
    def boundingPolygonObjectId (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def bounds (self, ext: PyDb.Extents)-> bool :
      '''                             '''
    ...
    def cancel (self)-> None :
      '''Terminates the current open operation. All changes made to the object since it was opened are undone, the object is marked as closed, and "cancel" notification is sent.Returns Acad::eOk if successful.'''
    ...

    @staticmethod
    def cast (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbVolumeSurface :
      '''                             '''
    ...
    def castShadows (self)-> bool :
      '''Returns a boolean value that indicates whether the entity can cast shadows. '''
    ...
    def changePointsElevations (self, pts : list[PyGe.Point3d], newZValues : list[float])-> bool :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...

    @staticmethod
    def cloneFrom (otherObject: PyRx.RxObject)-> PyBrxCv.CvDbVolumeSurface :
      '''                             '''
    ...
    def close (self)-> None :
      '''Closes the object. All changes made to the object since it was opened are committed to the database, the object is marked as pageable, and a "closed" notification (as well as any other appropriate notification such as "modified", "erased", and so on) is sent.Returns Acad::eOk if successful.If the object is not in an AcDbDatabase yet, then Acad::eNoDatabase is returned.If the object is sending notification, then Acad::eCloseWasNotifying is returned.If the subClose() call made within the close() method returns anything other than Acad::eOk, then that ErrorStatus is returned.'''
    ...
    def closestPointTo (self, pt : PyGe.Point3d)-> PyGe.Point3d :
      '''                             '''
    ...
    def collisionType (self)-> PyDb.CollisionType :
      '''This function returns the collision detection treatment for this entity. Subclasses may override this method to customize how the class interacts in collision-aware features.'''
    ...
    def color (self)-> PyDb.Color :
      '''This function returns the full true color information for the entity within an instance of AcCmColor.The index value will be in the range 0 to 256. 0 and 256 are special values.0 indicates the entity uses the color of the BlockReference that's displaying it. If the entity is not displayed through a BlockReference (for example, it's directly owned by the model space BlockTableRecord) and its color is 0, then it will display as though its color were 7.256 indicates the entity uses the color specified in the LayerTableRecord it references.'''
    ...
    def colorIndex (self)-> int :
      '''                             '''
    ...
    def comparedTo (self, other: PyRx.RxObject)-> PyRx.Ordering :
      '''Function usage:This function is intended to allow classes to provide a means to compare class objects much the way strcmp() compares character strings.The object pointed to by other is compared with this object. The result of the comparison is returned.The possible AcRx::Ordering types are:AcRx::kLessThanAcRx::kEqualAcRx::kGreaterThanAcRx::kNotOrderableThe AcRx::kNotOrderable type is there because C++ classes often cannot support object value comparison.Function implementation in derived classes:There are no restrictions or expectations on how this function is implemented. Each class will have its own requirements for comparison.Default implementation:Simply returns AcRx::kNotOrderable since many C++ classes cannot support object value comparison.'''
    ...
    def comparisonSurfaceObjectId (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def contains (self, pt : PyGe.Point3d)-> bool :
      '''                             '''
    ...
    def contoursAtElevation (self, elevation : float)-> list :
      '''                             '''
    ...
    def copyFrom (self, other: PyRx.RxObject)-> None :
      '''Function usage:Copies the contents of other into the messaged object, whenever feasible. Function implementation in derived classes:If implemented, this function needs to be able to read the data in the object pointed to by other and copy any or all data as appropriate into this object. There is no requirement that the object pointed to by other and this object be of the same class, but that is the generally assumed condition.Default implementation: Because this function must be overridden to have any meaning, a fatal error will be caused when calling the default implementation. '''
    ...
    def createExtensionDictionary (self)-> None :
      '''Creates an AcDbDictionary object and sets it up as the extension dictionary for the AcDbObject.Returns Acad::eOk if successful. If an extension dictionary already exists, Acad::eAlreadyInDb is returned.'''
    ...
    def createSnapshot (self)-> int :
      '''                             '''
    ...
    def cutVolume (self)-> float :
      '''                             '''
    ...
    def database (self)-> PyDb.Database :
      '''Returns a pointer to the AcDbDatabase object that contains the AcDbObject.'''
    ...
    def deepClone (self, owner: PyDb.DbObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function gives control of deep clone operations to the object. In the default implementation, the object is cloned and appended to the owner object (pOwnerObject). The cloning is performed by an AcDbDeepCloneFiler. A record is also added to the idMap. Then, using the filer, any owned objects are deep cloned, with isPrimary set to Adesk::kFalse.'''
    ...
    def definitionAt (self, index : int)-> PyBrxCv.CvDbTinSurfaceDefinition :
      '''                             '''
    ...
    def definitionCount (self)-> int :
      '''                             '''
    ...
    def definitionIndex (self, ref : PyBrxCv.CvDbTinSurfaceDefinition)-> tuple[Any,...] :
      '''                             '''
    ...
    def depthElevation (self)-> float :
      '''                             '''
    ...

    @staticmethod
    def desc ()-> PyRx.RxClass :
      '''Returns a pointer to the AcRxClass object representing the specific class, or most recent parent class explicitly registered with ObjectARX of either the pointer type used to invoke it or the class qualifier used with it. (Remember that when a static member function is invoked via a pointer, the pointer type, not the object type, determines which implementation of the function is invoked.)When working with a pointer to an object and the proper AcRxClass object for the class of the object pointed to is desired, the AcRxObject::isA() function should be used, since it is a virtual non-static method and is therefore not pointer type dependent.Caching the value of the pointer returned by this method is acceptable, provided the application knows that the AcRxClass object pointed to by the returned pointer was created by an ObjectARX application that will not be unloaded. '''
    ...
    def description (self)-> str :
      '''                             '''
    ...
    def disableUndoRecording (self, disable: bool)-> None :
      '''Turns off or on the Undo recording for the object. If disable == Adesk::kTrue, then Undo recording is turned off until this function is called with disable == Adesk::kFalse, at which time Undo recording is turned back on.'''
    ...
    def dispose (self)-> None :
      '''                             '''
    ...
    def downgradeOpen (self)-> None :
      '''Downgrades the object from being open AcDb::kForWrite, to being AcDb::kForRead. In the process, all changes made to the object while it was open for write are committed to the database and appropriate notification is sent.'''
    ...
    def downgradeToNotify (self, wasWritable: bool)-> None :
      '''Restores an object from being open both AcDb::kForNotify and AcDb::kForWrite, to being open just AcDb::kForNotify. The wasWritable value that was returned from the matching AcDbObject::upgradeFromNotify() call should be passed into this function to restore the proper open status.This function must have been preceded by a call to upgradeFromNotify().Returns Acad::eOk if successful.'''
    ...
    def drapeId (self, id : PyDb.ObjectId)-> list :
      '''                             '''
    ...
    def drapePoints (self, pts : list[PyGe.Point3d])-> list :
      '''                             '''
    ...
    def draw (self)-> None :
      '''This function queues up the entity's graphics and flushes the graphics queue, forcing the entity and anything else in the queue to be drawn or re-drawn on-screen.Returns Acad::eOk if successful.If the entity is not in a database, then Acad::eNotInDatabase will be returned.If the entity is in a database other than the one currently loaded into the AutoCAD editor, then Acad::eNotCurrentDatabase will be returned.'''
    ...
    def drawableType (self)-> PyGi.GiDrawableType :
      '''                             '''
    ...
    def elevationAtPoint (self, pt : PyGe.Point3d)-> tuple[Any,...] :
      '''                             '''
    ...
    def entityColor (self)-> PyDb.EntityColor :
      '''This function returns the color settings of the entity in an AcCmEntityColor form. Most clients should use the color() function, which returns the heavyweight AcCmColor object. However, if color name information is not required, this function provides faster access to the lightweight AcCmEntityColor data.'''
    ...
    def erase (self, erasing : bool=True)-> None :
      '''Sets the erase bit of the object. If erasing == Adesk::kTrue, then the erase bit is set on. If erasing == Adesk::kFalse, then the erase bit is set off.'''
    ...
    def eraseConstraint (self, id : PyDb.ObjectId | int, removeReactor : bool)-> bool :
      '''                             '''
    ...
    def eraseConstraints (self, int64ids : list[int], removeReactor : bool)-> bool :
      '''                             '''
    ...
    def eraseConstraintsIds (self, ids : list[PyDb.ObjectId], removeReactor : bool)-> bool :
      '''                             '''
    ...
    def explode (self)-> list :
      '''Function UsageThis function is primarily intended for AutoCAD to call as part of an explode operation that includes this entity. However, this function can be used by ObjectARX applications to obtain an array of pointers to non-database-resident entity objects that are what the entity considers to be its exploded parts.When calling this function, the entitySet array does not need to be empty. This function will append to it, and pointers to entities that it creates to be used in its place as the "exploded" result.If this function is successful, it will return Acad::eOk. Other return values may vary depending on how it has been implemented.Function Implementation in Derived ClassesThis function should dynamically create (using the new operator) whatever entity objects are appropriate to be used to replace the entity after an explode operation has taken place. Pointers to these entities are then appended to the entitySet array. Once the pointers have been appended, the function should return with a status of Acad::eOk.'''
    ...
    def extensionDictionary (self)-> PyDb.ObjectId :
      '''Returns the objectId of the extension dictionary owned by the object. If the object does not own an extension dictionary, then the returned objectId is set to AcDbObjectId::kNull.'''
    ...
    def fillVolume (self)-> float :
      '''                             '''
    ...
    def findDefinition (self, id : int)-> PyBrxCv.CvDbTinSurfaceDefinition :
      '''                             '''
    ...
    def findTinPointAt (self, pt : PyGe.Point3d)-> tuple[Any,...] :
      '''                             '''
    ...
    def findTinTrianglesAt (self, pt : PyGe.Point3d)-> list :
      '''                             '''
    ...
    def getBorders (self)-> list :
      '''                             '''
    ...
    def getCompoundObjectTransform (self)-> PyGe.Matrix3d :
      '''This function is intended to be overridden by derived classes that are compound objects (in other words, objects that behave like blocks in the display list).A compound object has little or no geometry of its own; instead it relies on nested entities, perhaps the contents of a BlockTableRecord, to represent itself. A compound object must use the same transformation matrix for all of its contained entities. Otherwise selection and osnap will not function correctly. This is the method that the system uses to obtain that matrix from the compound object.This method should only be overridden if you return the kDrawableIsCompoundObject flag from setAttributes. The matrix you should return here is the one that you pass to pushModelTransform before you render your nested objects. You must override this method if you return the compound object flag in setAttributes, even if you don't push a transform for your nested objects. In that case you would return Acad::eOk and the identity transform in xMat.Default implementation: Returns Acad::eNotApplicable and the identity matrix in xMat.'''
    ...
    def getConstraint (self, id : PyDb.ObjectId|int)-> PyBrxCv.CvDbTinSurfaceConstraint :
      '''                             '''
    ...
    def getConstraints (self)-> list :
      '''                             '''
    ...
    def getEcs (self)-> PyGe.Matrix3d :
      '''This function is intended to be overridden by derived classes that need to be able to provide access to an object coordinate system for objects of the class. The intent is that this function provide a transformation matrix that can be used to transform vectors or points from the object's object coordinate system (OCS) to the World Coordinate System (WCS).Default implementation: Return the identity matrix (ones along the diagonal, zeros elsewhere) in retVal.We recommend that all data stored in custom classes be stored in WCS coordinates. If this is done, then the object's OCS will be the WCS and the transformation matrix will be the identity matrix. Then this function will not need to be overridden since the identity matrix is this function's default return.'''
    ...
    def getField (self, prop: str='TEXT')-> PyDb.ObjectId :
      '''Gets the field ID. A field can be stored in an object using the property name as the key.Returns Acad::eOk if the object has a field for the specified property. Otherwise, returns an AutoCAD error status.'''
    ...
    def getFieldDictionary (self)-> PyDb.ObjectId :
      '''Returns the field dictionary ID. The field dictionary stores all the fields set in the object as property name-field object pairs. The ID will be null if there is no field in the object.'''
    ...
    def getGeomExtents (self)-> PyDb.Extents :
      '''Unimplemented at the AcDbEntity level, this method is intended to be overridden in derived classes.Derived classes should calculate and return the corner points (in WCS coordinates) of a box (with edges parallel to the WCS X, Y, and Z axes) that encloses the 3D extents of the entity, and return those points as an instance of class AcDbExtents in the "extents" parameter.Default implementation: Immediately returns Acad::eInvalidExtents.'''
    ...
    def getGeomExtents2d (self)-> PyDb.Extents2d :
      '''                             '''
    ...

    @overload
    def getGripPoints (self, /)-> tuple[Any,...] : ...
    @overload
    def getGripPoints (self, curViewUnitSize: float, gripSize: int, curViewDir: PyGe.Vector3d, bitflags: int)-> tuple[Any,...] : ...
    def getGripPoints (self, *args, **kwargs)-> tuple[Any,...] :
      '''Overloads:
    - None: Any
    - curViewUnitSize: float, gripSize: int, curViewDir: PyGe.Vector3d, bitflags: int
    
	-Function usageThis function supports "old style" grips, in applications that existed before the enhancement of grip functionality by the addition of the AcDbGripData class.This function is not intended to be called by ObjectARX applications. However, it is possible to do so (for example, as a pass-through from the getStretchPoints() method).Function implementation in derived classesThis function should append to the gripPoints array any points that are to treated as grip points for the entity.The gripPoints array is passed to all entities involved in the grip operation, so the array may already contain grip points for other entities. Therefore, it is very important to append the new points rather than assigning them to any existing elements in the array.When finished appending all desired grip points, return Acad::eOk. If anything other than Acad::eOk is returned, then grips are not activated for this entity.The osnapModes and geomIds arguments are not currently used.Default implementationImmediately returns Adesk::eNotImplemented.-'''
    ...
    def getHandle (self)-> PyDb.Handle :
      '''Fills in handle with the handle value for the object. If the object is not yet database-resident, then it will not have a handle. Use AcDbHandle::isNull to test for this condition.'''
    ...
    def getPlane (self)-> PyGe.Plane :
      '''If the entity is planar, then the plane containing the entity is returned in plane and flag is set to AcDb::kPlanar.If the entity is nonplanar, but is linear, then plane is set to an arbitrary plane that contains the entity and flag is set to AcDb::kLinear.If the entity is nonplanar and nonlinear, then plane is left unset and flag is set to AcDb::kNonPlanar.Returns Acad::eOk if successful. Other ErrorStatus return values are implementation-dependent.The default implementation is to return Acad::eNotApplicable.'''
    ...
    def getPlotStyleNameId (self)-> PyDb.ObjectId :
      '''Returns with id set to the object ID of the AcDbPlaceHolder object referenced by the entity. The AcDbPlaceHolder object resides in the plot style name dictionary, and its key in the dictionary is the plot style name.Use the AcDbDictionary::nameAt() function on the plot style name dictionary to get the plot style name string that corresponds to the ID obtained by this function.'''
    ...
    def getPoints (self, visibleOnly : bool=False)-> list :
      '''                             '''
    ...
    def getPointsInsidePolygon (self, pts : list[PyGe.Point3d], includeOnEdge : bool)-> list :
      '''                             '''
    ...
    def getStretchPoints (self)-> list :
      '''Function usageThis function is not intended to be called by ObjectARX applications. However, it is possible to do so (for example, as a pass-through from the getGripPoints() method).Function implementation in derived classesThis function should append to the stretchPoints array any points that are to treated as stretch points for the entity.Stretch points are used by the stretch command within AutoCAD. Any stretch points that are within the crossing selection window during the stretch command, will be moved by whatever amount the user decides to "stretch" the selected entities. Any stretch points not in the crossing selection window will be left alone. This combination of some stretch points moving while others do not is what "stretches" the entity. If all stretch points are in the crossing window, then the entity is moved instead of stretched.The stretchPoints array is passed to all entities involved in the stretch operation, so the array may already contain stretch points for other entities. Therefore it is very important to append the new points rather than assigning them to any existing elements in the array.When finished appending all desired stretch points, return Acad::eOk. If anything other than Acad::eOk is returned, then this entity's stretch points will be ignored by the stretch operation.Default implementationCalls the AcDbEntity::getGripPoints() method. So, unless the entity needs to have stretch points that are different from the grip points, there is no need to override this method.'''
    ...
    def getSubentPathsAtGsMarker (self, type: PyDb.SubentType, gsMark: int, pickPoint: PyGe.Point3d, viewXform: PyGe.Matrix3d)-> list[PyDb.FullSubentPath] :
      '''Entities use various graphic primitives defined in AcGi to draw themselves. Part of this mechanism is the ability to associate an integer identifier called a graphics system marker (or, GS marker) with each primitive or with groups of primitives. Through the use of certain selection mechanisms, the GS marker for the actual subentity selected on screen can be obtained and, along with some other information passed into this function, can be used to create one or more AcDbFullSubentPath objects, each one representing a subentity and providing a more complete description of the subentity and its environment. These AcDbFullSubentPath objects can be used by several other functions for various purposes such as highlighting or unhighlighting the subentities on screen.Function usageIf the entity (of which the subentity is a part) is directly owned by the model or paper space BlockTableRecords, then leave out numInserts and entAndInsertStack so that their default value will be used.Typically the GS marker is obtained via the use of ads_ssget() followed by ads_ssnamex() (see the ObjectARX Developer's Guide for more information on this).The pickPoint can be obtained from ads_ssnamex() as well (it's the first group 5009 in the returned list).The viewXform can be calculated using the ads_trans() function on the vectors (1,0,0), (0,1,0), and (0,0,1) to translate them from DCS to WCS. The translations of these three vectors (with an extra 0 appended on to the end of each) would be used as the first three rows of the matrix. The last row is not used so it can be left as is. This argument is not used by any of the AutoCAD built-in entities.If the entity is nested inside one or more block definitions, then the numInserts and entAndInsertStack arguments must also be filled in with non-zero or non-null values. If they are not filled in, then this function will fail and return an error status. One way to get the necessary object IDs is to use ads_nentselp() to obtain the list of ads_names of the container objects. This list must then be converted to object IDs and reversed.Upon return, the subentPaths argument will point to a dynamically allocated array of one or more AcDbFullSubentPath objects. The numPaths argument will contain the number of AcDbFullSubentPath objects being returned.The calling application is responsible for deallocating the memory used by the subentPaths array. The C++ delete [ ] should be used.Return values for this function may vary depending on how the function has been implemented (see below).Function implementation in derived classesEntity classes which do not set GS markers probably should not implement this function since the GS marker is the primary (and often the only) means of subentity distinction.When implemented, this function must use the material provided in type, gsMark, pickPoint, viewXform, numInserts, and entAndInsertStack to determine which subentity or subentities meet the criteria in these arguments. Next it must create a dynamically allocated array of AcDbFullSubentPaths (using the C++ new operator) with one element for each subentity determined in the first step. Finally it must fill in each AcDbFullSubentPath object in the array with the information appropriate to the subentity it will represent.If numInserts == 0 and entAndInsertStack == NULL, it's important to check to be sure that the entity's owner is indeed the model or paper space BlockTableRecord. This can be done by using the entity's ownerId() method to obtain the objectId of its owner, and then opening up that object and using its name() method to obtain its name string. If the owner is not the model or paper space BlockTableRecord, and numInserts == 0 or entAndInsertStack == NULL, or both, then the input data is invalid and this function should set numPaths to 0, set subentPaths to NULL and then return the error status Acad::eInvalidInput.Each AcDbFullSubentPath object has two parts, an array of objectIds containing all the container objects, and an embedded AcDbSubentId object which in turn has two elements: an index value and a SubentityType.If the "main" entity (the entity on which this function is being called) is not nested within BlockReferences (that is, numInserts == 0 and entAndInsertStack == NULL), then the objectId array should contain only the objectId of the "main" entity. If the "main" entity is nested in one or more BlockReferences, then the AcDbObjectIdArray is the same as entAndInsertStack, so copying the entAndInsertStack elements into the AcDbObjectIdArray is all that's required.The SubentType data item within the embedded AcDbSubentId should be set the same as type.The index data item within the embedded AcDbSubentId can be any value you wish (it is often simply the GS marker), but if implemented, the following functions must be able to interpret them to determine the corresponding GS marker(s) or subentity (or subentities):getGsMarkersAtSubentPath()subentPtr()The pickPoint and viewXform arguments are provided as extra aids (if necessary) in determining which subentity is involved. For example, some entity types might display differently depending on the display viewpoint. The viewXform transformation matrix can be used in such cases.The viewXform argument provides a transformation matrix to transform from WCS (World Coordinate System) to DCS (display coordinate system).The display coordinate system is oriented such that the positive Z axis is coming out of the display screen towards the user, the positive X axis is horizontally from left to right on screen, and the positive Y axis is vertically upwards on screen.So, if the current viewpoint is at (1,0,0) (the viewer is always looking towards (0,0,0)) then the viewXform matrix would be:0 1 0 00 0 1 01 0 0 00 0 0 1In this matrix the last row and the last column are not used. Notice also that the third row is the DCS Z axis in WCS coordinates (which is the WCS version of the AutoCAD VIEWPOINT system variable).When this function returns, the return code to use is completely up to the implementer, but to be consistent with other existing entity class implementations of this function the following should be used:If the function succeeds, it should return Acad::eOk.If an invalid or unsupported SubentType is passed in, then numPaths should be set to 0, subentPaths should be set to NULL, and Acad::eWrongSubentityType should be returned.If an invalid GS marker (or any other data item that turns out to be needed) is passed in, then numPaths should be set to 0, subentPaths should be set to NULL, and Acad::eInvalidInput should be returned.Default implementationImmediately returns Adesk::eNotApplicable.'''
    ...
    def getTinPoints (self)-> list :
      '''                             '''
    ...
    def getTransformedCopy (self, matrix3d: PyGe.Matrix3d)-> PyDb.Entity :
      '''Function usageThis function creates a clone of the entity, applies the xform transformation matrix to the clone, and then returns with pEnt pointing to the transformed clone.Returns Acad::eOk if successful.If xform is a non-uniform scaling matrix or non-orthogonal then Acad::eCannotScaleNonUniformly or Acad::eNotImplemented is returned.WarningFor AutoCAD built-in complex entities such as polylines, this function produces a shallow clone of the header entity only, which also owns the original set of "owned" entities (such as vertices for a polyline) which are then transformed by the xform matrix. This results in a corrupt drawing (two header entities owning the same set of "owned" entities) as well as transforming the original set of "owned" entities instead of a copied set.Function implementation in derived classesThe default AcDbEntity implementation of this function should be adequate for most derived entity types. However, derived entity classes that wish to support non-uniform scaling or non-orthogonal transformations will need to override this method with their own implementation.This function must create a copy of the entity (using memory that has been dynamically allocated via the C++ new operator), apply the transformation matrix xform to the copy and then return with pEnt pointing to the transformed copy.Determining what constitutes a valid transformation matrix and whether to do a shallow clone (that is, the entity's clone() method), a deepclone (if the entity owns other objects), or no clone at all (that is, make this function a no-op), is up to the implementer.Return values for this function are also up to the implementer, but to be consistent with other existing classes the following is recommended:If the function succeeds, it should return Acad::eOk.If the function is to be a no-op, it should return Acad::eNotImplementedIf non-uniform scaling is not to be supported and a non-uniform scaling matrix is passed in, then either Acad::eCannotScaleNonUniformly or Acad::eNotImplemented should be returned.Default implementationIf the entity is uniformly scaled and orthogonal, AcDbEntity::getTransformedCopy will call the entity's clone() method to create a clone of the entity, then call AcDbEntity::transformBy() on the clone, and then return with pEnt set to point to the transformed clone. If xform is a non-uniformly scaled or a non-orthogonal matrix, then this function will return Acad::eNotImplemented.'''
    ...
    def handOverTo (self, newObject: PyDb.DbObject, keepXData: bool, keepExtDict: bool)-> None :
      '''This function provides the ability to exchange a non-database-resident object (NDBRO) in place of an existing database-resident object (DBRO) while retaining the objectId, handle, and reactor list of the DBRO. An example of this situation is when the BREAK command is used to break a circle into one or two arc segments. AcDbArc is a completely different class from AcDbCircle, so a new AcDbArc object must be substituted in place of the AcDbCircle object that is there now, yet the arc must get the handle and objectId that the circle has.To use the handOverTo() function, the object to be replaced (the AcDbCircle in the example) must be open AcDb::kForWrite. The object's handOverTo() function is called with newObject pointing to a non-database-resident object that replaces it (the AcDbArc in the example).keepXData is set to Adesk::kTrue if the xdata is to be retained or Adesk::kFalse if the xdata is to be thrown out.keepExtDict is set to Adesk::kTrue if the extension dictionary and its contents are to be retained, or set to Adesk::kFalse if the extension dictionary and its contents are to be thrown out.Once returned from this function, the replacement object (the AcDbArc in the example) is open for AcDb::kForWrite and must have its close() member called to commit the change and close out Undo recording. Then it's up to the ObjectARX application to delete the old object (the AcDbCircle in the example) from memory since it's no longer database-resident.Returns Acad::eObjectToBeDeleted if the operation is successful. If newObject is pointing to an object that is already in the database, or the object invoking handOverTo() is not database-resident, then Acad::eIllegalReplacement is returned.'''
    ...
    def hasFields (self)-> bool :
      '''Returns true if the object has one or more PyDb.Field Objects. Otherwise returns false.'''
    ...
    def hasPersistentReactor (self, id: PyDb.ObjectId)-> bool :
      '''This method returns true if objId is the object ID of a reactor attached to this object. Otherwise, it returns false.'''
    ...
    def hasSnapshot (self)-> bool :
      '''                             '''
    ...
    def hasXData (self, appname: str)-> bool :
      '''                             '''
    ...
    def highlight (self, path: PyDb.FullSubentPath = None, highlightAll : bool = False)-> None :
      '''Function usageThis function uses the AcDbFullSubentPathid to determine which subentity in the entity is desired. It then highlights that subentity on screen. If no AcDbFullSubentPath argument is provided, then the entire entity will be highlighted.Typically, the AcDbFullSubentPath object passed in via subId is obtained from the entity's AcDbEntity::getSubentPathsAtGsMarker() method. This guarantees that it is fully and properly filled in.This function uses the entity's getGsMarkersAtSubentPath() method to get the GS markers associated with subId. If that function does not return Acad::eOk, then this function will fail and return whatever ErrorStatus was returned by getGsMarkersAtSubentPath().If this function succeeds, then it returns Acad::eOk.It is not necessary to balance each highlight() function call with a corresponding call to unhighlight(). Calling the unhighlight() function will unhighlight the entity designated by subId regardless of how many times the highlight function has been called on it.WarningIf the entity on which this method is called has its graphics queued for regeneration (that is, changes have been made to the entity but have not yet been reflected on screen), then this method will not cause a highlight to occur. Also, calling this method on an entity that's open for write and whose graphics are queued for regeneration may terminate AutoCAD.To avoid this limitation, before calling highlight(), you should flush the entity's graphics by either calling the entity's draw() method, or calling the AcTransactionManager::flushGraphics() function.Function implementation in derived classesThe AcDbEntity::highlight() implementation does all the work necessary to highlight any subentities that correspond to the subIdFullSubentPath. So, there is no need to override this method unless you wish to do some pre-or post-processing, or you wish to disable the ability to highlight subentities.If this method is overridden and it is supposed to highlight subentities, then the AcDbEntity::highlight() method will need to be invoked at some point within this function in order to do the actual highlighting.Within the AcDbEntity::highlight() method, the getGsMarkersAtSubentPath() method of this entity is called to translate the FullSubentPath into the corresponding GS markers. So, if this function is to succeed, the getGsMarkersAtSubentPath() method needs to be implemented as well.For more information on the subIdAcDbFullSubentPath argument, see the documentation on the getGsMarkersAtSubentPath() or getSubentPathsAtGsMarker() methods.'''
    ...
    def id (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def implRefCount (self)-> int :
      '''                             '''
    ...

    @overload
    def initialize (self, baseSurface: PyBrxCv.CvDbTinSurface, compSurface: PyBrxCv.CvDbTinSurface, boundingPolygon: list[PyGe.Poin3d])-> bool : ...
    @overload
    def initialize (self, baseSurface: PyBrxCv.CvDbTinSurface, compSurface: PyBrxCv.CvDbTinSurface, boundingPolygon: list[PyGe.Poin3d], midOrdinateDist: float)-> bool : ...
    @overload
    def initialize (self, baseSurface: PyBrxCv.CvDbTinSurface, referenceElevation: float, vType: PyBrxCv.VolumeSurfaceType, boundingPolygon: list[PyGe.Poin3d])-> bool : ...
    @overload
    def initialize (self, baseSurface: PyBrxCv.CvDbTinSurface, referenceElevation: float, vType: PyBrxCv.VolumeSurfaceType, boundingPolygonId: PyDb.ObjectId, midOrdinateDist: float)-> bool : ...
    def initialize (self, *args, **kwargs)-> bool :
      '''Overloads:
    - baseSurface: PyBrxCv.CvDbTinSurface, compSurface: PyBrxCv.CvDbTinSurface, boundingPolygon: list[PyGe.Poin3d]
    - baseSurface: PyBrxCv.CvDbTinSurface, compSurface: PyBrxCv.CvDbTinSurface, boundingPolygon: list[PyGe.Poin3d], midOrdinateDist: float
    - baseSurface: PyBrxCv.CvDbTinSurface, referenceElevation: float, vType: PyBrxCv.VolumeSurfaceType, boundingPolygon: list[PyGe.Poin3d]
    - baseSurface: PyBrxCv.CvDbTinSurface, referenceElevation: float, vType: PyBrxCv.VolumeSurfaceType, boundingPolygonId: PyDb.ObjectId, midOrdinateDist: float
    '''
    ...
    def insertDefinitionAt (self, index : int, ref : PyBrxCv.CvDbTinSurfaceDefinition)-> int :
      '''                             '''
    ...

    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, thisGsMarker : int, otherGsMarker : int)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane)-> list : ...
    @overload
    def intersectWith (self, entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane, thisGsMarker : int, otherGsMarker : int)-> list : ...
    def intersectWith (self, *args, **kwargs)-> list :
      '''Overloads:
    - entity: PyDb.Entity, intType : PyDb.Intersect
    - entity: PyDb.Entity, intType : PyDb.Intersect, thisGsMarker : int, otherGsMarker : int
    - entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane
    - entity: PyDb.Entity, intType : PyDb.Intersect, plane : PyGe.Plane, thisGsMarker : int, otherGsMarker : int
    
	-Function usageIt finds the intersections of the entity pointed to by pEnt and all the edges of the bounding box of this entity.The intType is used to determine how to deal with extending the two entities in order to calculate intersections. The possible AcDb::Intersect values are:AcDb::kOnBothOperandsDo not extend either entity. This results in only calculating intersections where the two entitys' geometry actually intersectAcDb::kExtendThisExtend this entity (if necessary) when calculating intersections, but do not extend the pEnt entity.AcDb::kExtendArgExtend the pEnt entity (if necessary) when calculating intersections, but do not extend this entity.AcDb::kExtendBothExtend both the pEnt entity and this entity (if necessary) when calculating intersectionsAny intersection points found are appended to the points array. All points are in WCS coordinates.The thisGsMarker and otherGsMarker arguments are intended to provide this function with information to allow it to localize the search for intersections to be between specific subentities. However, this function is not required to make use of either of these arguments (most, if not all, of the AutoCAD built-in entity classes do not). When calling this function, either or both of these arguments may be 0 in order to indicate that they should be ignored.If this function is successful it returns Acad::eOk. Return values for error conditions are dependent on the implementation of this function in the classes involved.Function implementation in derived classesThis function should do all it can to find all intersection points between the entity it's being called on and the entity pointed to by pEnt. All intersection points found should be appended to the points array. All such points must be in WCS coordinates.When implementing the intersection calculation portion of this function you should take a good look at the AcGe classes to see if they can provide any useful functionality to help in finding intersections with the geometric primitives that make up the entity this function is being called on and the pEnt entity. For example, the AcGeCurve3d class has an isOn() method that will indicate if a supplied point is on the curve and the AcGeCircArc3d class has several intersectWith() methods to find intersections with other AcGe types.If the pEnt entity is a type not recognized by this function, it is quite reasonable to call the pEnt entity's intersectWith() method passing in a pointer to this entity as the "pEnt", and all the other arguments passed into this function (remembering to convert the intType argument If necessary) to see if that entity can determine any intersection points. This is what the AutoCAD built-in classes do.Also, don't forget to take into account the intType value. The intType tells you which, if any, of the two entities should be extended to find "apparent" intersections. It is not required that apparent intersection be supported, but if it is not, then an appropriate ErrorStatus value should be returned to indicate that the call failed.The thisGsMarker and otherGsMarker arguments are provided to allow this function to determine exactly which subentities are involved in the intersection operation (for example, if this function is being called by AutoCAD as part of an intersection Osnap operation these arguments would indicate which subentities are within the osnap pickbox). For these arguments, a value less than or equal to zero indicates that that argument should not be used.If this function completes successfully (even if no intersection points are found), it should return Acad::eOk. Determining what is considered an error and what ErrorStatus return code to use for any such errors are up to the implementer -- there are no conventions in this regard.Default implementationImmediately returns Acad::eNotImplemented.-'''
    ...
    def intersectionsWithLine (self, start : PyGe.Point3d, end : PyGe.Point3d, type : PyBrxCv.TinSurfaceIntersectType, visibleOnly : bool)-> tuple[Any,...] :
      '''                             '''
    ...
    def isA (self)-> PyRx.RxClass :
      '''Function usage:For each class registered with ObjectARX, the implementation of this function is to return a pointer to the AcRxClass object for the class of the object in which this method is called. For classes not registered with ObjectARX, this method has no meaning.Function implementation in derived classes:This function is overridden in all derived classes. The AcRx macros declare and define this function, so that the override is taken care of as part of using the macros. The implementation of this function is simply to return ::desc(). For example. the implementation for AcDbLine would be:return AcDbLine::desc();Default implementation for AcRxObject:  { return AcRxObject::desc(); }'''
    ...
    def isAProxy (self)-> int :
      '''Returns Adesk::kTrue if the object is a proxy object or entity. Otherwise returns Adesk::kFalse.'''
    ...
    def isAcDbObjectIdsInFlux (self)-> int :
      '''This function refers to a condition that occurs during deep clone operations. It returns Adesk::kTrue when the cloned objects' IDs have not yet been translated and thus cannot be used in any operations on the objects. This condition normally occurs only during AcEditorReactor::beginDeepCloneXlation, AcDbObject::deepClone, or AcDbObject::wblockClone. Any operations that involve AcDbObjectId references, such as symbol table records, should be postponed until after endDeepClone. AcDbObject::subClose is never called on any objects whose IDs are in flux.'''
    ...
    def isAnnotative (self)-> PyDb.AnnotativeStates :
      '''                             '''
    ...
    def isAssociative (self)-> bool :
      '''                             '''
    ...
    def isAutoUpdate (self)-> bool :
      '''                             '''
    ...
    def isCancelling (self)-> int :
      '''Returns Adesk::kTrue if the object is currently in the middle of a cancel() call (that is, an open is being canceled and all changes made are being rolled back). Otherwise returns Adesk::kFalse.'''
    ...
    def isEraseStatusToggled (self)-> int :
      '''Returns Adesk::kTrue if the object's erase bit has been toggled since it was opened. Otherwise returns Adesk::kFalse.'''
    ...
    def isErased (self)-> int :
      '''Returns Adesk::kTrue if the object is currently erased. Otherwise returns Adesk::kFalse.'''
    ...
    def isKindOf (self, rhs: PyRx.RxClass)-> bool :
      '''Returns true if "this" object is of a member of either the class represented by aClass, or a class derived from aClass. '''
    ...
    def isModified (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called). Otherwise returns Adesk::kFalse.'''
    ...
    def isModifiedGraphics (self)-> int :
      '''Returns Adesk::kTrue if the object is derived from AcDbEntity and has had either an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called), or its recordGraphicsModified() function called with an Adesk::kTrue argument value.Otherwise it returns Adesk::kFalse.'''
    ...
    def isModifiedXData (self)-> int :
      '''Returns Adesk::kTrue if the object has had an assertWriteEnabled() called since it was opened (which would indicate that a member function that can change its data was called) and has then had its setXData() method called. Otherwise it returns Adesk::kFalse.'''
    ...
    def isNewObject (self)-> int :
      '''Returns Adesk::kTrue if the object has not yet been closed since it was first created. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifyEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForNotify. Otherwise returns Adesk::kFalse.'''
    ...
    def isNotifying (self)-> int :
      '''Returns Adesk::kTrue if the object is in the process of sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def isNullObj (self)-> bool :
      '''                             '''
    ...
    def isPersistent (self)-> int :
      '''                             '''
    ...
    def isPlanar (self)-> int :
      '''This function returns Adesk::kTrue if and only if there is a plane that contains the entity. Otherwise Adesk::kFalse is returned.'''
    ...
    def isReadEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForRead. Otherwise returns Adesk::kFalse.'''
    ...
    def isReallyClosing (self)-> int :
      '''Returns true if calling close() at this time would really close the object completely. For example, if the object is not in a transaction, and is open for read with only one reader, then Adesk::kTrue would be returned. If, on the other hand, the object is in a transaction, then Adesk::kFalse would be returned.'''
    ...
    def isRebuildPossible (self)-> bool :
      '''                             '''
    ...
    def isSnapshotUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isTransactionResident (self)-> int :
      '''Returns Adesk::kTrue if the object is currently part of a transaction. Otherwise returns Adesk::kFalse.'''
    ...
    def isUndoRecordingDisabled (self)-> bool :
      '''Returns true if undo recording is disabled.'''
    ...
    def isUndoing (self)-> int :
      '''Returns Adesk::kTrue if the object is involved in an Undo operation at this time. Otherwise returns Adesk::kFalse.'''
    ...
    def isUpdateNeeded (self)-> bool :
      '''                             '''
    ...
    def isWriteEnabled (self)-> int :
      '''Returns Adesk::kTrue if the object is currently open AcDb::kForWrite and is not currently sending notification. Otherwise returns Adesk::kFalse.'''
    ...
    def keepAlive (self, flag: bool)-> None :
      '''                             '''
    ...
    def layer (self)-> str :
      '''This function returns a copy of the name string in the AcDbLayerTableRecord object referenced by the entity.The calling application is responsible for deallocating the memory used by the returned string. The acutDelString() function is recommended.WarningCalling this function before the entity has had its referenced layer object ID set (that is, it's still set to AcDbObjectId::kNull) will terminate AutoCAD. If the referenced layer objectId is AcDbObjectId::kNull when the entity is added to a database, it will be set to the object ID of the database's current default layer.'''
    ...
    def layerId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the AcDbLayerTableRecord referenced by the entity. If the layerId has not been set yet, then AcDbObjectId::kNull is returned.'''
    ...
    def lineWeight (self)-> PyDb.LineWeight :
      '''This function returns the AcDb::LineWeight of the entity.'''
    ...
    def linetype (self)-> str :
      '''This function returns a copy of the name string in the AcDbLinetypeTableRecord object referenced by the entity.The calling application is responsible for deallocating the memory used by the returned string. Either the C++ delete [ ] or the C free() function may be used.Warning Calling this function before the entity has had its referenced linetype object ID set (that is, it's still set to AcDbObjectId::kNull) will terminate AutoCAD. If the referenced linetype objectId is AcDbObjectId::kNull when the entity is added to a database it will be set to the object ID of the database's current default linetype.'''
    ...
    def linetypeId (self)-> PyDb.ObjectId :
      '''This function returns the AcDbObjectId of the AcDbLinetypeTableRecord referenced by the entity. If the linetypeId has not been set yet, then AcDbObjectId::kNull will be returned.'''
    ...
    def linetypeScale (self)-> float :
      '''This function returns the linetype scale factor for the entity.'''
    ...
    def list (self)-> None :
      '''Function usageThis function is intended to be called from AutoCAD whenever the entity is selected during the LIST command. However, it can be called from ObjectARX applications if desired.This function will print entity specific information to the AutoCAD command line.Function implementation in derived classesWhen implementing this function in a derived class, the first thing that should be done in the function is to make a call to assertReadEnabled(). The next thing to do is to call the parent class's list() method to allow the parent class to list it's information (the parent class should in turn call its parent class first and so on up the inheritance chain until AcDbObject is reached. This way all the entity's information will be properly printed out in order). Once the parent class's list function has been called then a series of ads_printf() calls can be used to list whatever information is desired.Default implementationLists out the entity's DXF name, the layer, the space the entity resides in (model or paper), and the entity's handle.'''
    ...
    def majorContours (self)-> list :
      '''                             '''
    ...
    def majorContoursColor (self)-> tuple[Any,...] :
      '''                             '''
    ...
    def majorContoursInterval (self)-> tuple[Any,...] :
      '''                             '''
    ...
    def material (self)-> str :
      '''Returns the material name.'''
    ...
    def materialId (self)-> PyDb.ObjectId :
      '''Returns the ID of the associated AcDbMaterial object.'''
    ...
    def maxElevation (self, visibleOnly : bool=False)-> float :
      '''                             '''
    ...
    def merge (self, other : PyBrxCv.CvDbTinSurface)-> bool :
      '''                             '''
    ...

    @staticmethod
    def mergeSurfaces (theOne: PyBrxCv.CvDbTinSurface,theOther: PyBrxCv.CvDbTinSurface)-> PyBrxCv.CvDbTinSurface :
      '''                             '''
    ...
    def minElevation (self, visibleOnly : bool=False)-> float :
      '''                             '''
    ...
    def minorContours (self)-> list :
      '''                             '''
    ...
    def minorContoursColor (self)-> tuple[Any,...] :
      '''                             '''
    ...
    def minorContoursInterval (self)-> tuple[Any,...] :
      '''                             '''
    ...
    def moveDefinition (self, _from : int, _to : int)-> int :
      '''                             '''
    ...
    def movePoint (self, _from : PyGe.Point3d, _to : PyGe.Point3d)-> bool :
      '''                             '''
    ...
    def movePoints (self, _from : list[PyGe.Point3d], _to : list[PyGe.Point3d])-> bool :
      '''                             '''
    ...
    def name (self)-> str :
      '''                             '''
    ...
    def objectId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the object. If the object is not yet database-resident, then the returned objectId will be set to AcDbObjectId::kNull.'''
    ...
    def ownerId (self)-> PyDb.ObjectId :
      '''Returns the objectId of the owner of the object. If the object does not yet have an owner, or the ownerId data member has not yet been set using AcDbObject::setOwnerId, then the returned objectId will be set to AcDbObjectId::kNull.Appending the object to a BlockTable record, a symbol table, or a dictionary automatically calls AcDbObject::setOwnerId.'''
    ...
    def plotStyleName (self)-> str :
      '''This function returns a copy of the plotStyleName string of the entity. The caller is responsible for deallocating the returned string.The plotStyleName value is used for DXF group code 390.'''
    ...
    def pointsCount (self, visibleOnly : bool=False)-> int :
      '''                             '''
    ...
    def queryX (self, rhs: PyRx.RxClass)-> PyRx.RxObject :
      '''This method searches for a protocol extension object associated with this object.The method begins the search by examining the AcRxClass object associated with this object, and if no protocol extension object is found, the search continues in the base class of the object's class and so on up the inheritance tree for the class. This procedure provides a form of protocol extension inheritance. An object's AcRxClass member may be found by using the class's isA() method.If the search for a protocol extension object is unsuccessful, then NULL is returned.'''
    ...
    def raiseSurface (self, offset : float)-> bool :
      '''                             '''
    ...
    def rebuild (self, val : bool)-> bool :
      '''                             '''
    ...
    def rebuildSnapshot (self)-> bool :
      '''                             '''
    ...
    def receiveShadows (self)-> bool :
      '''Returns a boolean value indicating whether this entity can receive shadows.'''
    ...
    def recordGraphicsModified (self)-> None :
      '''This method sets the entity's state to indicate whether or not the entity should be updated on screen when it is closed. If the entity is set not to update, then any changes made will appear the next time the entity is regenerated.If setModified is false and the entity is currently set to update its graphics on close (which is its default state), then this function sets the entity so that it will not update on screen when it is closed and objectModified notification is sent to all entity type reactors attached to the entity. If setModified is false and the entity is already set not to update its graphics on close, then this function simply returns.If setModified is true, then the entity is set to update on screen when it is closed.'''
    ...
    def releaseExtensionDictionary (self)-> None :
      '''Removes the object's extension dictionary (that is, removes the object as the owner of the dictionary object) if it exists and is empty. Once removed, this function calls the dictionary's erase() method. Any reactors attached to the extension dictionary receive normal notification appropriate to an open for write, erase, close sequence.Returns Acad::eOk if successful.If the dictionary is not empty, then this function fails and returns Acad::eContainerNotEmpty.'''
    ...
    def removeAllDefinitions (self)-> int :
      '''                             '''
    ...
    def removeContext (self, obj : PyDb.ObjectContext)-> None :
      '''                             '''
    ...
    def removeDefinitionAt (self, index: int)-> bool :
      '''                             '''
    ...
    def removeField (self, id: str|PyDb.ObjectId)-> None :
      '''Removes the specified field.Returns Acad::eOk if successful. Otherwise, returns an AutoCAD error status.'''
    ...
    def removePersistentReactor (self, id: PyDb.ObjectId)-> None :
      '''Removes the persistent reactor specified by objId from the reactor list of the object. The object must be open AcDb::kForWrite to be able to execute this function.Returns Acad::eOk if successful. If the object is currently sending notification and is not open AcDb::kForWrite, then Acad::eWasNotifying is returned.'''
    ...
    def removePoint (self, pt : PyGe.Point3d)-> bool :
      '''                             '''
    ...
    def removePoints (self, pts : list[PyGe.Point3d])-> bool :
      '''                             '''
    ...
    def removeReactor (self, reactor: PyDb.EntityReactor)-> None :
      '''                             '''
    ...
    def removeSnapshot (self)-> bool :
      '''                             '''
    ...
    def rolloverHit (self, nSubentId: int, nMouseFlags: int, bReset: bool)-> int :
      '''                             '''
    ...
    def setAcDbObjectIdsInFlux (self)-> None :
      '''This function must be called on any newly created objects in AcDbObject::deepClone or AcDbObject::wblockClone. It indicates that reference object IDs are not yet pointing to the correct objects. The references can be translated only when the entire deep clone operation is complete. The flag is cleared at that time.'''
    ...
    def setAnnotative (self, state : PyDb.AnnotativeStates)-> None :
      '''                             '''
    ...
    def setAssociative (self, isAssociative : bool)-> bool :
      '''                             '''
    ...
    def setAttributes (self, traits: PyGi.DrawableTraits)-> int :
      '''                             '''
    ...
    def setCastShadows (self, val: bool)-> None :
      '''Sets the property to indicate whether the entity can cast shadows.'''
    ...
    def setColor (self, clr: PyDb.AcCmColor, dosubents : bool=True, db : PyDb.Database='current')-> None :
      '''Function usageThis method sets the entity's color to the color specified by color. If the entity owns subentities and doSubents == Adesk::kTrue, the color change is applied to the subentities as well. Custom classes may override this method.'''
    ...
    def setColorIndex (self, clr: int, dosubents : bool=True)-> None :
      '''Function usageThis method sets the entity's color to the AutoCAD color index color. If the entity owns subentities and doSubents == Adesk::kTrue, then the color index change will be applied to the subentities as well.'''
    ...
    def setDatabaseDefaults (self, db: PyDb.Database = 'current')-> None :
      '''This function sets the entity's:ColorLayerLinetypeLinetype scaleVisibilityPlot style nameLine weightto the default values of the database indicated by pDb: If pDb == NULL, then the current database in the AutoCAD editor is used.'''
    ...
    def setDescription (self, val : str)-> bool :
      '''                             '''
    ...

    @overload
    def setField (self, field: PyDb.Field)-> PyDb.ObjectId : ...
    @overload
    def setField (self, propName: str, field: PyDb.Field)-> PyDb.ObjectId : ...
    def setField (self, *args, **kwargs)-> PyDb.ObjectId :
      '''Overloads:
    - field: PyDb.Field
    - propName: str, field: PyDb.Field
    '''
    ...
    def setIsAutoUpdate (self, autoUpdateOn : bool)-> bool :
      '''                             '''
    ...
    def setLayer (self, val: str|PyDb.ObjectId, dosubents : bool=True, allowHiddenLayer : bool=False)-> None :
      '''This method sets entity to reference the AcDbLayerTableRecord identified by the name specified in newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the layer change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.'''
    ...
    def setLineWeight (self, val: PyDb.LineWeight, dosubents : bool=True)-> None :
      '''This method sets the entity to use lineweight. If the entity owns subentities and doSubents == Adesk::kTrue, then the line weight change will be applied to the subentities as well.Returns Acad::eOk if successful.Function implementation in derived classesIf this function is overridden and wishes to set the line weight of the entity, then it must call AcDbEntity::setLineWeight() passing on the lineweight and doSubents arguments.It is also possible for this function's implementation to deal directly with any subentities and pass a doSubents value of Adesk::kFalse to AcDbEntity:: setLineWeight().If the line weight setting operation is successful, then this function should return Acad::eOk. If lineweight is not an acceptable value, then this function should return Acad::eInvalidInput. Any other error return values are up to the implementer.'''
    ...
    def setLinetype (self, val: str|PyDb.ObjectId, dosubents : bool=True)-> None :
      '''Function usageThis method sets the entity to reference the AcDbLinetypeTableRecord with the name specified in newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the linetype change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.'''
    ...
    def setLinetypeScale (self, val: float, dosubents : bool=True)-> None :
      '''This method sets the entity to use newval as its linetype scale factor. newVal must be nonnegative. If the entity owns subentities and doSubents == Adesk::kTrue, then the linetype scale change will be applied to the subentities as well.'''
    ...
    def setMajorContoursColor (self, colorIndex : int)-> bool :
      '''                             '''
    ...
    def setMajorContoursInterval (self, interval : float)-> bool :
      '''                             '''
    ...
    def setMaterial (self, val: str|PyDb.ObjectId, dosubents : bool=True)-> None :
      '''This method sets the material reference to the specified material. The specified name must correspond to an existing AcDbMaterial object.Returns Acad::eOk when successful'''
    ...
    def setMinorContoursColor (self, colorIndex : int)-> bool :
      '''                             '''
    ...
    def setMinorContoursInterval (self, interval : float)-> bool :
      '''                             '''
    ...
    def setName (self, val : str)-> bool :
      '''                             '''
    ...
    def setOwnerId (self, owner: PyDb.ObjectId)-> None :
      '''Sets the ownerId data member of the object to be objId, thus establishing a "backpointer." This backpointer is used by WBLOCK to be sure all necessary objects are written out.Returns Acad::eOk if successful.'''
    ...

    @overload
    def setPlotStyleName (self, /)-> None : ...
    @overload
    def setPlotStyleName (self, nameType: PyDb.PlotStyleNameType, doSubents: bool)-> None : ...
    @overload
    def setPlotStyleName (self, nameType: PyDb.PlotStyleNameType, newId: PyDb.ObjectId, doSubents: bool)-> None : ...
    def setPlotStyleName (self, *args, **kwargs)-> None :
      '''Overloads:
    - None: Any
    - nameType: PyDb.PlotStyleNameType, doSubents: bool
    - nameType: PyDb.PlotStyleNameType, newId: PyDb.ObjectId, doSubents: bool
    
	-This function searches the PlotStyleName dictionary for an entry with the name that matches newName and if found, sets the entity to use that plotStyleName entry. Because a lookup in the PlotStyleName dictionary is required, the entity must be database-resident for this method to succeed. The names ByLayer and ByBlock are allowed as well as user-defined names.If the entity owns subentities and doSubents == Adesk::kTrue, then the change will be applied to the subentities as well. For an AcDbBlockReference entity, this method will also update any associated AcDbSequenceEnd subentity regardless of the doSubents setting.Returns Acad::eOk if successful. If the entity is not database-resident, then Acad::eNoDatabase will be returned. If there is no entry in the PlotStyleName dictionary for newName, then Acad::eKeyNotFound will be returned.The plotStyleName value is used for DXF group code 390.-'''
    ...
    def setPropertiesFrom (self, entity: PyDb.Entity, dosubents : bool=True)-> None :
      '''This method copies theColorLayerLinetypeLinetype scaleVisibilityvalues from the entity pointed to by pEntity into this entity. If the entity owns subentities and doSubents == Adesk::kTrue, then the property changes will be applied to the subentities as well.Returns Acad::eOk if successful.'''
    ...
    def setReceiveShadows (self, val: bool)-> None :
      '''Sets the property indicating whether this entity can receive shadows.'''
    ...
    def setStyle (self, style : PyBrxCv.TinSurfaceStyle)-> bool :
      '''                             '''
    ...
    def setSurfaceElevation (self, elevation : float)-> bool :
      '''                             '''
    ...
    def setVisibility (self, val: PyDb.Visibility, dosubents : bool=True)-> None :
      '''This method sets the visibility of an entity to the value specified by newVal. If the entity owns subentities and doSubents == Adesk::kTrue, then the visibility change will be applied to the subentities as well.'''
    ...
    def setXData (self, xdata: list)-> None :
      '''Each regapp sublist (delimited by a resbuf with restype == 1001 and resval.rstring == a valid regappName string) within the resbuf chain pointed to by xdata, is placed in the xdata area of the object. If any of the regappNames in xdata are already present in the xdata area of the object, then that regappName's existing data on the object is overwritten by that regappName's new data in xdata.All resbufs with restype == 1001 must have valid regappNames for the database the object resides in (that is, the regappNames must be in the APPID table of the database).Only valid xdata group codes (1000--1071) are accepted in the restype fields of the resbufs in xdata.No "-3" group code is necessary, and in fact, is not accepted. So, the first element in the resbuf chain must be a 1001 group code with a resval.rstring set to a regappName that's already registered in the regapp table. To register a regappName, use the acdbRegApp() function.To remove an appName (and its xdata) from an object, just use a resbuf with restype == 1001, resval == and no data resbufs following it (that is, either its rbnext == NULL or the next resbuf is another 1001)This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If this function is overridden, then it should supermessage its parent in order to invoke the built-in mechanism to add the xdata to the object.Returns Acad::eOk if the xdata is successfully added to the object. If there is insufficient space in the xdata area of the object, then Acad::eXdataSizeExceeded is returned. If any of the regappNames in xdata are not in the APPID table, then Acad::eRegappIdNotFound is returned.'''
    ...
    def snoop (self,  filer : PyDb.SnoopDwgFiler)-> None :
      '''                             '''
    ...

    @overload
    def solid3d (self, surface: PyBrxCv.CvDbTinSurface)-> PyDb.Solid3d : ...
    @overload
    def solid3d (self, surfaceType: PyBrxCv.TinSurfaceMeshType, thickness: float)-> PyDb.Solid3d : ...
    def solid3d (self, *args, **kwargs)-> PyDb.Solid3d :
      '''Overloads:
    - surface: PyBrxCv.CvDbTinSurface
    - surfaceType: PyBrxCv.TinSurfaceMeshType, thickness: float 
    '''
    ...
    def style (self)-> PyBrxCv.TinSurfaceStyle :
      '''                             '''
    ...

    @overload
    def subDMesh (self, /)-> PyDb.SubDMesh : ...
    @overload
    def subDMesh (self, surface: PyBrxCv.CvDbTinSurface)-> PyDb.SubDMesh : ...
    @overload
    def subDMesh (self, surfaceType: PyBrxCv.TinSurfaceMeshType, depthOrElevation: float)-> PyDb.SubDMesh : ...
    def subDMesh (self, *args, **kwargs)-> PyDb.SubDMesh :
      '''Overloads:
    - None: Any
    - surface: PyBrxCv.CvDbTinSurface
    - surfaceType: PyBrxCv.TinSurfaceMeshType, depthOrElevation: float 
    '''
    ...
    def swapEdge (self, pt : PyGe.Point3d)-> bool :
      '''                             '''
    ...
    def swapIdWith (self, otherId: PyDb.DbObject, swapXdata: bool, swapExtDict: bool)-> None :
      '''This function swaps objectIds and handles between the object specified by otherId and the object invoking this function. Both objects must currently be database-resident and must reside in the same database. If swapXdata == Adesk::kTrue, then the objects swap extended entity data as well. If swapExtDict == Adesk::kTrue, then the objects swap extension dictionaries also.If the object specified by otherId or the object invoking this function are not database-resident, then Acad::eNoDatabase is returned. If both objects involved are not in the same database, then Acad::eWrongDatabase is returned.'''
    ...
    def tinTriangles (self)-> list :
      '''                             '''
    ...
    def transformBy (self, matrix3d: PyGe.Matrix3d)-> None :
      '''Function usageThis function provides a means by which AutoCAD and ObjectARX applications can ask the entity to apply a transformation matrix (xform) to itself.Each entity class must implement this function, so restrictions on what types of transformations are supported are up to the implementer of the entity class. The AutoCAD built-in entity classes for entity types that existed before R13 (that is, all the classes listed in the header file dbents.h such as AcDbCircle, AcDbLine, AcDbArc, AcDb2dPolyline, etc.) require that the transformation matrix represent a uniformly scaling orthogonal transformation (if it is not, then Acad::eCannotScaleNonUniformly will be returned). Other AutoCAD built-in classes have no restrictions.Returns Acad::eOk if successful. Return values for errors are implementation-dependent.Function implementation in derived classesThis function must apply the transformation matrix xform to the entity and change the entity's state to reflect the transformation. It is completely up to the implementer as to how to apply the transformation. It is also up to the implementer to decide what, if any, restrictions will be placed on the type of transformations supported. If any restrictions are desired, then it's up to the implementation of this function to enforce them.If your derived class implements transformBy() without calling the base class, you must call AcDbObject:: xDataTransformBy() or your Xdata will not be transformed.If this function successfully transforms the entity, then it should return Acad::eOk.Return values for error conditions are completely up to the implementer of this function. However, if the error is caused by a non-uniformly scaling or non-orthogonal matrix, then to be consistent with other entities that have this restriction, it is recommended that Acad::eCannotScaleNonUniformly be returned.'''
    ...
    def triangles (self, visibleOnly : bool=False)-> list :
      '''                             '''
    ...
    def trianglesCount (self, visibleOnly : bool=False)-> int :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.VolumeSurfaceType :
      '''                             '''
    ...
    def updateConstraint (self, val : PyBrxCv.CvDbTinSurfaceConstraint)-> bool :
      '''                             '''
    ...
    def updateObjectData (self)-> None :
      '''                             '''
    ...
    def upgradeFromNotify (self, wasWritable: bool)-> None :
      '''Upgrades the object from being at least open AcDb::kForNotify to being open both AcDb::kForNotify and AcDb::kForWrite. The wasWritable argument is set to Adesk::kTrue if the object was already open for write, otherwise it's set to Adesk::kFalse. The wasWritable value should be saved to be passed into the downgradeToNotify() call later.This function must be followed at some point by a call to downgradeToNotify() with no open() (in any of its forms) or close() calls in between.This method should only be called from within other methods of the same object it is being called from. In other words, this method is intended to be used by an object to change it's own open status so that it can safely modify itself.upgradeFromNotify() and downgradeToNotify() call pairs are not nestable.Returns Acad::eOk if successful. If the object is not currently open AcDb::kForNotify, then Acad::eNotApplicable is returned. If the object is currently in the process of actually sending notification (that is, isNotifying() returns Adesk::kTrue), then Acad::eWasNotifying is returned.'''
    ...
    def upgradeOpen (self)-> None :
      '''If the object is currently open AcDb::kForRead with only one reader, then this function upgrades the object to open AcDb::kForWrite. In the process of changing to open for write, the object is closed, thus triggering any pertinent notification.Returns Acad::eOk if successful. If the object has more than one reader, then the open status is not changed and Adesk::eHadMultipleReaders is returned. If the object is already open AcDb::kForWrite, then Acad::eWasOpenForWrite is returned. If the object is currently sending notification, then the open status is not changed and Acad::eWasNotifying is returned.'''
    ...
    def viewportDraw (self, vpdraw: PyGi.ViewportDraw)-> None :
      '''                             '''
    ...
    def viewportDrawLogicalFlags (self, vpdraw: PyGi.ViewportDraw)-> int :
      '''                             '''
    ...
    def visibility (self)-> PyDb.Visibility :
      '''This method returns the entity's current visibility state, either AcDb::kVisible or AcDb::kInvisible.'''
    ...
    def wblockClone (self, owner: PyRx.RxObject, mapping: PyDb.IdMapping, isPrimary:bool=True)-> PyDb.DbObject :
      '''This function is almost identical to AcDbObject::deepClone, except that an AcDbWblockCloneFiler is used and ownership is not carried across database boundaries. Subcloning is based on hard owner and hard pointer connections.'''
    ...
    def worldDraw (self, wdraw: PyGi.WorldDraw)-> int :
      '''                             '''
    ...
    def xData (self, appname: str = None)-> list :
      '''Returns a linked list of resbuf structures containing a copy of the xdata for the object. If regappName == NULL is passed in, all xdata is returned, otherwise only the xdata for the specified name is returned. If not all xdata is required, but the xdata for more than one regappName is desired, then multiple calls to this member function must be made--one for each regappName.The caller of this function is responsible for releasing the memory used by the resbuf list that is returned. The most commonly used way to deallocate such a list is via the acutRelRb() function.This function is virtual because some objects or entities may need to store some or all of their "built-in" state as xdata. Classes defining such objects can override this function in order to monitor and validate xdata requests as they see fit. If an object does not care about what xdata is attached to it (which is the preferred practice), then it need not override this member.If a failure accessing the xdata occurs, NULL is returned.'''
    ...
    def xDataTransformBy (self, xform: PyGe.Matrix3d)-> None :
      '''This method applies the xform transformation matrix to any XData data types 1011, 1021, 1031, 1012, 1022, 1032, 1013, 1023, 1033, 1041, and 1042 in the object's XData. See the documentation on XData for more information on the way the transformation matrix is applied to the different data types.This method should be called from within the transformBy() method on custom entities so that such entities will transform XData in the same way that the built-in AcDb entities do.Returns Acad::eOk if successful.'''
    ...
    def xmitPropagateModify (self)-> None :
      '''Within an object's close() method is a call to the object's xmitPropagateModify().The AcDbObject::xmitPropagateModify() default implementation is to inform the containing database that the object has been modified, appended to the database, or erased. The database then sends out the appropriate notification to any AcDbDatabaseReactors attached to it.Within AutoCAD, this function is used by complex entities such as polylines to allow the subentities to notify the header that they have been changed. The header can then "propagate" the notification by sending its own notification that the "complex entity" has been modified.The way this works is:The subobject class has it's xmitPropagateModify() class overridden such that it calls it's parent class's xmitPropagateModify() and also calls the owning object's recvPropagateModify().The "root" or "header" class has it's recvPropagateModify() overridden to provide an implementation that triggers "modified" notification to be sent for the "root" or "header" (which effectively represents the whole complex object).The subobject's close() triggers "modified" notification for the subobject and calls the subobject's xmitPropagateModify() function. So, when the subobject's close() is called, its xmitPropagateModify() is called. This then calls the owning object's recvPropagateModify(), which then triggers the owner to send "modified" notification.So, the result is a "modified" notification from both the subentity and the "root" or "header" entity.When overridden, this function should:Call its parent class's xmitPropagateModify() (which ultimately results in the execution of AcDbObject::xmitPropagateModify() to trigger database notification).Call its owner's recvPropagateModify() (passing in its "this" pointer) to "propagate" the notification information to the "root" owner to be sent out.'''
    ...

class CvGradingRule(object):
    def __init__ (self, *args, **kwargs)-> None :
      '''__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)'''
    ...

    @staticmethod
    def cast (otherObject: PyBrxCv.CvGradingRule)-> PyBrxCv.CvGradingRule :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...

    @staticmethod
    def convertRadToSlope ()-> float :
      '''                             '''
    ...

    @staticmethod
    def convertSlopeToRad ()-> float :
      '''                             '''
    ...
    def isNull (self)-> bool :
      '''                             '''
    ...
    def release (self)-> bool :
      '''                             '''
    ...
    def setSide (self, format : int)-> bool :
      '''                             '''
    ...
    def setSlopeFormat (self, format : int)-> bool :
      '''                             '''
    ...
    def side (self)-> PyBrxCv.GradingSide :
      '''                             '''
    ...
    def slopeFormat (self)-> PyBrxCv.GradingSlopeFormat :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.GradingType :
      '''                             '''
    ...

class CvGradingSlopeOffsetRule(CvGradingRule):
    def __init__ (self, *args, **kwargs)-> None :
      '''__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1, (float)arg2, (float)arg3) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64,double,double)'''
    ...

    @staticmethod
    def cast (otherObject: PyBrxCv.CvGradingRule)-> PyBrxCv.CvGradingSlopeOffsetRule :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...

    @staticmethod
    def convertRadToSlope ()-> float :
      '''                             '''
    ...

    @staticmethod
    def convertSlopeToRad ()-> float :
      '''                             '''
    ...
    def isNull (self)-> bool :
      '''                             '''
    ...
    def offset (self)-> float :
      '''                             '''
    ...
    def release (self)-> bool :
      '''                             '''
    ...
    def setOffset (self, offset : float)-> bool :
      '''                             '''
    ...
    def setSide (self, format : int)-> bool :
      '''                             '''
    ...
    def setSlope (self, slope : float)-> bool :
      '''                             '''
    ...
    def setSlopeFormat (self, format : int)-> bool :
      '''                             '''
    ...
    def side (self)-> PyBrxCv.GradingSide :
      '''                             '''
    ...
    def slope (self)-> float :
      '''                             '''
    ...
    def slopeFormat (self)-> PyBrxCv.GradingSlopeFormat :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.GradingType :
      '''                             '''
    ...

class CvGradingSlopeSurfaceRule(CvGradingRule):
    def __init__ (self, *args, **kwargs)-> None :
      '''__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64)

__init__( (object)arg1, (ObjectId)arg2, (float)arg3, (float)arg4) -> None :

    C++ signature :
        void __init__(struct _object * __ptr64,class PyDbObjectId,double,double)'''
    ...

    @staticmethod
    def cast (otherObject: PyBrxCv.CvGradingRule)-> PyBrxCv.CvGradingSlopeSurfaceRule :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...

    @staticmethod
    def convertRadToSlope ()-> float :
      '''                             '''
    ...

    @staticmethod
    def convertSlopeToRad ()-> float :
      '''                             '''
    ...
    def cutSlope (self)-> float :
      '''                             '''
    ...
    def fillSlope (self)-> float :
      '''                             '''
    ...
    def isNull (self)-> bool :
      '''                             '''
    ...
    def release (self)-> bool :
      '''                             '''
    ...
    def setCutSlope (self, val : float)-> bool :
      '''                             '''
    ...
    def setFillSlope (self, val : float)-> bool :
      '''                             '''
    ...
    def setSide (self, format : int)-> bool :
      '''                             '''
    ...
    def setSlopeFormat (self, format : int)-> bool :
      '''                             '''
    ...
    def setSurfaceId (self, id : PyDb.ObjectId)-> bool :
      '''                             '''
    ...
    def side (self)-> PyBrxCv.GradingSide :
      '''                             '''
    ...
    def slopeFormat (self)-> PyBrxCv.GradingSlopeFormat :
      '''                             '''
    ...
    def surfaceId (self)-> PyDb.ObjectId :
      '''                             '''
    ...
    def type (self)-> PyBrxCv.GradingType :
      '''                             '''
    ...

class CvStationEquation(object):

    @overload
    def __init__ (self, /)-> None : ...
    @overload
    def __init__ (self, rawStation: float, stationForward: float, type: StationEquationType)-> None : ...
    def __init__ (self, *args, **kwargs)-> None :
      '''Overloads:
    - None: Any
    - rawStation: float, stationForward: float, type: StationEquationType
    '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def getRawStation (self)-> float :
      '''                             '''
    ...
    def getStationForward (self)-> float :
      '''                             '''
    ...
    def getType (self)-> PyBrxCv.StationEquationType :
      '''                             '''
    ...
    def isNull (self)-> bool :
      '''                             '''
    ...
    def setRawStation (self, val : float)-> bool :
      '''                             '''
    ...
    def setStationForward (self, val : float)-> bool :
      '''                             '''
    ...
    def setType (self, val : PyBrxCv.EStationEquationType)-> bool :
      '''                             '''
    ...

class CvStationEquations(object):

    @overload
    def __init__ (self, /)-> None : ...
    @overload
    def __init__ (self, alignment: PyBrxCv.CvDbHAlignment)-> None : ...
    def __init__ (self, *args, **kwargs)-> None :
      '''Overloads:
    - None: Any
    - alignment: PyBrxCv.CvDbHAlignment
    '''
    ...
    def addStationEquation (self, equation : PyBrxCv.CvStationEquation)-> bool :
      '''                             '''
    ...

    @staticmethod
    def className ()-> str :
      '''                             '''
    ...
    def getLengthFromRawStation (self, rawStation : float)-> float :
      '''                             '''
    ...
    def getRawStation (self, station : float)-> list :
      '''                             '''
    ...
    def getRawStationFromLength (self, length : float)-> float :
      '''                             '''
    ...
    def getRefRawStartingStation (self)-> float :
      '''                             '''
    ...
    def getRefStartingLength (self)-> float :
      '''                             '''
    ...
    def getStartingStation (self)-> float :
      '''                             '''
    ...
    def getStation (self, rawStation : float)-> float :
      '''                             '''
    ...
    def getStationBack (self, idx : int)-> float :
      '''                             '''
    ...
    def getStationEquation (self, idx : int)-> PyBrxCv.CvStationEquation :
      '''                             '''
    ...
    def removeAllStationEquations (self)-> bool :
      '''                             '''
    ...
    def removeStationEquation (self, idx : int)-> bool :
      '''                             '''
    ...
    def setRefRawStartingStation (self, rawStartingStation : float)-> bool :
      '''                             '''
    ...
    def setRefStartingLength (self, startingStation : float)-> bool :
      '''                             '''
    ...
    def stationEquationsCount (self)-> int :
      '''                             '''
    ...
    def update (self, *args, **kwargs)-> bool :
      '''update( (CvStationEquations)arg1) -> bool :

    C++ signature :
        bool update(class PyBrxCvStationEquations {lvalue})'''
    ...

class CvTinPoint(object):
    def __init__ (self)-> None :
      '''                             '''
    ...
    def isValid (self)-> bool :
      '''                             '''
    ...
    def location (self)-> PyGe.Point3d :
      '''                             '''
    ...
    def triangleWithPoint (self)-> PyBrxCv.CvTinTriangle :
      '''                             '''
    ...

class CvTinTriangle(object):
    def __init__ (self)-> None :
      '''                             '''
    ...
    def isValid (self)-> bool :
      '''                             '''
    ...
    def isVisible (self)-> bool :
      '''                             '''
    ...
    def locationAt (self, index: int)-> PyGe.Point3d :
      '''                             '''
    ...
    def neighborAt (self, index: int)-> PyBrxCv.CvTinTriangle :
      '''                             '''
    ...
    def pointAt (self, index: int)-> PyBrxCv.CvTinPoint :
      '''                             '''
    ...

class DrawingObjectType(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eBlock (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eCivilPoint (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eFace (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eLine (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def ePoint (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def ePolyline (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eText (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eUnknown (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class GradingCalculationMethod(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eGradingAccurate (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eGradingFast (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class GradingSide(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eGradingSideLeft (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eGradingSideNone (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eGradingSideRight (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class GradingSlopeFormat(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eSlopeDegrees (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSlopeNoFormat (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSlopePercent (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSlopeRadians (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSlopeRiseRun (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class GradingStatus(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eGradingGradingOutsideSurface (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eGradingIncorrectInputData (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eGradingInputDataMissing (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eGradingInputDataOutsideSurface (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eGradingInvalidInput (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eGradingInvalidRule (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eGradingMultipleOffsetResult (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eGradingNoStatus (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eGradingOffsetFailed (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eGradingOk (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eGradingRuleMissing (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eGradingSurfaceMissing (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eGradingTimeout (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eGradingUnknownError (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eGradingUpdateNeeded (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eGradingZeroGrading (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class GradingType(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eGradingTypeNone (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eGradingTypeSlopeOffset (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eGradingTypeSlopeSurface (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class GradingVisualStyle(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eGradingDrawDaylight (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eGradingDrawNothing (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eGradingDrawRays (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eGradingDrawSurface (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class HAlignmentElementType(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eArc (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eCurveCurveReverseCurve (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eCurveLineCurve (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eCurveReverseCurve (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eCurveSpiral (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eCurveSpiralSpiral (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eLine (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eLineSpiral (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eMultipleSegments (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def ePI (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSpiral (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSpiralCurve (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSpiralCurveSpiral (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSpiralCurveSpiralCurveSpiral (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSpiralCurveSpiralSpiralCurveSpiral (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSpiralLine (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSpiralLineSpiral (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSpiralSpiral (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSpiralSpiralCurve (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSpiralSpiralCurveSpiralSpiral (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eUndefined (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class HAlignmentParameterConstraint(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eArc_BestFit (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eArc_CenterPassThrough (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eArc_CenterRadius (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eArc_PassThrough (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eArc_PassThroughAttachToEnd (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eArc_PassThroughDirection (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eArc_PassThroughRadius (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eArc_PointOnTangent (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eArc_Radius (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eArc_RadiusAndLength (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eArc_ThreePoints (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eAutomatic (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eLine_BestFit (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eLine_Length (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eLine_ThroughPoint (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eLine_TwoPoints (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSCS_PointOnTangent (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSCS_SpiralAVal (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSCS_SpiralAValRadius (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSCS_SpiralAValRadiusArcLength (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSCS_SpiralAValRadiusPassThrough (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSCS_SpiralInAValRadiusSpiralOutAVal (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSCS_SpiralInAValSpiralOutAVal (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSCS_SpiralInLengthSpiralOutLength (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSCS_SpiralInRadiusSpiralOut (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSCS_SpiralLength (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSCS_SpiralLengthRadius (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSCS_SpiralLengthRadiusArcLength (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSCS_SpiralLengthRadiusPassThrough (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSSCSS_Sp1AValSp2AValPt1Pt2 (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSSCSS_Sp1AValSp2AValRadiusPt (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSSCSS_Sp1LenSp2LenPt1Pt2 (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSSCSS_Sp1LenSp2LenRadiusPt (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSTS_SpiralAValTangentLength (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSTS_SpiralAValTangentPassThrough  (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSTS_SpiralInAValSpiralOutAVal (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSTS_SpiralInLengthSpiralOutLength (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSTS_SpiralLengthTangentLength (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSTS_SpiralLengthTangentPassThrough (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSTS_TangentLength (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSpiral_StartPointDirRadiusLength (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSpiral_StartPointDirStartAndEndRadiusLength (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eUndefined (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class HAlignmentTangencyConstraint(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eBoth (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eFixed (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eNext (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def ePrevious (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eUndefined (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class HAlignmentVisualStyle(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eElementExtensions (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eElements (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eTangentExtensions (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eUndefined (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class SpiralCurveType(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eInCurve (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eOutCurve (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class SpiralDefinitionType(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eClothoid (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eCubicParabola (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class SpiralDefinitionTypeSpiral(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eClothoid (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eCubicParabola (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class SpiralDirectionType(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eDirectionLeft (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eDirectionRight (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class SpiralParameterType(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eClothoid (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eCubicParabola (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class SpiralParameterType2(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eParamA (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eParamLength (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class StationEquationType(object):
    def Decreasing (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def Increasing (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class StyleManagerType(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eContourLabel (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def ePointLabel (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSurfaceElevationLabel (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSurfaceSlopeLabel (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSymbolStyle (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class TinBoundaryType(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eTinHide (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eTinOuter (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eTinShow (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class TinBreaklineType(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eTinBreaklineNormal (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eTinNonDestructive (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class TinConstraintType(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eTinBoundary (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eTinBreakline (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eTinWall (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class TinIntersectionElevation(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eTinElevationMax (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eTinElevationMid (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eTinElevationMin (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eTinNotAllowed (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class TinSurfaceDefinitionType(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eAddBoundaries (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eAddBreaklines (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eAddDrawingObjects (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eAddLine (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eAddLines (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eAddPoint (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eAddPointClouds (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eAddPointFiles (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eAddPointGroups (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eAddPoints (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eAddWalls (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eCreateFromC3D (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eCreateFromContours (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eCreateFromCorridor (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eCreateFromFaces (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eCreateMerged (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eCreateSnapshot (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eCreateTypedSnapshot (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eDeform (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eDeleteEdge (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eDeleteEdges (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eDeletePoint (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eDeletePoints (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eGroupDefinitions (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eIFC (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eLandXML (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eMerge (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eMinimizeFlatAreas (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eModifyPointElevation (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eModifyPointsElevation (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eModifyPointsElevations (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eMovePoint (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eMovePoints (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eNone (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eRemoveBelowAboveElevation (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eRemoveOuterEdges (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eRiseLower (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSmoothen (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSwapEdge (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eTransform (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eTrianglesVisibility (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eVolume (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class TinSurfaceIntersectType(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eTinSurfaceAll (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eTinSurfaceFirstOnly (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class TinSurfaceMeshType(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eTinSurfaceMeshDepth (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eTinSurfaceMeshElevation (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eTinSurfaceMeshSurface (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class TinSurfaceSolidType(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eSolidTypeSurfaceDepth (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSolidTypeSurfaceElevation (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eSolidTypeSurfaceSurface (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class TinSurfaceStyle(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eTinStyleBoundaryLine (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eTinStyleContours (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eTinStyleElevationTooltip (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eTinStyleNone (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eTinStylePoints (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eTinStyleTriangles (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class TinWallSide(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eTinWallLeft (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eTinWallRight (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class TinWallType(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eTinWallNormal (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eTinWallProjected (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class VAlignmentElementType(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eArc (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def ePVI (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eParabola (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eTangent (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eUndefined (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class VAlignmentParameterConstraint(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eAngle (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eAutomatic (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eLength (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def ePassThroughPoints (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def ePointOnTangent (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eRadius (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eUndefined (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class VAlignmentTangencyConstraint(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eBoth (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eFixed (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eNext (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def ePrevious (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eUndefined (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class VAlignmentType(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eAutomatic (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eDynamicSurface (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eLayout (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eStaticSurface (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class VAlignmentVisualStyle(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eElements (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eExtensions (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eTangents (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...

class VolumeSurfaceType(object):
    def __add__ (self, value, /) :
      '''Return self+value.'''
    ...
    def __init__ (self, /, *args, **kwargs) :
      '''Initialize self.  See help(type(self)) for accurate signature.'''
    ...
    def __mul__ (self, value, /) :
      '''Return self*value.'''
    ...
    def __rmul__ (self, value, /) :
      '''Return value*self.'''
    ...
    def __sub__ (self, value, /) :
      '''Return self-value.'''
    ...
    def __truediv__ (self, value, /) :
      '''Return self/value.'''
    ...
    def eTinVolumeBaseComparison (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eTinVolumeToDepth (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def eTinVolumeToElevation (self, *args, **kwargs)-> None :
      '''None'''
    ...
    def name (self, *args, **kwargs)-> None :
      '''None'''
    ...
